import Dt, { createContext as $2, useState as Vp, useEffect as G2, useContext as j2 } from "react";
import V2, { flushSync as K2 } from "react-dom";
var F1 = {}, W2 = {
  get exports() {
    return F1;
  },
  set exports(t) {
    F1 = t;
  }
}, si = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ml, $c;
function Kp() {
  if ($c)
    return ml;
  $c = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(o).map(function(c) {
        return o[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ml = i() ? Object.assign : function(s, o) {
    for (var a, l = r(s), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var f in a)
        e.call(a, f) && (l[f] = a[f]);
      if (t) {
        u = t(a);
        for (var h = 0; h < u.length; h++)
          n.call(a, u[h]) && (l[u[h]] = a[u[h]]);
      }
    }
    return l;
  }, ml;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gc;
function Y2() {
  if (Gc)
    return si;
  Gc = 1, Kp();
  var t = Dt, e = 60103;
  if (si.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var n = Symbol.for;
    e = n("react.element"), si.Fragment = n("react.fragment");
  }
  var r = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, u) {
    var c, f = {}, h = null, d = null;
    u !== void 0 && (h = "" + u), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (d = l.ref);
    for (c in l)
      i.call(l, c) && !s.hasOwnProperty(c) && (f[c] = l[c]);
    if (a && a.defaultProps)
      for (c in l = a.defaultProps, l)
        f[c] === void 0 && (f[c] = l[c]);
    return { $$typeof: e, type: a, key: h, ref: d, props: f, _owner: r.current };
  }
  return si.jsx = o, si.jsxs = o, si;
}
var gl = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jc;
function Q2() {
  return jc || (jc = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = Dt, n = Kp(), r = 60103, i = 60106;
      t.Fragment = 60107;
      var s = 60108, o = 60114, a = 60109, l = 60110, u = 60112, c = 60113, f = 60120, h = 60115, d = 60116, m = 60121, g = 60122, E = 60117, T = 60129, k = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var _ = Symbol.for;
        r = _("react.element"), i = _("react.portal"), t.Fragment = _("react.fragment"), s = _("react.strict_mode"), o = _("react.profiler"), a = _("react.provider"), l = _("react.context"), u = _("react.forward_ref"), c = _("react.suspense"), f = _("react.suspense_list"), h = _("react.memo"), d = _("react.lazy"), m = _("react.block"), g = _("react.server.block"), E = _("react.fundamental"), _("react.scope"), _("react.opaque.id"), T = _("react.debug_trace_mode"), _("react.offscreen"), k = _("react.legacy_hidden");
      }
      var R = typeof Symbol == "function" && Symbol.iterator, M = "@@iterator";
      function N(x) {
        if (x === null || typeof x != "object")
          return null;
        var B = R && x[R] || x[M];
        return typeof B == "function" ? B : null;
      }
      var S = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function O(x) {
        {
          for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), re = 1; re < B; re++)
            G[re - 1] = arguments[re];
          $("error", x, G);
        }
      }
      function $(x, B, G) {
        {
          var re = S.ReactDebugCurrentFrame, Se = re.getStackAddendum();
          Se !== "" && (B += "%s", G = G.concat([Se]));
          var Ne = G.map(function(pe) {
            return "" + pe;
          });
          Ne.unshift("Warning: " + B), Function.prototype.apply.call(console[x], console, Ne);
        }
      }
      var J = !1;
      function v(x) {
        return !!(typeof x == "string" || typeof x == "function" || x === t.Fragment || x === o || x === T || x === s || x === c || x === f || x === k || J || typeof x == "object" && x !== null && (x.$$typeof === d || x.$$typeof === h || x.$$typeof === a || x.$$typeof === l || x.$$typeof === u || x.$$typeof === E || x.$$typeof === m || x[0] === g));
      }
      function P(x, B, G) {
        var re = B.displayName || B.name || "";
        return x.displayName || (re !== "" ? G + "(" + re + ")" : G);
      }
      function ee(x) {
        return x.displayName || "Context";
      }
      function Y(x) {
        if (x == null)
          return null;
        if (typeof x.tag == "number" && O("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof x == "function")
          return x.displayName || x.name || null;
        if (typeof x == "string")
          return x;
        switch (x) {
          case t.Fragment:
            return "Fragment";
          case i:
            return "Portal";
          case o:
            return "Profiler";
          case s:
            return "StrictMode";
          case c:
            return "Suspense";
          case f:
            return "SuspenseList";
        }
        if (typeof x == "object")
          switch (x.$$typeof) {
            case l:
              var B = x;
              return ee(B) + ".Consumer";
            case a:
              var G = x;
              return ee(G._context) + ".Provider";
            case u:
              return P(x, x.render, "ForwardRef");
            case h:
              return Y(x.type);
            case m:
              return Y(x._render);
            case d: {
              var re = x, Se = re._payload, Ne = re._init;
              try {
                return Y(Ne(Se));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var w = 0, ke, Ee, me, Te, Ae, C, b;
      function _n() {
      }
      _n.__reactDisabledLog = !0;
      function Sr() {
        {
          if (w === 0) {
            ke = console.log, Ee = console.info, me = console.warn, Te = console.error, Ae = console.group, C = console.groupCollapsed, b = console.groupEnd;
            var x = {
              configurable: !0,
              enumerable: !0,
              value: _n,
              writable: !0
            };
            Object.defineProperties(console, {
              info: x,
              log: x,
              warn: x,
              error: x,
              group: x,
              groupCollapsed: x,
              groupEnd: x
            });
          }
          w++;
        }
      }
      function jn() {
        {
          if (w--, w === 0) {
            var x = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: n({}, x, {
                value: ke
              }),
              info: n({}, x, {
                value: Ee
              }),
              warn: n({}, x, {
                value: me
              }),
              error: n({}, x, {
                value: Te
              }),
              group: n({}, x, {
                value: Ae
              }),
              groupCollapsed: n({}, x, {
                value: C
              }),
              groupEnd: n({}, x, {
                value: b
              })
            });
          }
          w < 0 && O("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Ie = S.ReactCurrentDispatcher, ft;
      function _t(x, B, G) {
        {
          if (ft === void 0)
            try {
              throw Error();
            } catch (Se) {
              var re = Se.stack.trim().match(/\n( *(at )?)/);
              ft = re && re[1] || "";
            }
          return `
` + ft + x;
        }
      }
      var dn = !1, Jt;
      {
        var Qi = typeof WeakMap == "function" ? WeakMap : Map;
        Jt = new Qi();
      }
      function Ji(x, B) {
        if (!x || dn)
          return "";
        {
          var G = Jt.get(x);
          if (G !== void 0)
            return G;
        }
        var re;
        dn = !0;
        var Se = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Ne;
        Ne = Ie.current, Ie.current = null, Sr();
        try {
          if (B) {
            var pe = function() {
              throw Error();
            };
            if (Object.defineProperty(pe.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(pe, []);
              } catch (wn) {
                re = wn;
              }
              Reflect.construct(x, [], pe);
            } else {
              try {
                pe.call();
              } catch (wn) {
                re = wn;
              }
              x.call(pe.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (wn) {
              re = wn;
            }
            x();
          }
        } catch (wn) {
          if (wn && re && typeof wn.stack == "string") {
            for (var fe = wn.stack.split(`
`), ht = re.stack.split(`
`), Fe = fe.length - 1, qe = ht.length - 1; Fe >= 1 && qe >= 0 && fe[Fe] !== ht[qe]; )
              qe--;
            for (; Fe >= 1 && qe >= 0; Fe--, qe--)
              if (fe[Fe] !== ht[qe]) {
                if (Fe !== 1 || qe !== 1)
                  do
                    if (Fe--, qe--, qe < 0 || fe[Fe] !== ht[qe]) {
                      var On = `
` + fe[Fe].replace(" at new ", " at ");
                      return typeof x == "function" && Jt.set(x, On), On;
                    }
                  while (Fe >= 1 && qe >= 0);
                break;
              }
          }
        } finally {
          dn = !1, Ie.current = Ne, jn(), Error.prepareStackTrace = Se;
        }
        var ii = x ? x.displayName || x.name : "", zc = ii ? _t(ii) : "";
        return typeof x == "function" && Jt.set(x, zc), zc;
      }
      function Xs(x, B, G) {
        return Ji(x, !1);
      }
      function fl(x) {
        var B = x.prototype;
        return !!(B && B.isReactComponent);
      }
      function ti(x, B, G) {
        if (x == null)
          return "";
        if (typeof x == "function")
          return Ji(x, fl(x));
        if (typeof x == "string")
          return _t(x);
        switch (x) {
          case c:
            return _t("Suspense");
          case f:
            return _t("SuspenseList");
        }
        if (typeof x == "object")
          switch (x.$$typeof) {
            case u:
              return Xs(x.render);
            case h:
              return ti(x.type, B, G);
            case m:
              return Xs(x._render);
            case d: {
              var re = x, Se = re._payload, Ne = re._init;
              try {
                return ti(Ne(Se), B, G);
              } catch {
              }
            }
          }
        return "";
      }
      var Xi = {}, Zi = S.ReactDebugCurrentFrame;
      function Nr(x) {
        if (x) {
          var B = x._owner, G = ti(x.type, x._source, B ? B.type : null);
          Zi.setExtraStackFrame(G);
        } else
          Zi.setExtraStackFrame(null);
      }
      function hl(x, B, G, re, Se) {
        {
          var Ne = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var pe in x)
            if (Ne(x, pe)) {
              var fe = void 0;
              try {
                if (typeof x[pe] != "function") {
                  var ht = Error((re || "React class") + ": " + G + " type `" + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof x[pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ht.name = "Invariant Violation", ht;
                }
                fe = x[pe](B, pe, re, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Fe) {
                fe = Fe;
              }
              fe && !(fe instanceof Error) && (Nr(Se), O("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", G, pe, typeof fe), Nr(null)), fe instanceof Error && !(fe.message in Xi) && (Xi[fe.message] = !0, Nr(Se), O("Failed %s type: %s", G, fe.message), Nr(null));
            }
        }
      }
      var Vn = S.ReactCurrentOwner, ni = Object.prototype.hasOwnProperty, dl = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Zs, eo, es;
      es = {};
      function pl(x) {
        if (ni.call(x, "ref")) {
          var B = Object.getOwnPropertyDescriptor(x, "ref").get;
          if (B && B.isReactWarning)
            return !1;
        }
        return x.ref !== void 0;
      }
      function D(x) {
        if (ni.call(x, "key")) {
          var B = Object.getOwnPropertyDescriptor(x, "key").get;
          if (B && B.isReactWarning)
            return !1;
        }
        return x.key !== void 0;
      }
      function z(x, B) {
        if (typeof x.ref == "string" && Vn.current && B && Vn.current.stateNode !== B) {
          var G = Y(Vn.current.type);
          es[G] || (O('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Y(Vn.current.type), x.ref), es[G] = !0);
        }
      }
      function te(x, B) {
        {
          var G = function() {
            Zs || (Zs = !0, O("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
          };
          G.isReactWarning = !0, Object.defineProperty(x, "key", {
            get: G,
            configurable: !0
          });
        }
      }
      function ge(x, B) {
        {
          var G = function() {
            eo || (eo = !0, O("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
          };
          G.isReactWarning = !0, Object.defineProperty(x, "ref", {
            get: G,
            configurable: !0
          });
        }
      }
      var ye = function(x, B, G, re, Se, Ne, pe) {
        var fe = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: x,
          key: B,
          ref: G,
          props: pe,
          // Record the component responsible for creating this element.
          _owner: Ne
        };
        return fe._store = {}, Object.defineProperty(fe._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(fe, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: re
        }), Object.defineProperty(fe, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Se
        }), Object.freeze && (Object.freeze(fe.props), Object.freeze(fe)), fe;
      };
      function kt(x, B, G, re, Se) {
        {
          var Ne, pe = {}, fe = null, ht = null;
          G !== void 0 && (fe = "" + G), D(B) && (fe = "" + B.key), pl(B) && (ht = B.ref, z(B, Se));
          for (Ne in B)
            ni.call(B, Ne) && !dl.hasOwnProperty(Ne) && (pe[Ne] = B[Ne]);
          if (x && x.defaultProps) {
            var Fe = x.defaultProps;
            for (Ne in Fe)
              pe[Ne] === void 0 && (pe[Ne] = Fe[Ne]);
          }
          if (fe || ht) {
            var qe = typeof x == "function" ? x.displayName || x.name || "Unknown" : x;
            fe && te(pe, qe), ht && ge(pe, qe);
          }
          return ye(x, fe, ht, Se, re, Vn.current, pe);
        }
      }
      var Rt = S.ReactCurrentOwner, vt = S.ReactDebugCurrentFrame;
      function Lt(x) {
        if (x) {
          var B = x._owner, G = ti(x.type, x._source, B ? B.type : null);
          vt.setExtraStackFrame(G);
        } else
          vt.setExtraStackFrame(null);
      }
      var kn;
      kn = !1;
      function Oe(x) {
        return typeof x == "object" && x !== null && x.$$typeof === r;
      }
      function ri() {
        {
          if (Rt.current) {
            var x = Y(Rt.current.type);
            if (x)
              return `

Check the render method of \`` + x + "`.";
          }
          return "";
        }
      }
      function Xt(x) {
        {
          if (x !== void 0) {
            var B = x.fileName.replace(/^.*[\\\/]/, ""), G = x.lineNumber;
            return `

Check your code at ` + B + ":" + G + ".";
          }
          return "";
        }
      }
      var Fc = {};
      function P2(x) {
        {
          var B = ri();
          if (!B) {
            var G = typeof x == "string" ? x : x.displayName || x.name;
            G && (B = `

Check the top-level render call using <` + G + ">.");
          }
          return B;
        }
      }
      function Hc(x, B) {
        {
          if (!x._store || x._store.validated || x.key != null)
            return;
          x._store.validated = !0;
          var G = P2(B);
          if (Fc[G])
            return;
          Fc[G] = !0;
          var re = "";
          x && x._owner && x._owner !== Rt.current && (re = " It was passed a child from " + Y(x._owner.type) + "."), Lt(x), O('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, re), Lt(null);
        }
      }
      function Uc(x, B) {
        {
          if (typeof x != "object")
            return;
          if (Array.isArray(x))
            for (var G = 0; G < x.length; G++) {
              var re = x[G];
              Oe(re) && Hc(re, B);
            }
          else if (Oe(x))
            x._store && (x._store.validated = !0);
          else if (x) {
            var Se = N(x);
            if (typeof Se == "function" && Se !== x.entries)
              for (var Ne = Se.call(x), pe; !(pe = Ne.next()).done; )
                Oe(pe.value) && Hc(pe.value, B);
          }
        }
      }
      function B2(x) {
        {
          var B = x.type;
          if (B == null || typeof B == "string")
            return;
          var G;
          if (typeof B == "function")
            G = B.propTypes;
          else if (typeof B == "object" && (B.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          B.$$typeof === h))
            G = B.propTypes;
          else
            return;
          if (G) {
            var re = Y(B);
            hl(G, x.props, "prop", re, x);
          } else if (B.PropTypes !== void 0 && !kn) {
            kn = !0;
            var Se = Y(B);
            O("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Se || "Unknown");
          }
          typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && O("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function F2(x) {
        {
          for (var B = Object.keys(x.props), G = 0; G < B.length; G++) {
            var re = B[G];
            if (re !== "children" && re !== "key") {
              Lt(x), O("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), Lt(null);
              break;
            }
          }
          x.ref !== null && (Lt(x), O("Invalid attribute `ref` supplied to `React.Fragment`."), Lt(null));
        }
      }
      function qc(x, B, G, re, Se, Ne) {
        {
          var pe = v(x);
          if (!pe) {
            var fe = "";
            (x === void 0 || typeof x == "object" && x !== null && Object.keys(x).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var ht = Xt(Se);
            ht ? fe += ht : fe += ri();
            var Fe;
            x === null ? Fe = "null" : Array.isArray(x) ? Fe = "array" : x !== void 0 && x.$$typeof === r ? (Fe = "<" + (Y(x.type) || "Unknown") + " />", fe = " Did you accidentally export a JSX literal instead of a component?") : Fe = typeof x, O("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Fe, fe);
          }
          var qe = kt(x, B, G, Se, Ne);
          if (qe == null)
            return qe;
          if (pe) {
            var On = B.children;
            if (On !== void 0)
              if (re)
                if (Array.isArray(On)) {
                  for (var ii = 0; ii < On.length; ii++)
                    Uc(On[ii], x);
                  Object.freeze && Object.freeze(On);
                } else
                  O("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                Uc(On, x);
          }
          return x === t.Fragment ? F2(qe) : B2(qe), qe;
        }
      }
      function H2(x, B, G) {
        return qc(x, B, G, !0);
      }
      function U2(x, B, G) {
        return qc(x, B, G, !1);
      }
      var q2 = U2, z2 = H2;
      t.jsx = q2, t.jsxs = z2;
    }();
  }(gl)), gl;
}
(function(t) {
  process.env.NODE_ENV === "production" ? t.exports = Y2() : t.exports = Q2();
})(W2);
const Wp = F1.jsx;
function et(t) {
  this.content = t;
}
et.prototype = {
  constructor: et,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), s = r.content.slice();
    return i == -1 ? s.push(n || t, e) : (s[i + 1] = e, n && (s[i] = n)), new et(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1)
      return this;
    var n = this.content.slice();
    return n.splice(e, 2), new et(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new et([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new et(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(t);
    return i.splice(s == -1 ? i.length : s, 0, e, n), new et(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = et.from(t), t.size ? new et(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = et.from(t), t.size ? new et(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = et.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
et.from = function(t) {
  if (t instanceof et)
    return t;
  var e = [];
  if (t)
    for (var n in t)
      e.push(n, t[n]);
  return new et(e);
};
function Yp(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), s = e.child(r);
    if (i == s) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return n;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (i.content.size || s.content.size) {
      let o = Yp(i.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += i.nodeSize;
  }
}
function Qp(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: n, b: r };
    let o = t.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: r };
    if (o.isText && o.text != a.text) {
      let u = 0, c = Math.min(o.text.length, a.text.length);
      for (; u < c && o.text[o.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (o.content.size || a.content.size) {
      let u = Qp(o.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= l, r -= l;
  }
}
class L {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], u = a + l.nodeSize;
      if (u > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, n - c), r, i + c);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      a.isText ? (s += a.text.slice(Math.max(e, l) - l, n - l), o = !r) : a.isLeaf ? (i ? s += typeof i == "function" ? i(a) : i : a.type.spec.leafText && (s += a.type.spec.leafText(a)), o = !r) : !o && a.isBlock && (s += r, o = !0);
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new L(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new L(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? L.empty : e == 0 && n == this.content.length ? this : new L(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new L(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new L([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new L(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return Yp(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return Qp(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return to(0, e);
    if (e == this.size)
      return to(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? to(r + 1, o) : to(r, i);
      i = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return L.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new L(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return L.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new L(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return L.empty;
    if (e instanceof L)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new L([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
L.empty = new L([], 0);
const El = { index: 0, offset: 0 };
function to(t, e) {
  return El.index = t, El.offset = e, El;
}
function jo(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!jo(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !jo(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let xe = class H1 {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        n || (n = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(s);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && jo(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    return r.create(n.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return H1.none;
    if (e instanceof H1)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
xe.none = [];
class Vo extends Error {
}
class j {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = Xp(this.content, e + this.openStart, n);
    return r && new j(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new j(Jp(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return j.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new j(L.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new j(e, r, i);
  }
}
j.empty = new j(L.empty, 0, 0);
function Jp(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: o, offset: a } = t.findIndex(n);
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, s.copy(Jp(s.content, e - i - 1, n - i - 1)));
}
function Xp(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e), o = t.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = Xp(o.content, e - s - 1, n);
  return a && t.replaceChild(i, o.copy(a));
}
function J2(t, e, n) {
  if (n.openStart > t.depth)
    throw new Vo("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new Vo("Inconsistent open depths");
  return Zp(t, e, n, 0);
}
function Zp(t, e, n, r) {
  let i = t.index(r), s = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let o = Zp(t, e, n, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let o = t.parent, a = o.content;
      return zr(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = X2(n, t);
      return zr(s, t0(t, o, a, e, r));
    }
  else
    return zr(s, Ko(t, e, r));
}
function e0(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new Vo("Cannot join " + e.type.name + " onto " + t.type.name);
}
function U1(t, e, n) {
  let r = t.node(n);
  return e0(r, e.node(n)), r;
}
function qr(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function Es(t, e, n, r) {
  let i = (e || t).node(n), s = 0, o = e ? e.index(n) : i.childCount;
  t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (qr(t.nodeAfter, r), s++));
  for (let a = s; a < o; a++)
    qr(i.child(a), r);
  e && e.depth == n && e.textOffset && qr(e.nodeBefore, r);
}
function zr(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function t0(t, e, n, r, i) {
  let s = t.depth > i && U1(t, e, i + 1), o = r.depth > i && U1(n, r, i + 1), a = [];
  return Es(null, t, i, a), s && o && e.index(i) == n.index(i) ? (e0(s, o), qr(zr(s, t0(t, e, n, r, i + 1)), a)) : (s && qr(zr(s, Ko(t, e, i + 1)), a), Es(e, n, i, a), o && qr(zr(o, Ko(n, r, i + 1)), a)), Es(r, null, i, a), new L(a);
}
function Ko(t, e, n) {
  let r = [];
  if (Es(null, t, n, r), t.depth > n) {
    let i = U1(t, e, n + 1);
    qr(zr(i, Ko(t, e, n + 1)), r);
  }
  return Es(e, null, n, r), new L(r);
}
function X2(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let s = n - 1; s >= 0; s--)
    i = e.node(s).copy(L.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class Rs {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return xe.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Wo(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, s = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), u = s - l;
      if (r.push(o, a, i + l), !u || (o = o.child(a), o.isText))
        break;
      s = u - 1, i += l + 1;
    }
    return new Rs(n, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    for (let i = 0; i < Tl.length; i++) {
      let s = Tl[i];
      if (s.pos == n && s.doc == e)
        return s;
    }
    let r = Tl[Al] = Rs.resolve(e, n);
    return Al = (Al + 1) % Z2, r;
  }
}
let Tl = [], Al = 0, Z2 = 12;
class Wo {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const e5 = /* @__PURE__ */ Object.create(null);
let fr = class q1 {
  /**
  @internal
  */
  constructor(e, n, r, i = xe.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || L.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  parent-relative position, its parent node, and its child index.
  When the callback returns false for a given node, that node's
  children will not be recursed over. The last parameter can be
  used to specify a starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && jo(this.attrs, n || e.defaultAttrs || e5) && xe.sameSet(this.marks, r || xe.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new q1(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new q1(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return j.empty;
    let i = this.resolve(e), s = this.resolve(n), o = r ? 0 : i.sharedDepth(n), a = i.start(o), u = i.node(o).content.cut(i.pos - a, s.pos - a);
    return new j(u, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return J2(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Rs.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Rs.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), n0(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = L.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < s; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, n);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let e = xe.none;
    for (let n = 0; n < this.marks.length; n++)
      e = this.marks[n].addToSet(e);
    if (!xe.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r = null;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = L.fromJSON(e, n.content);
    return e.nodeType(n.type).create(n.attrs, i, r);
  }
};
fr.prototype.text = void 0;
class Yo extends fr {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : n0(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Yo(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Yo(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function n0(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class jr {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new t5(e, n);
    if (r.next == null)
      return jr.empty;
    let i = r0(r);
    r.next && r.err("Unexpected trailing text");
    let s = l5(a5(i));
    return u5(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let s = n; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function s(o, a) {
      let l = o.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return L.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < o.next.length; u++) {
        let { type: c, next: f } = o.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(f) == -1) {
          i.push(f);
          let h = s(f, a.concat(c));
          if (h)
            return h;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = i; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
jr.empty = new jr(!0);
class t5 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function r0(t) {
  let e = [];
  do
    e.push(n5(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function n5(t) {
  let e = [];
  do
    e.push(r5(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function r5(t) {
  let e = o5(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = i5(t, e);
    else
      break;
  return e;
}
function Vc(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function i5(t, e) {
  let n = Vc(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = Vc(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function s5(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let s in n) {
    let o = n[s];
    o.groups.indexOf(e) > -1 && i.push(o);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function o5(t) {
  if (t.eat("(")) {
    let e = r0(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = s5(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function a5(t) {
  let e = [[]];
  return i(s(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(o, a, l) {
    let u = { term: l, to: a };
    return e[o].push(u), u;
  }
  function i(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, u) => l.concat(s(u, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let u = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (o.type == "star") {
      let l = n();
      return r(a, l), i(s(o.expr, l), l), [r(l)];
    } else if (o.type == "plus") {
      let l = n();
      return i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)];
    } else {
      if (o.type == "opt")
        return [r(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let u = 0; u < o.min; u++) {
          let c = n();
          i(s(o.expr, l), c), l = c;
        }
        if (o.max == -1)
          i(s(o.expr, l), l);
        else
          for (let u = o.min; u < o.max; u++) {
            let c = n();
            r(l, c), i(s(o.expr, l), c), l = c;
          }
        return [r(l)];
      } else {
        if (o.type == "name")
          return [r(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function i0(t, e) {
  return e - t;
}
function Kc(t, e) {
  let n = [];
  return r(e), n.sort(i0);
  function r(i) {
    let s = t[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    n.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function l5(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Kc(t, 0));
  function n(r) {
    let i = [];
    r.forEach((o) => {
      t[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let u;
        for (let c = 0; c < i.length; c++)
          i[c][0] == a && (u = i[c][1]);
        Kc(t, l).forEach((c) => {
          u || i.push([a, u = []]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let s = e[r.join(",")] = new jr(r.indexOf(t.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(i0);
      s.next.push({ type: i[o][0], next: e[a.join(",")] || n(a) });
    }
    return s;
  }
}
function u5(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], s = !i.validEnd, o = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: u } = i.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), r.indexOf(u) == -1 && r.push(u);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function s0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function o0(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let s = t[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function a0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let n in t)
      e[n] = new c5(t[n]);
  return e;
}
let Wc = class l0 {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = a0(r.attrs), this.defaultAttrs = s0(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == jr.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : o0(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new fr(this, this.computeAttrs(e), L.from(n), xe.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = L.from(n), this.checkContent(n), new fr(this, this.computeAttrs(e), n, xe.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = L.from(n), n.size) {
      let o = this.contentMatch.fillBefore(n);
      if (!o)
        return null;
      n = o.append(n);
    }
    let i = this.contentMatch.matchFragment(n), s = i && i.fillBefore(L.empty, !0);
    return s ? new fr(this, e, n.append(s), xe.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : xe.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new l0(s, n, o));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
class c5 {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Ia {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = a0(i.attrs), this.excluded = null;
    let s = s0(this.attrs);
    this.instance = s ? new xe(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new xe(this, o0(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new Ia(s, i++, n, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
let f5 = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = et.from(e.nodes), n.marks = et.from(e.marks || {}), this.nodes = Wc.compile(this.spec.nodes, this), this.marks = Ia.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", a = s.spec.marks;
      s.contentMatch = r[o] || (r[o] = jr.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.markSet = a == "_" ? null : a ? Yc(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : Yc(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Wc) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new Yo(r, r.defaultAttrs, e, xe.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return fr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return xe.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
};
function Yc(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = t.marks[i], o = s;
    if (s)
      n.push(s);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
class Vr {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [], n.forEach((r) => {
      r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new Jc(this, n, !1);
    return r.addAll(e, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new Jc(this, n, !0);
    return r.addAll(e, n.from, n.to), j.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (p5(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      n.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Xc(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Xc(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Vr(e, Vr.schemaRules(e)));
  }
}
const u0 = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, h5 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, c0 = { ol: !0, ul: !0 }, Qo = 1, Jo = 2, Ts = 4;
function Qc(t, e, n) {
  return e != null ? (e ? Qo : 0) | (e === "full" ? Jo : 0) : t && t.whitespace == "pre" ? Qo | Jo : n & ~Ts;
}
class no {
  constructor(e, n, r, i, s, o, a) {
    this.type = e, this.attrs = n, this.marks = r, this.pendingMarks = i, this.solid = s, this.options = a, this.content = [], this.activeMarks = xe.none, this.stashMarks = [], this.match = o || (a & Ts ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(L.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Qo)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let n = L.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(L.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  popFromStashMark(e) {
    for (let n = this.stashMarks.length - 1; n >= 0; n--)
      if (e.eq(this.stashMarks[n]))
        return this.stashMarks.splice(n, 1)[0];
  }
  applyPending(e) {
    for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
      let i = r[n];
      (this.type ? this.type.allowsMarkType(i.type) : g5(i.type, e)) && !i.isInSet(this.activeMarks) && (this.activeMarks = i.addToSet(this.activeMarks), this.pendingMarks = i.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !u0.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Jc {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0;
    let i = n.topNode, s, o = Qc(null, n.preserveWhitespace, 0) | (r ? Ts : 0);
    i ? s = new no(i.type, i.attrs, xe.none, xe.none, !0, n.topMatch || i.type.contentMatch, o) : r ? s = new no(null, null, xe.none, xe.none, !0, null, o) : s = new no(e.schema.topNodeType, null, xe.none, xe.none, !0, null, o), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    if (e.nodeType == 3)
      this.addTextNode(e);
    else if (e.nodeType == 1) {
      let n = e.getAttribute("style");
      if (!n)
        this.addElement(e);
      else {
        let r = this.readStyles(m5(n));
        if (!r)
          return;
        let [i, s] = r, o = this.top;
        for (let a = 0; a < s.length; a++)
          this.removePendingMark(s[a], o);
        for (let a = 0; a < i.length; a++)
          this.addPendingMark(i[a]);
        this.addElement(e);
        for (let a = 0; a < i.length; a++)
          this.removePendingMark(i[a], o);
        for (let a = 0; a < s.length; a++)
          this.addPendingMark(s[a]);
      }
    }
  }
  addTextNode(e) {
    let n = e.nodeValue, r = this.top;
    if (r.options & Jo || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (r.options & Qo)
        r.options & Jo ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let i = r.content[r.content.length - 1], s = e.previousSibling;
        (!i || s && s.nodeName == "BR" || i.isText && /[ \t\r\n\u000c]$/.test(i.text)) && (n = n.slice(1));
      }
      n && this.insertNode(this.parser.schema.text(n)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n) {
    let r = e.nodeName.toLowerCase(), i;
    c0.hasOwnProperty(r) && this.parser.normalizeLists && d5(e);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, n));
    if (s ? s.ignore : h5.hasOwnProperty(r))
      this.findInside(e), this.ignoreFallback(e);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
      let o, a = this.top, l = this.needsBlock;
      if (u0.hasOwnProperty(r))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), o = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      this.addAll(e), o && this.sync(a), this.needsBlock = l;
    } else
      this.addElementByRule(e, s, s.consuming === !1 ? i : void 0);
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let n = xe.none, r = xe.none;
    e:
      for (let i = 0; i < e.length; i += 2)
        for (let s = void 0; ; ) {
          let o = this.parser.matchStyle(e[i], e[i + 1], this, s);
          if (!o)
            continue e;
          if (o.ignore)
            return null;
          if (o.clearMark ? this.top.pendingMarks.forEach((a) => {
            o.clearMark(a) && (r = a.addToSet(r));
          }) : n = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(n), o.consuming === !1)
            s = o;
          else
            break;
        }
    return [n, r];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r) {
    let i, s, o;
    n.node ? (s = this.parser.schema.nodes[n.node], s.isLeaf ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e) : i = this.enter(s, n.attrs || null, n.preserveWhitespace)) : (o = this.parser.schema.marks[n.mark].create(n.attrs), this.addPendingMark(o));
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l);
    }
    i && this.sync(a) && this.open--, o && this.removePendingMark(o, a);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r) {
    let i = n || 0;
    for (let s = n ? e.childNodes[n] : e.firstChild, o = r == null ? null : e.childNodes[r]; s != o; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let n, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], o = s.findWrapping(e);
      if (o && (!n || n.length > o.length) && (n = o, r = s, !o.length) || s.solid)
        break;
    }
    if (!n)
      return !1;
    this.sync(r);
    for (let i = 0; i < n.length; i++)
      this.enterInner(n[i], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let n = this.textblockFromContext();
      n && this.enterInner(n);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let n = this.top;
      n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type));
      let r = n.activeMarks;
      for (let i = 0; i < e.marks.length; i++)
        (!n.type || n.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
      return n.content.push(e.mark(r)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r) {
    let i = this.findPlace(e.create(n));
    return i && this.enterInner(e, n, !0, r), i;
  }
  // Open a node of the given type
  enterInner(e, n = null, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.applyPending(e), s.match = s.match && s.match.matchType(e);
    let o = Qc(e, i, s.options);
    s.options & Ts && s.content.length == 0 && (o |= Ts), this.nodes.push(new no(e, n, s.activeMarks, s.pendingMarks, r, null, o)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
          if (!c || c.name != u && c.groups.indexOf(u) == -1)
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
  addPendingMark(e) {
    let n = E5(e, this.top.pendingMarks);
    n && this.top.stashMarks.push(n), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, n) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r];
      if (i.pendingMarks.lastIndexOf(e) > -1)
        i.pendingMarks = e.removeFromSet(i.pendingMarks);
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks);
        let o = i.popFromStashMark(e);
        o && i.type && i.type.allowsMarkType(o.type) && (i.activeMarks = o.addToSet(i.activeMarks));
      }
      if (i == n)
        break;
    }
  }
}
function d5(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && c0.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function p5(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function m5(t) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, n, r = [];
  for (; n = e.exec(t); )
    r.push(n[1], n[2].trim());
  return r;
}
function Xc(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function g5(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: u, next: c } = a.edge(l);
        if (u == e || s.indexOf(c) < 0 && o(c))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
function E5(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.eq(e[n]))
      return e[n];
}
class an {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = yl(n).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let u = o.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(s[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          i = s.pop()[1];
        for (; l < o.marks.length; ) {
          let u = o.marks[l++], c = this.serializeMark(u, o.isInline, n);
          c && (s.push([u, i]), i.appendChild(c.dom), i = c.contentDOM || c.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = an.renderSpec(yl(n), this.nodes[e.type.name](e));
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, n);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && an.renderSpec(yl(r), i(e, n));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(e, n, r = null) {
    if (typeof n == "string")
      return { dom: e.createTextNode(n) };
    if (n.nodeType != null)
      return { dom: n };
    if (n.dom && n.dom.nodeType != null)
      return n;
    let i = n[0], s = i.indexOf(" ");
    s > 0 && (r = i.slice(0, s), i = i.slice(s + 1));
    let o, a = r ? e.createElementNS(r, i) : e.createElement(i), l = n[1], u = 1;
    if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
      u = 2;
      for (let c in l)
        if (l[c] != null) {
          let f = c.indexOf(" ");
          f > 0 ? a.setAttributeNS(c.slice(0, f), c.slice(f + 1), l[c]) : a.setAttribute(c, l[c]);
        }
    }
    for (let c = u; c < n.length; c++) {
      let f = n[c];
      if (f === 0) {
        if (c < n.length - 1 || c > u)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: a, contentDOM: a };
      } else {
        let { dom: h, contentDOM: d } = an.renderSpec(e, f, r);
        if (a.appendChild(h), d) {
          if (o)
            throw new RangeError("Multiple content holes");
          o = d;
        }
      }
    }
    return { dom: a, contentDOM: o };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new an(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Zc(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Zc(e.marks);
  }
}
function Zc(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function yl(t) {
  return t.document || window.document;
}
const f0 = 65535, h0 = Math.pow(2, 16);
function T5(t, e) {
  return t + e * h0;
}
function ef(t) {
  return t & f0;
}
function A5(t) {
  return (t - (t & f0)) / h0;
}
const d0 = 1, p0 = 2, wo = 4, m0 = 8;
class z1 {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & m0) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (d0 | wo)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (p0 | wo)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & wo) > 0;
  }
}
class zt {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && zt.empty)
      return zt.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = ef(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + A5(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let u = this.ranges[a + s], c = this.ranges[a + o], f = l + u;
      if (e <= f) {
        let h = u ? e == l ? -1 : e == f ? 1 : n : n, d = l + i + (h < 0 ? 0 : c);
        if (r)
          return d;
        let m = e == (n < 0 ? l : f) ? null : T5(a / 3, e - l), g = e == l ? p0 : e == f ? d0 : wo;
        return (n < 0 ? e != l : e != f) && (g |= m0), new z1(d, g, m);
      }
      i += c - u;
    }
    return r ? e + i : new z1(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = ef(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let u = this.ranges[a + s], c = l + u;
      if (e <= c && a == i * 3)
        return !0;
      r += this.ranges[a + o] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), u = this.ranges[i + n], c = this.ranges[i + r];
      e(a, a + u, l, l + c), s += c - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new zt(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? zt.empty : new zt(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
zt.empty = new zt([]);
class ki {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new ki(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new ki(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new ki();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new z1(e, i, null);
  }
}
const Cl = /* @__PURE__ */ Object.create(null);
class St {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return zt.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Cl[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Cl)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Cl[e] = n, n.prototype.jsonID = e, n;
  }
}
class Ke {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Ke(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Ke(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return Ke.ok(e.replace(n, r, i));
    } catch (s) {
      if (s instanceof Vo)
        return Ke.fail(s.message);
      throw s;
    }
  }
}
function _u(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i);
    s.content.size && (s = s.copy(_u(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s);
  }
  return L.fromArray(r);
}
class lr extends St {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new j(_u(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
    return Ke.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new bn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new lr(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof lr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new lr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new lr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
St.jsonID("addMark", lr);
class bn extends St {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new j(_u(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return Ke.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new lr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new bn(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof bn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new bn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new bn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
St.jsonID("removeMark", bn);
class ur extends St {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ke.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Ke.fromReplace(e, this.pos, this.pos + 1, new j(L.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new ur(this.pos, n.marks[i]);
        return new ur(this.pos, this.mark);
      }
    }
    return new vi(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ur(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new ur(n.pos, e.markFromJSON(n.mark));
  }
}
St.jsonID("addNodeMark", ur);
class vi extends St {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ke.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Ke.fromReplace(e, this.pos, this.pos + 1, new j(L.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new ur(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new vi(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new vi(n.pos, e.markFromJSON(n.mark));
  }
}
St.jsonID("removeNodeMark", vi);
class at extends St {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && $1(e, this.from, this.to) ? Ke.fail("Structure replace would overwrite content") : Ke.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new zt([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new at(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new at(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof at) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? j.empty : new j(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new at(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? j.empty : new j(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new at(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new at(n.from, n.to, j.fromJSON(e, n.slice), !!n.structure);
  }
}
St.jsonID("replace", at);
class Xe extends St {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && ($1(e, this.from, this.gapFrom) || $1(e, this.gapTo, this.to)))
      return Ke.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Ke.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Ke.fromReplace(e, this.from, this.to, r) : Ke.fail("Content does not fit in gap");
  }
  getMap() {
    return new zt([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Xe(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = e.map(this.gapFrom, -1), s = e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new Xe(n.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Xe(n.from, n.to, n.gapFrom, n.gapTo, j.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
St.jsonID("replaceAround", Xe);
function $1(t, e, n) {
  let r = t.resolve(e), i = n - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function y5(t, e, n, r) {
  let i = [], s = [], o, a;
  t.doc.nodesBetween(e, n, (l, u, c) => {
    if (!l.isInline)
      return;
    let f = l.marks;
    if (!r.isInSet(f) && c.type.allowsMarkType(r.type)) {
      let h = Math.max(u, e), d = Math.min(u + l.nodeSize, n), m = r.addToSet(f);
      for (let g = 0; g < f.length; g++)
        f[g].isInSet(m) || (o && o.to == h && o.mark.eq(f[g]) ? o.to = d : i.push(o = new bn(h, d, f[g])));
      a && a.to == h ? a.to = d : s.push(a = new lr(h, d, r));
    }
  }), i.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function C5(t, e, n, r) {
  let i = [], s = 0;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (r instanceof Ia) {
      let u = o.marks, c;
      for (; c = r.isInSet(u); )
        (l || (l = [])).push(c), u = c.removeFromSet(u);
    } else
      r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let u = Math.min(a + o.nodeSize, n);
      for (let c = 0; c < l.length; c++) {
        let f = l[c], h;
        for (let d = 0; d < i.length; d++) {
          let m = i[d];
          m.step == s - 1 && f.eq(i[d].style) && (h = m);
        }
        h ? (h.to = u, h.step = s) : i.push({ style: f, from: Math.max(a, e), to: u, step: s });
      }
    }
  }), i.forEach((o) => t.step(new bn(o.from, o.to, o.style)));
}
function b5(t, e, n, r = n.contentMatch) {
  let i = t.doc.nodeAt(e), s = [], o = e + 1;
  for (let a = 0; a < i.childCount; a++) {
    let l = i.child(a), u = o + l.nodeSize, c = r.matchType(l.type);
    if (!c)
      s.push(new at(o, u, j.empty));
    else {
      r = c;
      for (let f = 0; f < l.marks.length; f++)
        n.allowsMarkType(l.marks[f].type) || t.step(new bn(o, u, l.marks[f]));
    }
    o = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(L.empty, !0);
    t.replace(o, o, new j(a, 0, 0));
  }
  for (let a = s.length - 1; a >= 0; a--)
    t.step(s[a]);
}
function x5(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function qi(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), s = t.$from.index(r), o = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(s, o, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !x5(i, s, o))
      break;
  }
  return null;
}
function S5(t, e, n) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), l = o, u = a, c = L.empty, f = 0;
  for (let m = s, g = !1; m > n; m--)
    g || r.index(m) > 0 ? (g = !0, c = L.from(r.node(m).copy(c)), f++) : l--;
  let h = L.empty, d = 0;
  for (let m = s, g = !1; m > n; m--)
    g || i.after(m + 1) < i.end(m) ? (g = !0, h = L.from(i.node(m).copy(h)), d++) : u++;
  t.step(new Xe(l, u, o, a, new j(c.append(h), f, d), c.size - f, !0));
}
function ku(t, e, n = null, r = t) {
  let i = N5(t, e), s = i && _5(r, e);
  return s ? i.map(tf).concat({ type: e, attrs: n }).concat(s.map(tf)) : null;
}
function tf(t) {
  return { type: t, attrs: null };
}
function N5(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return n.canReplaceWith(r, i, o) ? s : null;
}
function _5(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let u = r; l && u < i; u++)
    l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : o;
}
function k5(t, e, n) {
  let r = L.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = n[o].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = L.from(n[o].type.create(n[o].attrs, r));
  }
  let i = e.start, s = e.end;
  t.step(new Xe(i, s, i, s, new j(r, 0, 0), n.length, !0));
}
function O5(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (o.isTextblock && !o.hasMarkup(r, i) && w5(t.doc, t.mapping.slice(s).map(a), r)) {
      t.clearIncompatible(t.mapping.slice(s).map(a, 1), r);
      let l = t.mapping.slice(s), u = l.map(a, 1), c = l.map(a + o.nodeSize, 1);
      return t.step(new Xe(u, c, u + 1, c - 1, new j(L.from(r.create(i, null, o.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function w5(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function D5(t, e, n, r, i) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  n || (n = s.type);
  let o = n.create(r, null, i || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, o);
  if (!n.validContent(s.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Xe(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new j(L.from(o), 0, 0), 1, !0));
}
function Oi(t, e, n = 1, r) {
  let i = t.resolve(e), s = i.depth - n, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, c = n - 2; u > s; u--, c--) {
    let f = i.node(u), h = i.index(u);
    if (f.type.spec.isolating)
      return !1;
    let d = f.content.cutByIndex(h, f.childCount), m = r && r[c] || f;
    if (m != f && (d = d.replaceChild(0, m.type.create(m.attrs))), !f.canReplace(h + 1, f.childCount) || !m.type.validContent(d))
      return !1;
  }
  let a = i.indexAfter(s), l = r && r[0];
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type);
}
function I5(t, e, n = 1, r) {
  let i = t.doc.resolve(e), s = L.empty, o = L.empty;
  for (let a = i.depth, l = i.depth - n, u = n - 1; a > l; a--, u--) {
    s = L.from(i.node(a).copy(s));
    let c = r && r[u];
    o = L.from(c ? c.type.create(c.attrs, o) : i.node(a).copy(o));
  }
  t.step(new at(e, e, new j(s.append(o), n, n), !0));
}
function Ar(t, e) {
  let n = t.resolve(e), r = n.index();
  return g0(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function g0(t, e) {
  return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function E0(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let s, o, a = r.index(i);
    if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : n > 0 ? (s = r.node(i + 1), a++, o = r.node(i).maybeChild(a)) : (s = r.node(i).maybeChild(a - 1), o = r.node(i + 1)), s && !s.isTextblock && g0(s, o) && r.node(i).canReplace(a, a + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function M5(t, e, n) {
  let r = new at(e - n, e + n, j.empty, !0);
  t.step(r);
}
function R5(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function v5(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let s = 0; s < n.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (a > 0 ? 1 : 0), u = r.node(o), c = !1;
      if (s == 1)
        c = u.canReplace(l, l, i);
      else {
        let f = u.contentMatchAt(l).findWrapping(i.firstChild.type);
        c = f && u.canReplaceWith(l, l, f[0]);
      }
      if (c)
        return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function Ou(t, e, n = e, r = j.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), s = t.resolve(n);
  return T0(i, s, r) ? new at(e, n, r) : new L5(i, s, r).fit();
}
function T0(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class L5 {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = L.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = L.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, a = i.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new j(s, o, a);
    return e > -1 ? new Xe(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new at(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = n.firstChild;
      if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = s.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = bl(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: u } = this.frontier[a], c, f = null;
          if (n == 1 && (o ? u.matchType(o.type) || (f = u.fillBefore(L.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: f };
          if (n == 2 && o && (c = u.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: c };
          if (s && u.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = bl(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new j(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = bl(e, n);
    if (i.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + i.size;
      this.unplaced = new j(ds(e, n - 1, 1), n - 1, s ? n - 1 : r);
    } else
      this.unplaced = new j(ds(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (s)
      for (let g = 0; g < s.length; g++)
        this.openFrontierNode(s[g]);
    let o = this.unplaced, a = r ? r.content : o.content, l = o.openStart - e, u = 0, c = [], { match: f, type: h } = this.frontier[n];
    if (i) {
      for (let g = 0; g < i.childCount; g++)
        c.push(i.child(g));
      f = f.matchFragment(i);
    }
    let d = a.size + e - (o.content.size - o.openEnd);
    for (; u < a.childCount; ) {
      let g = a.child(u), E = f.matchType(g.type);
      if (!E)
        break;
      u++, (u > 1 || l == 0 || g.content.size) && (f = E, c.push(A0(g.mark(h.allowedMarks(g.marks)), u == 1 ? l : 0, u == a.childCount ? d : -1)));
    }
    let m = u == a.childCount;
    m || (d = -1), this.placed = ps(this.placed, n, L.from(c)), this.frontier[n].match = f, m && d < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, E = a; g < d; g++) {
      let T = E.lastChild;
      this.frontier.push({ type: T.type, match: T.contentMatchAt(T.childCount) }), E = T.content;
    }
    this.unplaced = m ? e == 0 ? j.empty : new j(ds(o.content, e - 1, 1), e - 1, d < 0 ? o.openEnd : e - 1) : new j(ds(o.content, e, u), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !xl(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: r, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = xl(e, n, i, r, s);
        if (o) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: u } = this.frontier[a], c = xl(e, a, u, l, !0);
            if (!c || c.childCount)
              continue e;
          }
          return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = ps(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = ps(this.placed, this.depth, L.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(L.empty, !0);
    n.childCount && (this.placed = ps(this.placed, this.frontier.length, n));
  }
}
function ds(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(ds(t.firstChild.content, e - 1, n)));
}
function ps(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(ps(t.lastChild.content, e - 1, n)));
}
function bl(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function A0(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, A0(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(L.empty, !0)))), t.copy(r);
}
function xl(t, e, n, r, i) {
  let s = t.node(e), o = i ? t.indexAfter(e) : t.index(e);
  if (o == s.childCount && !n.compatibleContent(s.type))
    return null;
  let a = r.fillBefore(s.content, !0, o);
  return a && !P5(n, s.content, o) ? a : null;
}
function P5(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function B5(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function F5(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), s = t.doc.resolve(n);
  if (T0(i, s, r))
    return t.step(new at(e, n, r));
  let o = C0(i, t.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(i.depth + 1);
  o.unshift(a);
  for (let h = i.depth, d = i.pos - 1; h > 0; h--, d--) {
    let m = i.node(h).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    o.indexOf(h) > -1 ? a = h : i.before(h) == d && o.splice(1, 0, -h);
  }
  let l = o.indexOf(a), u = [], c = r.openStart;
  for (let h = r.content, d = 0; ; d++) {
    let m = h.firstChild;
    if (u.push(m), d == r.openStart)
      break;
    h = m.content;
  }
  for (let h = c - 1; h >= 0; h--) {
    let d = u[h].type, m = B5(d);
    if (m && i.node(l).type != d)
      c = h;
    else if (m || !d.isTextblock)
      break;
  }
  for (let h = r.openStart; h >= 0; h--) {
    let d = (h + c + 1) % (r.openStart + 1), m = u[d];
    if (m)
      for (let g = 0; g < o.length; g++) {
        let E = o[(g + l) % o.length], T = !0;
        E < 0 && (T = !1, E = -E);
        let k = i.node(E - 1), _ = i.index(E - 1);
        if (k.canReplaceWith(_, _, m.type, m.marks))
          return t.replace(i.before(E), T ? s.after(E) : n, new j(y0(r.content, 0, r.openStart, d), d, r.openEnd));
      }
  }
  let f = t.steps.length;
  for (let h = o.length - 1; h >= 0 && (t.replace(e, n, r), !(t.steps.length > f)); h--) {
    let d = o[h];
    d < 0 || (e = i.before(d), n = s.after(d));
  }
}
function y0(t, e, n, r, i) {
  if (e < n) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy(y0(s.content, e + 1, n, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(t).append(t);
    t = o.append(s.matchFragment(o).fillBefore(L.empty, !0));
  }
  return t;
}
function H5(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = R5(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new j(L.from(r), 0, 0));
}
function U5(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), s = C0(r, i);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
      return t.delete(r.before(o), n);
  t.delete(e, n);
}
function C0(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = t.start(i);
    if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i);
  }
  return n;
}
class wi extends St {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ke.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      r[s] = n.attrs[s];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Ke.fromReplace(e, this.pos, this.pos + 1, new j(L.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return zt.empty;
  }
  invert(e) {
    return new wi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new wi(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new wi(n.pos, n.attr, n.value);
  }
}
St.jsonID("attr", wi);
let Li = class extends Error {
};
Li = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
Li.prototype = Object.create(Error.prototype);
Li.prototype.constructor = Li;
Li.prototype.name = "TransformError";
class b0 {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new ki();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new Li(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = j.empty) {
    let i = Ou(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new j(L.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, j.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return F5(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return H5(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return U5(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return S5(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return M5(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return k5(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return O5(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return D5(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new wi(e, n, r)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new ur(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof xe)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new vi(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return I5(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return y5(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return C5(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return b5(this, e, n, r), this;
  }
}
const Sl = /* @__PURE__ */ Object.create(null);
class oe {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new q5(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = j.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: u } = o[a], c = e.mapping.slice(s);
      e.replaceRange(c.map(l.pos), c.map(u.pos), a ? j.empty : n), a == 0 && sf(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s], l = e.mapping.slice(r), u = l.map(o.pos), c = l.map(a.pos);
      s ? e.deleteRange(u, c) : (e.replaceRangeWith(u, c, n), sf(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new ae(e) : di(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = n < 0 ? di(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : di(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new ln(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return di(e, e, 0, 0, 1) || new ln(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return di(e, e, e.content.size, e.childCount, -1) || new ln(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Sl[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in Sl)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Sl[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ae.between(this.$anchor, this.$head).getBookmark();
  }
}
oe.prototype.visible = !0;
class q5 {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let nf = !1;
function rf(t) {
  !nf && !t.parent.inlineContent && (nf = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ae extends oe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    rf(e), rf(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return oe.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new ae(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = j.empty) {
    if (super.replace(e, n), n == j.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ae && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Ma(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ae(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let s = oe.findFrom(n, r, !0) || oe.findFrom(n, -r, !0);
      if (s)
        n = s.$head;
      else
        return oe.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = (oe.findFrom(e, -r, !0) || oe.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new ae(e, n);
  }
}
oe.jsonID("text", ae);
class Ma {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Ma(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ae.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ne extends oe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), s = e.resolve(i);
    return r ? oe.near(s) : new ne(s);
  }
  content() {
    return new j(L.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ne && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new wu(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ne(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ne(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ne.prototype.visible = !1;
oe.jsonID("node", ne);
class wu {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Ma(r, r) : new wu(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && ne.isSelectable(r) ? new ne(n) : oe.near(n);
  }
}
class ln extends oe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = j.empty) {
    if (n == j.empty) {
      e.delete(0, e.doc.content.size);
      let r = oe.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ln(e);
  }
  map(e) {
    return new ln(e);
  }
  eq(e) {
    return e instanceof ln;
  }
  getBookmark() {
    return z5;
  }
}
oe.jsonID("all", ln);
const z5 = {
  map() {
    return this;
  },
  resolve(t) {
    return new ln(t);
  }
};
function di(t, e, n, r, i, s = !1) {
  if (e.inlineContent)
    return ae.create(t, n);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && ne.isSelectable(a))
        return ne.create(t, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = di(t, a, n + i, i < 0 ? a.childCount : 0, i, s);
      if (l)
        return l;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function sf(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof at || i instanceof Xe))
    return;
  let s = t.mapping.maps[r], o;
  s.forEach((a, l, u, c) => {
    o == null && (o = c);
  }), t.setSelection(oe.near(t.doc.resolve(o), n));
}
const of = 1, ro = 2, af = 4;
class $5 extends b0 {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | of) & ~ro, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & of) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= ro, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return xe.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & ro) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~ro, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || xe.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(n);
        s = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, s)), this.selection.empty || this.setSelection(oe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= af, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & af) > 0;
  }
}
function lf(t, e) {
  return !e || !t ? t : t.bind(e);
}
class ms {
  constructor(e, n, r) {
    this.name = e, this.init = lf(n.init, r), this.apply = lf(n.apply, r);
  }
}
const G5 = [
  new ms("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new ms("selection", {
    init(t, e) {
      return t.selection || oe.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new ms("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new ms("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Nl {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = G5.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new ms(r.key, r.spec.state, r));
    });
  }
}
class Ai {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0, u = i ? i[o].state : this, c = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, u, r);
          if (c && r.filterTransaction(c, o)) {
            if (c.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let f = 0; f < this.config.plugins.length; f++)
                i.push(f < o ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(c), r = r.applyInner(c), s = !0;
          }
          i && (i[o] = { state: r, n: n.length });
        }
      }
      if (!s)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Ai(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      n[s.name] = s.apply(e, this[s.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new $5(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new Nl(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Ai(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new Nl(this.schema, e.plugins), r = n.fields, i = new Ai(n);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Nl(e.schema, e.plugins), s = new Ai(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = fr.fromJSON(e.schema, n.doc);
      else if (o.name == "selection")
        s.selection = oe.fromJSON(s.doc, n.selection);
      else if (o.name == "storedMarks")
        n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], u = l.spec.state;
            if (l.key == o.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              s[o.name] = u.fromJSON.call(l, e, n[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function x0(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = x0(i, e, {})), n[r] = i;
  }
  return n;
}
class Ye {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && x0(e.props, this, this.props), this.key = e.key ? e.key.key : S0("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const _l = /* @__PURE__ */ Object.create(null);
function S0(t) {
  return t in _l ? t + "$" + ++_l[t] : (_l[t] = 0, t + "$");
}
class st {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = S0(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const It = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, vs = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let uf = null;
const Bn = function(t, e, n) {
  let r = uf || (uf = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, Kr = function(t, e, n, r) {
  return n && (cf(t, e, n, r, -1) || cf(t, e, n, r, 1));
}, j5 = /^(img|br|input|textarea|hr)$/i;
function cf(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : yn(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || K5(t) || j5.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = It(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? yn(t) : 0;
    } else
      return !1;
  }
}
function yn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function V5(t, e, n) {
  for (let r = e == 0, i = e == yn(t); r || i; ) {
    if (t == n)
      return !0;
    let s = It(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && s == 0, i = i && s == yn(t);
  }
}
function K5(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Ra = function(t) {
  return t.focusNode && Kr(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Mr(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function W5(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
const Er = typeof navigator < "u" ? navigator : null, ff = typeof document < "u" ? document : null, yr = Er && Er.userAgent || "", G1 = /Edge\/(\d+)/.exec(yr), N0 = /MSIE \d/.exec(yr), j1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(yr), xt = !!(N0 || j1 || G1), hr = N0 ? document.documentMode : j1 ? +j1[1] : G1 ? +G1[1] : 0, cn = !xt && /gecko\/(\d+)/i.test(yr);
cn && +(/Firefox\/(\d+)/.exec(yr) || [0, 0])[1];
const V1 = !xt && /Chrome\/(\d+)/.exec(yr), dt = !!V1, Y5 = V1 ? +V1[1] : 0, mt = !xt && !!Er && /Apple Computer/.test(Er.vendor), Pi = mt && (/Mobile\/\w+/.test(yr) || !!Er && Er.maxTouchPoints > 2), Ht = Pi || (Er ? /Mac/.test(Er.platform) : !1), sn = /Android \d/.test(yr), va = !!ff && "webkitFontSmoothing" in ff.documentElement.style, Q5 = va ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function J5(t) {
  return {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function Kn(t, e) {
  return typeof t == "number" ? t : t[e];
}
function X5(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function hf(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, s = t.dom.ownerDocument;
  for (let o = n || t.dom; o; o = vs(o)) {
    if (o.nodeType != 1)
      continue;
    let a = o, l = a == s.body, u = l ? J5(s) : X5(a), c = 0, f = 0;
    if (e.top < u.top + Kn(r, "top") ? f = -(u.top - e.top + Kn(i, "top")) : e.bottom > u.bottom - Kn(r, "bottom") && (f = e.bottom - u.bottom + Kn(i, "bottom")), e.left < u.left + Kn(r, "left") ? c = -(u.left - e.left + Kn(i, "left")) : e.right > u.right - Kn(r, "right") && (c = e.right - u.right + Kn(i, "right")), c || f)
      if (l)
        s.defaultView.scrollBy(c, f);
      else {
        let h = a.scrollLeft, d = a.scrollTop;
        f && (a.scrollTop += f), c && (a.scrollLeft += c);
        let m = a.scrollLeft - h, g = a.scrollTop - d;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    if (l)
      break;
  }
}
function Z5(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t.root.elementFromPoint(s, o);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: _0(t.dom) };
}
function _0(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = vs(r))
    ;
  return e;
}
function e4({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  k0(n, r == 0 ? 0 : r - e);
}
function k0(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: s } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let oi = null;
function t4(t) {
  if (t.setActive)
    return t.setActive();
  if (oi)
    return t.focus(oi);
  let e = _0(t);
  t.focus(oi == null ? {
    get preventScroll() {
      return oi = { preventScroll: !0 }, !0;
    }
  } : void 0), oi || (oi = !1, k0(e, 0));
}
function O0(t, e) {
  let n, r = 2e8, i, s = 0, o = e.top, a = e.top;
  for (let l = t.firstChild, u = 0; l; l = l.nextSibling, u++) {
    let c;
    if (l.nodeType == 1)
      c = l.getClientRects();
    else if (l.nodeType == 3)
      c = Bn(l).getClientRects();
    else
      continue;
    for (let f = 0; f < c.length; f++) {
      let h = c[f];
      if (h.top <= o && h.bottom >= a) {
        o = Math.max(h.bottom, o), a = Math.min(h.top, a);
        let d = h.left > e.left ? h.left - e.left : h.right < e.left ? e.left - h.right : 0;
        if (d < r) {
          n = l, r = d, i = d && n.nodeType == 3 ? {
            left: h.right < e.left ? h.right : h.left,
            top: e.top
          } : e, l.nodeType == 1 && d && (s = u + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
          continue;
        }
      }
      !n && (e.left >= h.right && e.top >= h.top || e.left >= h.left && e.top >= h.bottom) && (s = u + 1);
    }
  }
  return n && n.nodeType == 3 ? n4(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: s } : O0(n, i);
}
function n4(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let s = er(r, 1);
    if (s.top != s.bottom && Du(e, s))
      return { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function Du(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function r4(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function i4(t, e, n) {
  let { node: r, offset: i } = O0(e, n), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, s);
}
function s4(t, e, n, r) {
  let i = -1;
  for (let s = e, o = !1; s != t.dom; ) {
    let a = t.docView.nearestDesc(s, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent && !o || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && !o && (o = !0, l.left > r.left || l.top > r.top ? i = a.posBefore : (l.right < r.left || l.bottom < r.top) && (i = a.posAfter)), !a.contentDOM && i < 0)
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    s = a.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function w0(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ; ) {
      let o = t.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          if (Du(e, u))
            return w0(o, e, u);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return t;
}
function o4(t, e) {
  let n = t.dom.ownerDocument, r, i = 0;
  if (n.caretPositionFromPoint)
    try {
      let l = n.caretPositionFromPoint(e.left, e.top);
      l && ({ offsetNode: r, offset: i } = l);
    } catch {
    }
  if (!r && n.caretRangeFromPoint) {
    let l = n.caretRangeFromPoint(e.left, e.top);
    l && ({ startContainer: r, startOffset: i } = l);
  }
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), o;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let l = t.dom.getBoundingClientRect();
    if (!Du(e, l) || (s = w0(t.dom, e, l), !s))
      return null;
  }
  if (mt)
    for (let l = s; r && l; l = vs(l))
      l.draggable && (r = void 0);
  if (s = r4(s, e), r) {
    if (cn && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let l = r.childNodes[i], u;
      l.nodeName == "IMG" && (u = l.getBoundingClientRect()).right <= e.left && u.bottom > e.top && i++;
    }
    r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? o = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (o = s4(t, r, i, e));
  }
  o == null && (o = i4(t, s, e));
  let a = t.docView.nearestDesc(s, !0);
  return { pos: o, inside: a ? a.posAtStart - a.border : -1 };
}
function er(t, e) {
  let n = t.getClientRects();
  return n.length ? n[e < 0 ? 0 : n.length - 1] : t.getBoundingClientRect();
}
const a4 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function D0(t, e, n) {
  let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1), o = va || cn;
  if (r.nodeType == 3)
    if (o && (a4.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = er(Bn(r, i, i), n);
      if (cn && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = er(Bn(r, i - 1, i - 1), -1);
        if (u.top == l.top) {
          let c = er(Bn(r, i, i + 1), -1);
          if (c.top != l.top)
            return ts(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = i, u = i, c = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, c = -1) : n >= 0 && i == r.nodeValue.length ? (l--, c = 1) : n < 0 ? l-- : u++, ts(er(Bn(r, l, u), 1), c < 0);
    }
  if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (n < 0 || i == yn(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return kl(l.getBoundingClientRect(), !1);
    }
    if (s == null && i < yn(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return kl(l.getBoundingClientRect(), !0);
    }
    return kl(r.getBoundingClientRect(), n >= 0);
  }
  if (s == null && i && (n < 0 || i == yn(r))) {
    let l = r.childNodes[i - 1], u = l.nodeType == 3 ? Bn(l, yn(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return ts(er(u, 1), !1);
  }
  if (s == null && i < yn(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? Bn(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return ts(er(u, -1), !0);
  }
  return ts(er(r.nodeType == 3 ? Bn(r) : r, -n), n >= 0);
}
function ts(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function kl(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function I0(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function l4(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return I0(t, e, () => {
    let { node: s } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = D0(t, i.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Bn(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (c.bottom > c.top + 1 && (n == "up" ? o.top - c.top > (c.bottom - o.top) * 2 : c.bottom - o.bottom > (o.bottom - c.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const u4 = /[\u0590-\u08ac]/;
function c4(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, a = t.domSelection();
  return !u4.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : o : I0(t, e, () => {
    let { focusNode: l, focusOffset: u, anchorNode: c, anchorOffset: f } = t.domSelectionRange(), h = a.caretBidiLevel;
    a.modify("move", n, "character");
    let d = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: m, focusOffset: g } = t.domSelectionRange(), E = m && !d.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && u == g;
    try {
      a.collapse(c, f), l && (l != c || u != f) && a.extend && a.extend(l, u);
    } catch {
    }
    return h != null && (a.caretBidiLevel = h), E;
  });
}
let df = null, pf = null, mf = !1;
function f4(t, e, n) {
  return df == e && pf == n ? mf : (df = e, pf = n, mf = n == "up" || n == "down" ? l4(t, e, n) : c4(t, e, n));
}
const un = 0, gf = 1, yi = 2, Sn = 3;
class js {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = un, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > It(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!n || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], a = s + o.size;
      if (a > e || o instanceof R0) {
        i = e - s;
        break;
      }
      s = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof M0 && s.side >= 0; r--)
      ;
    if (n <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && n && o && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? It(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? It(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a], u = o + l.size;
      if (i == -1 && e <= u) {
        let c = o + l.border;
        if (e >= c && n <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, c);
        e = o;
        for (let f = a; f > 0; f--) {
          let h = this.children[f - 1];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(1)) {
            i = It(h.dom) + 1;
            break;
          }
          e -= h.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let c = a + 1; c < this.children.length; c++) {
          let f = this.children[c];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
            s = It(f.dom);
            break;
          }
          n += f.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = u;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let s = Math.min(e, n), o = Math.max(e, n);
    for (let h = 0, d = 0; h < this.children.length; h++) {
      let m = this.children[h], g = d + m.size;
      if (s > d && o < g)
        return m.setSelection(e - d - m.border, n - d - m.border, r, i);
      d = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), u = r.getSelection(), c = !1;
    if ((cn || mt) && e == n) {
      let { node: h, offset: d } = a;
      if (h.nodeType == 3) {
        if (c = !!(d && h.nodeValue[d - 1] == `
`), c && d == h.nodeValue.length)
          for (let m = h, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: It(g) + 1 });
              break;
            }
            let E = m.pmViewDesc;
            if (E && E.node && E.node.isBlock)
              break;
          }
      } else {
        let m = h.childNodes[d - 1];
        c = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (cn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let h = u.focusNode.childNodes[u.focusOffset];
      h && h.contentEditable == "false" && (i = !0);
    }
    if (!(i || c && mt) && Kr(a.node, a.offset, u.anchorNode, u.anchorOffset) && Kr(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((u.extend || e == n) && !c) {
      u.collapse(a.node, a.offset);
      try {
        e != n && u.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let d = a;
        a = l, l = d;
      }
      let h = document.createRange();
      h.setEnd(l.node, l.offset), h.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && n >= r : e < o && n > r) {
        let a = r + s.border, l = o - s.border;
        if (e >= a && n <= l) {
          this.dirty = e == r || n == o ? yi : gf, e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Sn : s.markDirty(e - a, n - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? yi : Sn;
      }
      r = o;
    }
    this.dirty = yi;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? yi : gf;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class M0 extends js {
  constructor(e, n, r, i) {
    let s, o = n.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !n.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = n, this.widget = n, s = this;
  }
  matchesWidget(e) {
    return this.dirty == un && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class h4 extends js {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Wr extends js {
  constructor(e, n, r, i) {
    super(e, [], r, i), this.mark = n;
  }
  static create(e, n, r, i) {
    let s = i.nodeViews[n.type.name], o = s && s(n, i, r);
    return (!o || !o.dom) && (o = an.renderSpec(document, n.type.spec.toDOM(n, r))), new Wr(e, n, o.dom, o.contentDOM || o.dom);
  }
  parseRule() {
    return this.dirty & Sn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(e) {
    return this.dirty != Sn && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != un) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = un;
    }
  }
  slice(e, n, r) {
    let i = Wr.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    n < o && (s = Y1(s, n, o, r)), e > 0 && (s = Y1(s, 0, e, r));
    for (let a = 0; a < s.length; a++)
      s[a].parent = i;
    return i.children = s, i;
  }
}
class Yr extends js {
  constructor(e, n, r, i, s, o, a, l, u) {
    super(e, [], s, o), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a, o && this.updateChildren(l, u);
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, s, o) {
    let a = s.nodeViews[n.type.name], l, u = a && a(n, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), c = u && u.dom, f = u && u.contentDOM;
    if (n.isText) {
      if (!c)
        c = document.createTextNode(n.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      c || ({ dom: c, contentDOM: f } = an.renderSpec(document, n.type.spec.toDOM(n)));
    !f && !n.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), n.type.spec.draggable && (c.draggable = !0));
    let h = c;
    return c = P0(c, r, n), u ? l = new d4(e, n, r, i, c, f || null, h, u, s, o + 1) : n.isText ? new La(e, n, r, i, c, h, s) : new Yr(e, n, r, i, c, f || null, h, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => L.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == un && e.eq(this.node) && W1(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, s = e.composing ? this.localCompositionInfo(e, n) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new m4(this, o && o.node, e);
    T4(this.node, this.innerDeco, (u, c, f) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, r, e) : u.type.side >= 0 && !f && l.syncToMarks(c == this.node.childCount ? xe.none : this.node.child(c).marks, r, e), l.placeWidget(u, e, i);
    }, (u, c, f, h) => {
      l.syncToMarks(u.marks, r, e);
      let d;
      l.findNodeMatch(u, c, f, h) || a && e.state.selection.from > i && e.state.selection.to < i + u.nodeSize && (d = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(u, c, f, d, e) || l.updateNextNode(u, c, f, e, h) || l.addNode(u, c, f, e, i), i += u.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == yi) && (o && this.protectLocalComposition(e, o), v0(this.contentDOM, this.children, e), Pi && A4(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof ae) || r < n || i > n + this.node.content.size)
      return null;
    let s = e.domSelectionRange(), o = y4(s.focusNode, s.focusOffset);
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let a = o.nodeValue, l = C4(this.node.content, a, r - n, i - n);
      return l < 0 ? null : { node: o, pos: l, text: a };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let s = n;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new h4(this, s, n, i);
    e.input.compositionNodes.push(o), this.children = Y1(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == Sn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = un;
  }
  updateOuterDeco(e) {
    if (W1(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = L0(this.dom, this.nodeDOM, K1(this.outerDeco, this.node, n), K1(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Ef(t, e, n, r, i) {
  return P0(r, e, t), new Yr(void 0, t, e, n, r, r, r, i, 0);
}
class La extends Yr {
  constructor(e, n, r, i, s, o, a) {
    super(e, n, r, i, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == Sn || this.dirty != un && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != un || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = un, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), s = document.createTextNode(i.text);
    return new La(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Sn);
  }
  get domAtom() {
    return !1;
  }
}
class R0 extends js {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == un && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class d4 extends Yr {
  constructor(e, n, r, i, s, o, a, l, u, c) {
    super(e, n, r, i, s, o, a, u, c), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == Sn)
      return !1;
    if (this.spec.update) {
      let s = this.spec.update(e, n, r);
      return s && this.updateInner(e, n, r, i), s;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function v0(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = Tf(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(a, r);
    if (o instanceof Wr) {
      let l = r ? r.previousSibling : t.lastChild;
      v0(o.contentDOM, o.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = Tf(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const As = function(t) {
  t && (this.nodeName = t);
};
As.prototype = /* @__PURE__ */ Object.create(null);
const Pr = [new As()];
function K1(t, e, n) {
  if (t.length == 0)
    return Pr;
  let r = n ? Pr[0] : new As(), i = [r];
  for (let s = 0; s < t.length; s++) {
    let o = t[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new As(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (n && i.length == 1 && i.push(r = new As(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function L0(t, e, n, r) {
  if (n == Pr && r == Pr)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], a = n[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = Pr[0]), i = l;
    }
    p4(i, a || Pr[0], o);
  }
  return i;
}
function p4(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && t.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && t.classList.add(i[s]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function P0(t, e, n) {
  return L0(t, t, Pr, K1(e, n, t.nodeType != 1));
}
function W1(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function Tf(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class m4 {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = g4(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = un, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(e[s]) && !this.isLocked(u.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Wr.create(this.top, e[s], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == Sn && o.dom == o.contentDOM && (o.dirty = yi), o.update(e, n, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, s) {
    for (let o = this.index; o < this.top.children.length; o++) {
      let a = this.top.children[o];
      if (a instanceof Yr) {
        let l = this.preMatch.matched.get(a);
        if (l != null && l != s)
          return !1;
        let u = a.dom;
        if (!(this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != Sn && W1(n, a.outerDeco))) && a.update(e, n, r, i))
          return this.destroyBetween(this.index, o), a.dom != u && (this.changed = !0), this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, s) {
    this.top.children.splice(this.index++, 0, Yr.create(this.top, e, n, r, i, s)), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new M0(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Wr; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof La) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((mt || dt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new R0(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function g4(t, e) {
  let n = e, r = n.children.length, i = t.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e:
    for (; i > 0; ) {
      let a;
      for (; ; )
        if (r) {
          let u = n.children[r - 1];
          if (u instanceof Wr)
            n = u, r = u.children.length;
          else {
            a = u, r--;
            break;
          }
        } else {
          if (n == e)
            break e;
          r = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(i - 1))
          break;
        --i, s.set(a, i), o.push(a);
      }
    }
  return { index: i, matched: s, matches: o.reverse() };
}
function E4(t, e) {
  return t.type.side - e.type.side;
}
function T4(t, e, n, r) {
  let i = e.locals(t), s = 0;
  if (i.length == 0) {
    for (let u = 0; u < t.childCount; u++) {
      let c = t.child(u);
      r(c, i, e.forChild(s, c), u), s += c.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let u = 0; ; ) {
    if (o < i.length && i[o].to == s) {
      let m = i[o++], g;
      for (; o < i.length && i[o].to == s; )
        (g || (g = [m])).push(i[o++]);
      if (g) {
        g.sort(E4);
        for (let E = 0; E < g.length; E++)
          n(g[E], u, !!l);
      } else
        n(m, u, !!l);
    }
    let c, f;
    if (l)
      f = -1, c = l, l = null;
    else if (u < t.childCount)
      f = u, c = t.child(u++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= s && a.splice(m--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      a.push(i[o++]);
    let h = s + c.nodeSize;
    if (c.isText) {
      let m = h;
      o < i.length && i[o].from < m && (m = i[o].from);
      for (let g = 0; g < a.length; g++)
        a[g].to < m && (m = a[g].to);
      m < h && (l = c.cut(m - s), c = c.cut(0, m - s), h = m, f = -1);
    }
    let d = c.isInline && !c.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    r(c, d, e.forChild(s, c), f), s = h;
  }
}
function A4(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function y4(t, e) {
  for (; ; ) {
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.childNodes.length > e && t.childNodes[e].nodeType == 3)
        return t.childNodes[e];
      t = t.childNodes[e - 1], e = yn(t);
    } else if (t.nodeType == 1 && e < t.childNodes.length)
      t = t.childNodes[e], e = 0;
    else
      return null;
  }
}
function C4(t, e, n, r) {
  for (let i = 0, s = 0; i < t.childCount && s <= r; ) {
    let o = t.child(i++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; i < t.childCount; ) {
      let u = t.child(i++);
      if (s += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (s >= n) {
      let u = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (u >= 0 && u + e.length + a >= n)
        return a + u;
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Y1(t, e, n, r, i) {
  let s = [];
  for (let o = 0, a = 0; o < t.length; o++) {
    let l = t[o], u = a, c = a += l.size;
    u >= n || c <= e ? s.push(l) : (u < e && s.push(l.slice(0, e - u, r)), i && (s.push(i), i = void 0), c > n && s.push(l.slice(n - u, l.size, r)));
  }
  return s;
}
function Iu(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), s = i && i.size == 0, o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = r.resolve(o), l, u;
  if (Ra(n)) {
    for (l = a; i && !i.node; )
      i = i.parent;
    let c = i.node;
    if (i && c.isAtom && ne.isSelectable(c) && i.parent && !(c.isInline && V5(n.focusNode, n.focusOffset, i.dom))) {
      let f = i.posBefore;
      u = new ne(o == f ? a : r.resolve(f));
    }
  } else {
    let c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
    l = r.resolve(c);
  }
  if (!u) {
    let c = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    u = Mu(t, l, a, c);
  }
  return u;
}
function B0(t) {
  return t.editable ? t.hasFocus() : H0(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function qn(t, e = !1) {
  let n = t.state.selection;
  if (F0(t, n), !!B0(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && dt) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Kr(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      x4(t);
    else {
      let { anchor: r, head: i } = n, s, o;
      Af && !(n instanceof ae) && (n.$from.parent.inlineContent || (s = yf(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = yf(t, n.to))), t.docView.setSelection(r, i, t.root, e), Af && (s && Cf(s), o && Cf(o)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && b4(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Af = mt || dt && Y5 < 63;
function yf(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, s = r ? n.childNodes[r - 1] : null;
  if (mt && i && i.contentEditable == "false")
    return Ol(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return Ol(i);
    if (s)
      return Ol(s);
  }
}
function Ol(t) {
  return t.contentEditable = "true", mt && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Cf(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function b4(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!B0(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function x4(t) {
  let e = t.domSelection(), n = document.createRange(), r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setEnd(r.parentNode, It(r) + 1) : n.setEnd(r, 0), n.collapse(!1), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && xt && hr <= 11 && (r.disabled = !0, r.disabled = !1);
}
function F0(t, e) {
  if (e instanceof ne) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (bf(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    bf(t);
}
function bf(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function Mu(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || ae.between(e, n, r);
}
function xf(t) {
  return t.editable && !t.hasFocus() ? !1 : H0(t);
}
function H0(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function S4(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Kr(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Q1(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && oe.findFrom(s, e);
}
function Rr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Sf(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ae) {
    if (!r.empty || n.indexOf("s") > -1)
      return !1;
    if (t.endOfTextblock(e > 0 ? "right" : "left")) {
      let i = Q1(t.state, e);
      return i && i instanceof ne ? Rr(t, i) : !1;
    } else if (!(Ht && n.indexOf("m") > -1)) {
      let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
      if (!s || s.isText)
        return !1;
      let a = e < 0 ? i.pos - s.nodeSize : i.pos;
      return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? ne.isSelectable(s) ? Rr(t, new ne(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : va ? Rr(t, new ae(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
    }
  } else {
    if (r instanceof ne && r.node.isInline)
      return Rr(t, new ae(e > 0 ? r.$to : r.$from));
    {
      let i = Q1(t.state, e);
      return i ? Rr(t, i) : !1;
    }
  }
}
function Xo(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function ys(t) {
  let e = t.pmViewDesc;
  return e && e.size == 0 && (t.nextSibling || t.nodeName != "BR");
}
function wl(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, s, o = !1;
  for (cn && n.nodeType == 1 && r < Xo(n) && ys(n.childNodes[r]) && (o = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (ys(a))
          i = n, s = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (U0(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && ys(a); )
          i = n.parentNode, s = It(a), a = a.previousSibling;
        if (a)
          n = a, r = Xo(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  o ? J1(t, n, r) : i && J1(t, i, s);
}
function Dl(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = Xo(n), s, o;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (ys(a))
        s = n, o = ++r;
      else
        break;
    } else {
      if (U0(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && ys(a); )
          s = a.parentNode, o = It(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Xo(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && J1(t, s, o);
}
function U0(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function J1(t, e, n) {
  let r = t.domSelection();
  if (Ra(r)) {
    let s = document.createRange();
    s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s);
  } else
    r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && qn(t);
  }, 50);
}
function Nf(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ae && !r.empty || n.indexOf("s") > -1 || Ht && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Q1(t.state, e);
    if (o && o instanceof ne)
      return Rr(t, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, a = r instanceof ln ? oe.near(o, e) : oe.findFrom(o, e);
    return a ? Rr(t, a) : !1;
  }
  return !1;
}
function _f(t, e) {
  if (!(t.state.selection instanceof ae))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (s && !s.isText) {
    let o = t.state.tr;
    return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize), t.dispatch(o), !0;
  }
  return !1;
}
function kf(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function N4(t) {
  if (!mt || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    kf(t, r, "true"), setTimeout(() => kf(t, r, "false"), 20);
  }
  return !1;
}
function _4(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function k4(t, e) {
  let n = e.keyCode, r = _4(e);
  return n == 8 || Ht && n == 72 && r == "c" ? _f(t, -1) || wl(t) : n == 46 || Ht && n == 68 && r == "c" ? _f(t, 1) || Dl(t) : n == 13 || n == 27 ? !0 : n == 37 || Ht && n == 66 && r == "c" ? Sf(t, -1, r) || wl(t) : n == 39 || Ht && n == 70 && r == "c" ? Sf(t, 1, r) || Dl(t) : n == 38 || Ht && n == 80 && r == "c" ? Nf(t, -1, r) || wl(t) : n == 40 || Ht && n == 78 && r == "c" ? N4(t) || Nf(t, 1, r) || Dl(t) : r == (Ht ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90);
}
function q0(t, e) {
  t.someProp("transformCopied", (d) => {
    e = d(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let d = r.firstChild;
    n.push(d.type.name, d.attrs != d.type.defaultAttrs ? d.attrs : null), r = d.content;
  }
  let o = t.someProp("clipboardSerializer") || an.fromSchema(t.state.schema), a = K0(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: a }));
  let u = l.firstChild, c, f = 0;
  for (; u && u.nodeType == 1 && (c = V0[u.nodeName.toLowerCase()]); ) {
    for (let d = c.length - 1; d >= 0; d--) {
      let m = a.createElement(c[d]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), f++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${s}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`);
  let h = t.someProp("clipboardTextSerializer", (d) => d(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: h };
}
function z0(t, e, n, r, i) {
  let s = i.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (r || s || !n);
  if (l) {
    if (t.someProp("transformPastedText", (h) => {
      e = h(e, s || r, t);
    }), s)
      return e ? new j(L.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : j.empty;
    let f = t.someProp("clipboardTextParser", (h) => h(e, i, r, t));
    if (f)
      a = f;
    else {
      let h = i.marks(), { schema: d } = t.state, m = an.fromSchema(d);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let E = o.appendChild(document.createElement("p"));
        g && E.appendChild(m.serializeNode(d.text(g, h)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (f) => {
      n = f(n, t);
    }), o = D4(n), va && I4(o);
  let u = o && o.querySelector("[data-pm-slice]"), c = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let f = +c[3]; f > 0; f--) {
      let h = o.firstChild;
      for (; h && h.nodeType != 1; )
        h = h.nextSibling;
      if (!h)
        break;
      o = h;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Vr.fromSchema(t.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || c),
    context: i,
    ruleFromNode(h) {
      return h.nodeName == "BR" && !h.nextSibling && h.parentNode && !O4.test(h.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    a = M4(Of(a, +c[1], +c[2]), c[4]);
  else if (a = j.maxOpen(w4(a.content, i), !0), a.openStart || a.openEnd) {
    let f = 0, h = 0;
    for (let d = a.content.firstChild; f < a.openStart && !d.type.spec.isolating; f++, d = d.firstChild)
      ;
    for (let d = a.content.lastChild; h < a.openEnd && !d.type.spec.isolating; h++, d = d.lastChild)
      ;
    a = Of(a, f, h);
  }
  return t.someProp("transformPasted", (f) => {
    a = f(a, t);
  }), a;
}
const O4 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function w4(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), s, o = [];
    if (t.forEach((a) => {
      if (!o)
        return;
      let l = i.findWrapping(a.type), u;
      if (!l)
        return o = null;
      if (u = o.length && s.length && G0(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = u;
      else {
        o.length && (o[o.length - 1] = j0(o[o.length - 1], s.length));
        let c = $0(a, l);
        o.push(c), i = i.matchType(c.type), s = l;
      }
    }), o)
      return L.from(o);
  }
  return t;
}
function $0(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, L.from(t));
  return t;
}
function G0(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let s = G0(t, e, n, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(L.from($0(n, t, i + 1))));
  }
}
function j0(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, j0(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(L.empty, !0);
  return t.copy(n.append(r));
}
function X1(t, e, n, r, i, s) {
  let o = e < 0 ? t.firstChild : t.lastChild, a = o.content;
  return i < r - 1 && (a = X1(a, e, n, r, i + 1, s)), i >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, t.childCount > 1 || s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(L.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a));
}
function Of(t, e, n) {
  return e < t.openStart && (t = new j(X1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new j(X1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const V0 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let wf = null;
function K0() {
  return wf || (wf = document.implementation.createHTMLDocument("title"));
}
function D4(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = K0().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && V0[r[1].toLowerCase()]) && (t = i.map((s) => "<" + s + ">").join("") + t + i.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = t, i)
    for (let s = 0; s < i.length; s++)
      n = n.querySelector(i[s]) || n;
  return n;
}
function I4(t) {
  let e = t.querySelectorAll(dt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function M4(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: s, openEnd: o } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = L.from(l.create(r[a + 1], i)), s++, o++;
  }
  return new j(i, s, o);
}
const gt = {}, Et = {}, R4 = { touchstart: !0, touchmove: !0 };
class v4 {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function L4(t) {
  for (let e in gt) {
    let n = gt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      B4(t, r) && !Ru(t, r) && (t.editable || !(r.type in Et)) && n(t, r);
    }, R4[e] ? { passive: !0 } : void 0);
  }
  mt && t.dom.addEventListener("input", () => null), Z1(t);
}
function cr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function P4(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Z1(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => Ru(t, r));
  });
}
function Ru(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function B4(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function F4(t, e) {
  !Ru(t, e) && gt[e.type] && (t.editable || !(e.type in Et)) && gt[e.type](t, e);
}
Et.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !Y0(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(sn && dt && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), Pi && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, Mr(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || k4(t, n) ? n.preventDefault() : cr(t, "key");
};
Et.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Et.keypress = (t, e) => {
  let n = e;
  if (Y0(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Ht && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof ae) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function Pa(t) {
  return { left: t.clientX, top: t.clientY };
}
function H4(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function vu(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let s = t.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (t.someProp(e, (a) => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), i, !0) : a(t, n, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function Di(t, e, n) {
  t.focused || t.focus();
  let r = t.state.tr.setSelection(e);
  n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function U4(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ne.isSelectable(r) ? (Di(t, new ne(n), "pointer"), !0) : !1;
}
function q4(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof ne && (r = n.node);
  let s = t.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ne.isSelectable(a)) {
      r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (Di(t, ne.create(t.state.doc, i), "pointer"), !0) : !1;
}
function z4(t, e, n, r, i) {
  return vu(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (s) => s(t, e, r)) || (i ? q4(t, n) : U4(t, n));
}
function $4(t, e, n, r) {
  return vu(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function G4(t, e, n, r) {
  return vu(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || j4(t, n, r);
}
function j4(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Di(t, ae.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
    if (o.inlineContent)
      Di(t, ae.create(r, a + 1, a + 1 + o.content.size), "pointer");
    else if (ne.isSelectable(o))
      Di(t, ne.create(r, a), "pointer");
    else
      continue;
    return !0;
  }
}
function Lu(t) {
  return Zo(t);
}
const W0 = Ht ? "metaKey" : "ctrlKey";
gt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = Lu(t), i = Date.now(), s = "singleClick";
  i - t.input.lastClick.time < 500 && H4(n, t.input.lastClick) && !n[W0] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s };
  let o = t.posAtCoords(Pa(n));
  o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new V4(t, o, n, !!r)) : (s == "doubleClick" ? $4 : G4)(t, o.pos, o.inside, n) ? n.preventDefault() : cr(t, "pointer"));
};
class V4 {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[W0], this.allowDefault = r.shiftKey;
    let s, o;
    if (n.inside > -1)
      s = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let c = e.state.doc.resolve(n.pos);
      s = c.parent, o = c.depth ? c.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l ? l.dom : null;
    let { selection: u } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || u instanceof ne && u.from <= o && u.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && cn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), cr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => qn(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Pa(e))), this.updateAllowDefault(e), this.allowDefault || !n ? cr(this.view, "pointer") : z4(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    mt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    dt && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Di(this.view, oe.near(this.view.state.doc.resolve(n.pos)), "pointer"), e.preventDefault()) : cr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), cr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
gt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), Lu(t), cr(t, "pointer");
};
gt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), cr(t, "pointer");
};
gt.contextmenu = (t) => Lu(t);
function Y0(t, e) {
  return t.composing ? !0 : mt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const K4 = sn ? 5e3 : -1;
Et.compositionstart = Et.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Zo(t, !0), t.markCursor = null;
    else if (Zo(t), cn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          t.domSelection().collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    t.input.composing = !0;
  }
  Q0(t, K4);
};
Et.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, Q0(t, 20));
};
function Q0(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Zo(t), e));
}
function J0(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = W4()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function W4() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Zo(t, e = !1) {
  if (!(sn && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), J0(t), e || t.docView && t.docView.dirty) {
      let n = Iu(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function Y4(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Bi = xt && hr < 15 || Pi && Q5 < 604;
gt.copy = Et.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let s = Bi ? null : n.clipboardData, o = r.content(), { dom: a, text: l } = q0(t, o);
  s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : Y4(t, a), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function Q4(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function J4(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Ls(t, r.value, null, t.input.shiftKey, e) : Ls(t, r.textContent, r.innerHTML, t.input.shiftKey, e);
  }, 50);
}
function Ls(t, e, n, r, i) {
  let s = z0(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, s || j.empty)))
    return !0;
  if (!s)
    return !1;
  let o = Q4(s), a = o ? t.state.tr.replaceSelectionWith(o, t.input.shiftKey) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
Et.paste = (t, e) => {
  let n = e;
  if (t.composing && !sn)
    return;
  let r = Bi ? null : n.clipboardData;
  r && Ls(t, r.getData("text/plain"), r.getData("text/html"), t.input.shiftKey, n) ? n.preventDefault() : J4(t, n);
};
class X4 {
  constructor(e, n) {
    this.slice = e, this.move = n;
  }
}
const X0 = Ht ? "altKey" : "ctrlKey";
gt.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, s = i.empty ? null : t.posAtCoords(Pa(n));
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ne ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      t.dispatch(t.state.tr.setSelection(ne.create(t.state.doc, r.mightDrag.pos)));
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && t.dispatch(t.state.tr.setSelection(ne.create(t.state.doc, u.posBefore)));
    }
  }
  let o = t.state.selection.content(), { dom: a, text: l } = q0(t, o);
  n.dataTransfer.clearData(), n.dataTransfer.setData(Bi ? "Text" : "text/html", a.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Bi || n.dataTransfer.setData("text/plain", l), t.dragging = new X4(o, !n[X0]);
};
gt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Et.dragover = Et.dragenter = (t, e) => e.preventDefault();
Et.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(Pa(n));
  if (!i)
    return;
  let s = t.state.doc.resolve(i.pos), o = r && r.slice;
  o ? t.someProp("transformPasted", (m) => {
    o = m(o, t);
  }) : o = z0(t, n.dataTransfer.getData(Bi ? "Text" : "text/plain"), Bi ? null : n.dataTransfer.getData("text/html"), !1, s);
  let a = !!(r && !n[X0]);
  if (t.someProp("handleDrop", (m) => m(t, n, o || j.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? v5(t.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let u = t.state.tr;
  a && u.deleteSelection();
  let c = u.mapping.map(l), f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, h = u.doc;
  if (f ? u.replaceRangeWith(c, c, o.content.firstChild) : u.replaceRange(c, c, o), u.doc.eq(h))
    return;
  let d = u.doc.resolve(c);
  if (f && ne.isSelectable(o.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(o.content.firstChild))
    u.setSelection(new ne(d));
  else {
    let m = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((g, E, T, k) => m = k), u.setSelection(Mu(t, d, u.doc.resolve(m)));
  }
  t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
gt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && qn(t);
  }, 20));
};
gt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
gt.beforeinput = (t, e) => {
  if (dt && sn && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, Mr(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Et)
  gt[t] = Et[t];
function Ps(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Pu {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || $r, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new bt(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Pu && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Ps(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class dr {
  constructor(e, n) {
    this.attrs = e, this.spec = n || $r;
  }
  map(e, n, r, i) {
    let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new bt(s, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof dr && Ps(this.attrs, e.attrs) && Ps(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof dr;
  }
  destroy() {
  }
}
class Bu {
  constructor(e, n) {
    this.attrs = e, this.spec = n || $r;
  }
  map(e, n, r, i) {
    let s = e.mapResult(n.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(n.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new bt(s.pos - r, o.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), s;
    return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof Bu && Ps(this.attrs, e.attrs) && Ps(this.spec, e.spec);
  }
  destroy() {
  }
}
class bt {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new bt(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new bt(e, e, new Pu(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new bt(e, n, new dr(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new bt(e, n, new Bu(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof dr;
  }
}
const pi = [], $r = {};
class He {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : pi, this.children = n.length ? n : pi;
  }
  /**
  Create a set of decorations, using the structure of the given
  document.
  */
  static create(e, n) {
    return n.length ? ea(n, e, 0, $r) : ot;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, r, i + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == ot || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || $r);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? Z4(this.children, o || [], e, n, r, i, s) : o ? new He(o.sort(Gr), pi) : ot;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Needs access to the current document to
  create the appropriate tree structure.
  */
  add(e, n) {
    return n.length ? this == ot ? He.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, s = 0;
    e.forEach((a, l) => {
      let u = l + r, c;
      if (c = em(n, a, u)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
          s += 3;
        i[s] == l ? i[s + 2] = i[s + 2].addInner(a, c, u + 1) : i.splice(s, 0, l, l + a.nodeSize, ea(c, a, u + 1, $r)), s += 3;
      }
    });
    let o = Z0(s ? tm(n) : n, -r);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new He(o.length ? this.local.concat(o).sort(Gr) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == ot ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, a = r[s] + n, l = r[s + 1] + n;
      for (let c = 0, f; c < e.length; c++)
        (f = e[c]) && f.from > a && f.to < l && (e[c] = null, (o || (o = [])).push(f));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[s + 2].removeInner(o, a + 1);
      u != ot ? r[s + 2] = u : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new He(i, r) : ot;
  }
  /**
  @internal
  */
  forChild(e, n) {
    if (this == ot)
      return this;
    if (n.isLeaf)
      return He.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof dr) {
        let u = Math.max(s, l.from) - s, c = Math.min(o, l.to) - s;
        u < c && (i || (i = [])).push(l.copy(u, c));
      }
    }
    if (i) {
      let a = new He(i.sort(Gr), pi);
      return r ? new or([a, r]) : a;
    }
    return r || ot;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof He) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Fu(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == ot)
      return pi;
    if (e.inlineContent || !this.local.some(dr.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof dr || n.push(this.local[r]);
    return n;
  }
}
He.empty = new He([], []);
He.removeOverlap = Fu;
const ot = He.empty;
class or {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, $r));
    return or.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return He.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, n);
      s != ot && (s instanceof or ? r = r.concat(s.members) : r.push(s));
    }
    return or.from(r);
  }
  eq(e) {
    if (!(e instanceof or) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!n)
          n = s;
        else {
          r && (n = n.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            n.push(s[o]);
        }
    }
    return n ? Fu(r ? n : n.sort(Gr)) : pi;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return ot;
      case 1:
        return e[0];
      default:
        return new or(e.every((n) => n instanceof He) ? e : e.reduce((n, r) => n.concat(r instanceof He ? r : r.members), []));
    }
  }
}
function Z4(t, e, n, r, i, s, o) {
  let a = t.slice();
  for (let u = 0, c = s; u < n.maps.length; u++) {
    let f = 0;
    n.maps[u].forEach((h, d, m, g) => {
      let E = g - m - (d - h);
      for (let T = 0; T < a.length; T += 3) {
        let k = a[T + 1];
        if (k < 0 || h > k + c - f)
          continue;
        let _ = a[T] + c - f;
        d >= _ ? a[T + 1] = h <= _ ? -2 : -1 : m >= i && E && (a[T] += E, a[T + 1] += E);
      }
      f += E;
    }), c = n.maps[u].map(c, -1);
  }
  let l = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        l = !0, a[u + 1] = -1;
        continue;
      }
      let c = n.map(t[u] + s), f = c - i;
      if (f < 0 || f >= r.content.size) {
        l = !0;
        continue;
      }
      let h = n.map(t[u + 1] + s, -1), d = h - i, { index: m, offset: g } = r.content.findIndex(f), E = r.maybeChild(m);
      if (E && g == f && g + E.nodeSize == d) {
        let T = a[u + 2].mapInner(n, E, c + 1, t[u] + s + 1, o);
        T != ot ? (a[u] = f, a[u + 1] = d, a[u + 2] = T) : (a[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = eE(a, t, e, n, i, s, o), c = ea(u, r, 0, o);
    e = c.local;
    for (let f = 0; f < a.length; f += 3)
      a[f + 1] < 0 && (a.splice(f, 3), f -= 3);
    for (let f = 0, h = 0; f < c.children.length; f += 3) {
      let d = c.children[f];
      for (; h < a.length && a[h] < d; )
        h += 3;
      a.splice(h, 0, c.children[f], c.children[f + 1], c.children[f + 2]);
    }
  }
  return new He(e.sort(Gr), a);
}
function Z0(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new bt(i.from + e, i.to + e, i.type));
  }
  return n;
}
function eE(t, e, n, r, i, s, o) {
  function a(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let f = l.local[c].map(r, i, u);
      f ? n.push(f) : o.onRemove && o.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return n;
}
function em(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o), t[s] = null);
  return i;
}
function tm(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function ea(t, e, n, r) {
  let i = [], s = !1;
  e.forEach((a, l) => {
    let u = em(t, a, l + n);
    if (u) {
      s = !0;
      let c = ea(u, a, n + l + 1, r);
      c != ot && i.push(l, l + a.nodeSize, c);
    }
  });
  let o = Z0(s ? tm(t) : t, -n).sort(Gr);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || i.length ? new He(o, i) : ot;
}
function Gr(t, e) {
  return t.from - e.from || t.to - e.to;
}
function Fu(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == t && (e = t.slice()), e[i] = s.copy(s.from, r.to), Df(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, s.from), Df(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Df(t, e, n) {
  for (; e < t.length && Gr(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Il(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != ot && e.push(r);
  }), t.cursorWrapper && e.push(He.create(t.state.doc, [t.cursorWrapper.deco])), or.from(e);
}
const tE = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, nE = xt && hr <= 11;
class rE {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class iE {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new rE(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      xt && hr <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), nE && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, tE)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (xf(this.view)) {
      if (this.suppressingSelectionUpdates)
        return qn(this.view);
      if (xt && hr <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Kr(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = vs(s))
      n.add(s);
    for (let s = e.anchorNode; s; s = vs(s))
      if (n.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.observer ? this.observer.takeRecords() : [];
    this.queue.length && (n = this.queue.concat(n), this.queue.length = 0);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && xf(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let c = 0; c < n.length; c++) {
        let f = this.registerMutation(n[c], l);
        f && (s = s < 0 ? f.from : Math.min(f.from, s), o = o < 0 ? f.to : Math.max(f.to, o), f.typeOver && (a = !0));
      }
    if (cn && l.length > 1) {
      let c = l.filter((f) => f.nodeName == "BR");
      if (c.length == 2) {
        let f = c[0], h = c[1];
        f.parentNode && f.parentNode.parentNode == h.parentNode ? h.remove() : f.remove();
      }
    }
    let u = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ra(r) && (u = Iu(e)) && u.eq(oe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, qn(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), sE(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || qn(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let c = 0; c < e.addedNodes.length; c++)
        n.push(e.addedNodes[c]);
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (xt && hr <= 11 && e.addedNodes.length)
        for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: f, nextSibling: h } = e.addedNodes[c];
          (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f), (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (s = h);
        }
      let o = i && i.parentNode == e.target ? It(i) + 1 : 0, a = r.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? It(s) : e.target.childNodes.length, u = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: u };
    } else
      return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : {
        from: r.posAtStart,
        to: r.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      };
  }
}
let If = /* @__PURE__ */ new WeakMap(), Mf = !1;
function sE(t) {
  if (!If.has(t) && (If.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = cn, Mf)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Mf = !0;
  }
}
function oE(t) {
  let e;
  function n(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  t.dom.addEventListener("beforeinput", n, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", n, !0);
  let r = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.domAtPos(t.state.selection.anchor);
  return Kr(a.node, a.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };
}
function aE(t, e, n) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), u, c = l.anchorNode;
  if (c && t.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (u = [{ node: c, offset: l.anchorOffset }], Ra(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), dt && t.input.lastKeyCode === 8)
    for (let E = s; E > i; E--) {
      let T = r.childNodes[E - 1], k = T.pmViewDesc;
      if (T.nodeName == "BR" && !k) {
        s = E;
        break;
      }
      if (!k || k.size)
        break;
    }
  let f = t.state.doc, h = t.someProp("domParser") || Vr.fromSchema(t.state.schema), d = f.resolve(o), m = null, g = h.parse(r, {
    topNode: d.parent,
    topMatch: d.parent.contentMatchAt(d.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: d.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: lE,
    context: d
  });
  if (u && u[0].pos != null) {
    let E = u[0].pos, T = u[1] && u[1].pos;
    T == null && (T = E), m = { anchor: E + o, head: T + o };
  }
  return { doc: g, sel: m, from: o, to: a };
}
function lE(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (mt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || mt && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const uE = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function cE(t, e, n, r, i) {
  if (e < 0) {
    let O = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, $ = Iu(t, O);
    if ($ && !t.state.selection.eq($)) {
      if (dt && sn && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (v) => v(t, Mr(13, "Enter"))))
        return;
      let J = t.state.tr.setSelection($);
      O == "pointer" ? J.setMeta("pointer", !0) : O == "key" && J.scrollIntoView(), t.dispatch(J);
    }
    return;
  }
  let s = t.state.doc.resolve(e), o = s.sharedDepth(n);
  e = s.before(o + 1), n = t.state.doc.resolve(n).after(o + 1);
  let a = t.state.selection, l = aE(t, e, n), u = t.state.doc, c = u.slice(l.from, l.to), f, h;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, h = "end") : (f = t.state.selection.from, h = "start"), t.input.lastKeyCode = null;
  let d = dE(c.content, l.doc.content, l.from, f, h);
  if ((Pi && t.input.lastIOSEnter > Date.now() - 225 || sn) && i.some((O) => O.nodeType == 1 && !uE.test(O.nodeName)) && (!d || d.endA >= d.endB) && t.someProp("handleKeyDown", (O) => O(t, Mr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!d)
    if (r && a instanceof ae && !a.empty && a.$head.sameParent(a.$anchor) && !t.composing && !(l.sel && l.sel.anchor != l.sel.head))
      d = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (l.sel) {
        let O = Rf(t, t.state.doc, l.sel);
        O && !O.eq(t.state.selection) && t.dispatch(t.state.tr.setSelection(O));
      }
      return;
    }
  if (dt && t.cursorWrapper && l.sel && l.sel.anchor == t.cursorWrapper.deco.from && l.sel.head == l.sel.anchor) {
    let O = d.endB - d.start;
    l.sel = { anchor: l.sel.anchor + O, head: l.sel.anchor + O };
  }
  t.input.domChangeCount++, t.state.selection.from < t.state.selection.to && d.start == d.endB && t.state.selection instanceof ae && (d.start > t.state.selection.from && d.start <= t.state.selection.from + 2 && t.state.selection.from >= l.from ? d.start = t.state.selection.from : d.endA < t.state.selection.to && d.endA >= t.state.selection.to - 2 && t.state.selection.to <= l.to && (d.endB += t.state.selection.to - d.endA, d.endA = t.state.selection.to)), xt && hr <= 11 && d.endB == d.start + 1 && d.endA == d.start && d.start > l.from && l.doc.textBetween(d.start - l.from - 1, d.start - l.from + 1) == "  " && (d.start--, d.endA--, d.endB--);
  let m = l.doc.resolveNoCache(d.start - l.from), g = l.doc.resolveNoCache(d.endB - l.from), E = u.resolve(d.start), T = m.sameParent(g) && m.parent.inlineContent && E.end() >= d.endA, k;
  if ((Pi && t.input.lastIOSEnter > Date.now() - 225 && (!T || i.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !T && m.pos < l.doc.content.size && (k = oe.findFrom(l.doc.resolve(m.pos + 1), 1, !0)) && k.head == g.pos) && t.someProp("handleKeyDown", (O) => O(t, Mr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > d.start && hE(u, d.start, d.endA, m, g) && t.someProp("handleKeyDown", (O) => O(t, Mr(8, "Backspace")))) {
    sn && dt && t.domObserver.suppressSelectionUpdates();
    return;
  }
  dt && sn && d.endB == d.start && (t.input.lastAndroidDelete = Date.now()), sn && !T && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == d.endA && (d.endB -= 2, g = l.doc.resolveNoCache(d.endB - l.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(O) {
      return O(t, Mr(13, "Enter"));
    });
  }, 20));
  let _ = d.start, R = d.endA, M, N, S;
  if (T) {
    if (m.pos == g.pos)
      xt && hr <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => qn(t), 20)), M = t.state.tr.delete(_, R), N = u.resolve(d.start).marksAcross(u.resolve(d.endA));
    else if (
      // Adding or removing a mark
      d.endA == d.endB && (S = fE(m.parent.content.cut(m.parentOffset, g.parentOffset), E.parent.content.cut(E.parentOffset, d.endA - E.start())))
    )
      M = t.state.tr, S.type == "add" ? M.addMark(_, R, S.mark) : M.removeMark(_, R, S.mark);
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let O = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (t.someProp("handleTextInput", ($) => $(t, _, R, O)))
        return;
      M = t.state.tr.insertText(O, _, R);
    }
  }
  if (M || (M = t.state.tr.replace(_, R, l.doc.slice(d.start - l.from, d.endB - l.from))), l.sel) {
    let O = Rf(t, M.doc, l.sel);
    O && !(dt && sn && t.composing && O.empty && (d.start != d.endB || t.input.lastAndroidDelete < Date.now() - 100) && (O.head == _ || O.head == M.mapping.map(R) - 1) || xt && O.empty && O.head == _) && M.setSelection(O);
  }
  N && M.ensureMarks(N), t.dispatch(M.scrollIntoView());
}
function Rf(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : Mu(t, e.resolve(n.anchor), e.resolve(n.head));
}
function fE(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, s = r, o, a, l;
  for (let c = 0; c < r.length; c++)
    i = r[c].removeFromSet(i);
  for (let c = 0; c < n.length; c++)
    s = n[c].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    a = i[0], o = "add", l = (c) => c.mark(a.addToSet(c.marks));
  else if (i.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (c) => c.mark(a.removeFromSet(c.marks));
  else
    return null;
  let u = [];
  for (let c = 0; c < e.childCount; c++)
    u.push(l(e.child(c)));
  if (L.from(u).eq(t))
    return { mark: a, type: o };
}
function hE(t, e, n, r, i) {
  if (!r.parent.isTextblock || // The content must have shrunk
  n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
  Ml(r, !0, !1) < i.pos)
    return !1;
  let s = t.resolve(e);
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = t.resolve(Ml(s, !0, !0));
  return !o.parent.isTextblock || o.pos > n || Ml(o, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function Ml(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let s = t.node(r).maybeChild(t.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function dE(t, e, n, r, i) {
  let s = t.findDiffStart(e, n);
  if (s == null)
    return null;
  let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && t.size < e.size) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
class pE {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new v4(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Ff), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Pf(this), Lf(this), this.nodeViews = Bf(this), this.docView = Ef(this.state.doc, vf(this), Il(this), this.dom, this), this.domObserver = new iE(this, (r, i, s, o) => cE(this, r, i, s, o)), this.domObserver.start(), L4(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Z1(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Ff), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    let r = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (J0(this), s = !0), this.state = e;
    let o = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (o || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h = Bf(this);
      gE(h, this.nodeViews) && (this.nodeViews = h, i = !0);
    }
    (o || n.handleDOMEvents != this._props.handleDOMEvents) && Z1(this), this.editable = Pf(this), Lf(this);
    let a = Il(this), l = vf(this), u = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", c = i || !this.docView.matchesNode(e.doc, l, a);
    (c || !e.selection.eq(r.selection)) && (s = !0);
    let f = u == "preserve" && s && this.dom.style.overflowAnchor == null && Z5(this);
    if (s) {
      this.domObserver.stop();
      let h = c && (xt || dt) && !this.composing && !r.selection.empty && !e.selection.empty && mE(r.selection, e.selection);
      if (c) {
        let d = dt ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (i || !this.docView.update(e.doc, l, a, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = Ef(e.doc, l, a, this.dom, this)), d && !this.trackWrites && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && S4(this)) ? qn(this, h) : (F0(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && e4(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this)))
      if (this.state.selection instanceof ne) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && hf(this, n.getBoundingClientRect(), e);
      } else
        hf(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (xt) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && t4(this.dom), qn(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return o4(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return D0(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return f4(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return Ls(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return Ls(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (P4(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Il(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return F4(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return mt && this.root.nodeType === 11 && W5(this.dom.ownerDocument) == this.dom ? oE(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function vf(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), e.translate = "no", t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" && (e.class += " " + n[r]), r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), [bt.node(0, t.state.doc.content.size, e)];
}
function Lf(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: bt.widget(t.state.selection.head, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function Pf(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function mE(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function Bf(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function gE(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function Ff(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Tr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ta = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Hf = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), EE = typeof navigator < "u" && /Mac/.test(navigator.platform), TE = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), AE = EE || Hf && +Hf[1] < 57;
for (var nt = 0; nt < 10; nt++)
  Tr[48 + nt] = Tr[96 + nt] = String(nt);
for (var nt = 1; nt <= 24; nt++)
  Tr[nt + 111] = "F" + nt;
for (var nt = 65; nt <= 90; nt++)
  Tr[nt] = String.fromCharCode(nt + 32), ta[nt] = String.fromCharCode(nt);
for (var Rl in Tr)
  ta.hasOwnProperty(Rl) || (ta[Rl] = Tr[Rl]);
function yE(t) {
  var e = AE && (t.ctrlKey || t.altKey || t.metaKey) || TE && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? ta : Tr)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const CE = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function bE(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      CE ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), o && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function xE(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[bE(n)] = t[n];
  return e;
}
function vl(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function SE(t) {
  return new Ye({ props: { handleKeyDown: nm(t) } });
}
function nm(t) {
  let e = xE(t);
  return function(n, r) {
    let i = yE(r), s, o = e[vl(i, r)];
    if (o && o(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = e[vl(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (s = Tr[r.keyCode]) && s != i) {
        let a = e[vl(s, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const NE = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function _E(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const kE = (t, e, n) => {
  let r = _E(t, n);
  if (!r)
    return !1;
  let i = rm(r);
  if (!i) {
    let o = r.blockRange(), a = o && qi(o);
    return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (!s.type.spec.isolating && om(t, i, e))
    return !0;
  if (r.parent.content.size == 0 && (Fi(s, "end") || ne.isSelectable(s))) {
    let o = Ou(t.doc, r.before(), r.after(), j.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(Fi(s, "end") ? oe.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : ne.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
};
function Fi(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const OE = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    s = rm(r);
  }
  let o = s && s.nodeBefore;
  return !o || !ne.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function rm(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function wE(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const DE = (t, e, n) => {
  let r = wE(t, n);
  if (!r)
    return !1;
  let i = im(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (om(t, i, e))
    return !0;
  if (r.parent.content.size == 0 && (Fi(s, "start") || ne.isSelectable(s))) {
    let o = Ou(t.doc, r.before(), r.after(), j.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(Fi(s, "start") ? oe.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ne.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, IE = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    s = im(r);
  }
  let o = s && s.nodeAfter;
  return !o || !ne.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, s.pos)).scrollIntoView()), !0);
};
function im(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const ME = (t, e) => {
  let n = t.selection, r = n instanceof ne, i;
  if (r) {
    if (n.node.isTextblock || !Ar(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = E0(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let s = t.tr.join(i);
    r && s.setSelection(ne.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, RE = (t, e) => {
  let n = t.selection, r;
  if (n instanceof ne) {
    if (n.node.isTextblock || !Ar(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = E0(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, vE = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), s = i && qi(i);
  return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()), !0);
}, LE = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function sm(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const PE = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), s = n.indexAfter(-1), o = sm(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(oe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, BE = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof ln || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = sm(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = t.tr.insert(o, s.createAndFill());
    a.setSelection(ae.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, FE = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let s = n.before();
    if (Oi(t.doc, s))
      return e && e(t.tr.split(s).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && qi(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, HE = (t, e) => {
  let { $from: n, to: r } = t.selection, i, s = n.sharedDepth(r);
  return s == 0 ? !1 : (i = n.before(s), e && e(t.tr.setSelection(ne.create(t.doc, i))), !0);
};
function UE(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Ar(t.doc, e.pos)) ? !1 : (n && n(t.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()), !0);
}
function om(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, s, o;
  if (r.type.spec.isolating || i.type.spec.isolating)
    return !1;
  if (UE(t, e, n))
    return !0;
  let a = e.parent.canReplace(e.index(), e.index() + 1);
  if (a && (s = (o = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && o.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let f = e.pos + i.nodeSize, h = L.empty;
      for (let g = s.length - 1; g >= 0; g--)
        h = L.from(s[g].create(null, h));
      h = L.from(r.copy(h));
      let d = t.tr.step(new Xe(e.pos - 1, f, e.pos, f, new j(h, 1, 0), s.length, !0)), m = f + 2 * s.length;
      Ar(d.doc, m) && d.join(m), n(d.scrollIntoView());
    }
    return !0;
  }
  let l = oe.findFrom(e, 1), u = l && l.$from.blockRange(l.$to), c = u && qi(u);
  if (c != null && c >= e.depth)
    return n && n(t.tr.lift(u, c).scrollIntoView()), !0;
  if (a && Fi(i, "start", !0) && Fi(r, "end")) {
    let f = r, h = [];
    for (; h.push(f), !f.isTextblock; )
      f = f.lastChild;
    let d = i, m = 1;
    for (; !d.isTextblock; d = d.firstChild)
      m++;
    if (f.canReplace(f.childCount, f.childCount, d.content)) {
      if (n) {
        let g = L.empty;
        for (let T = h.length - 1; T >= 0; T--)
          g = L.from(h[T].copy(g));
        let E = t.tr.step(new Xe(e.pos - h.length, e.pos + i.nodeSize, e.pos + m, e.pos + i.nodeSize - m, new j(g, h.length, 0), 0, !0));
        n(E.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function am(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (n && n(e.tr.setSelection(ae.create(e.doc, t < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const qE = am(-1), zE = am(1);
function $E(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = o && ku(o, t, e);
    return a ? (r && r(n.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function Uf(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let s = 0; s < n.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[s];
      n.doc.nodesBetween(o, a, (l, u) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let c = n.doc.resolve(u), f = c.index();
            i = c.parent.canReplaceWith(f, f + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = n.tr;
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
        s.setBlockType(a, l, t, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function GE(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = !1, l = o;
    if (!o)
      return !1;
    if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
      if (i.index(o.depth - 1) == 0)
        return !1;
      let c = n.doc.resolve(o.start - 2);
      l = new Wo(c, c, o.depth), o.endIndex < o.parent.childCount && (o = new Wo(i, n.doc.resolve(s.end(o.depth)), o.depth)), a = !0;
    }
    let u = ku(l, t, e, o);
    return u ? (r && r(jE(n.tr, o, u, a, t).scrollIntoView()), !0) : !1;
  };
}
function jE(t, e, n, r, i) {
  let s = L.empty;
  for (let c = n.length - 1; c >= 0; c--)
    s = L.from(n[c].type.create(n[c].attrs, s));
  t.step(new Xe(e.start - (r ? 2 : 0), e.end, e.start, e.end, new j(s, 0, 0), n.length, !0));
  let o = 0;
  for (let c = 0; c < n.length; c++)
    n[c].type == i && (o = c + 1);
  let a = n.length - o, l = e.start + n.length - (r ? 2 : 0), u = e.parent;
  for (let c = e.startIndex, f = e.endIndex, h = !0; c < f; c++, h = !1)
    !h && Oi(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += u.child(c).nodeSize;
  return t;
}
function VE(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == t);
    return s ? n ? r.node(s.depth - 1).type == t ? KE(e, n, t, s) : WE(e, n, s) : !0 : !1;
  };
}
function KE(t, e, n, r) {
  let i = t.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Xe(s - 1, o, s, o, new j(L.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Wo(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const a = qi(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.mapping.map(s, -1) - 1;
  return Ar(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function WE(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let d = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
    d -= i.child(m).nodeSize, r.delete(d - 1, d + 1);
  let s = r.doc.resolve(n.start), o = s.nodeAfter;
  if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == i.childCount, u = s.node(-1), c = s.index(-1);
  if (!u.canReplace(c + (a ? 0 : 1), c + 1, o.content.append(l ? L.empty : L.from(i))))
    return !1;
  let f = s.pos, h = f + o.nodeSize;
  return r.step(new Xe(f - (a ? 1 : 0), h + (l ? 1 : 0), f + 1, h - 1, new j((a ? L.empty : L.from(i.copy(L.empty))).append(l ? L.empty : L.from(i.copy(L.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function YE(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == t);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == a.type, c = L.from(u ? t.create() : null), f = new j(L.from(t.create(null, L.from(a.type.create(null, c)))), u ? 3 : 1, 0), h = s.start, d = s.end;
      n(e.tr.step(new Xe(h - (u ? 3 : 1), d, h, d, f, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Ba(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: i } = n, { storedMarks: s } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    filterTransaction: e.filterTransaction,
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, s = n.storedMarks, n;
    }
  };
}
class Fa {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: s } = r, o = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...c) => {
      const f = l(...c)(o);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), f;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = [], l = !!e, u = e || s.tr, c = () => (!l && n && !u.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(u), a.every((h) => h === !0)), f = {
      ...Object.fromEntries(Object.entries(r).map(([h, d]) => [h, (...g) => {
        const E = this.buildProps(u, n), T = d(...g)(E);
        return a.push(T), f;
      }])),
      run: c
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, i = !1, s = e || r.tr, o = this.buildProps(s, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, u]) => [l, (...c) => u(...c)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(s, i)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i;
    s.storedMarks && e.setStoredMarks(s.storedMarks);
    const a = {
      tr: e,
      editor: i,
      view: o,
      state: Ba({
        state: s,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, u]) => [l, (...c) => u(...c)(a)]));
      }
    };
    return a;
  }
}
class QE {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function K(t, e, n) {
  return t.config[e] === void 0 && t.parent ? K(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? K(t.parent, e, n) : null
  }) : t.config[e];
}
function Ha(t) {
  const e = t.filter((i) => i.type === "extension"), n = t.filter((i) => i.type === "node"), r = t.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function lm(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = Ha(t), i = [...n, ...r], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = K(o, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((c) => {
      c.types.forEach((f) => {
        Object.entries(c.attributes).forEach(([h, d]) => {
          e.push({
            type: f,
            name: h,
            attribute: {
              ...s,
              ...d
            }
          });
        });
      });
    });
  }), i.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = K(o, "addAttributes", a);
    if (!l)
      return;
    const u = l();
    Object.entries(u).forEach(([c, f]) => {
      const h = {
        ...s,
        ...f
      };
      f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete h.default, e.push({
        type: o.name,
        name: c,
        attribute: h
      });
    });
  }), e;
}
function Ze(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Ue(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([i, s]) => {
      if (!r[i]) {
        r[i] = s;
        return;
      }
      i === "class" ? r[i] = [r[i], s].join(" ") : i === "style" ? r[i] = [r[i], s].join("; ") : r[i] = s;
    }), r;
  }, {});
}
function eu(t, e) {
  return e.filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => Ue(n, r), {});
}
function um(t) {
  return typeof t == "function";
}
function se(t, e = void 0, ...n) {
  return um(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function JE(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function XE(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function qf(t, e) {
  return t.style ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((s, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : XE(n.getAttribute(o.name));
        return a == null ? s : {
          ...s,
          [o.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function zf(t) {
  return Object.fromEntries(Object.entries(t).filter(([e, n]) => e === "attrs" && JE(n) ? !1 : n != null));
}
function cm(t) {
  var e;
  const n = lm(t), { nodeExtensions: r, markExtensions: i } = Ha(t), s = (e = r.find((l) => K(l, "topNode"))) === null || e === void 0 ? void 0 : e.name, o = Object.fromEntries(r.map((l) => {
    const u = n.filter((E) => E.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage
    }, f = t.reduce((E, T) => {
      const k = K(T, "extendNodeSchema", c);
      return {
        ...E,
        ...k ? k(l) : {}
      };
    }, {}), h = zf({
      ...f,
      content: se(K(l, "content", c)),
      marks: se(K(l, "marks", c)),
      group: se(K(l, "group", c)),
      inline: se(K(l, "inline", c)),
      atom: se(K(l, "atom", c)),
      selectable: se(K(l, "selectable", c)),
      draggable: se(K(l, "draggable", c)),
      code: se(K(l, "code", c)),
      defining: se(K(l, "defining", c)),
      isolating: se(K(l, "isolating", c)),
      attrs: Object.fromEntries(u.map((E) => {
        var T;
        return [E.name, { default: (T = E == null ? void 0 : E.attribute) === null || T === void 0 ? void 0 : T.default }];
      }))
    }), d = se(K(l, "parseHTML", c));
    d && (h.parseDOM = d.map((E) => qf(E, u)));
    const m = K(l, "renderHTML", c);
    m && (h.toDOM = (E) => m({
      node: E,
      HTMLAttributes: eu(E, u)
    }));
    const g = K(l, "renderText", c);
    return g && (h.toText = g), [l.name, h];
  })), a = Object.fromEntries(i.map((l) => {
    const u = n.filter((g) => g.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage
    }, f = t.reduce((g, E) => {
      const T = K(E, "extendMarkSchema", c);
      return {
        ...g,
        ...T ? T(l) : {}
      };
    }, {}), h = zf({
      ...f,
      inclusive: se(K(l, "inclusive", c)),
      excludes: se(K(l, "excludes", c)),
      group: se(K(l, "group", c)),
      spanning: se(K(l, "spanning", c)),
      code: se(K(l, "code", c)),
      attrs: Object.fromEntries(u.map((g) => {
        var E;
        return [g.name, { default: (E = g == null ? void 0 : g.attribute) === null || E === void 0 ? void 0 : E.default }];
      }))
    }), d = se(K(l, "parseHTML", c));
    d && (h.parseDOM = d.map((g) => qf(g, u)));
    const m = K(l, "renderHTML", c);
    return m && (h.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: eu(g, u)
    })), [l.name, h];
  }));
  return new f5({
    topNode: s,
    nodes: o,
    marks: a
  });
}
function Ll(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function $f(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
const ZE = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
    var l, u;
    const c = ((u = (l = i.type.spec).toText) === null || u === void 0 ? void 0 : u.call(l, {
      node: i,
      pos: s,
      parent: o,
      index: a
    })) || i.textContent || "%leaf%";
    n += c.slice(0, Math.max(0, r - s));
  }), n;
};
function Hu(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Ua {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const eT = (t, e) => {
  if (Hu(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function Pl(t) {
  var e;
  const { editor: n, from: r, to: i, text: s, rules: o, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const u = l.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || !((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) && e.marks.find((h) => h.type.spec.code)
  )
    return !1;
  let c = !1;
  const f = ZE(u) + s;
  return o.forEach((h) => {
    if (c)
      return;
    const d = eT(f, h.find);
    if (!d)
      return;
    const m = l.state.tr, g = Ba({
      state: l.state,
      transaction: m
    }), E = {
      from: r - (d[0].length - s.length),
      to: i
    }, { commands: T, chain: k, can: _ } = new Fa({
      editor: n,
      state: g
    });
    h.handler({
      state: g,
      range: E,
      match: d,
      commands: T,
      chain: k,
      can: _
    }) === null || !m.steps.length || (m.setMeta(a, {
      transform: m,
      from: r,
      to: i,
      text: s
    }), l.dispatch(m), c = !0);
  }), c;
}
function tT(t) {
  const { editor: e, rules: n } = t, r = new Ye({
    state: {
      init() {
        return null;
      },
      apply(i, s) {
        const o = i.getMeta(r);
        return o || (i.selectionSet || i.docChanged ? null : s);
      }
    },
    props: {
      handleTextInput(i, s, o, a) {
        return Pl({
          editor: e,
          from: s,
          to: o,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: s } = i.state.selection;
          s && Pl({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = i.state.selection;
        return o ? Pl({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function nT(t) {
  return typeof t == "number";
}
class rT {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const iT = (t, e) => {
  if (Hu(e))
    return [...t.matchAll(e)];
  const n = e(t);
  return n ? n.map((r) => {
    const i = [r.text];
    return i.index = r.index, i.input = t, i.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(r.replaceWith)), i;
  }) : [];
};
function sT(t) {
  const { editor: e, state: n, from: r, to: i, rule: s } = t, { commands: o, chain: a, can: l } = new Fa({
    editor: e,
    state: n
  }), u = [];
  return n.doc.nodesBetween(r, i, (f, h) => {
    if (!f.isTextblock || f.type.spec.code)
      return;
    const d = Math.max(r, h), m = Math.min(i, h + f.content.size), g = f.textBetween(d - h, m - h, void 0, "￼");
    iT(g, s.find).forEach((T) => {
      if (T.index === void 0)
        return;
      const k = d + T.index + 1, _ = k + T[0].length, R = {
        from: n.tr.mapping.map(k),
        to: n.tr.mapping.map(_)
      }, M = s.handler({
        state: n,
        range: R,
        match: T,
        commands: o,
        chain: a,
        can: l
      });
      u.push(M);
    });
  }), u.every((f) => f !== null);
}
function oT(t) {
  const { editor: e, rules: n } = t;
  let r = null, i = !1, s = !1;
  return n.map((a) => new Ye({
    // we register a global drag handler to track the current drag source element
    view(l) {
      const u = (c) => {
        var f;
        r = !((f = l.dom.parentElement) === null || f === void 0) && f.contains(c.target) ? l.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", u), {
        destroy() {
          window.removeEventListener("dragstart", u);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (l) => (s = r === l.dom.parentElement, !1),
        paste: (l, u) => {
          var c;
          const f = (c = u.clipboardData) === null || c === void 0 ? void 0 : c.getData("text/html");
          return i = !!(f != null && f.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (l, u, c) => {
      const f = l[0], h = f.getMeta("uiEvent") === "paste" && !i, d = f.getMeta("uiEvent") === "drop" && !s;
      if (!h && !d)
        return;
      const m = u.doc.content.findDiffStart(c.doc.content), g = u.doc.content.findDiffEnd(c.doc.content);
      if (!nT(m) || !g || m === g.b)
        return;
      const E = c.tr, T = Ba({
        state: c,
        transaction: E
      });
      if (!(!sT({
        editor: e,
        state: T,
        from: Math.max(m - 1, 0),
        to: g.b - 1,
        rule: a
      }) || !E.steps.length))
        return E;
    }
  }));
}
function aT(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return [...new Set(e)];
}
class Br {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Br.resolve(e), this.schema = cm(this.extensions), this.extensions.forEach((r) => {
      var i;
      this.editor.extensionStorage[r.name] = r.storage;
      const s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: this.editor,
        type: Ll(r.name, this.schema)
      };
      r.type === "mark" && (!((i = se(K(r, "keepOnSplit", s))) !== null && i !== void 0) || i) && this.splittableMarks.push(r.name);
      const o = K(r, "onBeforeCreate", s);
      o && this.editor.on("beforeCreate", o);
      const a = K(r, "onCreate", s);
      a && this.editor.on("create", a);
      const l = K(r, "onUpdate", s);
      l && this.editor.on("update", l);
      const u = K(r, "onSelectionUpdate", s);
      u && this.editor.on("selectionUpdate", u);
      const c = K(r, "onTransaction", s);
      c && this.editor.on("transaction", c);
      const f = K(r, "onFocus", s);
      f && this.editor.on("focus", f);
      const h = K(r, "onBlur", s);
      h && this.editor.on("blur", h);
      const d = K(r, "onDestroy", s);
      d && this.editor.on("destroy", d);
    });
  }
  static resolve(e) {
    const n = Br.sort(Br.flatten(e)), r = aT(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = K(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  static sort(e) {
    return e.sort((r, i) => {
      const s = K(r, "priority") || 100, o = K(i, "priority") || 100;
      return s > o ? -1 : s < o ? 1 : 0;
    });
  }
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: Ll(n.name, this.schema)
      }, i = K(n, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  get plugins() {
    const { editor: e } = this, n = Br.sort([...this.extensions].reverse()), r = [], i = [], s = n.map((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: Ll(o.name, this.schema)
      }, l = [], u = K(o, "addKeyboardShortcuts", a);
      let c = {};
      if (o.type === "mark" && o.config.exitable && (c.ArrowRight = () => Vt.handleExit({ editor: e, mark: o })), u) {
        const g = Object.fromEntries(Object.entries(u()).map(([E, T]) => [E, () => T({ editor: e })]));
        c = { ...c, ...g };
      }
      const f = SE(c);
      l.push(f);
      const h = K(o, "addInputRules", a);
      $f(o, e.options.enableInputRules) && h && r.push(...h());
      const d = K(o, "addPasteRules", a);
      $f(o, e.options.enablePasteRules) && d && i.push(...d());
      const m = K(o, "addProseMirrorPlugins", a);
      if (m) {
        const g = m();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      tT({
        editor: e,
        rules: r
      }),
      ...oT({
        editor: e,
        rules: i
      }),
      ...s
    ];
  }
  get attributes() {
    return lm(this.extensions);
  }
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = Ha(this.extensions);
    return Object.fromEntries(n.filter((r) => !!K(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Ze(r.name, this.schema)
      }, o = K(r, "addNodeView", s);
      if (!o)
        return [];
      const a = (l, u, c, f) => {
        const h = eu(l, i);
        return o()({
          editor: e,
          node: l,
          getPos: c,
          decorations: f,
          HTMLAttributes: h,
          extension: r
        });
      };
      return [r.name, a];
    }));
  }
}
function lT(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Bl(t) {
  return lT(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function qa(t, e) {
  const n = { ...t };
  return Bl(t) && Bl(e) && Object.keys(e).forEach((r) => {
    Bl(e[r]) ? r in t ? n[r] = qa(t[r], e[r]) : Object.assign(n, { [r]: e[r] }) : Object.assign(n, { [r]: e[r] });
  }), n;
}
class jt {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = se(K(this, "addOptions", {
      name: this.name
    }))), this.storage = se(K(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new jt(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = qa(this.options, e), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new jt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = se(K(n, "addOptions", {
      name: n.name
    })), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function fm(t, e, n) {
  const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = n || {};
  let a = "", l = !0;
  return t.nodesBetween(r, i, (u, c, f, h) => {
    var d;
    const m = o == null ? void 0 : o[u.type.name];
    m ? (u.isBlock && !l && (a += s, l = !0), f && (a += m({
      node: u,
      pos: c,
      parent: f,
      index: h,
      range: e
    }))) : u.isText ? (a += (d = u == null ? void 0 : u.text) === null || d === void 0 ? void 0 : d.slice(Math.max(r, c) - c, i - c), l = !1) : u.isBlock && !l && (a += s, l = !0);
  }), a;
}
function hm(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const uT = jt.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map((c) => c.$from.pos)), a = Math.max(...s.map((c) => c.$to.pos)), l = hm(n);
            return fm(r, { from: o, to: a }, {
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), cT = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), fT = (t = !1) => ({ commands: e }) => e.setContent("", t), hT = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: i } = r;
  return n && i.forEach(({ $from: s, $to: o }) => {
    t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: c } = e, f = u.resolve(c.map(l)), h = u.resolve(c.map(l + a.nodeSize)), d = f.blockRange(h);
      if (!d)
        return;
      const m = qi(d);
      if (a.type.isTextblock) {
        const { defaultType: g } = f.parent.contentMatchAt(f.index());
        e.setNodeMarkup(d.start, g);
      }
      (m || m === 0) && e.lift(d, m);
    });
  }), !0;
}, dT = (t) => (e) => t(e), pT = () => ({ state: t, dispatch: e }) => BE(t, e), mT = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = t.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r.type) {
      if (e) {
        const a = i.before(s), l = i.after(s);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, gT = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const i = Ze(t, n.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === i) {
      if (r) {
        const l = s.before(o), u = s.after(o);
        e.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, ET = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: i } = t;
  return n && e.delete(r, i), !0;
}, TT = () => ({ state: t, dispatch: e }) => NE(t, e), AT = () => ({ commands: t }) => t.keyboardShortcut("Enter"), yT = () => ({ state: t, dispatch: e }) => PE(t, e);
function na(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => n.strict ? e[i] === t[i] : Hu(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0;
}
function tu(t, e, n = {}) {
  return t.find((r) => r.type === e && na(r.attrs, n));
}
function CT(t, e, n = {}) {
  return !!tu(t, e, n);
}
function Uu(t, e, n = {}) {
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)), !r.node)
    return;
  const i = tu([...r.node.marks], e, n);
  if (!i)
    return;
  let s = r.index, o = t.start() + r.offset, a = s + 1, l = o + r.node.nodeSize;
  for (tu([...r.node.marks], e, n); s > 0 && i.isInSet(t.parent.child(s - 1).marks); )
    s -= 1, o -= t.parent.child(s).nodeSize;
  for (; a < t.parent.childCount && CT([...t.parent.child(a).marks], e, n); )
    l += t.parent.child(a).nodeSize, a += 1;
  return {
    from: o,
    to: l
  };
}
function Cr(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const bT = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const s = Cr(t, r.schema), { doc: o, selection: a } = n, { $from: l, from: u, to: c } = a;
  if (i) {
    const f = Uu(l, s, e);
    if (f && f.from <= u && f.to >= c) {
      const h = ae.create(o, f.from, f.to);
      n.setSelection(h);
    }
  }
  return !0;
}, xT = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function dm(t) {
  return t instanceof ae;
}
function Fr(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function pm(t, e = null) {
  if (!e)
    return null;
  const n = oe.atStart(t), r = oe.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const i = n.from, s = r.to;
  return e === "all" ? ae.create(t, Fr(0, i, s), Fr(t.content.size, i, s)) : ae.create(t, Fr(e, i, s), Fr(e, i, s));
}
function qu() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const ST = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    qu() && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (s && t === null && !dm(n.state.selection))
    return o(), !0;
  const a = pm(i.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0;
}, NT = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })), _T = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e);
function Gf(t) {
  const e = `<body>${t}</body>`;
  return new window.DOMParser().parseFromString(e, "text/html").body;
}
function ra(t, e, n) {
  if (n = {
    slice: !0,
    parseOptions: {},
    ...n
  }, typeof t == "object" && t !== null)
    try {
      return Array.isArray(t) && t.length > 0 ? L.fromArray(t.map((r) => e.nodeFromJSON(r))) : e.nodeFromJSON(t);
    } catch (r) {
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", r), ra("", e, n);
    }
  if (typeof t == "string") {
    const r = Vr.fromSchema(e);
    return n.slice ? r.parseSlice(Gf(t), n.parseOptions).content : r.parse(Gf(t), n.parseOptions);
  }
  return ra("", e, n);
}
function kT(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const i = t.steps[r];
  if (!(i instanceof at || i instanceof Xe))
    return;
  const s = t.mapping.maps[r];
  let o = 0;
  s.forEach((a, l, u, c) => {
    o === 0 && (o = c);
  }), t.setSelection(oe.near(t.doc.resolve(o), n));
}
const OT = (t) => t.toString().startsWith("<"), wT = (t, e, n) => ({ tr: r, dispatch: i, editor: s }) => {
  if (i) {
    n = {
      parseOptions: {},
      updateSelection: !0,
      ...n
    };
    const o = ra(e, s.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...n.parseOptions
      }
    });
    if (o.toString() === "<>")
      return !0;
    let { from: a, to: l } = typeof t == "number" ? { from: t, to: t } : t, u = !0, c = !0;
    if ((OT(o) ? o : [o]).forEach((h) => {
      h.check(), u = u ? h.isText && h.marks.length === 0 : !1, c = c ? h.isBlock : !1;
    }), a === l && c) {
      const { parent: h } = r.doc.resolve(a);
      h.isTextblock && !h.type.spec.code && !h.childCount && (a -= 1, l += 1);
    }
    u ? Array.isArray(e) ? r.insertText(e.map((h) => h.text || "").join(""), a, l) : typeof e == "object" && e && e.text ? r.insertText(e.text, a, l) : r.insertText(e, a, l) : r.replaceWith(a, l, o), n.updateSelection && kT(r, r.steps.length - 1, -1);
  }
  return !0;
}, DT = () => ({ state: t, dispatch: e }) => ME(t, e), IT = () => ({ state: t, dispatch: e }) => RE(t, e), MT = () => ({ state: t, dispatch: e }) => kE(t, e), RT = () => ({ state: t, dispatch: e }) => DE(t, e);
function mm() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function vT(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      qu() || mm() ? o = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), o && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n;
}
const LT = (t) => ({ editor: e, view: n, tr: r, dispatch: i }) => {
  const s = vT(t).split(/-(?!$)/), o = s.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return l == null || l.steps.forEach((u) => {
    const c = u.map(r.mapping);
    c && i && r.maybeStep(c);
  }), !0;
};
function Bs(t, e, n = {}) {
  const { from: r, to: i, empty: s } = t.selection, o = e ? Ze(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, i, (f, h) => {
    if (f.isText)
      return;
    const d = Math.max(r, h), m = Math.min(i, h + f.nodeSize);
    a.push({
      node: f,
      from: d,
      to: m
    });
  });
  const l = i - r, u = a.filter((f) => o ? o.name === f.node.type.name : !0).filter((f) => na(f.node.attrs, n, { strict: !1 }));
  return s ? !!u.length : u.reduce((f, h) => f + h.to - h.from, 0) >= l;
}
const PT = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Ze(t, n.schema);
  return Bs(n, i, e) ? vE(n, r) : !1;
}, BT = () => ({ state: t, dispatch: e }) => FE(t, e), FT = (t) => ({ state: e, dispatch: n }) => {
  const r = Ze(t, e.schema);
  return VE(r)(e, n);
}, HT = () => ({ state: t, dispatch: e }) => LE(t, e);
function za(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function jf(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
const UT = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = za(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = Ze(t, r.schema)), a === "mark" && (o = Cr(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
      s && s === u.type && n.setNodeMarkup(c, void 0, jf(u.attrs, e)), o && u.marks.length && u.marks.forEach((f) => {
        o === f.type && n.addMark(c, c + u.nodeSize, o.create(jf(f.attrs, e)));
      });
    });
  }), !0) : !1;
}, qT = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), zT = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), $T = () => ({ state: t, dispatch: e }) => OE(t, e), GT = () => ({ state: t, dispatch: e }) => IE(t, e), jT = () => ({ state: t, dispatch: e }) => HE(t, e), VT = () => ({ state: t, dispatch: e }) => zE(t, e), KT = () => ({ state: t, dispatch: e }) => qE(t, e);
function gm(t, e, n = {}) {
  return ra(t, e, { slice: !1, parseOptions: n });
}
const WT = (t, e = !1, n = {}) => ({ tr: r, editor: i, dispatch: s }) => {
  const { doc: o } = r, a = gm(t, i.schema, n);
  return s && r.replaceWith(0, o.content.size, a).setMeta("preventUpdate", !e), !0;
};
function YT(t, e) {
  const n = new b0(t);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function QT(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function JT(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (i, s) => {
    n(i) && r.push({
      node: i,
      pos: s
    });
  }), r;
}
function XT(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function zu(t) {
  return (e) => XT(e.$from, t);
}
function ZT(t, e) {
  const n = an.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function e8(t) {
  const e = Br.resolve(t);
  return cm(e);
}
function t8(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return fm(t, n, e);
}
function $a(t, e) {
  const n = Cr(e, t.schema), { from: r, to: i, empty: s } = t.selection, o = [];
  s ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function n8(t, e) {
  const n = Ze(e, t.schema), { from: r, to: i } = t.selection, s = [];
  t.doc.nodesBetween(r, i, (a) => {
    s.push(a);
  });
  const o = s.reverse().find((a) => a.type.name === n.name);
  return o ? { ...o.attrs } : {};
}
function Em(t, e) {
  const n = za(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? n8(t, e) : n === "mark" ? $a(t, e) : {};
}
function r8(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function i8(t) {
  const e = r8(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((s, o) => o !== r).some((s) => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to));
}
function s8(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((i, s) => {
    const o = [];
    if (i.ranges.length)
      i.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[s];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const u = e.slice(s).map(a, -1), c = e.slice(s).map(l), f = e.invert().map(u, -1), h = e.invert().map(c);
      r.push({
        oldRange: {
          from: f,
          to: h
        },
        newRange: {
          from: u,
          to: c
        }
      });
    });
  }), i8(r);
}
function ia(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((i) => {
    const s = n.resolve(t - 1), o = Uu(s, i.type);
    o && r.push({
      mark: i,
      ...o
    });
  }) : n.nodesBetween(t, e, (i, s) => {
    r.push(...i.marks.map((o) => ({
      from: s,
      to: s + i.nodeSize,
      mark: o
    })));
  }), r;
}
function Do(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = t.find((s) => s.type === e && s.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function nu(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection, s = e ? Cr(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((f) => s ? s.name === f.type.name : !0).find((f) => na(f.attrs, n, { strict: !1 }));
  let o = 0;
  const a = [];
  if (i.forEach(({ $from: f, $to: h }) => {
    const d = f.pos, m = h.pos;
    t.doc.nodesBetween(d, m, (g, E) => {
      if (!g.isText && !g.marks.length)
        return;
      const T = Math.max(d, E), k = Math.min(m, E + g.nodeSize), _ = k - T;
      o += _, a.push(...g.marks.map((R) => ({
        mark: R,
        from: T,
        to: k
      })));
    });
  }), o === 0)
    return !1;
  const l = a.filter((f) => s ? s.name === f.mark.type.name : !0).filter((f) => na(f.mark.attrs, n, { strict: !1 })).reduce((f, h) => f + h.to - h.from, 0), u = a.filter((f) => s ? f.mark.type !== s && f.mark.type.excludes(s) : !0).reduce((f, h) => f + h.to - h.from, 0);
  return (l > 0 ? l + u : l) >= o;
}
function o8(t, e, n = {}) {
  if (!e)
    return Bs(t, null, n) || nu(t, null, n);
  const r = za(e, t.schema);
  return r === "node" ? Bs(t, e, n) : r === "mark" ? nu(t, e, n) : !1;
}
function Vf(t, e) {
  const { nodeExtensions: n } = Ha(e), r = n.find((o) => o.name === t);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, s = se(K(r, "group", i));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function a8(t) {
  var e;
  const n = (e = t.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON(), r = t.toJSON();
  return JSON.stringify(n) === JSON.stringify(r);
}
function l8(t, e, n) {
  var r;
  const { selection: i } = e;
  let s = null;
  if (dm(i) && (s = i.$cursor), s) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: o } = i;
  return o.some(({ $from: a, $to: l }) => {
    let u = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (c, f, h) => {
      if (u)
        return !1;
      if (c.isInline) {
        const d = !h || h.type.allowsMarkType(n), m = !!n.isInSet(c.marks) || !c.marks.some((g) => g.type.excludes(n));
        u = d && m;
      }
      return !u;
    }), u;
  });
}
const u8 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: s } = n, { empty: o, ranges: a } = s, l = Cr(t, r.schema);
  if (i)
    if (o) {
      const u = $a(r, l);
      n.addStoredMark(l.create({
        ...u,
        ...e
      }));
    } else
      a.forEach((u) => {
        const c = u.$from.pos, f = u.$to.pos;
        r.doc.nodesBetween(c, f, (h, d) => {
          const m = Math.max(d, c), g = Math.min(d + h.nodeSize, f);
          h.marks.find((T) => T.type === l) ? h.marks.forEach((T) => {
            l === T.type && n.addMark(m, g, l.create({
              ...T.attrs,
              ...e
            }));
          }) : n.addMark(m, g, l.create(e));
        });
      });
  return l8(r, n, l);
}, c8 = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), f8 = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const s = Ze(t, n.schema);
  return s.isTextblock ? i().command(({ commands: o }) => Uf(s, e)(n) ? !0 : o.clearNodes()).command(({ state: o }) => Uf(s, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, h8 = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, i = Fr(t, 0, r.content.size), s = ne.create(r, i);
    e.setSelection(s);
  }
  return !0;
}, d8 = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: i, to: s } = typeof t == "number" ? { from: t, to: t } : t, o = ae.atStart(r).from, a = ae.atEnd(r).to, l = Fr(i, o, a), u = Fr(s, o, a), c = ae.create(r, l, u);
    e.setSelection(c);
  }
  return !0;
}, p8 = (t) => ({ state: e, dispatch: n }) => {
  const r = Ze(t, e.schema);
  return YE(r)(e, n);
};
function Kf(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    t.tr.ensureMarks(r);
  }
}
const m8 = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  const { selection: s, doc: o } = e, { $from: a, $to: l } = s, u = i.extensionManager.attributes, c = Do(u, a.node().type.name, a.node().attrs);
  if (s instanceof ne && s.node.isBlock)
    return !a.parentOffset || !Oi(o, a.pos) ? !1 : (r && (t && Kf(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  if (r) {
    const f = l.parentOffset === l.parent.content.size;
    s instanceof ae && e.deleteSelection();
    const h = a.depth === 0 ? void 0 : QT(a.node(-1).contentMatchAt(a.indexAfter(-1)));
    let d = f && h ? [
      {
        type: h,
        attrs: c
      }
    ] : void 0, m = Oi(e.doc, e.mapping.map(a.pos), 1, d);
    if (!d && !m && Oi(e.doc, e.mapping.map(a.pos), 1, h ? [{ type: h }] : void 0) && (m = !0, d = h ? [
      {
        type: h,
        attrs: c
      }
    ] : void 0), m && (e.split(e.mapping.map(a.pos), 1, d), h && !f && !a.parentOffset && a.parent.type !== h)) {
      const g = e.mapping.map(a.before()), E = e.doc.resolve(g);
      a.node(-1).canReplaceWith(E.index(), E.index() + 1, h) && e.setNodeMarkup(e.mapping.map(a.before()), h);
    }
    t && Kf(n, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return !0;
}, g8 = (t) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  var s;
  const o = Ze(t, n.schema), { $from: a, $to: l } = n.selection, u = n.selection.node;
  if (u && u.isBlock || a.depth < 2 || !a.sameParent(l))
    return !1;
  const c = a.node(-1);
  if (c.type !== o)
    return !1;
  const f = i.extensionManager.attributes;
  if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
    if (a.depth === 2 || a.node(-3).type !== o || a.index(-2) !== a.node(-2).childCount - 1)
      return !1;
    if (r) {
      let E = L.empty;
      const T = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
      for (let S = a.depth - T; S >= a.depth - 3; S -= 1)
        E = L.from(a.node(S).copy(E));
      const k = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, _ = Do(f, a.node().type.name, a.node().attrs), R = ((s = o.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(_)) || void 0;
      E = E.append(L.from(o.createAndFill(null, R) || void 0));
      const M = a.before(a.depth - (T - 1));
      e.replace(M, a.after(-k), new j(E, 4 - T, 0));
      let N = -1;
      e.doc.nodesBetween(M, e.doc.content.size, (S, O) => {
        if (N > -1)
          return !1;
        S.isTextblock && S.content.size === 0 && (N = O + 1);
      }), N > -1 && e.setSelection(ae.near(e.doc.resolve(N))), e.scrollIntoView();
    }
    return !0;
  }
  const h = l.pos === a.end() ? c.contentMatchAt(0).defaultType : null, d = Do(f, c.type.name, c.attrs), m = Do(f, a.node().type.name, a.node().attrs);
  e.delete(a.pos, l.pos);
  const g = h ? [
    { type: o, attrs: d },
    { type: h, attrs: m }
  ] : [{ type: o, attrs: d }];
  if (!Oi(e.doc, a.pos, 2))
    return !1;
  if (r) {
    const { selection: E, storedMarks: T } = n, { splittableMarks: k } = i.extensionManager, _ = T || E.$to.parentOffset && E.$from.marks();
    if (e.split(a.pos, 2, g).scrollIntoView(), !_ || !r)
      return !0;
    const R = _.filter((M) => k.includes(M.type.name));
    e.ensureMarks(R);
  }
  return !0;
}, Fl = (t, e) => {
  const n = zu((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Ar(t.doc, n.pos) && t.join(n.pos), !0;
}, Hl = (t, e) => {
  const n = zu((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Ar(t.doc, r) && t.join(r), !0;
}, E8 = (t, e, n) => ({ editor: r, tr: i, state: s, dispatch: o, chain: a, commands: l, can: u }) => {
  const { extensions: c, splittableMarks: f } = r.extensionManager, h = Ze(t, s.schema), d = Ze(e, s.schema), { selection: m, storedMarks: g } = s, { $from: E, $to: T } = m, k = E.blockRange(T), _ = g || m.$to.parentOffset && m.$from.marks();
  if (!k)
    return !1;
  const R = zu((M) => Vf(M.type.name, c))(m);
  if (k.depth >= 1 && R && k.depth - R.depth <= 1) {
    if (R.node.type === h)
      return l.liftListItem(d);
    if (Vf(R.node.type.name, c) && h.validContent(R.node.content) && o)
      return a().command(() => (i.setNodeMarkup(R.pos, h), !0)).command(() => Fl(i, h)).command(() => Hl(i, h)).run();
  }
  return !n || !_ || !o ? a().command(() => u().wrapInList(h) ? !0 : l.clearNodes()).wrapInList(h).command(() => Fl(i, h)).command(() => Hl(i, h)).run() : a().command(() => {
    const M = u().wrapInList(h), N = _.filter((S) => f.includes(S.type.name));
    return i.ensureMarks(N), M ? !0 : l.clearNodes();
  }).wrapInList(h).command(() => Fl(i, h)).command(() => Hl(i, h)).run();
}, T8 = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: s = !1 } = n, o = Cr(t, r.schema);
  return nu(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e);
}, A8 = (t, e, n = {}) => ({ state: r, commands: i }) => {
  const s = Ze(t, r.schema), o = Ze(e, r.schema);
  return Bs(r, s, n) ? i.setNode(o) : i.setNode(s, n);
}, y8 = (t, e = {}) => ({ state: n, commands: r }) => {
  const i = Ze(t, n.schema);
  return Bs(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, C8 = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let s;
    if (i.spec.isInputRules && (s = i.getState(t))) {
      if (e) {
        const o = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, b8 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: i } = n;
  return r || e && i.forEach((s) => {
    t.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, x8 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: a } = n, l = Cr(t, r.schema), { $from: u, empty: c, ranges: f } = a;
  if (!i)
    return !0;
  if (c && o) {
    let { from: h, to: d } = a;
    const m = (s = u.marks().find((E) => E.type === l)) === null || s === void 0 ? void 0 : s.attrs, g = Uu(u, l, m);
    g && (h = g.from, d = g.to), n.removeMark(h, d, l);
  } else
    f.forEach((h) => {
      n.removeMark(h.$from.pos, h.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, S8 = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = za(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = Ze(t, r.schema)), a === "mark" && (o = Cr(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    const u = l.$from.pos, c = l.$to.pos;
    r.doc.nodesBetween(u, c, (f, h) => {
      s && s === f.type && n.setNodeMarkup(h, void 0, {
        ...f.attrs,
        ...e
      }), o && f.marks.length && f.marks.forEach((d) => {
        if (o === d.type) {
          const m = Math.max(h, u), g = Math.min(h + f.nodeSize, c);
          n.addMark(m, g, o.create({
            ...d.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, N8 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Ze(t, n.schema);
  return $E(i, e)(n, r);
}, _8 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Ze(t, n.schema);
  return GE(i, e)(n, r);
};
var k8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: cT,
  clearContent: fT,
  clearNodes: hT,
  command: dT,
  createParagraphNear: pT,
  deleteCurrentNode: mT,
  deleteNode: gT,
  deleteRange: ET,
  deleteSelection: TT,
  enter: AT,
  exitCode: yT,
  extendMarkRange: bT,
  first: xT,
  focus: ST,
  forEach: NT,
  insertContent: _T,
  insertContentAt: wT,
  joinUp: DT,
  joinDown: IT,
  joinBackward: MT,
  joinForward: RT,
  keyboardShortcut: LT,
  lift: PT,
  liftEmptyBlock: BT,
  liftListItem: FT,
  newlineInCode: HT,
  resetAttributes: UT,
  scrollIntoView: qT,
  selectAll: zT,
  selectNodeBackward: $T,
  selectNodeForward: GT,
  selectParentNode: jT,
  selectTextblockEnd: VT,
  selectTextblockStart: KT,
  setContent: WT,
  setMark: u8,
  setMeta: c8,
  setNode: f8,
  setNodeSelection: h8,
  setTextSelection: d8,
  sinkListItem: p8,
  splitBlock: m8,
  splitListItem: g8,
  toggleList: E8,
  toggleMark: T8,
  toggleNode: A8,
  toggleWrap: y8,
  undoInputRule: C8,
  unsetAllMarks: b8,
  unsetMark: x8,
  updateAttributes: S8,
  wrapIn: N8,
  wrapInList: _8
});
const O8 = jt.create({
  name: "commands",
  addCommands() {
    return {
      ...k8
    };
  }
}), w8 = jt.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), D8 = jt.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ye({
        key: new st("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), I8 = jt.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: u } = a, { empty: c, $anchor: f } = l, { pos: h, parent: d } = f, m = oe.atStart(u).from === h;
        return !c || !m || !d.type.isTextblock || d.textContent.length ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, s = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return qu() || mm() ? s : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Ye({
        key: new st("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (!(t.some((m) => m.docChanged) && !e.doc.eq(n.doc)))
            return;
          const { empty: i, from: s, to: o } = e.selection, a = oe.atStart(e.doc).from, l = oe.atEnd(e.doc).to, u = s === a && o === l, c = n.doc.textBetween(0, n.doc.content.size, " ", " ").length === 0;
          if (i || !u || !c)
            return;
          const f = n.tr, h = Ba({
            state: n,
            transaction: f
          }), { commands: d } = new Fa({
            editor: this.editor,
            state: h
          });
          if (d.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), M8 = jt.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var R8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: uT,
  Commands: O8,
  Editable: w8,
  FocusEvents: D8,
  Keymap: I8,
  Tabindex: M8
});
const v8 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function L8(t, e) {
  const n = document.querySelector("style[data-tiptap-style]");
  if (n !== null)
    return n;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute("data-tiptap-style", ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let P8 = class extends QE {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }));
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = L8(v8, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(e, n) {
    const r = um(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    this.view.updateState(i);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = typeof e == "string" ? `${e}$` : e.key, r = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((i) => !i.key.startsWith(n))
    });
    this.view.updateState(r);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    const n = [...this.options.enableCoreExtensions ? Object.values(R8) : [], ...this.options.extensions].filter((r) => ["extension", "node", "mark"].includes(r == null ? void 0 : r.type));
    this.extensionManager = new Br(n, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Fa({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const e = gm(this.options.content, this.schema, this.options.parseOptions), n = pm(e, this.options.autofocus);
    this.view = new pE(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Ai.create({
        doc: e,
        selection: n || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), s = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Em(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
    return o8(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return ZT(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return t8(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...hm(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return a8(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
};
function Hi(t) {
  return new Ua({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = se(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], a = r[0];
      let l = n.to;
      if (o) {
        const u = a.search(/\S/), c = n.from + a.indexOf(o), f = c + o.length;
        if (ia(n.from, n.to, e.doc).filter((d) => d.mark.type.excluded.find((g) => g === t.type && g !== d.mark.type)).filter((d) => d.to > c).length)
          return null;
        f < n.to && s.delete(f, n.to), c > n.from && s.delete(n.from + u, c), l = n.from + u + o.length, s.addMark(n.from + u, l, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function B8(t) {
  return new Ua({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = se(t.getAttributes, void 0, r) || {}, { tr: s } = e, o = n.from;
      let a = n.to;
      if (r[1]) {
        const l = r[0].lastIndexOf(r[1]);
        let u = o + l;
        u > a ? u = a : a = u + r[1].length;
        const c = r[0][r[0].length - 1];
        s.insertText(c, o + r[0].length - 1), s.replaceWith(u, a, t.type.create(i));
      } else
        r[0] && s.replaceWith(o, a, t.type.create(i));
    }
  });
}
function ru(t) {
  return new Ua({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from), s = se(t.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s);
    }
  });
}
function Fs(t) {
  return new Ua({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const s = se(t.getAttributes, void 0, r) || {}, o = e.tr.delete(n.from, n.to), l = o.doc.resolve(n.from).blockRange(), u = l && ku(l, t.type, s);
      if (!u)
        return null;
      if (o.wrap(l, u), t.keepMarks && t.editor) {
        const { selection: f, storedMarks: h } = e, { splittableMarks: d } = t.editor.extensionManager, m = h || f.$to.parentOffset && f.$from.marks();
        if (m) {
          const g = m.filter((E) => d.includes(E.type.name));
          o.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const f = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(f, s).run();
      }
      const c = o.doc.resolve(n.from - 1).nodeBefore;
      c && c.type === t.type && Ar(o.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, c)) && o.join(n.from - 1);
    }
  });
}
class Vt {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = se(K(this, "addOptions", {
      name: this.name
    }))), this.storage = se(K(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Vt(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = qa(this.options, e), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new Vt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = se(K(n, "addOptions", {
      name: n.name
    })), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const o = i.marks();
      if (!!!o.find((u) => (u == null ? void 0 : u.type.name) === n.name))
        return !1;
      const l = o.find((u) => (u == null ? void 0 : u.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
class $e {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = se(K(this, "addOptions", {
      name: this.name
    }))), this.storage = se(K(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new $e(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = qa(this.options, e), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new $e(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = se(K(n, "addOptions", {
      name: n.name
    })), n.storage = se(K(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function Qr(t) {
  return new rT({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = se(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], a = r[0];
      let l = n.to;
      if (o) {
        const u = a.search(/\S/), c = n.from + a.indexOf(o), f = c + o.length;
        if (ia(n.from, n.to, e.doc).filter((d) => d.mark.type.excluded.find((g) => g === t.type && g !== d.mark.type)).filter((d) => d.to > c).length)
          return null;
        f < n.to && s.delete(f, n.to), c > n.from && s.delete(n.from + u, c), l = n.from + u + o.length, s.addMark(n.from + u, l, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function F8(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
const H8 = /^\s*>\s$/, Tm = $e.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Fs({
        find: H8,
        type: this.type
      })
    ];
  }
}), U8 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/, q8 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g, z8 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/, $8 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g, Am = Vt.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Hi({
        find: U8,
        type: this.type
      }),
      Hi({
        find: z8,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Qr({
        find: q8,
        type: this.type
      }),
      Qr({
        find: $8,
        type: this.type
      })
    ];
  }
}), G8 = $e.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ue(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Wf = Vt.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = $a(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), Yf = /^\s*([-+*])\s$/, ym = $e.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(G8.name, this.editor.getAttributes(Wf.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Fs({
      find: Yf,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Fs({
      find: Yf,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Wf.name),
      editor: this.editor
    })), [
      t
    ];
  }
}), j8 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/, V8 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g, Cm = Vt.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Hi({
        find: j8,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Qr({
        find: V8,
        type: this.type
      })
    ];
  }
}), K8 = /^```([a-z]+)?[\s\n]$/, W8 = /^~~~([a-z]+)?[\s\n]$/, bm = $e.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(n)).map((o) => o.replace(n, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Ue(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
        return !s || !o ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: i, empty: s } = n;
        if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 || r.nodeAt(a) ? !1 : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      ru({
        find: K8,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      ru({
        find: W8,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Ye({
        key: new st("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i == null ? void 0 : i.mode;
            if (!n || !s)
              return !1;
            const { tr: o } = t.state;
            return o.replaceSelectionWith(this.type.create({ language: s })), o.setSelection(ae.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.insertText(n.replace(/\r\n?/g, `
`)), o.setMeta("paste", !0), t.dispatch(o), !0;
          }
        }
      })
    ];
  }
}), xm = $e.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
class Be extends oe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Be.valid(r) ? new Be(r) : oe.near(r);
  }
  content() {
    return j.empty;
  }
  eq(e) {
    return e instanceof Be && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Be(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new $u(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !Y8(e) || !Q8(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e:
      for (; ; ) {
        if (!r && Be.valid(e))
          return e;
        let i = e.pos, s = null;
        for (let o = e.depth; ; o--) {
          let a = e.node(o);
          if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
            s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
            break;
          } else if (o == 0)
            return null;
          i += n;
          let l = e.doc.resolve(i);
          if (Be.valid(l))
            return l;
        }
        for (; ; ) {
          let o = n > 0 ? s.firstChild : s.lastChild;
          if (!o) {
            if (s.isAtom && !s.isText && !ne.isSelectable(s)) {
              e = e.doc.resolve(i + s.nodeSize * n), r = !1;
              continue e;
            }
            break;
          }
          s = o, i += n;
          let a = e.doc.resolve(i);
          if (Be.valid(a))
            return a;
        }
        return null;
      }
  }
}
Be.prototype.visible = !1;
Be.findFrom = Be.findGapCursorFrom;
oe.jsonID("gapcursor", Be);
class $u {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new $u(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Be.valid(n) ? new Be(n) : oe.near(n);
  }
}
function Y8(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Q8(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function J8() {
  return new Ye({
    props: {
      decorations: tA,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Be.valid(n) ? new Be(n) : null;
      },
      handleClick: Z8,
      handleKeyDown: X8,
      handleDOMEvents: { beforeinput: eA }
    }
  });
}
const X8 = nm({
  ArrowLeft: io("horiz", -1),
  ArrowRight: io("horiz", 1),
  ArrowUp: io("vert", -1),
  ArrowDown: io("vert", 1)
});
function io(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof ae) {
      if (!s.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let u = Be.findGapCursorFrom(a, e, l);
    return u ? (i && i(r.tr.setSelection(new Be(u))), !0) : !1;
  };
}
function Z8(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Be.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ne.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Be(r))), !0);
}
function eA(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Be))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = L.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = L.from(r[o].createAndFill(null, i));
  let s = t.state.tr.replace(n.pos, n.pos, new j(i, 0, 0));
  return s.setSelection(ae.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1;
}
function tA(t) {
  if (!(t.selection instanceof Be))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", He.create(t.doc, [bt.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const nA = jt.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      J8()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = se(K(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), Sm = $e.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Ue(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: i, storedMarks: s } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: a } = r.extensionManager, l = s || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: u, dispatch: c }) => {
            if (c && l && o) {
              const f = l.filter((h) => a.includes(h.type.name));
              u.ensureMarks(f);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), rA = $e.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Ue(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => ru({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
var sa = 200, rt = function() {
};
rt.prototype.append = function(e) {
  return e.length ? (e = rt.from(e), !this.length && e || e.length < sa && this.leafAppend(e) || this.length < sa && e.leafPrepend(this) || this.appendInner(e)) : this;
};
rt.prototype.prepend = function(e) {
  return e.length ? rt.from(e).append(this) : this;
};
rt.prototype.appendInner = function(e) {
  return new iA(this, e);
};
rt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? rt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
rt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
rt.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
rt.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, n, r), i;
};
rt.from = function(e) {
  return e instanceof rt ? e : e && e.length ? new Nm(e) : rt.empty;
};
var Nm = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, a) {
    for (var l = s; l < o; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= sa)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= sa)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(rt);
rt.empty = new Nm([]);
var iA = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(rt), _m = rt;
const sA = 500;
class on {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    n && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, a, l, u = [], c = [];
    return this.items.forEach((f, h) => {
      if (!f.step) {
        i || (i = this.remapping(r, h + 1), s = i.maps.length), s--, c.push(f);
        return;
      }
      if (i) {
        c.push(new mn(f.map));
        let d = f.step.map(i.slice(s)), m;
        d && o.maybeStep(d).doc && (m = o.mapping.maps[o.mapping.maps.length - 1], u.push(new mn(m, void 0, void 0, u.length + c.length))), s--, m && i.appendMap(m, s);
      } else
        o.maybeStep(f.step);
      if (f.selection)
        return a = i ? f.selection.map(i.slice(s)) : f.selection, l = new on(this.items.slice(0, r).append(c.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let s = [], o = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let f = e.steps[c].invert(e.docs[c]), h = new mn(e.mapping.maps[c], f, n), d;
      (d = l && l.merge(h)) && (h = d, c ? s.pop() : a = a.slice(0, a.length - 1)), s.push(h), n && (o++, n = void 0), i || (l = h);
    }
    let u = o - r.depth;
    return u > aA && (a = oA(a, u), o -= u), new on(a.append(s), o);
  }
  remapping(e, n) {
    let r = new ki();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new on(this.items.append(e.map((n) => new mn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((h) => {
      h.selection && a--;
    }, i);
    let l = n;
    this.items.forEach((h) => {
      let d = s.getMirror(--l);
      if (d == null)
        return;
      o = Math.min(o, d);
      let m = s.maps[d];
      if (h.step) {
        let g = e.steps[d].invert(e.docs[d]), E = h.selection && h.selection.map(s.slice(l + 1, d));
        E && a++, r.push(new mn(m, g, E));
      } else
        r.push(new mn(m));
    }, i);
    let u = [];
    for (let h = n; h < o; h++)
      u.push(new mn(s.maps[h]));
    let c = this.items.slice(0, i).append(u).append(r), f = new on(c, a);
    return f.emptyItemCount() > sA && (f = f.compress(this.items.length - r.length)), f;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(n.slice(r)), u = l && l.getMap();
        if (r--, u && n.appendMap(u, r), l) {
          let c = o.selection && o.selection.map(n.slice(r));
          c && s++;
          let f = new mn(u.invert(), l, c), h, d = i.length - 1;
          (h = i.length && i[d].merge(f)) ? i[d] = h : i.push(f);
        }
      } else
        o.map && r--;
    }, this.items.length, 0), new on(_m.from(i.reverse()), s);
  }
}
on.empty = new on(_m.empty, 0);
function oA(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
class mn {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new mn(n.getMap().invert(), n, this.selection);
    }
  }
}
class rr {
  constructor(e, n, r, i) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i;
  }
}
const aA = 20;
function lA(t, e, n, r) {
  let i = n.getMeta(pr), s;
  if (i)
    return i.historyState;
  n.getMeta(cA) && (t = new rr(t.done, t.undone, null, 0));
  let o = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (o && o.getMeta(pr))
    return o.getMeta(pr).redo ? new rr(t.done.addTransform(n, void 0, r, Io(e)), t.undone, Qf(n.mapping.maps[n.steps.length - 1]), t.prevTime) : new rr(t.done, t.undone.addTransform(n, void 0, r, Io(e)), null, t.prevTime);
  if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = t.prevTime == 0 || !o && (t.prevTime < (n.time || 0) - r.newGroupDelay || !uA(n, t.prevRanges)), l = o ? Ul(t.prevRanges, n.mapping) : Qf(n.mapping.maps[n.steps.length - 1]);
    return new rr(t.done.addTransform(n, a ? e.selection.getBookmark() : void 0, r, Io(e)), on.empty, l, n.time);
  } else
    return (s = n.getMeta("rebased")) ? new rr(t.done.rebased(n, s), t.undone.rebased(n, s), Ul(t.prevRanges, n.mapping), t.prevTime) : new rr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Ul(t.prevRanges, n.mapping), t.prevTime);
}
function uA(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (n = !0);
  }), n;
}
function Qf(t) {
  let e = [];
  return t.forEach((n, r, i, s) => e.push(i, s)), e;
}
function Ul(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), s = e.map(t[r + 1], -1);
    i <= s && n.push(i, s);
  }
  return n;
}
function km(t, e, n, r) {
  let i = Io(e), s = pr.get(e).spec.config, o = (r ? t.undone : t.done).popEvent(e, i);
  if (!o)
    return;
  let a = o.selection.resolve(o.transform.doc), l = (r ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), s, i), u = new rr(r ? l : o.remaining, r ? o.remaining : l, null, 0);
  n(o.transform.setSelection(a).setMeta(pr, { redo: r, historyState: u }).scrollIntoView());
}
let ql = !1, Jf = null;
function Io(t) {
  let e = t.plugins;
  if (Jf != e) {
    ql = !1, Jf = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        ql = !0;
        break;
      }
  }
  return ql;
}
const pr = new st("history"), cA = new st("closeHistory");
function fA(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Ye({
    key: pr,
    state: {
      init() {
        return new rr(on.empty, on.empty, null, 0);
      },
      apply(e, n, r) {
        return lA(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? Om : r == "historyRedo" ? wm : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const Om = (t, e) => {
  let n = pr.getState(t);
  return !n || n.done.eventCount == 0 ? !1 : (e && km(n, t, e, !1), !0);
}, wm = (t, e) => {
  let n = pr.getState(t);
  return !n || n.undone.eventCount == 0 ? !1 : (e && km(n, t, e, !0), !0);
}, Dm = jt.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => Om(t, e),
      redo: () => ({ state: t, dispatch: e }) => wm(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      fA(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), hA = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/, dA = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g, pA = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/, mA = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g, Im = Vt.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Hi({
        find: hA,
        type: this.type
      }),
      Hi({
        find: pA,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Qr({
        find: dA,
        type: this.type
      }),
      Qr({
        find: mA,
        type: this.type
      })
    ];
  }
}), Mm = Vt.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), Rm = $e.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Ue(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t }) => t().insertContent({ type: this.name }).command(({ tr: e, dispatch: n }) => {
        var r;
        if (n) {
          const { $to: i } = e.selection, s = i.end();
          if (i.nodeAfter)
            e.setSelection(ae.create(e.doc, i.pos));
          else {
            const o = (r = i.parent.type.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.create();
            o && (e.insert(s, o), e.setSelection(ae.create(e.doc, s)));
          }
          e.scrollIntoView();
        }
        return !0;
      }).run()
    };
  },
  addInputRules() {
    return [
      B8({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), vm = $e.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ue(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), gA = $e.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ue(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Xf = Vt.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = $a(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), Zf = /^(\d+)\.\s$/, Lm = $e.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Ue(this.options.HTMLAttributes, n), 0] : ["ol", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(gA.name, this.editor.getAttributes(Xf.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Fs({
      find: Zf,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Fs({
      find: Zf,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Xf.name),
      editor: this.editor
    })), [
      t
    ];
  }
}), Pm = $e.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), Bm = jt.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = [];
            if (!n)
              return null;
            const s = t.type.createAndFill(), o = (s == null ? void 0 : s.sameMarkup(t)) && s.content.findDiffStart(t.content) === null;
            return t.descendants((a, l) => {
              const u = r >= l && r <= l + a.nodeSize, c = !a.isLeaf && !a.childCount;
              if ((u || !this.options.showOnlyCurrent) && c) {
                const f = [this.options.emptyNodeClass];
                o && f.push(this.options.emptyEditorClass);
                const h = bt.node(l, l + a.nodeSize, {
                  class: f.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: l,
                    hasAnchor: u
                  }) : this.options.placeholder
                });
                i.push(h);
              }
              return this.options.includeChildren;
            }), He.create(t, i);
          }
        }
      })
    ];
  }
}), EA = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/, TA = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g, Fm = Vt.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Ue(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Hi({
        find: EA,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Qr({
        find: TA,
        type: this.type
      })
    ];
  }
}), Hm = $e.create({
  name: "text",
  group: "inline"
});
class AA extends P8 {
  constructor() {
    super(...arguments), this.contentComponent = null;
  }
}
const yA = ({ renderers: t }) => Dt.createElement(Dt.Fragment, null, Object.entries(t).map(([e, n]) => V2.createPortal(n.reactElement, n.element, e)));
class CA extends Dt.Component {
  constructor(e) {
    super(e), this.editorContentRef = Dt.createRef(), this.initialized = !1, this.state = {
      renderers: {}
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const { editor: e } = this.props;
    if (e && e.options.element) {
      if (e.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...e.options.element.childNodes), e.setOptions({
        element: n
      }), e.contentComponent = this, e.createNodeViews(), this.initialized = !0;
    }
  }
  maybeFlushSync(e) {
    this.initialized ? queueMicrotask(() => {
      K2(e);
    }) : e();
  }
  setRenderer(e, n) {
    this.maybeFlushSync(() => {
      this.setState(({ renderers: r }) => ({
        renderers: {
          ...r,
          [e]: n
        }
      }));
    });
  }
  removeRenderer(e) {
    this.maybeFlushSync(() => {
      this.setState(({ renderers: n }) => {
        const r = { ...n };
        return delete r[e], { renderers: r };
      });
    });
  }
  componentWillUnmount() {
    const { editor: e } = this.props;
    if (!e || (this.initialized = !1, e.isDestroyed || e.view.setProps({
      nodeViews: {}
    }), e.contentComponent = null, !e.options.element.firstChild))
      return;
    const n = document.createElement("div");
    n.append(...e.options.element.childNodes), e.setOptions({
      element: n
    });
  }
  render() {
    const { editor: e, ...n } = this.props;
    return Dt.createElement(
      Dt.Fragment,
      null,
      Dt.createElement("div", { ref: this.editorContentRef, ...n }),
      Dt.createElement(yA, { renderers: this.state.renderers })
    );
  }
}
const Um = Dt.memo(CA), bA = $2({
  onDragStart: void 0
}), xA = () => j2(bA);
Dt.forwardRef((t, e) => {
  const { onDragStart: n } = xA(), r = t.as || "div";
  return Dt.createElement(r, { ...t, ref: e, "data-node-view-wrapper": "", onDragStart: n, style: {
    whiteSpace: "normal",
    ...t.style
  } });
});
function SA() {
  const [, t] = Vp(0);
  return () => t((e) => e + 1);
}
const qm = (t = {}, e = []) => {
  const [n, r] = Vp(null), i = SA();
  return G2(() => {
    let s = !0;
    const o = new AA(t);
    return r(o), o.on("transaction", () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          s && i();
        });
      });
    }), () => {
      o.destroy(), s = !1;
    };
  }, e), n;
}, NA = $e.create({
  name: "figureAudio",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("source")) == null ? void 0 : e.getAttribute("src");
        }
      },
      title: {
        default: "",
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector(".title")) == null ? void 0 : e.textContent;
        }
      },
      duration: {
        default: "00:00",
        parseHTML: (t) => {
          var n;
          const e = t.querySelector(".duration");
          return (n = e == null ? void 0 : e.dataset) == null ? void 0 : n.time;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'figure[class="audio"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "figure",
      { class: "audio" },
      [
        "audio",
        { controls: !0 },
        [
          "source",
          {
            src: t.src,
            type: "audio/mp3",
            draggable: !1,
            contenteditable: !1
          }
        ]
      ],
      [
        "div",
        { class: "player" },
        [
          "header",
          [
            "div",
            { class: "meta" },
            ["h4", { class: "title" }, t.title],
            [
              "div",
              { class: "time" },
              ["span", { class: "current", "data-time": "00:00" }],
              [
                "span",
                {
                  class: "duration",
                  "data-time": t.duration
                }
              ]
            ]
          ],
          ["span", { class: "play" }]
        ],
        ["footer", ["div", { class: "progress-bar" }, ["span", {}]]]
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureAudio: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("removePastedFigureAudio"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.audio.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), _A = (t) => {
  const e = {
    url: "",
    allowfullscreen: !1,
    sandbox: []
  };
  let n;
  try {
    n = new URL(t);
  } catch {
    return e;
  }
  const { hostname: r, pathname: i, searchParams: s } = n;
  if ([
    "youtube.com",
    "youtu.be",
    "www.youtu.be",
    "www.youtube.com"
  ].includes(r)) {
    const h = s.get("v"), d = s.get("t"), m = new URLSearchParams({
      rel: "0",
      ...d ? { start: d } : {}
    }).toString();
    let g = "";
    return h ? g = h : i.match("/embed/") ? g = i.split("/embed/")[1] : r.includes("youtu.be") && (g = i.split("/")[1]), {
      url: `https://www.youtube.com/embed/${g}` + (m ? `?=${m}` : ""),
      provider: "youtube",
      allowfullscreen: !0,
      sandbox: []
    };
  }
  if (["vimeo.com", "www.vimeo.com", "player.vimeo.com"].includes(
    r
  ))
    return {
      url: `https://player.vimeo.com/video/${i.replace(/\/$/, "").split("/").slice(-1)[0]}`,
      provider: "vimeo",
      allowfullscreen: !0,
      sandbox: []
    };
  if ([
    "bilibili.com",
    "player.bilibili.com",
    "www.bilibili.com"
  ].includes(r)) {
    const h = s.get("bvid");
    let d = "";
    return h ? d = h : d = i.replace(/\/$/, "").split("/").slice(-1)[0], {
      url: `https://player.bilibili.com/player.html?bvid=${d}`,
      provider: "bilibili",
      allowfullscreen: !0,
      sandbox: []
    };
  }
  if (["instagram.com", "www.instagram.com"].includes(r))
    return {
      url: `https://www.instagram.com/p/${i.replace("/embed", "").replace(/\/$/, "").split("/").slice(-1)[0]}/embed`,
      provider: "instagram",
      allowfullscreen: !1,
      sandbox: []
    };
  if (["jsfiddle.net", "www.jsfiddle.net"].includes(r)) {
    const h = i.replace("/embedded", "").replace(/\/$/, "").split("/").filter(Boolean);
    return {
      url: `https://jsfiddle.net/${h.length === 1 ? h[0] : h[1]}/embedded/`,
      provider: "jsfiddle",
      allowfullscreen: !1,
      sandbox: []
    };
  }
  if (["codepen.io", "www.codepen.io"].includes(r)) {
    const h = i.split("/")[1], d = i.replace(/\/$/, "").split("/").slice(-1)[0];
    return {
      url: `https://codepen.io/${h}/embed/preview/${d}`,
      provider: "codepen",
      allowfullscreen: !1,
      sandbox: []
    };
  }
  return e;
}, kA = $e.create({
  name: "figureEmbed",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      class: {
        default: null,
        parseHTML: (t) => t.getAttribute("class")
      },
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("iframe")) == null ? void 0 : e.getAttribute("src");
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        // match "embed", "embed-video", "embed-code" for backward compatibility
        tag: 'figure[class^="embed"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { url: e, provider: n, allowfullscreen: r, sandbox: i } = _A(
      t.src
    );
    return [
      "figure",
      { class: "embed", ...n ? { "data-provider": n } : {} },
      [
        "div",
        { class: "iframe-container" },
        [
          "iframe",
          {
            src: e,
            loading: "lazy",
            ...i && i.length > 0 ? { sandbox: i.join(" ") } : {},
            ...r ? { allowfullscreen: !0 } : {},
            frameborder: "0",
            draggable: !1,
            contenteditable: !1
          }
        ]
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureEmbed: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("removePastedFigureEmbed"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.embed.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), OA = $e.create({
  name: "figureImage",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      class: {
        default: null,
        parseHTML: (t) => t.getAttribute("class")
      },
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("img")) == null ? void 0 : e.getAttribute("src");
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'figure[class="image"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "figure",
      { class: "image" },
      [
        "img",
        {
          src: t.src,
          draggable: !1,
          contenteditable: !1
        }
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureImage: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ye({
        key: new st("removePastedFigureImage"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.image.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), wA = "aaa1rp3barth4b_ott3vie4c1le2ogado5udhabi7c_ademy5centure6ountant_s9o1tor4d_s1ult4e_g1ro2tna4f_l1rica5g_akhan5ency5i_g1rbus3force5tel5kdn3l_faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m_azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o_l2partments8p_le4q_uarelle8r_ab1mco4chi3my2pa2t_e3s_da2ia2sociates9t_hleta5torney7u_ction5di_ble3o3spost5thor3o_s4vianca6w_s2x_a2z_ure5ba_by2idu3namex3narepublic11d1k2r_celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b_c1t1va3cg1n2d1e_ats2uty4er2ntley5rlin4st_buy5t2f1g1h_arti5i_ble3d1ke2ng_o3o1z2j1lack_friday9ockbuster8g1omberg7ue3m_s1w2n_pparibas9o_ats3ehringer8fa2m1nd2o_k_ing5sch2tik2on4t1utique6x2r_adesco6idgestone9oadway5ker3ther5ussels7s1t1uild_ers6siness6y1zz3v1w1y1z_h3ca_b1fe2l_l1vinklein9m_era3p2non3petown5ital_one8r_avan4ds2e_er_s4s2sa1e1h1ino4t_ering5holic7ba1n1re2s2c1d1enter4o1rn3f_a1d2g1h_anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i_priani6rcle4sco3tadel4i_c2y_eats7k1l_aims4eaning6ick2nic1que6othing5ud3ub_med6m1n1o_ach3des3ffee4llege4ogne5m_cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking_channel11l1p2rsica5untry4pon_s4rses6pa2r_edit_card4union9icket5own3s1uise_s6u_isinella9v1w1x1y_mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e_al_er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si_gn4v2hl2iamonds6et2gital5rect_ory7scount3ver5h2y2j1k1m1np2o_cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c_o2deka3u_cation8e1g1mail3erck5nergy4gineer_ing9terprises10pson4quipment8r_icsson6ni3s_q1tate5t_isalat7u_rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n_s2rm_ers5shion4t3edex3edback6rrari3ero6i_at2delity5o2lm2nal1nce1ial7re_stone6mdale6sh_ing5t_ness6j1k1lickr3ghts4r2orist4wers5y2m1o_o_d_network8tball6rd1ex2sale4um3undation8x2r_ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n_d2rniture7tbol5yi3ga_l_lery3o1up4me_s3p1rden4y2b_iz3d_n2e_a1nt_ing5orge5f1g_ee3h1i_ft_s3ves2ing5l_ass3e1obal2o4m_ail3bh2o1x2n1odaddy5ld_point6f2o_dyear5g_le4p1t1v2p1q1r_ainger5phics5tis4een3ipe3ocery4up4s1t1u_ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc_bank7ealth_care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k_t2m1n1ockey4ldings5iday5medepot5goods5s_ense7nda3rse3spital5t_ing5t_eles2s3mail5use3w2r1sbc3t1u_ghes5yatt3undai7ibm2cbc2e1u2d1e_ee3fm2kano4l1m_amat4db2mo_bilien9n_c1dustries8finiti5o2g1k1stitute6urance4e4t_ernational10uit4vestments10o1piranga7q1r_ish4s_maili5t_anbul7t_au2v3jaguar4va3cb2e_ep2tzt3welry6io2ll2m_p2nj2o_bs1urg4t1y2p_morgan6rs3uegos4niper7kaufen5ddi3e_rryhotels6logistics9properties14fh2g1h1i_a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p_mg2n2r_d1ed3uokgroup8w1y_oto4z2la_caixa5mborghini8er3ncaster5ia3d_rover6xess5salle5t_ino3robe5w_yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i_dl2fe_insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan_s3cker3us3l1ndon4tte1o3ve3pl_financial11r1s1t_d_a3u_ndbeck6xe1ury5v1y2ma_cys3drid4if1son4keup4n_agement7go3p1rket_ing3s4riott5shalls7serati6ttel5ba2c_kinsey7d1e_d_ia3et2lbourne7me1orial6n_u2rckmsd7g1h1iami3crosoft7l1ni1t2t_subishi9k1l_b1s2m_a2n1o_bi_le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to_rcycles9v_ie4p1q1r1s_d2t_n1r2u_seum3ic3tual5v1w1x1y1z2na_b1goya4me2tura4vy3ba2c1e_c1t_bank4flix4work5ustar5w_s2xt_direct7us4f_l2g_o2hk2i_co2ke1on3nja3ssan1y5l1o_kia3rthwesternmutual14on4w_ruz3tv4p1r_a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan_group9dnavy5lo3m_ega4ne1g1l_ine5oo2pen3racle3nge4g_anic5igins6saka4tsuka4t2vh3pa_ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e_t2f_izer5g1h_armacy6d1ilips5one2to_graphy6s4ysio5ics1tet2ures6d1n_g1k2oneer5zza4k1l_ace2y_station9umbing5s3m1n_c2ohl2ker3litie5rn2st3r_america6xi3ess3ime3o_d_uctions8f1gressive8mo2perties3y5tection8u_dential9s1t1ub2w_c2y2qa1pon3uebec3st5racing4dio4e_ad1lestate6tor2y4cipes5d_stone5umbrella9hab3ise_n3t2liance6n_t_als5pair3ort3ublican8st_aurant8view_s5xroth6ich_ardli6oh3l1o1p2o_cher3ks3deo3gers4om3s_vp3u_gby3hr2n2w_e2yukyu6sa_arland6fe_ty4kura4le1on3msclub4ung5ndvik_coromant12ofi4p1rl2s1ve2xo3b_i1s2c_a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e_arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x_y3fr2g1h_angrila6rp2w2ell3ia1ksha5oes2p_ping5uji3w_time7i_lk2na1gles5te3j1k_i_n2y_pe4l_ing4m_art3ile4n_cf3o_ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa_ce3ort2t3r_l2s1t_ada2ples4r1tebank4farm7c_group6ockholm6rage3e3ream4udio2y3yle4u_cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y_dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x_i3c_i2d_k2eam2ch_nology8l1masek5nnis4va3f1g1h_d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j_maxx4x2k_maxx5l1m_all4n1o_day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r_ade1ing4ining5vel_channel7ers_insurance16ust3v2t1ube2i1nes3shu4v_s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va_cations7na1guard7c1e_gas3ntures6risign5mögensberater2ung14sicherung10t2g1i_ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u_elos6wales2mart4ter4ng_gou5tch_es6eather_channel12bcam3er2site5d_ding5ibo2r3f1hoswho6ien2ki2lliamhill9n_dows4e1ners6me2olterskluwer11odside6rk_s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u_tube6t1un3za_ppos4ra3ero3ip2m1one3uerich6w2", DA = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत_म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里_大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Ui = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, iu = "numeric", su = "ascii", ou = "alpha", Mo = "asciinumeric", so = "alphanumeric", au = "domain", zm = "emoji", IA = "scheme", MA = "slashscheme", eh = "whitespace";
function RA(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Hr(t, e, n) {
  e[iu] && (e[Mo] = !0, e[so] = !0), e[su] && (e[Mo] = !0, e[ou] = !0), e[Mo] && (e[so] = !0), e[ou] && (e[so] = !0), e[so] && (e[au] = !0), e[zm] && (e[au] = !0);
  for (const r in e) {
    const i = RA(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function vA(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Ct(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Ct.groups = {};
Ct.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], s = e.jr[r][1];
      if (s && i.test(t))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || Ct.groups;
    let i;
    return e && e.j ? i = e : (i = new Ct(e), n && r && Hr(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const s = t.length;
    if (!s)
      return i;
    for (let o = 0; o < s - 1; o++)
      i = i.tt(t[o]);
    return i.tt(t[s - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || Ct.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const s = e;
    let o, a = i.go(t);
    if (a ? (o = new Ct(), Ui(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new Ct(), s) {
      if (r)
        if (o.t && typeof o.t == "string") {
          const l = Ui(vA(o.t, r), n);
          Hr(s, l, r);
        } else
          n && Hr(s, n, r);
      o.t = s;
    }
    return i.j[t] = o, o;
  }
};
const W = (t, e, n, r, i) => t.ta(e, n, r, i), Pt = (t, e, n, r, i) => t.tr(e, n, r, i), th = (t, e, n, r, i) => t.ts(e, n, r, i), U = (t, e, n, r, i) => t.tt(e, n, r, i), Ln = "WORD", lu = "UWORD", Hs = "LOCALHOST", uu = "TLD", cu = "UTLD", Ro = "SCHEME", mi = "SLASH_SCHEME", oa = "NUM", $m = "WS", Gu = "NL", Ci = "OPENBRACE", Cs = "OPENBRACKET", bs = "OPENANGLEBRACKET", xs = "OPENPAREN", vr = "CLOSEBRACE", bi = "CLOSEBRACKET", xi = "CLOSEANGLEBRACKET", Lr = "CLOSEPAREN", aa = "AMPERSAND", la = "APOSTROPHE", ua = "ASTERISK", ir = "AT", ca = "BACKSLASH", fa = "BACKTICK", ha = "CARET", ar = "COLON", ju = "COMMA", da = "DOLLAR", gn = "DOT", pa = "EQUALS", Vu = "EXCLAMATION", En = "HYPHEN", ma = "PERCENT", ga = "PIPE", Ea = "PLUS", Ta = "POUND", Aa = "QUERY", Ku = "QUOTE", Wu = "SEMI", Fn = "SLASH", Ss = "TILDE", ya = "UNDERSCORE", Gm = "EMOJI", Ca = "SYM";
var jm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: Ln,
  UWORD: lu,
  LOCALHOST: Hs,
  TLD: uu,
  UTLD: cu,
  SCHEME: Ro,
  SLASH_SCHEME: mi,
  NUM: oa,
  WS: $m,
  NL: Gu,
  OPENBRACE: Ci,
  OPENBRACKET: Cs,
  OPENANGLEBRACKET: bs,
  OPENPAREN: xs,
  CLOSEBRACE: vr,
  CLOSEBRACKET: bi,
  CLOSEANGLEBRACKET: xi,
  CLOSEPAREN: Lr,
  AMPERSAND: aa,
  APOSTROPHE: la,
  ASTERISK: ua,
  AT: ir,
  BACKSLASH: ca,
  BACKTICK: fa,
  CARET: ha,
  COLON: ar,
  COMMA: ju,
  DOLLAR: da,
  DOT: gn,
  EQUALS: pa,
  EXCLAMATION: Vu,
  HYPHEN: En,
  PERCENT: ma,
  PIPE: ga,
  PLUS: Ea,
  POUND: Ta,
  QUERY: Aa,
  QUOTE: Ku,
  SEMI: Wu,
  SLASH: Fn,
  TILDE: Ss,
  UNDERSCORE: ya,
  EMOJI: Gm,
  SYM: Ca
});
const ai = /[a-z]/, zl = /\p{L}/u, $l = /\p{Emoji}/u, Gl = /\d/, nh = /\s/, rh = `
`, LA = "️", PA = "‍";
let oo = null, ao = null;
function BA(t) {
  t === void 0 && (t = []);
  const e = {};
  Ct.groups = e;
  const n = new Ct();
  oo == null && (oo = ih(wA)), ao == null && (ao = ih(DA)), U(n, "'", la), U(n, "{", Ci), U(n, "[", Cs), U(n, "<", bs), U(n, "(", xs), U(n, "}", vr), U(n, "]", bi), U(n, ">", xi), U(n, ")", Lr), U(n, "&", aa), U(n, "*", ua), U(n, "@", ir), U(n, "`", fa), U(n, "^", ha), U(n, ":", ar), U(n, ",", ju), U(n, "$", da), U(n, ".", gn), U(n, "=", pa), U(n, "!", Vu), U(n, "-", En), U(n, "%", ma), U(n, "|", ga), U(n, "+", Ea), U(n, "#", Ta), U(n, "?", Aa), U(n, '"', Ku), U(n, "/", Fn), U(n, ";", Wu), U(n, "~", Ss), U(n, "_", ya), U(n, "\\", ca);
  const r = Pt(n, Gl, oa, {
    [iu]: !0
  });
  Pt(r, Gl, r);
  const i = Pt(n, ai, Ln, {
    [su]: !0
  });
  Pt(i, ai, i);
  const s = Pt(n, zl, lu, {
    [ou]: !0
  });
  Pt(s, ai), Pt(s, zl, s);
  const o = Pt(n, nh, $m, {
    [eh]: !0
  });
  U(n, rh, Gu, {
    [eh]: !0
  }), U(o, rh), Pt(o, nh, o);
  const a = Pt(n, $l, Gm, {
    [zm]: !0
  });
  Pt(a, $l, a), U(a, LA, a);
  const l = U(a, PA);
  Pt(l, $l, a);
  const u = [[ai, i]], c = [[ai, null], [zl, s]];
  for (let f = 0; f < oo.length; f++)
    Wn(n, oo[f], uu, Ln, u);
  for (let f = 0; f < ao.length; f++)
    Wn(n, ao[f], cu, lu, c);
  Hr(uu, {
    tld: !0,
    ascii: !0
  }, e), Hr(cu, {
    utld: !0,
    alpha: !0
  }, e), Wn(n, "file", Ro, Ln, u), Wn(n, "mailto", Ro, Ln, u), Wn(n, "http", mi, Ln, u), Wn(n, "https", mi, Ln, u), Wn(n, "ftp", mi, Ln, u), Wn(n, "ftps", mi, Ln, u), Hr(Ro, {
    scheme: !0,
    ascii: !0
  }, e), Hr(mi, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((f, h) => f[0] > h[0] ? 1 : -1);
  for (let f = 0; f < t.length; f++) {
    const h = t[f][0], m = t[f][1] ? {
      [IA]: !0
    } : {
      [MA]: !0
    };
    h.indexOf("-") >= 0 ? m[au] = !0 : ai.test(h) ? Gl.test(h) ? m[Mo] = !0 : m[su] = !0 : m[iu] = !0, th(n, h, h, m);
  }
  return th(n, "localhost", Hs, {
    ascii: !0
  }), n.jd = new Ct(Ca), {
    start: n,
    tokens: Ui({
      groups: e
    }, jm)
  };
}
function FA(t, e) {
  const n = HA(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let s = 0, o = 0;
  for (; o < r; ) {
    let a = t, l = null, u = 0, c = null, f = -1, h = -1;
    for (; o < r && (l = a.go(n[o])); )
      a = l, a.accepts() ? (f = 0, h = 0, c = a) : f >= 0 && (f += n[o].length, h++), u += n[o].length, s += n[o].length, o++;
    s -= f, o -= h, u -= f, i.push({
      t: c.t,
      // token type/name
      v: e.slice(s - u, s),
      // string value
      s: s - u,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return i;
}
function HA(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), s, o = i < 55296 || i > 56319 || r + 1 === n || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(o), r += o.length;
  }
  return e;
}
function Wn(t, e, n, r, i) {
  let s;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    t.j[l] ? s = t.j[l] : (s = new Ct(r), s.jr = i.slice(), t.j[l] = s), t = s;
  }
  return s = new Ct(n), s.jr = i.slice(), t.j[e[o - 1]] = s, s;
}
function ih(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let s = 0;
    for (; i.indexOf(t[r + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(n.join(""));
      let o = parseInt(t.substring(r, r + s), 10);
      for (; o > 0; o--)
        n.pop();
      r += s;
    } else
      t[r] === "_" ? (e.push(n.join("")), r++) : (n.push(t[r]), r++);
  }
  return e;
}
const Us = {
  defaultProtocol: "http",
  events: null,
  format: sh,
  formatHref: sh,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Yu(t, e) {
  e === void 0 && (e = null);
  let n = Ui({}, Us);
  t && (n = Ui(n, t instanceof Yu ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let s = 0; s < r.length; s++)
    i.push(r[s].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
Yu.prototype = {
  o: Us,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Us[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function sh(t) {
  return t;
}
function Vm(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
Vm.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = Us.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toFormattedHref(t), r = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, o = t.get("className", n, e), a = t.get("target", n, e), l = t.get("rel", n, e), u = t.getObj("attributes", n, e), c = t.getObj("events", n, e);
    return s.href = n, o && (s.class = o), a && (s.target = a), l && (s.rel = l), u && Ui(s, u), {
      tagName: r,
      attributes: s,
      content: i,
      eventListeners: c
    };
  }
};
function Ga(t, e) {
  class n extends Vm {
    constructor(i, s) {
      super(i, s), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const oh = Ga("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), ah = Ga("text"), UA = Ga("nl"), _r = Ga("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = Us.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Hs && t[1].t === ar;
  }
}), Qe = (t) => new Ct(t);
function qA(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([aa, ua, ir, ca, fa, ha, da, pa, En, oa, ma, ga, Ea, Ta, Fn, Ca, Ss, ya]), r = [la, xi, vr, bi, Lr, ar, ju, gn, Vu, bs, Ci, Cs, xs, Aa, Ku, Wu], i = [aa, la, ua, ca, fa, ha, vr, da, pa, En, oa, Ci, ma, ga, Ea, Ta, Aa, Fn, Ca, Ss, ya], s = Qe(), o = U(s, Ss);
  W(o, i, o), W(o, e.domain, o);
  const a = Qe(), l = Qe(), u = Qe();
  W(s, e.domain, a), W(s, e.scheme, l), W(s, e.slashscheme, u), W(a, i, o), W(a, e.domain, a);
  const c = U(a, ir);
  U(o, ir, c), U(l, ir, c), U(u, ir, c);
  const f = U(o, gn);
  W(f, i, o), W(f, e.domain, o);
  const h = Qe();
  W(c, e.domain, h), W(h, e.domain, h);
  const d = U(h, gn);
  W(d, e.domain, h);
  const m = Qe(oh);
  W(d, e.tld, m), W(d, e.utld, m), U(c, Hs, m);
  const g = U(h, En);
  W(g, e.domain, h), W(m, e.domain, h), U(m, gn, d), U(m, En, g);
  const E = U(m, ar);
  W(E, e.numeric, oh);
  const T = U(a, En), k = U(a, gn);
  W(T, e.domain, a), W(k, i, o), W(k, e.domain, a);
  const _ = Qe(_r);
  W(k, e.tld, _), W(k, e.utld, _), W(_, e.domain, a), W(_, i, o), U(_, gn, k), U(_, En, T), U(_, ir, c);
  const R = U(_, ar), M = Qe(_r);
  W(R, e.numeric, M);
  const N = Qe(_r), S = Qe();
  W(N, n, N), W(N, r, S), W(S, n, N), W(S, r, S), U(_, Fn, N), U(M, Fn, N);
  const O = U(l, ar), $ = U(u, ar), J = U($, Fn);
  U(J, Fn, O), W(l, e.domain, a), U(l, gn, k), U(l, En, T), W(u, e.domain, a), U(u, gn, k), U(u, En, T), W(O, e.domain, N), U(O, Fn, N);
  const v = U(N, Ci), P = U(N, Cs), ee = U(N, bs), Y = U(N, xs);
  U(S, Ci, v), U(S, Cs, P), U(S, bs, ee), U(S, xs, Y), U(v, vr, N), U(P, bi, N), U(ee, xi, N), U(Y, Lr, N), U(v, vr, N);
  const w = Qe(_r), ke = Qe(_r), Ee = Qe(_r), me = Qe(_r);
  W(v, n, w), W(P, n, ke), W(ee, n, Ee), W(Y, n, me);
  const Te = Qe(), Ae = Qe(), C = Qe(), b = Qe();
  return W(v, r), W(P, r), W(ee, r), W(Y, r), W(w, n, w), W(ke, n, ke), W(Ee, n, Ee), W(me, n, me), W(w, r, w), W(ke, r, ke), W(Ee, r, Ee), W(me, r, me), W(Te, n, Te), W(Ae, n, ke), W(C, n, Ee), W(b, n, me), W(Te, r, Te), W(Ae, r, Ae), W(C, r, C), W(b, r, b), U(ke, bi, N), U(Ee, xi, N), U(me, Lr, N), U(w, vr, N), U(Ae, bi, N), U(C, xi, N), U(b, Lr, N), U(Te, Lr, N), U(s, Hs, _), U(s, Gu, UA), {
    start: s,
    tokens: jm
  };
}
function zA(t, e, n) {
  let r = n.length, i = 0, s = [], o = [];
  for (; i < r; ) {
    let a = t, l = null, u = null, c = 0, f = null, h = -1;
    for (; i < r && !(l = a.go(n[i].t)); )
      o.push(n[i++]);
    for (; i < r && (u = l || a.go(n[i].t)); )
      l = null, a = u, a.accepts() ? (h = 0, f = a) : h >= 0 && h++, i++, c++;
    if (h < 0)
      i -= c, i < r && (o.push(n[i]), i++);
    else {
      o.length > 0 && (s.push(jl(ah, e, o)), o = []), i -= h, c -= h;
      const d = f.t, m = n.slice(i - c, i);
      s.push(jl(d, e, m));
    }
  }
  return o.length > 0 && s.push(jl(ah, e, o)), s;
}
function jl(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, s = e.slice(r, i);
  return new t(s, n);
}
const $A = typeof console < "u" && console && console.warn || (() => {
}), GA = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Re = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function jA() {
  Ct.groups = {}, Re.scanner = null, Re.parser = null, Re.tokenQueue = [], Re.pluginQueue = [], Re.customSchemes = [], Re.initialized = !1;
}
function lh(t, e) {
  if (e === void 0 && (e = !1), Re.initialized && $A(`linkifyjs: already initialized - will not register custom scheme "${t}" ${GA}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
 1. Must only contain digits, lowercase ASCII letters or "-"
 2. Cannot start or end with "-"
 3. "-" cannot repeat`);
  Re.customSchemes.push([t, e]);
}
function VA() {
  Re.scanner = BA(Re.customSchemes);
  for (let t = 0; t < Re.tokenQueue.length; t++)
    Re.tokenQueue[t][1]({
      scanner: Re.scanner
    });
  Re.parser = qA(Re.scanner.tokens);
  for (let t = 0; t < Re.pluginQueue.length; t++)
    Re.pluginQueue[t][1]({
      scanner: Re.scanner,
      parser: Re.parser
    });
  Re.initialized = !0;
}
function Km(t) {
  return Re.initialized || VA(), zA(Re.parser.start, t, FA(Re.scanner.start, t));
}
function Qu(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new Yu(n), i = Km(t), s = [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    a.isLink && (!e || a.t === e) && s.push(a.toFormattedObject(r));
  }
  return s;
}
function uh(t, e) {
  e === void 0 && (e = null);
  const n = Km(t);
  return n.length === 1 && n[0].isLink && (!e || n[0].t === e);
}
function KA(t) {
  return new Ye({
    key: new st("autolink"),
    appendTransaction: (e, n, r) => {
      const i = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), s = e.some(
        (c) => c.getMeta("preventAutolink")
      );
      if (!i || s)
        return;
      const { tr: o } = r, a = YT(n.doc, [...e]), { mapping: l } = a;
      if (s8(a).forEach(({ oldRange: c, newRange: f }) => {
        ia(c.from, c.to, n.doc).filter((g) => g.mark.type === t.type).forEach((g) => {
          const E = l.map(g.from), T = l.map(g.to), k = ia(
            E,
            T,
            r.doc
          ).filter((O) => O.mark.type === t.type);
          if (!k.length)
            return;
          const _ = k[0], R = n.doc.textBetween(
            g.from,
            g.to,
            void 0,
            " "
          ), M = r.doc.textBetween(
            _.from,
            _.to,
            void 0,
            " "
          ), N = uh(R), S = uh(M);
          N && !S && o.removeMark(_.from, _.to, t.type);
        });
        const h = JT(
          r.doc,
          f,
          (g) => g.isTextblock
        );
        let d, m;
        if (h.length > 1 ? (d = h[0], m = r.doc.textBetween(
          d.pos,
          d.pos + d.node.nodeSize,
          void 0,
          " "
        )) : h.length && // We want to make sure to include the block seperator argument to treat hard breaks like spaces
        r.doc.textBetween(f.from, f.to, " ", " ").endsWith(" ") && (d = h[0], m = r.doc.textBetween(
          d.pos,
          f.to,
          void 0,
          " "
        )), d && m) {
          const g = m.split(" ").filter((k) => k !== "");
          if (g.length <= 0)
            return !1;
          const E = g[g.length - 1], T = d.pos + m.lastIndexOf(E);
          if (!E)
            return !1;
          Qu(E).filter((k) => k.isLink).filter((k) => t.validate ? t.validate(k.value) : !0).map((k) => ({
            ...k,
            from: T + k.start + 1,
            to: T + k.end + 1
          })).forEach((k) => {
            o.addMark(
              k.from,
              k.to,
              t.type.create({
                href: k.href
              })
            );
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function WA(t) {
  return new Ye({
    key: new st("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var l;
        if (r.button !== 1)
          return !1;
        const i = Em(e.state, t.type.name), s = (l = r.target) == null ? void 0 : l.closest("a"), o = (s == null ? void 0 : s.href) ?? i.href, a = (s == null ? void 0 : s.target) ?? i.target;
        return s && o ? (window.open(o, a), !0) : !1;
      }
    }
  });
}
function YA(t) {
  return new Ye({
    key: new st("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e, { selection: s } = i, { empty: o } = s;
        if (o)
          return !1;
        let a = "";
        r.content.forEach((u) => {
          a += u.textContent;
        });
        const l = Qu(a).find(
          (u) => u.isLink && u.value === a
        );
        return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const Wm = Vt.create({
  name: "link",
  keepOnSplit: !1,
  onCreate() {
    this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        lh(t);
        return;
      }
      lh(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    jA();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([href *= "javascript:" i]):not([class="mention"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      Ue(this.options.HTMLAttributes, t),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Qr({
        find: (t) => Qu(t).filter((e) => this.options.validate ? this.options.validate(e.value) : !0).filter((e) => e.isLink).map((e) => ({
          text: e.value,
          index: e.start,
          data: e
        })),
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [];
    return this.options.autolink && t.push(
      KA({
        type: this.type,
        validate: this.options.validate
      })
    ), this.options.openOnClick && t.push(
      WA({
        type: this.type
      })
    ), this.options.linkOnPaste && t.push(
      YA({
        editor: this.editor,
        type: this.type
      })
    ), t;
  }
});
function QA(t) {
  var e;
  const { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: s, $position: o } = t, a = F8(n), l = new RegExp(`\\s${a}$`), u = s ? "^" : "", c = r ? new RegExp(`${u}${a}.*?(?=\\s${a}|$)`, "gm") : new RegExp(`${u}(?:^)?${a}[^\\s${a}]*`, "gm"), f = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text;
  if (!f)
    return null;
  const h = o.pos - f.length, d = Array.from(f.matchAll(c)).pop();
  if (!d || d.input === void 0 || d.index === void 0)
    return null;
  const m = d.input.slice(Math.max(0, d.index - 1), d.index), g = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(m);
  if (i !== null && !g)
    return null;
  const E = h + d.index;
  let T = E + d[0].length;
  return r && l.test(f.slice(T - 1, T + 1)) && (d[0] += " ", T += 1), E < o.pos && T >= o.pos ? {
    range: {
      from: E,
      to: T
    },
    query: d[0].slice(n.length),
    text: d[0]
  } : null;
}
const JA = new st("suggestion");
function XA({ pluginKey: t = JA, editor: e, char: n = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: o = "span", decorationClass: a = "suggestion", command: l = () => null, items: u = () => [], render: c = () => ({}), allow: f = () => !0 }) {
  let h;
  const d = c == null ? void 0 : c(), m = new Ye({
    key: t,
    view() {
      return {
        update: async (g, E) => {
          var T, k, _, R, M, N, S;
          const O = (T = this.key) === null || T === void 0 ? void 0 : T.getState(E), $ = (k = this.key) === null || k === void 0 ? void 0 : k.getState(g.state), J = O.active && $.active && O.range.from !== $.range.from, v = !O.active && $.active, P = O.active && !$.active, ee = !v && !P && O.query !== $.query, Y = v || J, w = ee && !J, ke = P || J;
          if (!Y && !w && !ke)
            return;
          const Ee = ke && !Y ? O : $, me = g.dom.querySelector(`[data-decoration-id="${Ee.decorationId}"]`);
          h = {
            editor: e,
            range: Ee.range,
            query: Ee.query,
            text: Ee.text,
            items: [],
            command: (Te) => {
              l({
                editor: e,
                range: Ee.range,
                props: Te
              });
            },
            decorationNode: me,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: me ? () => {
              var Te;
              const { decorationId: Ae } = (Te = this.key) === null || Te === void 0 ? void 0 : Te.getState(e.state), C = g.dom.querySelector(`[data-decoration-id="${Ae}"]`);
              return (C == null ? void 0 : C.getBoundingClientRect()) || null;
            } : null
          }, Y && ((_ = d == null ? void 0 : d.onBeforeStart) === null || _ === void 0 || _.call(d, h)), w && ((R = d == null ? void 0 : d.onBeforeUpdate) === null || R === void 0 || R.call(d, h)), (w || Y) && (h.items = await u({
            editor: e,
            query: Ee.query
          })), ke && ((M = d == null ? void 0 : d.onExit) === null || M === void 0 || M.call(d, h)), w && ((N = d == null ? void 0 : d.onUpdate) === null || N === void 0 || N.call(d, h)), Y && ((S = d == null ? void 0 : d.onStart) === null || S === void 0 || S.call(d, h));
        },
        destroy: () => {
          var g;
          h && ((g = d == null ? void 0 : d.onExit) === null || g === void 0 || g.call(d, h));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(g, E, T, k) {
        const { isEditable: _ } = e, { composing: R } = e.view, { selection: M } = g, { empty: N, from: S } = M, O = { ...E };
        if (O.composing = R, _ && (N || e.view.composing)) {
          (S < E.range.from || S > E.range.to) && !R && !E.composing && (O.active = !1);
          const $ = QA({
            char: n,
            allowSpaces: r,
            allowedPrefixes: i,
            startOfLine: s,
            $position: M.$from
          }), J = `id_${Math.floor(Math.random() * 4294967295)}`;
          $ && f({ editor: e, state: k, range: $.range }) ? (O.active = !0, O.decorationId = E.decorationId ? E.decorationId : J, O.range = $.range, O.query = $.query, O.text = $.text) : O.active = !1;
        } else
          O.active = !1;
        return O.active || (O.decorationId = null, O.range = { from: 0, to: 0 }, O.query = null, O.text = null), O;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(g, E) {
        var T;
        const { active: k, range: _ } = m.getState(g.state);
        return k && ((T = d == null ? void 0 : d.onKeyDown) === null || T === void 0 ? void 0 : T.call(d, { view: g, event: E, range: _ })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(g) {
        const { active: E, range: T, decorationId: k } = m.getState(g);
        return E ? He.create(g.doc, [
          bt.inline(T.from, T.to, {
            nodeName: o,
            class: a,
            "data-decoration-id": k
          })
        ]) : null;
      }
    }
  });
  return m;
}
const ZA = new st("mention"), Ym = $e.create({
  name: "mention",
  group: "inline",
  inline: !0,
  selectable: !1,
  atom: !0,
  addOptions() {
    return {
      suggestion: {
        char: "@",
        allowedPrefixes: null,
        pluginKey: ZA,
        command: ({ editor: t, range: e, props: n }) => {
          var f, h, d;
          const { $from: r, $to: i } = t.view.state.selection, s = r.parentOffset === 1, o = i.nodeBefore, a = i.nodeAfter, l = (f = o == null ? void 0 : o.text) == null ? void 0 : f.startsWith(" "), u = (h = a == null ? void 0 : a.text) == null ? void 0 : h.startsWith(" "), c = [];
          !s && !l && c.push({
            type: "text",
            text: " "
          }), c.push({
            type: this.name,
            attrs: n
          }), u || c.push({
            type: "text",
            text: " "
          }), t.chain().focus().insertContentAt(e, c).run(), (d = window.getSelection()) == null || d.collapseToEnd();
        },
        allow: ({ state: t, range: e }) => {
          const n = t.doc.resolve(e.from), r = t.schema.nodes[this.name];
          return !!n.parent.type.contentMatch.matchType(r);
        }
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-id")
      },
      userName: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-user-name")
      },
      displayName: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-display-name")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'a[class="mention"]'
      }
    ];
  },
  renderHTML({ node: t }) {
    return [
      "a",
      {
        class: "mention",
        href: "/" + this.options.suggestion.char + t.attrs.userName,
        "data-id": t.attrs.id,
        "data-user-name": t.attrs.userName,
        "data-display-name": t.attrs.displayName,
        ref: "noopener noreferrer nofollow"
      },
      ["span", `@${t.attrs.displayName ?? t.attrs.userName}`]
    ];
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: t, state: e }) => {
        let n = !1;
        const { selection: r } = e, { empty: i, anchor: s } = r;
        return i ? (e.doc.nodesBetween(s - 1, s, (o, a) => {
          if (o.type.name === this.name)
            return n = !0, t.insertText(
              this.options.suggestion.char || "",
              a,
              a + o.nodeSize
            ), !1;
        }), n) : !1;
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      XA({
        editor: this.editor,
        ...this.options.suggestion
      })
    ];
  }
}), Qm = ({
  placeholder: t,
  mentionSuggestion: e
}) => [
  xm,
  Dm,
  nA,
  Bm.configure({
    placeholder: t
  }),
  // Basic Formats
  Hm,
  Pm,
  rA.configure({
    levels: [2, 3]
  }),
  Am,
  Fm,
  Mm,
  Im,
  Cm,
  bm,
  Tm,
  Sm,
  Rm,
  Lm,
  vm,
  ym,
  // Custom Formats
  Wm,
  OA,
  NA,
  kA,
  Ym.configure({
    suggestion: e
  })
], Zw = ({
  content: t,
  placeholder: e,
  mentionSuggestion: n,
  ...r
}) => {
  const i = qm({
    extensions: Qm({ placeholder: e, mentionSuggestion: n }),
    content: t,
    ...r
  });
  return /* @__PURE__ */ Wp(Um, { editor: i });
}, Jm = ({
  placeholder: t,
  mentionSuggestion: e
}) => [
  xm,
  Dm,
  Bm.configure({
    placeholder: t
  }),
  // Basic Formats
  Hm,
  Pm,
  Am,
  Fm,
  Mm,
  Im,
  Cm,
  bm,
  Tm,
  Sm,
  Rm,
  vm,
  Lm,
  ym,
  // Custom Formats
  Wm,
  Ym.configure({
    suggestion: e
  })
], eD = ({
  content: t,
  placeholder: e,
  mentionSuggestion: n,
  ...r
}) => {
  const i = qm({
    extensions: Jm({ placeholder: e, mentionSuggestion: n }),
    content: t,
    ...r
  });
  return /* @__PURE__ */ Wp(Um, { editor: i });
};
function ch(t) {
  if (t)
    throw t;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Xm = function(e) {
  return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}, vo = Object.prototype.hasOwnProperty, Zm = Object.prototype.toString, fh = Object.defineProperty, hh = Object.getOwnPropertyDescriptor, dh = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : Zm.call(e) === "[object Array]";
}, ph = function(e) {
  if (!e || Zm.call(e) !== "[object Object]")
    return !1;
  var n = vo.call(e, "constructor"), r = e.constructor && e.constructor.prototype && vo.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !r)
    return !1;
  var i;
  for (i in e)
    ;
  return typeof i > "u" || vo.call(e, i);
}, mh = function(e, n) {
  fh && n.name === "__proto__" ? fh(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, gh = function(e, n) {
  if (n === "__proto__")
    if (vo.call(e, n)) {
      if (hh)
        return hh(e, n).value;
    } else
      return;
  return e[n];
}, ba = function t() {
  var e, n, r, i, s, o, a = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof a == "boolean" && (c = a, a = arguments[1] || {}, l = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < u; ++l)
    if (e = arguments[l], e != null)
      for (n in e)
        r = gh(a, n), i = gh(e, n), a !== i && (c && i && (ph(i) || (s = dh(i))) ? (s ? (s = !1, o = r && dh(r) ? r : []) : o = r && ph(r) ? r : {}, mh(a, { name: n, newValue: t(c, o, i) })) : typeof i < "u" && mh(a, { name: n, newValue: i }));
  return a;
};
function fu(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function e3() {
  const t = [], e = { run: n, use: r };
  return e;
  function n(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(l, ...u) {
      const c = t[++s];
      let f = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++f < i.length; )
        (u[f] === null || u[f] === void 0) && (u[f] = i[f]);
      i = u, c ? t3(c, a)(...u) : o(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return t.push(i), e;
  }
}
function t3(t, e) {
  let n;
  return r;
  function r(...o) {
    const a = t.length > o.length;
    let l;
    a && o.push(i);
    try {
      l = t.apply(this, o);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (a && n)
        throw c;
      return i(c);
    }
    a || (l instanceof Promise ? l.then(s, i) : l instanceof Error ? i(l) : s(l));
  }
  function i(o, ...a) {
    n || (n = !0, e(o, ...a));
  }
  function s(o) {
    i(null, o);
  }
}
function Ns(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? Eh(t.position) : "start" in t || "end" in t ? Eh(t) : "line" in t || "column" in t ? hu(t) : "";
}
function hu(t) {
  return Th(t && t.line) + ":" + Th(t && t.column);
}
function Eh(t) {
  return hu(t && t.start) + "-" + hu(t && t.end);
}
function Th(t) {
  return t && typeof t == "number" ? t : 1;
}
class Wt extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(e, n, r) {
    const i = [null, null];
    let s = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof n == "string" && (r = n, n = void 0), typeof r == "string") {
      const o = r.indexOf(":");
      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));
    }
    n && ("type" in n || "position" in n ? n.position && (s = n.position) : "start" in n || "end" in n ? s = n : ("line" in n || "column" in n) && (s.start = n)), this.name = Ns(n) || "1:1", this.message = typeof e == "object" ? e.message : e, this.stack = "", typeof e == "object" && e.stack && (this.stack = e.stack), this.reason = this.message, this.fatal, this.line = s.start.line, this.column = s.start.column, this.position = s, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
Wt.prototype.file = "";
Wt.prototype.name = "";
Wt.prototype.reason = "";
Wt.prototype.message = "";
Wt.prototype.stack = "";
Wt.prototype.fatal = null;
Wt.prototype.column = null;
Wt.prototype.line = null;
Wt.prototype.source = null;
Wt.prototype.ruleId = null;
Wt.prototype.position = null;
const Tn = { basename: n3, dirname: r3, extname: i3, join: s3, sep: "/" };
function n3(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  Vs(t);
  let n = 0, r = -1, i = t.length, s;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; i--; )
      if (t.charCodeAt(i) === 47) {
        if (s) {
          n = i + 1;
          break;
        }
      } else
        r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let o = -1, a = e.length - 1;
  for (; i--; )
    if (t.charCodeAt(i) === 47) {
      if (s) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), a > -1 && (t.charCodeAt(i) === e.charCodeAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return n === r ? r = o : r < 0 && (r = t.length), t.slice(n, r);
}
function r3(t) {
  if (Vs(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.charCodeAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else
      r || (r = !0);
  return e < 0 ? t.charCodeAt(0) === 47 ? "/" : "." : e === 1 && t.charCodeAt(0) === 47 ? "//" : t.slice(0, e);
}
function i3(t) {
  Vs(t);
  let e = t.length, n = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const a = t.charCodeAt(e);
    if (a === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = e + 1), a === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === n - 1 && i === r + 1 ? "" : t.slice(i, n);
}
function s3(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    Vs(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : o3(n);
}
function o3(t) {
  Vs(t);
  const e = t.charCodeAt(0) === 47;
  let n = a3(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.charCodeAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function a3(t, e) {
  let n = "", r = 0, i = -1, s = 0, o = -1, a, l;
  for (; ++o <= t.length; ) {
    if (o < t.length)
      a = t.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || s === 1))
        if (i !== o - 1 && s === 2) {
          if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (l = n.lastIndexOf("/"), l !== n.length - 1) {
                l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = o, s = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, i = o, s = 0;
              continue;
            }
          }
          e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + t.slice(i + 1, o) : n = t.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else
      a === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Vs(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const l3 = { cwd: u3 };
function u3() {
  return "/";
}
function du(t) {
  return t !== null && typeof t == "object" && // @ts-expect-error: indexable.
  t.href && // @ts-expect-error: indexable.
  t.origin;
}
function c3(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!du(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return f3(t);
}
function f3(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.charCodeAt(n) === 37 && e.charCodeAt(n + 1) === 50) {
      const r = e.charCodeAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const Vl = ["history", "path", "basename", "stem", "extname", "dirname"];
class h3 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? typeof e == "string" || d3(e) ? n = { value: e } : du(e) ? n = { path: e } : n = e : n = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = l3.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < Vl.length; ) {
      const s = Vl[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let i;
    for (i in n)
      Vl.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(e) {
    du(e) && (e = c3(e)), Wl(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Tn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(e) {
    Ah(this.basename, "dirname"), this.path = Tn.join(e || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Tn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(e) {
    Wl(e, "basename"), Kl(e, "basename"), this.path = Tn.join(this.dirname || "", e);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Tn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(e) {
    if (Kl(e, "extname"), Ah(this.dirname, "extname"), e) {
      if (e.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Tn.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Tn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(e) {
    Wl(e, "stem"), Kl(e, "stem"), this.path = Tn.join(this.dirname || "", e + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return (this.value || "").toString(e || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const i = new Wt(e, n, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const i = this.message(e, n, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const i = this.message(e, n, r);
    throw i.fatal = !0, i;
  }
}
function Kl(t, e) {
  if (t && t.includes(Tn.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + Tn.sep + "`"
    );
}
function Wl(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function Ah(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function d3(t) {
  return Xm(t);
}
const Ju = t9().freeze(), e9 = {}.hasOwnProperty;
function t9() {
  const t = e3(), e = [];
  let n = {}, r, i = -1;
  return s.data = o, s.Parser = void 0, s.Compiler = void 0, s.freeze = a, s.attachers = e, s.use = l, s.parse = u, s.stringify = c, s.run = f, s.runSync = h, s.process = d, s.processSync = m, s;
  function s() {
    const g = t9();
    let E = -1;
    for (; ++E < e.length; )
      g.use(...e[E]);
    return g.data(ba(!0, {}, n)), g;
  }
  function o(g, E) {
    return typeof g == "string" ? arguments.length === 2 ? (Jl("data", r), n[g] = E, s) : e9.call(n, g) && n[g] || null : g ? (Jl("data", r), n = g, s) : n;
  }
  function a() {
    if (r)
      return s;
    for (; ++i < e.length; ) {
      const [g, ...E] = e[i];
      if (E[0] === !1)
        continue;
      E[0] === !0 && (E[0] = void 0);
      const T = g.call(s, ...E);
      typeof T == "function" && t.use(T);
    }
    return r = !0, i = Number.POSITIVE_INFINITY, s;
  }
  function l(g, ...E) {
    let T;
    if (Jl("use", r), g != null)
      if (typeof g == "function")
        M(g, ...E);
      else if (typeof g == "object")
        Array.isArray(g) ? R(g) : _(g);
      else
        throw new TypeError("Expected usable value, not `" + g + "`");
    return T && (n.settings = Object.assign(n.settings || {}, T)), s;
    function k(N) {
      if (typeof N == "function")
        M(N);
      else if (typeof N == "object")
        if (Array.isArray(N)) {
          const [S, ...O] = N;
          M(S, ...O);
        } else
          _(N);
      else
        throw new TypeError("Expected usable value, not `" + N + "`");
    }
    function _(N) {
      R(N.plugins), N.settings && (T = Object.assign(T || {}, N.settings));
    }
    function R(N) {
      let S = -1;
      if (N != null)
        if (Array.isArray(N))
          for (; ++S < N.length; ) {
            const O = N[S];
            k(O);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + N + "`");
    }
    function M(N, S) {
      let O = -1, $;
      for (; ++O < e.length; )
        if (e[O][0] === N) {
          $ = e[O];
          break;
        }
      $ ? (fu($[1]) && fu(S) && (S = ba(!0, $[1], S)), $[1] = S) : e.push([...arguments]);
    }
  }
  function u(g) {
    s.freeze();
    const E = ns(g), T = s.Parser;
    return Yl("parse", T), yh(T, "parse") ? new T(String(E), E).parse() : T(String(E), E);
  }
  function c(g, E) {
    s.freeze();
    const T = ns(E), k = s.Compiler;
    return Ql("stringify", k), Ch(g), yh(k, "compile") ? new k(g, T).compile() : k(g, T);
  }
  function f(g, E, T) {
    if (Ch(g), s.freeze(), !T && typeof E == "function" && (T = E, E = void 0), !T)
      return new Promise(k);
    k(null, T);
    function k(_, R) {
      t.run(g, ns(E), M);
      function M(N, S, O) {
        S = S || g, N ? R(N) : _ ? _(S) : T(null, S, O);
      }
    }
  }
  function h(g, E) {
    let T, k;
    return s.run(g, E, _), bh("runSync", "run", k), T;
    function _(R, M) {
      ch(R), T = M, k = !0;
    }
  }
  function d(g, E) {
    if (s.freeze(), Yl("process", s.Parser), Ql("process", s.Compiler), !E)
      return new Promise(T);
    T(null, E);
    function T(k, _) {
      const R = ns(g);
      s.run(s.parse(R), R, (N, S, O) => {
        if (N || !S || !O)
          M(N);
        else {
          const $ = s.stringify(S, O);
          $ == null || (g3($) ? O.value = $ : O.result = $), M(N, O);
        }
      });
      function M(N, S) {
        N || !S ? _(N) : k ? k(S) : E(null, S);
      }
    }
  }
  function m(g) {
    let E;
    s.freeze(), Yl("processSync", s.Parser), Ql("processSync", s.Compiler);
    const T = ns(g);
    return s.process(T, k), bh("processSync", "process", E), T;
    function k(_) {
      E = !0, ch(_);
    }
  }
}
function yh(t, e) {
  return typeof t == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  t.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (p3(t.prototype) || e in t.prototype);
}
function p3(t) {
  let e;
  for (e in t)
    if (e9.call(t, e))
      return !0;
  return !1;
}
function Yl(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `Parser`");
}
function Ql(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `Compiler`");
}
function Jl(t, e) {
  if (e)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Ch(t) {
  if (!fu(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function bh(t, e, n) {
  if (!n)
    throw new Error(
      "`" + t + "` finished async. Use `" + e + "` instead"
    );
}
function ns(t) {
  return m3(t) ? t : new h3(t);
}
function m3(t) {
  return Boolean(
    t && typeof t == "object" && "message" in t && "messages" in t
  );
}
function g3(t) {
  return typeof t == "string" || Xm(t);
}
var fn = {};
const E3 = [
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
];
fn.REPLACEMENT_CHARACTER = "�";
fn.CODE_POINTS = {
  EOF: -1,
  NULL: 0,
  TABULATION: 9,
  CARRIAGE_RETURN: 13,
  LINE_FEED: 10,
  FORM_FEED: 12,
  SPACE: 32,
  EXCLAMATION_MARK: 33,
  QUOTATION_MARK: 34,
  NUMBER_SIGN: 35,
  AMPERSAND: 38,
  APOSTROPHE: 39,
  HYPHEN_MINUS: 45,
  SOLIDUS: 47,
  DIGIT_0: 48,
  DIGIT_9: 57,
  SEMICOLON: 59,
  LESS_THAN_SIGN: 60,
  EQUALS_SIGN: 61,
  GREATER_THAN_SIGN: 62,
  QUESTION_MARK: 63,
  LATIN_CAPITAL_A: 65,
  LATIN_CAPITAL_F: 70,
  LATIN_CAPITAL_X: 88,
  LATIN_CAPITAL_Z: 90,
  RIGHT_SQUARE_BRACKET: 93,
  GRAVE_ACCENT: 96,
  LATIN_SMALL_A: 97,
  LATIN_SMALL_F: 102,
  LATIN_SMALL_X: 120,
  LATIN_SMALL_Z: 122,
  REPLACEMENT_CHARACTER: 65533
};
fn.CODE_POINT_SEQUENCES = {
  DASH_DASH_STRING: [45, 45],
  //--
  DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
  //DOCTYPE
  CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
  //[CDATA[
  SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
  //script
  PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
  //PUBLIC
  SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
  //SYSTEM
};
fn.isSurrogate = function(t) {
  return t >= 55296 && t <= 57343;
};
fn.isSurrogatePair = function(t) {
  return t >= 56320 && t <= 57343;
};
fn.getSurrogatePairCodePoint = function(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
};
fn.isControlCodePoint = function(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
};
fn.isUndefinedCodePoint = function(t) {
  return t >= 64976 && t <= 65007 || E3.indexOf(t) > -1;
};
var Xu = {
  controlCharacterInInputStream: "control-character-in-input-stream",
  noncharacterInInputStream: "noncharacter-in-input-stream",
  surrogateInInputStream: "surrogate-in-input-stream",
  nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
  endTagWithAttributes: "end-tag-with-attributes",
  endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
  unexpectedSolidusInTag: "unexpected-solidus-in-tag",
  unexpectedNullCharacter: "unexpected-null-character",
  unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
  invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
  unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
  missingEndTagName: "missing-end-tag-name",
  unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
  unknownNamedCharacterReference: "unknown-named-character-reference",
  missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
  unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
  unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
  eofBeforeTagName: "eof-before-tag-name",
  eofInTag: "eof-in-tag",
  missingAttributeValue: "missing-attribute-value",
  missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
  missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
  missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
  missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
  missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
  missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
  missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
  abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
  abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
  cdataInHtmlContent: "cdata-in-html-content",
  incorrectlyOpenedComment: "incorrectly-opened-comment",
  eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
  eofInDoctype: "eof-in-doctype",
  nestedComment: "nested-comment",
  abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
  eofInComment: "eof-in-comment",
  incorrectlyClosedComment: "incorrectly-closed-comment",
  eofInCdata: "eof-in-cdata",
  absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
  nullCharacterReference: "null-character-reference",
  surrogateCharacterReference: "surrogate-character-reference",
  characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
  controlCharacterReference: "control-character-reference",
  noncharacterCharacterReference: "noncharacter-character-reference",
  missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
  missingDoctypeName: "missing-doctype-name",
  invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
  duplicateAttribute: "duplicate-attribute",
  nonConformingDoctype: "non-conforming-doctype",
  missingDoctype: "missing-doctype",
  misplacedDoctype: "misplaced-doctype",
  endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
  closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
  disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
  openElementsLeftAfterEof: "open-elements-left-after-eof",
  abandonedHeadElementChild: "abandoned-head-element-child",
  misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
  nestedNoscriptInHead: "nested-noscript-in-head",
  eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
};
const gi = fn, Xl = Xu, kr = gi.CODE_POINTS, T3 = 1 << 16;
let A3 = class {
  constructor() {
    this.html = null, this.pos = -1, this.lastGapPos = -1, this.lastCharPos = -1, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = T3;
  }
  _err() {
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.lastCharPos) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (gi.isSurrogatePair(n))
        return this.pos++, this._addGap(), gi.getSurrogatePairCodePoint(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, kr.EOF;
    return this._err(Xl.surrogateInInputStream), e;
  }
  dropParsedChunk() {
    this.pos > this.bufferWaterline && (this.lastCharPos -= this.pos, this.html = this.html.substring(this.pos), this.pos = 0, this.lastGapPos = -1, this.gapStack = []);
  }
  write(e, n) {
    this.html ? this.html += e : this.html = e, this.lastCharPos = this.html.length - 1, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1, this.html.length), this.lastCharPos = this.html.length - 1, this.endOfChunkHit = !1;
  }
  advance() {
    if (this.pos++, this.pos > this.lastCharPos)
      return this.endOfChunkHit = !this.lastChunkWritten, kr.EOF;
    let e = this.html.charCodeAt(this.pos);
    return this.skipNextNewLine && e === kr.LINE_FEED ? (this.skipNextNewLine = !1, this._addGap(), this.advance()) : e === kr.CARRIAGE_RETURN ? (this.skipNextNewLine = !0, kr.LINE_FEED) : (this.skipNextNewLine = !1, gi.isSurrogate(e) && (e = this._processSurrogate(e)), e > 31 && e < 127 || e === kr.LINE_FEED || e === kr.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    gi.isControlCodePoint(e) ? this._err(Xl.controlCharacterInInputStream) : gi.isUndefinedCodePoint(e) && this._err(Xl.noncharacterInInputStream);
  }
  retreat() {
    this.pos === this.lastGapPos && (this.lastGapPos = this.gapStack.pop(), this.pos--), this.pos--;
  }
};
var y3 = A3, C3 = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
const b3 = y3, Ce = fn, Ur = C3, I = Xu, A = Ce.CODE_POINTS, Or = Ce.CODE_POINT_SEQUENCES, x3 = {
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, n9 = 1 << 0, r9 = 1 << 1, i9 = 1 << 2, S3 = n9 | r9 | i9, ue = "DATA_STATE", Ei = "RCDATA_STATE", gs = "RAWTEXT_STATE", Pn = "SCRIPT_DATA_STATE", s9 = "PLAINTEXT_STATE", xh = "TAG_OPEN_STATE", Sh = "END_TAG_OPEN_STATE", Zl = "TAG_NAME_STATE", Nh = "RCDATA_LESS_THAN_SIGN_STATE", _h = "RCDATA_END_TAG_OPEN_STATE", kh = "RCDATA_END_TAG_NAME_STATE", Oh = "RAWTEXT_LESS_THAN_SIGN_STATE", wh = "RAWTEXT_END_TAG_OPEN_STATE", Dh = "RAWTEXT_END_TAG_NAME_STATE", Ih = "SCRIPT_DATA_LESS_THAN_SIGN_STATE", Mh = "SCRIPT_DATA_END_TAG_OPEN_STATE", Rh = "SCRIPT_DATA_END_TAG_NAME_STATE", vh = "SCRIPT_DATA_ESCAPE_START_STATE", Lh = "SCRIPT_DATA_ESCAPE_START_DASH_STATE", Zt = "SCRIPT_DATA_ESCAPED_STATE", Ph = "SCRIPT_DATA_ESCAPED_DASH_STATE", e1 = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE", lo = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE", Bh = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE", Fh = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE", Hh = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE", Dn = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE", Uh = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE", qh = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE", uo = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE", zh = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE", pn = "BEFORE_ATTRIBUTE_NAME_STATE", co = "ATTRIBUTE_NAME_STATE", t1 = "AFTER_ATTRIBUTE_NAME_STATE", n1 = "BEFORE_ATTRIBUTE_VALUE_STATE", fo = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE", ho = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE", po = "ATTRIBUTE_VALUE_UNQUOTED_STATE", r1 = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE", Yn = "SELF_CLOSING_START_TAG_STATE", rs = "BOGUS_COMMENT_STATE", $h = "MARKUP_DECLARATION_OPEN_STATE", Gh = "COMMENT_START_STATE", jh = "COMMENT_START_DASH_STATE", Qn = "COMMENT_STATE", Vh = "COMMENT_LESS_THAN_SIGN_STATE", Kh = "COMMENT_LESS_THAN_SIGN_BANG_STATE", Wh = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE", Yh = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE", mo = "COMMENT_END_DASH_STATE", go = "COMMENT_END_STATE", Qh = "COMMENT_END_BANG_STATE", Jh = "DOCTYPE_STATE", Eo = "BEFORE_DOCTYPE_NAME_STATE", To = "DOCTYPE_NAME_STATE", Xh = "AFTER_DOCTYPE_NAME_STATE", Zh = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE", ed = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE", i1 = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE", s1 = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE", o1 = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE", td = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE", nd = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE", rd = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE", is = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE", ss = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE", a1 = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE", In = "BOGUS_DOCTYPE_STATE", Ao = "CDATA_SECTION_STATE", id = "CDATA_SECTION_BRACKET_STATE", sd = "CDATA_SECTION_END_STATE", li = "CHARACTER_REFERENCE_STATE", od = "NAMED_CHARACTER_REFERENCE_STATE", ad = "AMBIGUOS_AMPERSAND_STATE", ld = "NUMERIC_CHARACTER_REFERENCE_STATE", ud = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE", cd = "DECIMAL_CHARACTER_REFERENCE_START_STATE", fd = "HEXADEMICAL_CHARACTER_REFERENCE_STATE", hd = "DECIMAL_CHARACTER_REFERENCE_STATE", as = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
function we(t) {
  return t === A.SPACE || t === A.LINE_FEED || t === A.TABULATION || t === A.FORM_FEED;
}
function _s(t) {
  return t >= A.DIGIT_0 && t <= A.DIGIT_9;
}
function tn(t) {
  return t >= A.LATIN_CAPITAL_A && t <= A.LATIN_CAPITAL_Z;
}
function Ir(t) {
  return t >= A.LATIN_SMALL_A && t <= A.LATIN_SMALL_Z;
}
function tr(t) {
  return Ir(t) || tn(t);
}
function l1(t) {
  return tr(t) || _s(t);
}
function o9(t) {
  return t >= A.LATIN_CAPITAL_A && t <= A.LATIN_CAPITAL_F;
}
function a9(t) {
  return t >= A.LATIN_SMALL_A && t <= A.LATIN_SMALL_F;
}
function N3(t) {
  return _s(t) || o9(t) || a9(t);
}
function Lo(t) {
  return t + 32;
}
function Le(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(t >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | t & 1023));
}
function Jn(t) {
  return String.fromCharCode(Lo(t));
}
function dd(t, e) {
  const n = Ur[++t];
  let r = ++t, i = r + n - 1;
  for (; r <= i; ) {
    const s = r + i >>> 1, o = Ur[s];
    if (o < e)
      r = s + 1;
    else if (o > e)
      i = s - 1;
    else
      return Ur[s + n];
  }
  return -1;
}
let Yt = class Tt {
  constructor() {
    this.preprocessor = new b3(), this.tokenQueue = [], this.allowCDATA = !1, this.state = ue, this.returnState = "", this.charRefCode = -1, this.tempBuff = [], this.lastStartTagName = "", this.consumedAfterSnapshot = -1, this.active = !1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = null;
  }
  //Errors
  _err() {
  }
  _errOnNextCodePoint(e) {
    this._consume(), this._err(e), this._unconsume();
  }
  //API
  getNextToken() {
    for (; !this.tokenQueue.length && this.active; ) {
      this.consumedAfterSnapshot = 0;
      const e = this._consume();
      this._ensureHibernation() || this[this.state](e);
    }
    return this.tokenQueue.shift();
  }
  write(e, n) {
    this.active = !0, this.preprocessor.write(e, n);
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e);
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--)
        this.preprocessor.retreat();
      return this.active = !1, this.tokenQueue.push({ type: Tt.HIBERNATION_TOKEN }), !0;
    }
    return !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume() {
    this.consumedAfterSnapshot--, this.preprocessor.retreat();
  }
  _reconsumeInState(e) {
    this.state = e, this._unconsume();
  }
  _consumeSequenceIfMatch(e, n, r) {
    let i = 0, s = !0;
    const o = e.length;
    let a = 0, l = n, u;
    for (; a < o; a++) {
      if (a > 0 && (l = this._consume(), i++), l === A.EOF) {
        s = !1;
        break;
      }
      if (u = e[a], l !== u && (r || l !== Lo(u))) {
        s = !1;
        break;
      }
    }
    if (!s)
      for (; i--; )
        this._unconsume();
    return s;
  }
  //Temp buffer
  _isTempBufferEqualToScriptString() {
    if (this.tempBuff.length !== Or.SCRIPT_STRING.length)
      return !1;
    for (let e = 0; e < this.tempBuff.length; e++)
      if (this.tempBuff[e] !== Or.SCRIPT_STRING[e])
        return !1;
    return !0;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Tt.START_TAG_TOKEN,
      tagName: "",
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: []
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Tt.END_TAG_TOKEN,
      tagName: "",
      selfClosing: !1,
      attrs: []
    };
  }
  _createCommentToken() {
    this.currentToken = {
      type: Tt.COMMENT_TOKEN,
      data: ""
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: Tt.DOCTYPE_TOKEN,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n
    };
  }
  _createEOFToken() {
    this.currentToken = { type: Tt.EOF_TOKEN };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    };
  }
  _leaveAttrName(e) {
    Tt.getTokenAttr(this.currentToken, this.currentAttr.name) === null ? this.currentToken.attrs.push(this.currentAttr) : this._err(I.duplicateAttribute), this.state = e;
  }
  _leaveAttrValue(e) {
    this.state = e;
  }
  //Token emission
  _emitCurrentToken() {
    this._emitCurrentCharacterToken();
    const e = this.currentToken;
    this.currentToken = null, e.type === Tt.START_TAG_TOKEN ? this.lastStartTagName = e.tagName : e.type === Tt.END_TAG_TOKEN && (e.attrs.length > 0 && this._err(I.endTagWithAttributes), e.selfClosing && this._err(I.endTagWithTrailingSolidus)), this.tokenQueue.push(e);
  }
  _emitCurrentCharacterToken() {
    this.currentCharacterToken && (this.tokenQueue.push(this.currentCharacterToken), this.currentCharacterToken = null);
  }
  _emitEOFToken() {
    this._createEOFToken(), this._emitCurrentToken();
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    this.currentCharacterToken && this.currentCharacterToken.type !== e && this._emitCurrentCharacterToken(), this.currentCharacterToken ? this.currentCharacterToken.chars += n : this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    let n = Tt.CHARACTER_TOKEN;
    we(e) ? n = Tt.WHITESPACE_CHARACTER_TOKEN : e === A.NULL && (n = Tt.NULL_CHARACTER_TOKEN), this._appendCharToCurrentCharacterToken(n, Le(e));
  }
  _emitSeveralCodePoints(e) {
    for (let n = 0; n < e.length; n++)
      this._emitCodePoint(e[n]);
  }
  //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
  //So we can avoid additional checks here.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(Tt.CHARACTER_TOKEN, e);
  }
  // Character reference helpers
  _matchNamedCharacterReference(e) {
    let n = null, r = 1, i = dd(0, e);
    for (this.tempBuff.push(e); i > -1; ) {
      const s = Ur[i], o = s < S3;
      o && s & n9 && (n = s & r9 ? [Ur[++i], Ur[++i]] : [Ur[++i]], r = 0);
      const l = this._consume();
      if (this.tempBuff.push(l), r++, l === A.EOF)
        break;
      o ? i = s & i9 ? dd(i, l) : -1 : i = l === s ? ++i : -1;
    }
    for (; r--; )
      this.tempBuff.pop(), this._unconsume();
    return n;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === fo || this.returnState === ho || this.returnState === po;
  }
  _isCharacterReferenceAttributeQuirk(e) {
    if (!e && this._isCharacterReferenceInAttribute()) {
      const n = this._consume();
      return this._unconsume(), n === A.EQUALS_SIGN || l1(n);
    }
    return !1;
  }
  _flushCodePointsConsumedAsCharacterReference() {
    if (this._isCharacterReferenceInAttribute())
      for (let e = 0; e < this.tempBuff.length; e++)
        this.currentAttr.value += Le(this.tempBuff[e]);
    else
      this._emitSeveralCodePoints(this.tempBuff);
    this.tempBuff = [];
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  [ue](e) {
    this.preprocessor.dropParsedChunk(), e === A.LESS_THAN_SIGN ? this.state = xh : e === A.AMPERSAND ? (this.returnState = ue, this.state = li) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitCodePoint(e)) : e === A.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  //  RCDATA state
  //------------------------------------------------------------------
  [Ei](e) {
    this.preprocessor.dropParsedChunk(), e === A.AMPERSAND ? (this.returnState = Ei, this.state = li) : e === A.LESS_THAN_SIGN ? this.state = Nh : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  [gs](e) {
    this.preprocessor.dropParsedChunk(), e === A.LESS_THAN_SIGN ? this.state = Oh : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // Script data state
  //------------------------------------------------------------------
  [Pn](e) {
    this.preprocessor.dropParsedChunk(), e === A.LESS_THAN_SIGN ? this.state = Ih : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  [s9](e) {
    this.preprocessor.dropParsedChunk(), e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // Tag open state
  //------------------------------------------------------------------
  [xh](e) {
    e === A.EXCLAMATION_MARK ? this.state = $h : e === A.SOLIDUS ? this.state = Sh : tr(e) ? (this._createStartTagToken(), this._reconsumeInState(Zl)) : e === A.QUESTION_MARK ? (this._err(I.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(), this._reconsumeInState(rs)) : e === A.EOF ? (this._err(I.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken()) : (this._err(I.invalidFirstCharacterOfTagName), this._emitChars("<"), this._reconsumeInState(ue));
  }
  // End tag open state
  //------------------------------------------------------------------
  [Sh](e) {
    tr(e) ? (this._createEndTagToken(), this._reconsumeInState(Zl)) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingEndTagName), this.state = ue) : e === A.EOF ? (this._err(I.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken()) : (this._err(I.invalidFirstCharacterOfTagName), this._createCommentToken(), this._reconsumeInState(rs));
  }
  // Tag name state
  //------------------------------------------------------------------
  [Zl](e) {
    we(e) ? this.state = pn : e === A.SOLIDUS ? this.state = Yn : e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : tn(e) ? this.currentToken.tagName += Jn(e) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.tagName += Ce.REPLACEMENT_CHARACTER) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : this.currentToken.tagName += Le(e);
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  [Nh](e) {
    e === A.SOLIDUS ? (this.tempBuff = [], this.state = _h) : (this._emitChars("<"), this._reconsumeInState(Ei));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  [_h](e) {
    tr(e) ? (this._createEndTagToken(), this._reconsumeInState(kh)) : (this._emitChars("</"), this._reconsumeInState(Ei));
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  [kh](e) {
    if (tn(e))
      this.currentToken.tagName += Jn(e), this.tempBuff.push(e);
    else if (Ir(e))
      this.currentToken.tagName += Le(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (we(e)) {
          this.state = pn;
          return;
        }
        if (e === A.SOLIDUS) {
          this.state = Yn;
          return;
        }
        if (e === A.GREATER_THAN_SIGN) {
          this.state = ue, this._emitCurrentToken();
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Ei);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  [Oh](e) {
    e === A.SOLIDUS ? (this.tempBuff = [], this.state = wh) : (this._emitChars("<"), this._reconsumeInState(gs));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  [wh](e) {
    tr(e) ? (this._createEndTagToken(), this._reconsumeInState(Dh)) : (this._emitChars("</"), this._reconsumeInState(gs));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  [Dh](e) {
    if (tn(e))
      this.currentToken.tagName += Jn(e), this.tempBuff.push(e);
    else if (Ir(e))
      this.currentToken.tagName += Le(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (we(e)) {
          this.state = pn;
          return;
        }
        if (e === A.SOLIDUS) {
          this.state = Yn;
          return;
        }
        if (e === A.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = ue;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(gs);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  [Ih](e) {
    e === A.SOLIDUS ? (this.tempBuff = [], this.state = Mh) : e === A.EXCLAMATION_MARK ? (this.state = vh, this._emitChars("<!")) : (this._emitChars("<"), this._reconsumeInState(Pn));
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  [Mh](e) {
    tr(e) ? (this._createEndTagToken(), this._reconsumeInState(Rh)) : (this._emitChars("</"), this._reconsumeInState(Pn));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  [Rh](e) {
    if (tn(e))
      this.currentToken.tagName += Jn(e), this.tempBuff.push(e);
    else if (Ir(e))
      this.currentToken.tagName += Le(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (we(e)) {
          this.state = pn;
          return;
        } else if (e === A.SOLIDUS) {
          this.state = Yn;
          return;
        } else if (e === A.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = ue;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Pn);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  [vh](e) {
    e === A.HYPHEN_MINUS ? (this.state = Lh, this._emitChars("-")) : this._reconsumeInState(Pn);
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  [Lh](e) {
    e === A.HYPHEN_MINUS ? (this.state = e1, this._emitChars("-")) : this._reconsumeInState(Pn);
  }
  // Script data escaped state
  //------------------------------------------------------------------
  [Zt](e) {
    e === A.HYPHEN_MINUS ? (this.state = Ph, this._emitChars("-")) : e === A.LESS_THAN_SIGN ? this.state = lo : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  [Ph](e) {
    e === A.HYPHEN_MINUS ? (this.state = e1, this._emitChars("-")) : e === A.LESS_THAN_SIGN ? this.state = lo : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.state = Zt, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Zt, this._emitCodePoint(e));
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  [e1](e) {
    e === A.HYPHEN_MINUS ? this._emitChars("-") : e === A.LESS_THAN_SIGN ? this.state = lo : e === A.GREATER_THAN_SIGN ? (this.state = Pn, this._emitChars(">")) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.state = Zt, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Zt, this._emitCodePoint(e));
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  [lo](e) {
    e === A.SOLIDUS ? (this.tempBuff = [], this.state = Bh) : tr(e) ? (this.tempBuff = [], this._emitChars("<"), this._reconsumeInState(Hh)) : (this._emitChars("<"), this._reconsumeInState(Zt));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  [Bh](e) {
    tr(e) ? (this._createEndTagToken(), this._reconsumeInState(Fh)) : (this._emitChars("</"), this._reconsumeInState(Zt));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  [Fh](e) {
    if (tn(e))
      this.currentToken.tagName += Jn(e), this.tempBuff.push(e);
    else if (Ir(e))
      this.currentToken.tagName += Le(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (we(e)) {
          this.state = pn;
          return;
        }
        if (e === A.SOLIDUS) {
          this.state = Yn;
          return;
        }
        if (e === A.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = ue;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Zt);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  [Hh](e) {
    we(e) || e === A.SOLIDUS || e === A.GREATER_THAN_SIGN ? (this.state = this._isTempBufferEqualToScriptString() ? Dn : Zt, this._emitCodePoint(e)) : tn(e) ? (this.tempBuff.push(Lo(e)), this._emitCodePoint(e)) : Ir(e) ? (this.tempBuff.push(e), this._emitCodePoint(e)) : this._reconsumeInState(Zt);
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  [Dn](e) {
    e === A.HYPHEN_MINUS ? (this.state = Uh, this._emitChars("-")) : e === A.LESS_THAN_SIGN ? (this.state = uo, this._emitChars("<")) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  [Uh](e) {
    e === A.HYPHEN_MINUS ? (this.state = qh, this._emitChars("-")) : e === A.LESS_THAN_SIGN ? (this.state = uo, this._emitChars("<")) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.state = Dn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Dn, this._emitCodePoint(e));
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  [qh](e) {
    e === A.HYPHEN_MINUS ? this._emitChars("-") : e === A.LESS_THAN_SIGN ? (this.state = uo, this._emitChars("<")) : e === A.GREATER_THAN_SIGN ? (this.state = Pn, this._emitChars(">")) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.state = Dn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === A.EOF ? (this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Dn, this._emitCodePoint(e));
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  [uo](e) {
    e === A.SOLIDUS ? (this.tempBuff = [], this.state = zh, this._emitChars("/")) : this._reconsumeInState(Dn);
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  [zh](e) {
    we(e) || e === A.SOLIDUS || e === A.GREATER_THAN_SIGN ? (this.state = this._isTempBufferEqualToScriptString() ? Zt : Dn, this._emitCodePoint(e)) : tn(e) ? (this.tempBuff.push(Lo(e)), this._emitCodePoint(e)) : Ir(e) ? (this.tempBuff.push(e), this._emitCodePoint(e)) : this._reconsumeInState(Dn);
  }
  // Before attribute name state
  //------------------------------------------------------------------
  [pn](e) {
    we(e) || (e === A.SOLIDUS || e === A.GREATER_THAN_SIGN || e === A.EOF ? this._reconsumeInState(t1) : e === A.EQUALS_SIGN ? (this._err(I.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = co) : (this._createAttr(""), this._reconsumeInState(co)));
  }
  // Attribute name state
  //------------------------------------------------------------------
  [co](e) {
    we(e) || e === A.SOLIDUS || e === A.GREATER_THAN_SIGN || e === A.EOF ? (this._leaveAttrName(t1), this._unconsume()) : e === A.EQUALS_SIGN ? this._leaveAttrName(n1) : tn(e) ? this.currentAttr.name += Jn(e) : e === A.QUOTATION_MARK || e === A.APOSTROPHE || e === A.LESS_THAN_SIGN ? (this._err(I.unexpectedCharacterInAttributeName), this.currentAttr.name += Le(e)) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentAttr.name += Ce.REPLACEMENT_CHARACTER) : this.currentAttr.name += Le(e);
  }
  // After attribute name state
  //------------------------------------------------------------------
  [t1](e) {
    we(e) || (e === A.SOLIDUS ? this.state = Yn : e === A.EQUALS_SIGN ? this.state = n1 : e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : (this._createAttr(""), this._reconsumeInState(co)));
  }
  // Before attribute value state
  //------------------------------------------------------------------
  [n1](e) {
    we(e) || (e === A.QUOTATION_MARK ? this.state = fo : e === A.APOSTROPHE ? this.state = ho : e === A.GREATER_THAN_SIGN ? (this._err(I.missingAttributeValue), this.state = ue, this._emitCurrentToken()) : this._reconsumeInState(po));
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  [fo](e) {
    e === A.QUOTATION_MARK ? this.state = r1 : e === A.AMPERSAND ? (this.returnState = fo, this.state = li) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Le(e);
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  [ho](e) {
    e === A.APOSTROPHE ? this.state = r1 : e === A.AMPERSAND ? (this.returnState = ho, this.state = li) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Le(e);
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  [po](e) {
    we(e) ? this._leaveAttrValue(pn) : e === A.AMPERSAND ? (this.returnState = po, this.state = li) : e === A.GREATER_THAN_SIGN ? (this._leaveAttrValue(ue), this._emitCurrentToken()) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === A.QUOTATION_MARK || e === A.APOSTROPHE || e === A.LESS_THAN_SIGN || e === A.EQUALS_SIGN || e === A.GRAVE_ACCENT ? (this._err(I.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += Le(e)) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Le(e);
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  [r1](e) {
    we(e) ? this._leaveAttrValue(pn) : e === A.SOLIDUS ? this._leaveAttrValue(Yn) : e === A.GREATER_THAN_SIGN ? (this._leaveAttrValue(ue), this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : (this._err(I.missingWhitespaceBetweenAttributes), this._reconsumeInState(pn));
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  [Yn](e) {
    e === A.GREATER_THAN_SIGN ? (this.currentToken.selfClosing = !0, this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInTag), this._emitEOFToken()) : (this._err(I.unexpectedSolidusInTag), this._reconsumeInState(pn));
  }
  // Bogus comment state
  //------------------------------------------------------------------
  [rs](e) {
    e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._emitCurrentToken(), this._emitEOFToken()) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.data += Ce.REPLACEMENT_CHARACTER) : this.currentToken.data += Le(e);
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  [$h](e) {
    this._consumeSequenceIfMatch(Or.DASH_DASH_STRING, e, !0) ? (this._createCommentToken(), this.state = Gh) : this._consumeSequenceIfMatch(Or.DOCTYPE_STRING, e, !1) ? this.state = Jh : this._consumeSequenceIfMatch(Or.CDATA_START_STRING, e, !0) ? this.allowCDATA ? this.state = Ao : (this._err(I.cdataInHtmlContent), this._createCommentToken(), this.currentToken.data = "[CDATA[", this.state = rs) : this._ensureHibernation() || (this._err(I.incorrectlyOpenedComment), this._createCommentToken(), this._reconsumeInState(rs));
  }
  // Comment start state
  //------------------------------------------------------------------
  [Gh](e) {
    e === A.HYPHEN_MINUS ? this.state = jh : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptClosingOfEmptyComment), this.state = ue, this._emitCurrentToken()) : this._reconsumeInState(Qn);
  }
  // Comment start dash state
  //------------------------------------------------------------------
  [jh](e) {
    e === A.HYPHEN_MINUS ? this.state = go : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptClosingOfEmptyComment), this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "-", this._reconsumeInState(Qn));
  }
  // Comment state
  //------------------------------------------------------------------
  [Qn](e) {
    e === A.HYPHEN_MINUS ? this.state = mo : e === A.LESS_THAN_SIGN ? (this.currentToken.data += "<", this.state = Vh) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.data += Ce.REPLACEMENT_CHARACTER) : e === A.EOF ? (this._err(I.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.data += Le(e);
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  [Vh](e) {
    e === A.EXCLAMATION_MARK ? (this.currentToken.data += "!", this.state = Kh) : e === A.LESS_THAN_SIGN ? this.currentToken.data += "!" : this._reconsumeInState(Qn);
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  [Kh](e) {
    e === A.HYPHEN_MINUS ? this.state = Wh : this._reconsumeInState(Qn);
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  [Wh](e) {
    e === A.HYPHEN_MINUS ? this.state = Yh : this._reconsumeInState(mo);
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  [Yh](e) {
    e !== A.GREATER_THAN_SIGN && e !== A.EOF && this._err(I.nestedComment), this._reconsumeInState(go);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  [mo](e) {
    e === A.HYPHEN_MINUS ? this.state = go : e === A.EOF ? (this._err(I.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "-", this._reconsumeInState(Qn));
  }
  // Comment end state
  //------------------------------------------------------------------
  [go](e) {
    e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : e === A.EXCLAMATION_MARK ? this.state = Qh : e === A.HYPHEN_MINUS ? this.currentToken.data += "-" : e === A.EOF ? (this._err(I.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "--", this._reconsumeInState(Qn));
  }
  // Comment end bang state
  //------------------------------------------------------------------
  [Qh](e) {
    e === A.HYPHEN_MINUS ? (this.currentToken.data += "--!", this.state = mo) : e === A.GREATER_THAN_SIGN ? (this._err(I.incorrectlyClosedComment), this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "--!", this._reconsumeInState(Qn));
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  [Jh](e) {
    we(e) ? this.state = Eo : e === A.GREATER_THAN_SIGN ? this._reconsumeInState(Eo) : e === A.EOF ? (this._err(I.eofInDoctype), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingWhitespaceBeforeDoctypeName), this._reconsumeInState(Eo));
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  [Eo](e) {
    we(e) || (tn(e) ? (this._createDoctypeToken(Jn(e)), this.state = To) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this._createDoctypeToken(Ce.REPLACEMENT_CHARACTER), this.state = To) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingDoctypeName), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._createDoctypeToken(Le(e)), this.state = To));
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  [To](e) {
    we(e) ? this.state = Xh : e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : tn(e) ? this.currentToken.name += Jn(e) : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.name += Ce.REPLACEMENT_CHARACTER) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.name += Le(e);
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  [Xh](e) {
    we(e) || (e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this._consumeSequenceIfMatch(Or.PUBLIC_STRING, e, !1) ? this.state = Zh : this._consumeSequenceIfMatch(Or.SYSTEM_STRING, e, !1) ? this.state = nd : this._ensureHibernation() || (this._err(I.invalidCharacterSequenceAfterDoctypeName), this.currentToken.forceQuirks = !0, this._reconsumeInState(In)));
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  [Zh](e) {
    we(e) ? this.state = ed : e === A.QUOTATION_MARK ? (this._err(I.missingWhitespaceAfterDoctypePublicKeyword), this.currentToken.publicId = "", this.state = i1) : e === A.APOSTROPHE ? (this._err(I.missingWhitespaceAfterDoctypePublicKeyword), this.currentToken.publicId = "", this.state = s1) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In));
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  [ed](e) {
    we(e) || (e === A.QUOTATION_MARK ? (this.currentToken.publicId = "", this.state = i1) : e === A.APOSTROPHE ? (this.currentToken.publicId = "", this.state = s1) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In)));
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  [i1](e) {
    e === A.QUOTATION_MARK ? this.state = o1 : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.publicId += Ce.REPLACEMENT_CHARACTER) : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.publicId += Le(e);
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  [s1](e) {
    e === A.APOSTROPHE ? this.state = o1 : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.publicId += Ce.REPLACEMENT_CHARACTER) : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.publicId += Le(e);
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  [o1](e) {
    we(e) ? this.state = td : e === A.GREATER_THAN_SIGN ? (this.state = ue, this._emitCurrentToken()) : e === A.QUOTATION_MARK ? (this._err(I.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), this.currentToken.systemId = "", this.state = is) : e === A.APOSTROPHE ? (this._err(I.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), this.currentToken.systemId = "", this.state = ss) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In));
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  [td](e) {
    we(e) || (e === A.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = ue) : e === A.QUOTATION_MARK ? (this.currentToken.systemId = "", this.state = is) : e === A.APOSTROPHE ? (this.currentToken.systemId = "", this.state = ss) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In)));
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  [nd](e) {
    we(e) ? this.state = rd : e === A.QUOTATION_MARK ? (this._err(I.missingWhitespaceAfterDoctypeSystemKeyword), this.currentToken.systemId = "", this.state = is) : e === A.APOSTROPHE ? (this._err(I.missingWhitespaceAfterDoctypeSystemKeyword), this.currentToken.systemId = "", this.state = ss) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In));
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  [rd](e) {
    we(e) || (e === A.QUOTATION_MARK ? (this.currentToken.systemId = "", this.state = is) : e === A.APOSTROPHE ? (this.currentToken.systemId = "", this.state = ss) : e === A.GREATER_THAN_SIGN ? (this._err(I.missingDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this.state = ue, this._emitCurrentToken()) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(In)));
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  [is](e) {
    e === A.QUOTATION_MARK ? this.state = a1 : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.systemId += Ce.REPLACEMENT_CHARACTER) : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.systemId += Le(e);
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  [ss](e) {
    e === A.APOSTROPHE ? this.state = a1 : e === A.NULL ? (this._err(I.unexpectedNullCharacter), this.currentToken.systemId += Ce.REPLACEMENT_CHARACTER) : e === A.GREATER_THAN_SIGN ? (this._err(I.abruptDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.systemId += Le(e);
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  [a1](e) {
    we(e) || (e === A.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = ue) : e === A.EOF ? (this._err(I.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(I.unexpectedCharacterAfterDoctypeSystemIdentifier), this._reconsumeInState(In)));
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  [In](e) {
    e === A.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = ue) : e === A.NULL ? this._err(I.unexpectedNullCharacter) : e === A.EOF && (this._emitCurrentToken(), this._emitEOFToken());
  }
  // CDATA section state
  //------------------------------------------------------------------
  [Ao](e) {
    e === A.RIGHT_SQUARE_BRACKET ? this.state = id : e === A.EOF ? (this._err(I.eofInCdata), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  [id](e) {
    e === A.RIGHT_SQUARE_BRACKET ? this.state = sd : (this._emitChars("]"), this._reconsumeInState(Ao));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  [sd](e) {
    e === A.GREATER_THAN_SIGN ? this.state = ue : e === A.RIGHT_SQUARE_BRACKET ? this._emitChars("]") : (this._emitChars("]]"), this._reconsumeInState(Ao));
  }
  // Character reference state
  //------------------------------------------------------------------
  [li](e) {
    this.tempBuff = [A.AMPERSAND], e === A.NUMBER_SIGN ? (this.tempBuff.push(e), this.state = ld) : l1(e) ? this._reconsumeInState(od) : (this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Named character reference state
  //------------------------------------------------------------------
  [od](e) {
    const n = this._matchNamedCharacterReference(e);
    if (this._ensureHibernation())
      this.tempBuff = [A.AMPERSAND];
    else if (n) {
      const r = this.tempBuff[this.tempBuff.length - 1] === A.SEMICOLON;
      this._isCharacterReferenceAttributeQuirk(r) || (r || this._errOnNextCodePoint(I.missingSemicolonAfterCharacterReference), this.tempBuff = n), this._flushCodePointsConsumedAsCharacterReference(), this.state = this.returnState;
    } else
      this._flushCodePointsConsumedAsCharacterReference(), this.state = ad;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  [ad](e) {
    l1(e) ? this._isCharacterReferenceInAttribute() ? this.currentAttr.value += Le(e) : this._emitCodePoint(e) : (e === A.SEMICOLON && this._err(I.unknownNamedCharacterReference), this._reconsumeInState(this.returnState));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  [ld](e) {
    this.charRefCode = 0, e === A.LATIN_SMALL_X || e === A.LATIN_CAPITAL_X ? (this.tempBuff.push(e), this.state = ud) : this._reconsumeInState(cd);
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  [ud](e) {
    N3(e) ? this._reconsumeInState(fd) : (this._err(I.absenceOfDigitsInNumericCharacterReference), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Decimal character reference start state
  //------------------------------------------------------------------
  [cd](e) {
    _s(e) ? this._reconsumeInState(hd) : (this._err(I.absenceOfDigitsInNumericCharacterReference), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  [fd](e) {
    o9(e) ? this.charRefCode = this.charRefCode * 16 + e - 55 : a9(e) ? this.charRefCode = this.charRefCode * 16 + e - 87 : _s(e) ? this.charRefCode = this.charRefCode * 16 + e - 48 : e === A.SEMICOLON ? this.state = as : (this._err(I.missingSemicolonAfterCharacterReference), this._reconsumeInState(as));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  [hd](e) {
    _s(e) ? this.charRefCode = this.charRefCode * 10 + e - 48 : e === A.SEMICOLON ? this.state = as : (this._err(I.missingSemicolonAfterCharacterReference), this._reconsumeInState(as));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  [as]() {
    if (this.charRefCode === A.NULL)
      this._err(I.nullCharacterReference), this.charRefCode = A.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(I.characterReferenceOutsideUnicodeRange), this.charRefCode = A.REPLACEMENT_CHARACTER;
    else if (Ce.isSurrogate(this.charRefCode))
      this._err(I.surrogateCharacterReference), this.charRefCode = A.REPLACEMENT_CHARACTER;
    else if (Ce.isUndefinedCodePoint(this.charRefCode))
      this._err(I.noncharacterCharacterReference);
    else if (Ce.isControlCodePoint(this.charRefCode) || this.charRefCode === A.CARRIAGE_RETURN) {
      this._err(I.controlCharacterReference);
      const e = x3[this.charRefCode];
      e && (this.charRefCode = e);
    }
    this.tempBuff = [this.charRefCode], this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState);
  }
};
Yt.CHARACTER_TOKEN = "CHARACTER_TOKEN";
Yt.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
Yt.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
Yt.START_TAG_TOKEN = "START_TAG_TOKEN";
Yt.END_TAG_TOKEN = "END_TAG_TOKEN";
Yt.COMMENT_TOKEN = "COMMENT_TOKEN";
Yt.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
Yt.EOF_TOKEN = "EOF_TOKEN";
Yt.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
Yt.MODE = {
  DATA: ue,
  RCDATA: Ei,
  RAWTEXT: gs,
  SCRIPT_DATA: Pn,
  PLAINTEXT: s9
};
Yt.getTokenAttr = function(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
};
var ja = Yt, hn = {};
const u1 = hn.NAMESPACES = {
  HTML: "http://www.w3.org/1999/xhtml",
  MATHML: "http://www.w3.org/1998/Math/MathML",
  SVG: "http://www.w3.org/2000/svg",
  XLINK: "http://www.w3.org/1999/xlink",
  XML: "http://www.w3.org/XML/1998/namespace",
  XMLNS: "http://www.w3.org/2000/xmlns/"
};
hn.ATTRS = {
  TYPE: "type",
  ACTION: "action",
  ENCODING: "encoding",
  PROMPT: "prompt",
  NAME: "name",
  COLOR: "color",
  FACE: "face",
  SIZE: "size"
};
hn.DOCUMENT_MODE = {
  NO_QUIRKS: "no-quirks",
  QUIRKS: "quirks",
  LIMITED_QUIRKS: "limited-quirks"
};
const H = hn.TAG_NAMES = {
  A: "a",
  ADDRESS: "address",
  ANNOTATION_XML: "annotation-xml",
  APPLET: "applet",
  AREA: "area",
  ARTICLE: "article",
  ASIDE: "aside",
  B: "b",
  BASE: "base",
  BASEFONT: "basefont",
  BGSOUND: "bgsound",
  BIG: "big",
  BLOCKQUOTE: "blockquote",
  BODY: "body",
  BR: "br",
  BUTTON: "button",
  CAPTION: "caption",
  CENTER: "center",
  CODE: "code",
  COL: "col",
  COLGROUP: "colgroup",
  DD: "dd",
  DESC: "desc",
  DETAILS: "details",
  DIALOG: "dialog",
  DIR: "dir",
  DIV: "div",
  DL: "dl",
  DT: "dt",
  EM: "em",
  EMBED: "embed",
  FIELDSET: "fieldset",
  FIGCAPTION: "figcaption",
  FIGURE: "figure",
  FONT: "font",
  FOOTER: "footer",
  FOREIGN_OBJECT: "foreignObject",
  FORM: "form",
  FRAME: "frame",
  FRAMESET: "frameset",
  H1: "h1",
  H2: "h2",
  H3: "h3",
  H4: "h4",
  H5: "h5",
  H6: "h6",
  HEAD: "head",
  HEADER: "header",
  HGROUP: "hgroup",
  HR: "hr",
  HTML: "html",
  I: "i",
  IMG: "img",
  IMAGE: "image",
  INPUT: "input",
  IFRAME: "iframe",
  KEYGEN: "keygen",
  LABEL: "label",
  LI: "li",
  LINK: "link",
  LISTING: "listing",
  MAIN: "main",
  MALIGNMARK: "malignmark",
  MARQUEE: "marquee",
  MATH: "math",
  MENU: "menu",
  META: "meta",
  MGLYPH: "mglyph",
  MI: "mi",
  MO: "mo",
  MN: "mn",
  MS: "ms",
  MTEXT: "mtext",
  NAV: "nav",
  NOBR: "nobr",
  NOFRAMES: "noframes",
  NOEMBED: "noembed",
  NOSCRIPT: "noscript",
  OBJECT: "object",
  OL: "ol",
  OPTGROUP: "optgroup",
  OPTION: "option",
  P: "p",
  PARAM: "param",
  PLAINTEXT: "plaintext",
  PRE: "pre",
  RB: "rb",
  RP: "rp",
  RT: "rt",
  RTC: "rtc",
  RUBY: "ruby",
  S: "s",
  SCRIPT: "script",
  SECTION: "section",
  SELECT: "select",
  SOURCE: "source",
  SMALL: "small",
  SPAN: "span",
  STRIKE: "strike",
  STRONG: "strong",
  STYLE: "style",
  SUB: "sub",
  SUMMARY: "summary",
  SUP: "sup",
  TABLE: "table",
  TBODY: "tbody",
  TEMPLATE: "template",
  TEXTAREA: "textarea",
  TFOOT: "tfoot",
  TD: "td",
  TH: "th",
  THEAD: "thead",
  TITLE: "title",
  TR: "tr",
  TRACK: "track",
  TT: "tt",
  U: "u",
  UL: "ul",
  SVG: "svg",
  VAR: "var",
  WBR: "wbr",
  XMP: "xmp"
};
hn.SPECIAL_ELEMENTS = {
  [u1.HTML]: {
    [H.ADDRESS]: !0,
    [H.APPLET]: !0,
    [H.AREA]: !0,
    [H.ARTICLE]: !0,
    [H.ASIDE]: !0,
    [H.BASE]: !0,
    [H.BASEFONT]: !0,
    [H.BGSOUND]: !0,
    [H.BLOCKQUOTE]: !0,
    [H.BODY]: !0,
    [H.BR]: !0,
    [H.BUTTON]: !0,
    [H.CAPTION]: !0,
    [H.CENTER]: !0,
    [H.COL]: !0,
    [H.COLGROUP]: !0,
    [H.DD]: !0,
    [H.DETAILS]: !0,
    [H.DIR]: !0,
    [H.DIV]: !0,
    [H.DL]: !0,
    [H.DT]: !0,
    [H.EMBED]: !0,
    [H.FIELDSET]: !0,
    [H.FIGCAPTION]: !0,
    [H.FIGURE]: !0,
    [H.FOOTER]: !0,
    [H.FORM]: !0,
    [H.FRAME]: !0,
    [H.FRAMESET]: !0,
    [H.H1]: !0,
    [H.H2]: !0,
    [H.H3]: !0,
    [H.H4]: !0,
    [H.H5]: !0,
    [H.H6]: !0,
    [H.HEAD]: !0,
    [H.HEADER]: !0,
    [H.HGROUP]: !0,
    [H.HR]: !0,
    [H.HTML]: !0,
    [H.IFRAME]: !0,
    [H.IMG]: !0,
    [H.INPUT]: !0,
    [H.LI]: !0,
    [H.LINK]: !0,
    [H.LISTING]: !0,
    [H.MAIN]: !0,
    [H.MARQUEE]: !0,
    [H.MENU]: !0,
    [H.META]: !0,
    [H.NAV]: !0,
    [H.NOEMBED]: !0,
    [H.NOFRAMES]: !0,
    [H.NOSCRIPT]: !0,
    [H.OBJECT]: !0,
    [H.OL]: !0,
    [H.P]: !0,
    [H.PARAM]: !0,
    [H.PLAINTEXT]: !0,
    [H.PRE]: !0,
    [H.SCRIPT]: !0,
    [H.SECTION]: !0,
    [H.SELECT]: !0,
    [H.SOURCE]: !0,
    [H.STYLE]: !0,
    [H.SUMMARY]: !0,
    [H.TABLE]: !0,
    [H.TBODY]: !0,
    [H.TD]: !0,
    [H.TEMPLATE]: !0,
    [H.TEXTAREA]: !0,
    [H.TFOOT]: !0,
    [H.TH]: !0,
    [H.THEAD]: !0,
    [H.TITLE]: !0,
    [H.TR]: !0,
    [H.TRACK]: !0,
    [H.UL]: !0,
    [H.WBR]: !0,
    [H.XMP]: !0
  },
  [u1.MATHML]: {
    [H.MI]: !0,
    [H.MO]: !0,
    [H.MN]: !0,
    [H.MS]: !0,
    [H.MTEXT]: !0,
    [H.ANNOTATION_XML]: !0
  },
  [u1.SVG]: {
    [H.TITLE]: !0,
    [H.FOREIGN_OBJECT]: !0,
    [H.DESC]: !0
  }
};
const l9 = hn, q = l9.TAG_NAMES, be = l9.NAMESPACES;
function pd(t) {
  switch (t.length) {
    case 1:
      return t === q.P;
    case 2:
      return t === q.RB || t === q.RP || t === q.RT || t === q.DD || t === q.DT || t === q.LI;
    case 3:
      return t === q.RTC;
    case 6:
      return t === q.OPTION;
    case 8:
      return t === q.OPTGROUP;
  }
  return !1;
}
function _3(t) {
  switch (t.length) {
    case 1:
      return t === q.P;
    case 2:
      return t === q.RB || t === q.RP || t === q.RT || t === q.DD || t === q.DT || t === q.LI || t === q.TD || t === q.TH || t === q.TR;
    case 3:
      return t === q.RTC;
    case 5:
      return t === q.TBODY || t === q.TFOOT || t === q.THEAD;
    case 6:
      return t === q.OPTION;
    case 7:
      return t === q.CAPTION;
    case 8:
      return t === q.OPTGROUP || t === q.COLGROUP;
  }
  return !1;
}
function yo(t, e) {
  switch (t.length) {
    case 2:
      if (t === q.TD || t === q.TH)
        return e === be.HTML;
      if (t === q.MI || t === q.MO || t === q.MN || t === q.MS)
        return e === be.MATHML;
      break;
    case 4:
      if (t === q.HTML)
        return e === be.HTML;
      if (t === q.DESC)
        return e === be.SVG;
      break;
    case 5:
      if (t === q.TABLE)
        return e === be.HTML;
      if (t === q.MTEXT)
        return e === be.MATHML;
      if (t === q.TITLE)
        return e === be.SVG;
      break;
    case 6:
      return (t === q.APPLET || t === q.OBJECT) && e === be.HTML;
    case 7:
      return (t === q.CAPTION || t === q.MARQUEE) && e === be.HTML;
    case 8:
      return t === q.TEMPLATE && e === be.HTML;
    case 13:
      return t === q.FOREIGN_OBJECT && e === be.SVG;
    case 14:
      return t === q.ANNOTATION_XML && e === be.MATHML;
  }
  return !1;
}
let k3 = class {
  constructor(e, n) {
    this.stackTop = -1, this.items = [], this.current = e, this.currentTagName = null, this.currentTmplContent = null, this.tmplCount = 0, this.treeAdapter = n;
  }
  //Index of element
  _indexOf(e) {
    let n = -1;
    for (let r = this.stackTop; r >= 0; r--)
      if (this.items[r] === e) {
        n = r;
        break;
      }
    return n;
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagName === q.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === be.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagName = this.current && this.treeAdapter.getTagName(this.current), this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
  }
  //Mutations
  push(e) {
    this.items[++this.stackTop] = e, this._updateCurrentElement(), this._isInTemplate() && this.tmplCount++;
  }
  pop() {
    this.stackTop--, this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this._updateCurrentElement();
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && this._updateCurrentElement();
  }
  insertAfter(e, n) {
    const r = this._indexOf(e) + 1;
    this.items.splice(r, 0, n), r === ++this.stackTop && this._updateCurrentElement();
  }
  popUntilTagNamePopped(e) {
    for (; this.stackTop > -1; ) {
      const n = this.currentTagName, r = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), n === e && r === be.HTML)
        break;
    }
  }
  popUntilElementPopped(e) {
    for (; this.stackTop > -1; ) {
      const n = this.current;
      if (this.pop(), n === e)
        break;
    }
  }
  popUntilNumberedHeaderPopped() {
    for (; this.stackTop > -1; ) {
      const e = this.currentTagName, n = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), e === q.H1 || e === q.H2 || e === q.H3 || e === q.H4 || e === q.H5 || e === q.H6 && n === be.HTML)
        break;
    }
  }
  popUntilTableCellPopped() {
    for (; this.stackTop > -1; ) {
      const e = this.currentTagName, n = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), e === q.TD || e === q.TH && n === be.HTML)
        break;
    }
  }
  popAllUpToHtmlElement() {
    this.stackTop = 0, this._updateCurrentElement();
  }
  clearBackToTableContext() {
    for (; this.currentTagName !== q.TABLE && this.currentTagName !== q.TEMPLATE && this.currentTagName !== q.HTML || this.treeAdapter.getNamespaceURI(this.current) !== be.HTML; )
      this.pop();
  }
  clearBackToTableBodyContext() {
    for (; this.currentTagName !== q.TBODY && this.currentTagName !== q.TFOOT && this.currentTagName !== q.THEAD && this.currentTagName !== q.TEMPLATE && this.currentTagName !== q.HTML || this.treeAdapter.getNamespaceURI(this.current) !== be.HTML; )
      this.pop();
  }
  clearBackToTableRowContext() {
    for (; this.currentTagName !== q.TR && this.currentTagName !== q.TEMPLATE && this.currentTagName !== q.HTML || this.treeAdapter.getNamespaceURI(this.current) !== be.HTML; )
      this.pop();
  }
  remove(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.items[n] === e) {
        this.items.splice(n, 1), this.stackTop--, this._updateCurrentElement();
        break;
      }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    const e = this.items[1];
    return e && this.treeAdapter.getTagName(e) === q.BODY ? e : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    let n = this._indexOf(e);
    return --n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.currentTagName === q.HTML;
  }
  //Element in scope
  hasInScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === be.HTML)
        return !0;
      if (yo(r, i))
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.treeAdapter.getTagName(this.items[e]), r = this.treeAdapter.getNamespaceURI(this.items[e]);
      if ((n === q.H1 || n === q.H2 || n === q.H3 || n === q.H4 || n === q.H5 || n === q.H6) && r === be.HTML)
        return !0;
      if (yo(n, r))
        return !1;
    }
    return !0;
  }
  hasInListItemScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === be.HTML)
        return !0;
      if ((r === q.UL || r === q.OL) && i === be.HTML || yo(r, i))
        return !1;
    }
    return !0;
  }
  hasInButtonScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === be.HTML)
        return !0;
      if (r === q.BUTTON && i === be.HTML || yo(r, i))
        return !1;
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]);
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === be.HTML) {
        if (r === e)
          return !0;
        if (r === q.TABLE || r === q.TEMPLATE || r === q.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.treeAdapter.getTagName(this.items[e]);
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === be.HTML) {
        if (n === q.TBODY || n === q.THEAD || n === q.TFOOT)
          return !0;
        if (n === q.TABLE || n === q.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]);
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === be.HTML) {
        if (r === e)
          return !0;
        if (r !== q.OPTION && r !== q.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; pd(this.currentTagName); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; _3(this.currentTagName); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; pd(this.currentTagName) && this.currentTagName !== e; )
      this.pop();
  }
};
var O3 = k3;
const Co = 3;
let Zu = class nr {
  constructor(e) {
    this.length = 0, this.entries = [], this.treeAdapter = e, this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e) {
    const n = [];
    if (this.length >= Co) {
      const r = this.treeAdapter.getAttrList(e).length, i = this.treeAdapter.getTagName(e), s = this.treeAdapter.getNamespaceURI(e);
      for (let o = this.length - 1; o >= 0; o--) {
        const a = this.entries[o];
        if (a.type === nr.MARKER_ENTRY)
          break;
        const l = a.element, u = this.treeAdapter.getAttrList(l);
        this.treeAdapter.getTagName(l) === i && this.treeAdapter.getNamespaceURI(l) === s && u.length === r && n.push({ idx: o, attrs: u });
      }
    }
    return n.length < Co ? [] : n;
  }
  _ensureNoahArkCondition(e) {
    const n = this._getNoahArkConditionCandidates(e);
    let r = n.length;
    if (r) {
      const i = this.treeAdapter.getAttrList(e), s = i.length, o = /* @__PURE__ */ Object.create(null);
      for (let a = 0; a < s; a++) {
        const l = i[a];
        o[l.name] = l.value;
      }
      for (let a = 0; a < s; a++)
        for (let l = 0; l < r; l++) {
          const u = n[l].attrs[a];
          if (o[u.name] !== u.value && (n.splice(l, 1), r--), n.length < Co)
            return;
        }
      for (let a = r - 1; a >= Co - 1; a--)
        this.entries.splice(n[a].idx, 1), this.length--;
    }
  }
  //Mutations
  insertMarker() {
    this.entries.push({ type: nr.MARKER_ENTRY }), this.length++;
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.push({
      type: nr.ELEMENT_ENTRY,
      element: e,
      token: n
    }), this.length++;
  }
  insertElementAfterBookmark(e, n) {
    let r = this.length - 1;
    for (; r >= 0 && this.entries[r] !== this.bookmark; r--)
      ;
    this.entries.splice(r + 1, 0, {
      type: nr.ELEMENT_ENTRY,
      element: e,
      token: n
    }), this.length++;
  }
  removeEntry(e) {
    for (let n = this.length - 1; n >= 0; n--)
      if (this.entries[n] === e) {
        this.entries.splice(n, 1), this.length--;
        break;
      }
  }
  clearToLastMarker() {
    for (; this.length; ) {
      const e = this.entries.pop();
      if (this.length--, e.type === nr.MARKER_ENTRY)
        break;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    for (let n = this.length - 1; n >= 0; n--) {
      const r = this.entries[n];
      if (r.type === nr.MARKER_ENTRY)
        return null;
      if (this.treeAdapter.getTagName(r.element) === e)
        return r;
    }
    return null;
  }
  getElementEntry(e) {
    for (let n = this.length - 1; n >= 0; n--) {
      const r = this.entries[n];
      if (r.type === nr.ELEMENT_ENTRY && r.element === e)
        return r;
    }
    return null;
  }
};
Zu.MARKER_ENTRY = "MARKER_ENTRY";
Zu.ELEMENT_ENTRY = "ELEMENT_ENTRY";
var w3 = Zu;
let u9 = class {
  constructor(e) {
    const n = {}, r = this._getOverriddenMethods(this, n);
    for (const i of Object.keys(r))
      typeof r[i] == "function" && (n[i] = e[i], e[i] = r[i]);
  }
  _getOverriddenMethods() {
    throw new Error("Not implemented");
  }
};
u9.install = function(t, e, n) {
  t.__mixins || (t.__mixins = []);
  for (let i = 0; i < t.__mixins.length; i++)
    if (t.__mixins[i].constructor === e)
      return t.__mixins[i];
  const r = new e(t, n);
  return t.__mixins.push(r), r;
};
var $n = u9;
const D3 = $n;
let I3 = class extends D3 {
  constructor(e) {
    super(e), this.preprocessor = e, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.offset = 0, this.col = 0, this.line = 1;
  }
  _getOverriddenMethods(e, n) {
    return {
      advance() {
        const r = this.pos + 1, i = this.html[r];
        return e.isEol && (e.isEol = !1, e.line++, e.lineStartPos = r), (i === `
` || i === "\r" && this.html[r + 1] !== `
`) && (e.isEol = !0), e.col = r - e.lineStartPos + 1, e.offset = e.droppedBufferSize + r, n.advance.call(this);
      },
      retreat() {
        n.retreat.call(this), e.isEol = !1, e.col = this.pos - e.lineStartPos + 1;
      },
      dropParsedChunk() {
        const r = this.pos;
        n.dropParsedChunk.call(this);
        const i = r - this.pos;
        e.lineStartPos -= i, e.droppedBufferSize += i, e.offset = e.droppedBufferSize + this.pos;
      }
    };
  }
};
var c9 = I3;
const md = $n, c1 = ja, M3 = c9;
let R3 = class extends md {
  constructor(e) {
    super(e), this.tokenizer = e, this.posTracker = md.install(e.preprocessor, M3), this.currentAttrLocation = null, this.ctLoc = null;
  }
  _getCurrentLocation() {
    return {
      startLine: this.posTracker.line,
      startCol: this.posTracker.col,
      startOffset: this.posTracker.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _attachCurrentAttrLocationInfo() {
    this.currentAttrLocation.endLine = this.posTracker.line, this.currentAttrLocation.endCol = this.posTracker.col, this.currentAttrLocation.endOffset = this.posTracker.offset;
    const e = this.tokenizer.currentToken, n = this.tokenizer.currentAttr;
    e.location.attrs || (e.location.attrs = /* @__PURE__ */ Object.create(null)), e.location.attrs[n.name] = this.currentAttrLocation;
  }
  _getOverriddenMethods(e, n) {
    const r = {
      _createStartTagToken() {
        n._createStartTagToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createEndTagToken() {
        n._createEndTagToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createCommentToken() {
        n._createCommentToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createDoctypeToken(i) {
        n._createDoctypeToken.call(this, i), this.currentToken.location = e.ctLoc;
      },
      _createCharacterToken(i, s) {
        n._createCharacterToken.call(this, i, s), this.currentCharacterToken.location = e.ctLoc;
      },
      _createEOFToken() {
        n._createEOFToken.call(this), this.currentToken.location = e._getCurrentLocation();
      },
      _createAttr(i) {
        n._createAttr.call(this, i), e.currentAttrLocation = e._getCurrentLocation();
      },
      _leaveAttrName(i) {
        n._leaveAttrName.call(this, i), e._attachCurrentAttrLocationInfo();
      },
      _leaveAttrValue(i) {
        n._leaveAttrValue.call(this, i), e._attachCurrentAttrLocationInfo();
      },
      _emitCurrentToken() {
        const i = this.currentToken.location;
        this.currentCharacterToken && (this.currentCharacterToken.location.endLine = i.startLine, this.currentCharacterToken.location.endCol = i.startCol, this.currentCharacterToken.location.endOffset = i.startOffset), this.currentToken.type === c1.EOF_TOKEN ? (i.endLine = i.startLine, i.endCol = i.startCol, i.endOffset = i.startOffset) : (i.endLine = e.posTracker.line, i.endCol = e.posTracker.col + 1, i.endOffset = e.posTracker.offset + 1), n._emitCurrentToken.call(this);
      },
      _emitCurrentCharacterToken() {
        const i = this.currentCharacterToken && this.currentCharacterToken.location;
        i && i.endOffset === -1 && (i.endLine = e.posTracker.line, i.endCol = e.posTracker.col, i.endOffset = e.posTracker.offset), n._emitCurrentCharacterToken.call(this);
      }
    };
    return Object.keys(c1.MODE).forEach((i) => {
      const s = c1.MODE[i];
      r[s] = function(o) {
        e.ctLoc = e._getCurrentLocation(), n[s].call(this, o);
      };
    }), r;
  }
};
var f9 = R3;
const v3 = $n;
let L3 = class extends v3 {
  constructor(e, n) {
    super(e), this.onItemPop = n.onItemPop;
  }
  _getOverriddenMethods(e, n) {
    return {
      pop() {
        e.onItemPop(this.current), n.pop.call(this);
      },
      popAllUpToHtmlElement() {
        for (let r = this.stackTop; r > 0; r--)
          e.onItemPop(this.items[r]);
        n.popAllUpToHtmlElement.call(this);
      },
      remove(r) {
        e.onItemPop(this.current), n.remove.call(this, r);
      }
    };
  }
};
var P3 = L3;
const f1 = $n, gd = ja, B3 = f9, F3 = P3, H3 = hn, h1 = H3.TAG_NAMES;
let U3 = class extends f1 {
  constructor(e) {
    super(e), this.parser = e, this.treeAdapter = this.parser.treeAdapter, this.posTracker = null, this.lastStartTagToken = null, this.lastFosterParentingLocation = null, this.currentToken = null;
  }
  _setStartLocation(e) {
    let n = null;
    this.lastStartTagToken && (n = Object.assign({}, this.lastStartTagToken.location), n.startTag = this.lastStartTagToken.location), this.treeAdapter.setNodeSourceCodeLocation(e, n);
  }
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const i = n.location, s = this.treeAdapter.getTagName(e), o = n.type === gd.END_TAG_TOKEN && s === n.tagName, a = {};
      o ? (a.endTag = Object.assign({}, i), a.endLine = i.endLine, a.endCol = i.endCol, a.endOffset = i.endOffset) : (a.endLine = i.startLine, a.endCol = i.startCol, a.endOffset = i.startOffset), this.treeAdapter.updateNodeSourceCodeLocation(e, a);
    }
  }
  _getOverriddenMethods(e, n) {
    return {
      _bootstrap(r, i) {
        n._bootstrap.call(this, r, i), e.lastStartTagToken = null, e.lastFosterParentingLocation = null, e.currentToken = null;
        const s = f1.install(this.tokenizer, B3);
        e.posTracker = s.posTracker, f1.install(this.openElements, F3, {
          onItemPop: function(o) {
            e._setEndLocation(o, e.currentToken);
          }
        });
      },
      _runParsingLoop(r) {
        n._runParsingLoop.call(this, r);
        for (let i = this.openElements.stackTop; i >= 0; i--)
          e._setEndLocation(this.openElements.items[i], e.currentToken);
      },
      //Token processing
      _processTokenInForeignContent(r) {
        e.currentToken = r, n._processTokenInForeignContent.call(this, r);
      },
      _processToken(r) {
        if (e.currentToken = r, n._processToken.call(this, r), r.type === gd.END_TAG_TOKEN && (r.tagName === h1.HTML || r.tagName === h1.BODY && this.openElements.hasInScope(h1.BODY)))
          for (let s = this.openElements.stackTop; s >= 0; s--) {
            const o = this.openElements.items[s];
            if (this.treeAdapter.getTagName(o) === r.tagName) {
              e._setEndLocation(o, r);
              break;
            }
          }
      },
      //Doctype
      _setDocumentType(r) {
        n._setDocumentType.call(this, r);
        const i = this.treeAdapter.getChildNodes(this.document), s = i.length;
        for (let o = 0; o < s; o++) {
          const a = i[o];
          if (this.treeAdapter.isDocumentTypeNode(a)) {
            this.treeAdapter.setNodeSourceCodeLocation(a, r.location);
            break;
          }
        }
      },
      //Elements
      _attachElementToTree(r) {
        e._setStartLocation(r), e.lastStartTagToken = null, n._attachElementToTree.call(this, r);
      },
      _appendElement(r, i) {
        e.lastStartTagToken = r, n._appendElement.call(this, r, i);
      },
      _insertElement(r, i) {
        e.lastStartTagToken = r, n._insertElement.call(this, r, i);
      },
      _insertTemplate(r) {
        e.lastStartTagToken = r, n._insertTemplate.call(this, r);
        const i = this.treeAdapter.getTemplateContent(this.openElements.current);
        this.treeAdapter.setNodeSourceCodeLocation(i, null);
      },
      _insertFakeRootElement() {
        n._insertFakeRootElement.call(this), this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
      },
      //Comments
      _appendCommentNode(r, i) {
        n._appendCommentNode.call(this, r, i);
        const s = this.treeAdapter.getChildNodes(i), o = s[s.length - 1];
        this.treeAdapter.setNodeSourceCodeLocation(o, r.location);
      },
      //Text
      _findFosterParentingLocation() {
        return e.lastFosterParentingLocation = n._findFosterParentingLocation.call(this), e.lastFosterParentingLocation;
      },
      _insertCharacters(r) {
        n._insertCharacters.call(this, r);
        const i = this._shouldFosterParentOnInsertion(), s = i && e.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current, o = this.treeAdapter.getChildNodes(s), a = i && e.lastFosterParentingLocation.beforeElement ? o.indexOf(e.lastFosterParentingLocation.beforeElement) - 1 : o.length - 1, l = o[a];
        if (this.treeAdapter.getNodeSourceCodeLocation(l)) {
          const { endLine: c, endCol: f, endOffset: h } = r.location;
          this.treeAdapter.updateNodeSourceCodeLocation(l, { endLine: c, endCol: f, endOffset: h });
        } else
          this.treeAdapter.setNodeSourceCodeLocation(l, r.location);
      }
    };
  }
};
var q3 = U3;
const z3 = $n;
let $3 = class extends z3 {
  constructor(e, n) {
    super(e), this.posTracker = null, this.onParseError = n.onParseError;
  }
  _setErrorLocation(e) {
    e.startLine = e.endLine = this.posTracker.line, e.startCol = e.endCol = this.posTracker.col, e.startOffset = e.endOffset = this.posTracker.offset;
  }
  _reportError(e) {
    const n = {
      code: e,
      startLine: -1,
      startCol: -1,
      startOffset: -1,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    this._setErrorLocation(n), this.onParseError(n);
  }
  _getOverriddenMethods(e) {
    return {
      _err(n) {
        e._reportError(n);
      }
    };
  }
};
var ec = $3;
const G3 = ec, j3 = c9, V3 = $n;
let K3 = class extends G3 {
  constructor(e, n) {
    super(e, n), this.posTracker = V3.install(e, j3), this.lastErrOffset = -1;
  }
  _reportError(e) {
    this.lastErrOffset !== this.posTracker.offset && (this.lastErrOffset = this.posTracker.offset, super._reportError(e));
  }
};
var W3 = K3;
const Y3 = ec, Q3 = W3, J3 = $n;
let X3 = class extends Y3 {
  constructor(e, n) {
    super(e, n);
    const r = J3.install(e.preprocessor, Q3, n);
    this.posTracker = r.posTracker;
  }
};
var Z3 = X3;
const ey = ec, ty = Z3, ny = f9, Ed = $n;
let ry = class extends ey {
  constructor(e, n) {
    super(e, n), this.opts = n, this.ctLoc = null, this.locBeforeToken = !1;
  }
  _setErrorLocation(e) {
    this.ctLoc && (e.startLine = this.ctLoc.startLine, e.startCol = this.ctLoc.startCol, e.startOffset = this.ctLoc.startOffset, e.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine, e.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol, e.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset);
  }
  _getOverriddenMethods(e, n) {
    return {
      _bootstrap(r, i) {
        n._bootstrap.call(this, r, i), Ed.install(this.tokenizer, ty, e.opts), Ed.install(this.tokenizer, ny);
      },
      _processInputToken(r) {
        e.ctLoc = r.location, n._processInputToken.call(this, r);
      },
      _err(r, i) {
        e.locBeforeToken = i && i.beforeToken, e._reportError(r);
      }
    };
  }
};
var iy = ry, de = {};
const { DOCUMENT_MODE: sy } = hn;
de.createDocument = function() {
  return {
    nodeName: "#document",
    mode: sy.NO_QUIRKS,
    childNodes: []
  };
};
de.createDocumentFragment = function() {
  return {
    nodeName: "#document-fragment",
    childNodes: []
  };
};
de.createElement = function(t, e, n) {
  return {
    nodeName: t,
    tagName: t,
    attrs: n,
    namespaceURI: e,
    childNodes: [],
    parentNode: null
  };
};
de.createCommentNode = function(t) {
  return {
    nodeName: "#comment",
    data: t,
    parentNode: null
  };
};
const h9 = function(t) {
  return {
    nodeName: "#text",
    value: t,
    parentNode: null
  };
}, d9 = de.appendChild = function(t, e) {
  t.childNodes.push(e), e.parentNode = t;
}, oy = de.insertBefore = function(t, e, n) {
  const r = t.childNodes.indexOf(n);
  t.childNodes.splice(r, 0, e), e.parentNode = t;
};
de.setTemplateContent = function(t, e) {
  t.content = e;
};
de.getTemplateContent = function(t) {
  return t.content;
};
de.setDocumentType = function(t, e, n, r) {
  let i = null;
  for (let s = 0; s < t.childNodes.length; s++)
    if (t.childNodes[s].nodeName === "#documentType") {
      i = t.childNodes[s];
      break;
    }
  i ? (i.name = e, i.publicId = n, i.systemId = r) : d9(t, {
    nodeName: "#documentType",
    name: e,
    publicId: n,
    systemId: r
  });
};
de.setDocumentMode = function(t, e) {
  t.mode = e;
};
de.getDocumentMode = function(t) {
  return t.mode;
};
de.detachNode = function(t) {
  if (t.parentNode) {
    const e = t.parentNode.childNodes.indexOf(t);
    t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
  }
};
de.insertText = function(t, e) {
  if (t.childNodes.length) {
    const n = t.childNodes[t.childNodes.length - 1];
    if (n.nodeName === "#text") {
      n.value += e;
      return;
    }
  }
  d9(t, h9(e));
};
de.insertTextBefore = function(t, e, n) {
  const r = t.childNodes[t.childNodes.indexOf(n) - 1];
  r && r.nodeName === "#text" ? r.value += e : oy(t, h9(e), n);
};
de.adoptAttributes = function(t, e) {
  const n = [];
  for (let r = 0; r < t.attrs.length; r++)
    n.push(t.attrs[r].name);
  for (let r = 0; r < e.length; r++)
    n.indexOf(e[r].name) === -1 && t.attrs.push(e[r]);
};
de.getFirstChild = function(t) {
  return t.childNodes[0];
};
de.getChildNodes = function(t) {
  return t.childNodes;
};
de.getParentNode = function(t) {
  return t.parentNode;
};
de.getAttrList = function(t) {
  return t.attrs;
};
de.getTagName = function(t) {
  return t.tagName;
};
de.getNamespaceURI = function(t) {
  return t.namespaceURI;
};
de.getTextNodeContent = function(t) {
  return t.value;
};
de.getCommentNodeContent = function(t) {
  return t.data;
};
de.getDocumentTypeNodeName = function(t) {
  return t.name;
};
de.getDocumentTypeNodePublicId = function(t) {
  return t.publicId;
};
de.getDocumentTypeNodeSystemId = function(t) {
  return t.systemId;
};
de.isTextNode = function(t) {
  return t.nodeName === "#text";
};
de.isCommentNode = function(t) {
  return t.nodeName === "#comment";
};
de.isDocumentTypeNode = function(t) {
  return t.nodeName === "#documentType";
};
de.isElementNode = function(t) {
  return !!t.tagName;
};
de.setNodeSourceCodeLocation = function(t, e) {
  t.sourceCodeLocation = e;
};
de.getNodeSourceCodeLocation = function(t) {
  return t.sourceCodeLocation;
};
de.updateNodeSourceCodeLocation = function(t, e) {
  t.sourceCodeLocation = Object.assign(t.sourceCodeLocation, e);
};
var ay = function(e, n) {
  return n = n || /* @__PURE__ */ Object.create(null), [e, n].reduce((r, i) => (Object.keys(i).forEach((s) => {
    r[s] = i[s];
  }), r), /* @__PURE__ */ Object.create(null));
}, Va = {};
const { DOCUMENT_MODE: ui } = hn, p9 = "html", ly = "about:legacy-compat", uy = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", m9 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], cy = m9.concat([
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
]), fy = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"], g9 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], hy = g9.concat([
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
]);
function Td(t) {
  const e = t.indexOf('"') !== -1 ? "'" : '"';
  return e + t + e;
}
function Ad(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.indexOf(e[n]) === 0)
      return !0;
  return !1;
}
Va.isConforming = function(t) {
  return t.name === p9 && t.publicId === null && (t.systemId === null || t.systemId === ly);
};
Va.getDocumentMode = function(t) {
  if (t.name !== p9)
    return ui.QUIRKS;
  const e = t.systemId;
  if (e && e.toLowerCase() === uy)
    return ui.QUIRKS;
  let n = t.publicId;
  if (n !== null) {
    if (n = n.toLowerCase(), fy.indexOf(n) > -1)
      return ui.QUIRKS;
    let r = e === null ? cy : m9;
    if (Ad(n, r))
      return ui.QUIRKS;
    if (r = e === null ? g9 : hy, Ad(n, r))
      return ui.LIMITED_QUIRKS;
  }
  return ui.NO_QUIRKS;
};
Va.serializeContent = function(t, e, n) {
  let r = "!DOCTYPE ";
  return t && (r += t), e ? r += " PUBLIC " + Td(e) : n && (r += " SYSTEM"), n !== null && (r += " " + Td(n)), r;
};
var br = {};
const d1 = ja, tc = hn, Q = tc.TAG_NAMES, tt = tc.NAMESPACES, Po = tc.ATTRS, yd = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, dy = "definitionurl", py = "definitionURL", my = {
  attributename: "attributeName",
  attributetype: "attributeType",
  basefrequency: "baseFrequency",
  baseprofile: "baseProfile",
  calcmode: "calcMode",
  clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef",
  gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits",
  kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength",
  keypoints: "keyPoints",
  keysplines: "keySplines",
  keytimes: "keyTimes",
  lengthadjust: "lengthAdjust",
  limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight",
  markerunits: "markerUnits",
  markerwidth: "markerWidth",
  maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits",
  numoctaves: "numOctaves",
  pathlength: "pathLength",
  patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform",
  patternunits: "patternUnits",
  pointsatx: "pointsAtX",
  pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ",
  preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits",
  refx: "refX",
  refy: "refY",
  repeatcount: "repeatCount",
  repeatdur: "repeatDur",
  requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent",
  spreadmethod: "spreadMethod",
  startoffset: "startOffset",
  stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles",
  surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage",
  tablevalues: "tableValues",
  targetx: "targetX",
  targety: "targetY",
  textlength: "textLength",
  viewbox: "viewBox",
  viewtarget: "viewTarget",
  xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector",
  zoomandpan: "zoomAndPan"
}, gy = {
  "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: tt.XLINK },
  "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: tt.XLINK },
  "xlink:href": { prefix: "xlink", name: "href", namespace: tt.XLINK },
  "xlink:role": { prefix: "xlink", name: "role", namespace: tt.XLINK },
  "xlink:show": { prefix: "xlink", name: "show", namespace: tt.XLINK },
  "xlink:title": { prefix: "xlink", name: "title", namespace: tt.XLINK },
  "xlink:type": { prefix: "xlink", name: "type", namespace: tt.XLINK },
  "xml:base": { prefix: "xml", name: "base", namespace: tt.XML },
  "xml:lang": { prefix: "xml", name: "lang", namespace: tt.XML },
  "xml:space": { prefix: "xml", name: "space", namespace: tt.XML },
  xmlns: { prefix: "", name: "xmlns", namespace: tt.XMLNS },
  "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: tt.XMLNS }
}, Ey = br.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
  altglyph: "altGlyph",
  altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem",
  animatecolor: "animateColor",
  animatemotion: "animateMotion",
  animatetransform: "animateTransform",
  clippath: "clipPath",
  feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer",
  fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight",
  feflood: "feFlood",
  fefunca: "feFuncA",
  fefuncb: "feFuncB",
  fefuncg: "feFuncG",
  fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur",
  feimage: "feImage",
  femerge: "feMerge",
  femergenode: "feMergeNode",
  femorphology: "feMorphology",
  feoffset: "feOffset",
  fepointlight: "fePointLight",
  fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight",
  fetile: "feTile",
  feturbulence: "feTurbulence",
  foreignobject: "foreignObject",
  glyphref: "glyphRef",
  lineargradient: "linearGradient",
  radialgradient: "radialGradient",
  textpath: "textPath"
}, Ty = {
  [Q.B]: !0,
  [Q.BIG]: !0,
  [Q.BLOCKQUOTE]: !0,
  [Q.BODY]: !0,
  [Q.BR]: !0,
  [Q.CENTER]: !0,
  [Q.CODE]: !0,
  [Q.DD]: !0,
  [Q.DIV]: !0,
  [Q.DL]: !0,
  [Q.DT]: !0,
  [Q.EM]: !0,
  [Q.EMBED]: !0,
  [Q.H1]: !0,
  [Q.H2]: !0,
  [Q.H3]: !0,
  [Q.H4]: !0,
  [Q.H5]: !0,
  [Q.H6]: !0,
  [Q.HEAD]: !0,
  [Q.HR]: !0,
  [Q.I]: !0,
  [Q.IMG]: !0,
  [Q.LI]: !0,
  [Q.LISTING]: !0,
  [Q.MENU]: !0,
  [Q.META]: !0,
  [Q.NOBR]: !0,
  [Q.OL]: !0,
  [Q.P]: !0,
  [Q.PRE]: !0,
  [Q.RUBY]: !0,
  [Q.S]: !0,
  [Q.SMALL]: !0,
  [Q.SPAN]: !0,
  [Q.STRONG]: !0,
  [Q.STRIKE]: !0,
  [Q.SUB]: !0,
  [Q.SUP]: !0,
  [Q.TABLE]: !0,
  [Q.TT]: !0,
  [Q.U]: !0,
  [Q.UL]: !0,
  [Q.VAR]: !0
};
br.causesExit = function(t) {
  const e = t.tagName;
  return e === Q.FONT && (d1.getTokenAttr(t, Po.COLOR) !== null || d1.getTokenAttr(t, Po.SIZE) !== null || d1.getTokenAttr(t, Po.FACE) !== null) ? !0 : Ty[e];
};
br.adjustTokenMathMLAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === dy) {
      t.attrs[e].name = py;
      break;
    }
};
br.adjustTokenSVGAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = my[t.attrs[e].name];
    n && (t.attrs[e].name = n);
  }
};
br.adjustTokenXMLAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = gy[t.attrs[e].name];
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
};
br.adjustTokenSVGTagName = function(t) {
  const e = Ey[t.tagName];
  e && (t.tagName = e);
};
function Ay(t, e) {
  return e === tt.MATHML && (t === Q.MI || t === Q.MO || t === Q.MN || t === Q.MS || t === Q.MTEXT);
}
function yy(t, e, n) {
  if (e === tt.MATHML && t === Q.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === Po.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === yd.TEXT_HTML || i === yd.APPLICATION_XML;
      }
  }
  return e === tt.SVG && (t === Q.FOREIGN_OBJECT || t === Q.DESC || t === Q.TITLE);
}
br.isIntegrationPoint = function(t, e, n, r) {
  return !!((!r || r === tt.HTML) && yy(t, e, n) || (!r || r === tt.MATHML) && Ay(t, e));
};
const y = ja, Cy = O3, Cd = w3, by = q3, xy = iy, bd = $n, Sy = de, Ny = ay, xd = Va, Cn = br, it = Xu, _y = fn, Xr = hn, p = Xr.TAG_NAMES, V = Xr.NAMESPACES, E9 = Xr.ATTRS, ky = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  onParseError: null,
  treeAdapter: Sy
}, T9 = "hidden", Oy = 8, wy = 3, A9 = "INITIAL_MODE", nc = "BEFORE_HTML_MODE", Ka = "BEFORE_HEAD_MODE", zi = "IN_HEAD_MODE", y9 = "IN_HEAD_NO_SCRIPT_MODE", Wa = "AFTER_HEAD_MODE", xn = "IN_BODY_MODE", xa = "TEXT_MODE", ut = "IN_TABLE_MODE", C9 = "IN_TABLE_TEXT_MODE", Ya = "IN_CAPTION_MODE", Ks = "IN_COLUMN_GROUP_MODE", Gt = "IN_TABLE_BODY_MODE", zn = "IN_ROW_MODE", Qa = "IN_CELL_MODE", rc = "IN_SELECT_MODE", ic = "IN_SELECT_IN_TABLE_MODE", Sa = "IN_TEMPLATE_MODE", sc = "AFTER_BODY_MODE", Ja = "IN_FRAMESET_MODE", b9 = "AFTER_FRAMESET_MODE", x9 = "AFTER_AFTER_BODY_MODE", S9 = "AFTER_AFTER_FRAMESET_MODE", Dy = {
  [p.TR]: zn,
  [p.TBODY]: Gt,
  [p.THEAD]: Gt,
  [p.TFOOT]: Gt,
  [p.CAPTION]: Ya,
  [p.COLGROUP]: Ks,
  [p.TABLE]: ut,
  [p.BODY]: xn,
  [p.FRAMESET]: Ja
}, Iy = {
  [p.CAPTION]: ut,
  [p.COLGROUP]: ut,
  [p.TBODY]: ut,
  [p.TFOOT]: ut,
  [p.THEAD]: ut,
  [p.COL]: Ks,
  [p.TR]: Gt,
  [p.TD]: zn,
  [p.TH]: zn
}, Sd = {
  [A9]: {
    [y.CHARACTER_TOKEN]: us,
    [y.NULL_CHARACTER_TOKEN]: us,
    [y.WHITESPACE_CHARACTER_TOKEN]: ce,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: qy,
    [y.START_TAG_TOKEN]: us,
    [y.END_TAG_TOKEN]: us,
    [y.EOF_TOKEN]: us
  },
  [nc]: {
    [y.CHARACTER_TOKEN]: ks,
    [y.NULL_CHARACTER_TOKEN]: ks,
    [y.WHITESPACE_CHARACTER_TOKEN]: ce,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: zy,
    [y.END_TAG_TOKEN]: $y,
    [y.EOF_TOKEN]: ks
  },
  [Ka]: {
    [y.CHARACTER_TOKEN]: Os,
    [y.NULL_CHARACTER_TOKEN]: Os,
    [y.WHITESPACE_CHARACTER_TOKEN]: ce,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: bo,
    [y.START_TAG_TOKEN]: Gy,
    [y.END_TAG_TOKEN]: jy,
    [y.EOF_TOKEN]: Os
  },
  [zi]: {
    [y.CHARACTER_TOKEN]: ws,
    [y.NULL_CHARACTER_TOKEN]: ws,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: bo,
    [y.START_TAG_TOKEN]: Je,
    [y.END_TAG_TOKEN]: Zr,
    [y.EOF_TOKEN]: ws
  },
  [y9]: {
    [y.CHARACTER_TOKEN]: Ds,
    [y.NULL_CHARACTER_TOKEN]: Ds,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: bo,
    [y.START_TAG_TOKEN]: Vy,
    [y.END_TAG_TOKEN]: Ky,
    [y.EOF_TOKEN]: Ds
  },
  [Wa]: {
    [y.CHARACTER_TOKEN]: Is,
    [y.NULL_CHARACTER_TOKEN]: Is,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: bo,
    [y.START_TAG_TOKEN]: Wy,
    [y.END_TAG_TOKEN]: Yy,
    [y.EOF_TOKEN]: Is
  },
  [xn]: {
    [y.CHARACTER_TOKEN]: xo,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: Nt,
    [y.END_TAG_TOKEN]: oc,
    [y.EOF_TOKEN]: Rn
  },
  [xa]: {
    [y.CHARACTER_TOKEN]: At,
    [y.NULL_CHARACTER_TOKEN]: At,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: ce,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: ce,
    [y.END_TAG_TOKEN]: _6,
    [y.EOF_TOKEN]: k6
  },
  [ut]: {
    [y.CHARACTER_TOKEN]: vn,
    [y.NULL_CHARACTER_TOKEN]: vn,
    [y.WHITESPACE_CHARACTER_TOKEN]: vn,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: ac,
    [y.END_TAG_TOKEN]: lc,
    [y.EOF_TOKEN]: Rn
  },
  [C9]: {
    [y.CHARACTER_TOKEN]: B6,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: P6,
    [y.COMMENT_TOKEN]: cs,
    [y.DOCTYPE_TOKEN]: cs,
    [y.START_TAG_TOKEN]: cs,
    [y.END_TAG_TOKEN]: cs,
    [y.EOF_TOKEN]: cs
  },
  [Ya]: {
    [y.CHARACTER_TOKEN]: xo,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: F6,
    [y.END_TAG_TOKEN]: H6,
    [y.EOF_TOKEN]: Rn
  },
  [Ks]: {
    [y.CHARACTER_TOKEN]: Na,
    [y.NULL_CHARACTER_TOKEN]: Na,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: U6,
    [y.END_TAG_TOKEN]: q6,
    [y.EOF_TOKEN]: Rn
  },
  [Gt]: {
    [y.CHARACTER_TOKEN]: vn,
    [y.NULL_CHARACTER_TOKEN]: vn,
    [y.WHITESPACE_CHARACTER_TOKEN]: vn,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: z6,
    [y.END_TAG_TOKEN]: $6,
    [y.EOF_TOKEN]: Rn
  },
  [zn]: {
    [y.CHARACTER_TOKEN]: vn,
    [y.NULL_CHARACTER_TOKEN]: vn,
    [y.WHITESPACE_CHARACTER_TOKEN]: vn,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: G6,
    [y.END_TAG_TOKEN]: j6,
    [y.EOF_TOKEN]: Rn
  },
  [Qa]: {
    [y.CHARACTER_TOKEN]: xo,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: V6,
    [y.END_TAG_TOKEN]: K6,
    [y.EOF_TOKEN]: Rn
  },
  [rc]: {
    [y.CHARACTER_TOKEN]: At,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: N9,
    [y.END_TAG_TOKEN]: _9,
    [y.EOF_TOKEN]: Rn
  },
  [ic]: {
    [y.CHARACTER_TOKEN]: At,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: W6,
    [y.END_TAG_TOKEN]: Y6,
    [y.EOF_TOKEN]: Rn
  },
  [Sa]: {
    [y.CHARACTER_TOKEN]: xo,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: Q6,
    [y.END_TAG_TOKEN]: J6,
    [y.EOF_TOKEN]: k9
  },
  [sc]: {
    [y.CHARACTER_TOKEN]: _a,
    [y.NULL_CHARACTER_TOKEN]: _a,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: Uy,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: X6,
    [y.END_TAG_TOKEN]: Z6,
    [y.EOF_TOKEN]: ls
  },
  [Ja]: {
    [y.CHARACTER_TOKEN]: ce,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: eC,
    [y.END_TAG_TOKEN]: tC,
    [y.EOF_TOKEN]: ls
  },
  [b9]: {
    [y.CHARACTER_TOKEN]: ce,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: At,
    [y.COMMENT_TOKEN]: je,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: nC,
    [y.END_TAG_TOKEN]: rC,
    [y.EOF_TOKEN]: ls
  },
  [x9]: {
    [y.CHARACTER_TOKEN]: Bo,
    [y.NULL_CHARACTER_TOKEN]: Bo,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: Nd,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: iC,
    [y.END_TAG_TOKEN]: Bo,
    [y.EOF_TOKEN]: ls
  },
  [S9]: {
    [y.CHARACTER_TOKEN]: ce,
    [y.NULL_CHARACTER_TOKEN]: ce,
    [y.WHITESPACE_CHARACTER_TOKEN]: wr,
    [y.COMMENT_TOKEN]: Nd,
    [y.DOCTYPE_TOKEN]: ce,
    [y.START_TAG_TOKEN]: sC,
    [y.END_TAG_TOKEN]: ce,
    [y.EOF_TOKEN]: ls
  }
};
class My {
  constructor(e) {
    this.options = Ny(ky, e), this.treeAdapter = this.options.treeAdapter, this.pendingScript = null, this.options.sourceCodeLocationInfo && bd.install(this, by), this.options.onParseError && bd.install(this, xy, { onParseError: this.options.onParseError });
  }
  // API
  parse(e) {
    const n = this.treeAdapter.createDocument();
    return this._bootstrap(n, null), this.tokenizer.write(e, !0), this._runParsingLoop(null), n;
  }
  parseFragment(e, n) {
    n || (n = this.treeAdapter.createElement(p.TEMPLATE, V.HTML, []));
    const r = this.treeAdapter.createElement("documentmock", V.HTML, []);
    this._bootstrap(r, n), this.treeAdapter.getTagName(n) === p.TEMPLATE && this._pushTmplInsertionMode(Sa), this._initTokenizerForFragmentParsing(), this._insertFakeRootElement(), this._resetInsertionMode(), this._findFormInFragmentContext(), this.tokenizer.write(e, !0), this._runParsingLoop(null);
    const i = this.treeAdapter.getFirstChild(r), s = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(i, s), s;
  }
  //Bootstrap parser
  _bootstrap(e, n) {
    this.tokenizer = new y(this.options), this.stopped = !1, this.insertionMode = A9, this.originalInsertionMode = "", this.document = e, this.fragmentContext = n, this.headElement = null, this.formElement = null, this.openElements = new Cy(this.document, this.treeAdapter), this.activeFormattingElements = new Cd(this.treeAdapter), this.tmplInsertionModeStack = [], this.tmplInsertionModeStackTop = -1, this.currentTmplInsertionMode = null, this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1;
  }
  //Errors
  _err() {
  }
  //Parsing loop
  _runParsingLoop(e) {
    for (; !this.stopped; ) {
      this._setupTokenizerCDATAMode();
      const n = this.tokenizer.getNextToken();
      if (n.type === y.HIBERNATION_TOKEN)
        break;
      if (this.skipNextNewLine && (this.skipNextNewLine = !1, n.type === y.WHITESPACE_CHARACTER_TOKEN && n.chars[0] === `
`)) {
        if (n.chars.length === 1)
          continue;
        n.chars = n.chars.substr(1);
      }
      if (this._processInputToken(n), e && this.pendingScript)
        break;
    }
  }
  runParsingLoopForCurrentChunk(e, n) {
    if (this._runParsingLoop(n), n && this.pendingScript) {
      const r = this.pendingScript;
      this.pendingScript = null, n(r);
      return;
    }
    e && e();
  }
  //Text parsing
  _setupTokenizerCDATAMode() {
    const e = this._getAdjustedCurrentElement();
    this.tokenizer.allowCDATA = e && e !== this.document && this.treeAdapter.getNamespaceURI(e) !== V.HTML && !this._isIntegrationPoint(e);
  }
  _switchToTextParsing(e, n) {
    this._insertElement(e, V.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = xa;
  }
  switchToPlaintextParsing() {
    this.insertionMode = xa, this.originalInsertionMode = xn, this.tokenizer.state = y.MODE.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    do {
      if (this.treeAdapter.getTagName(e) === p.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    } while (e);
  }
  _initTokenizerForFragmentParsing() {
    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === V.HTML) {
      const e = this.treeAdapter.getTagName(this.fragmentContext);
      e === p.TITLE || e === p.TEXTAREA ? this.tokenizer.state = y.MODE.RCDATA : e === p.STYLE || e === p.XMP || e === p.IFRAME || e === p.NOEMBED || e === p.NOFRAMES || e === p.NOSCRIPT ? this.tokenizer.state = y.MODE.RAWTEXT : e === p.SCRIPT ? this.tokenizer.state = y.MODE.SCRIPT_DATA : e === p.PLAINTEXT && (this.tokenizer.state = y.MODE.PLAINTEXT);
    }
  }
  //Tree mutation
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", i = e.systemId || "";
    this.treeAdapter.setDocumentType(this.document, n, r, i);
  }
  _attachElementToTree(e) {
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const n = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.appendChild(n, e);
    }
  }
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r);
  }
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r), this.openElements.push(r);
  }
  _insertFakeElement(e) {
    const n = this.treeAdapter.createElement(e, V.HTML, []);
    this._attachElementToTree(n), this.openElements.push(n);
  }
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, V.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n), this.openElements.push(n);
  }
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(p.HTML, V.HTML, []);
    this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e);
  }
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r);
  }
  _insertCharacters(e) {
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentText(e.chars);
    else {
      const n = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.insertText(n, e.chars);
    }
  }
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  //Token processing
  _shouldProcessTokenInForeignContent(e) {
    const n = this._getAdjustedCurrentElement();
    if (!n || n === this.document)
      return !1;
    const r = this.treeAdapter.getNamespaceURI(n);
    if (r === V.HTML || this.treeAdapter.getTagName(n) === p.ANNOTATION_XML && r === V.MATHML && e.type === y.START_TAG_TOKEN && e.tagName === p.SVG)
      return !1;
    const i = e.type === y.CHARACTER_TOKEN || e.type === y.NULL_CHARACTER_TOKEN || e.type === y.WHITESPACE_CHARACTER_TOKEN;
    return (e.type === y.START_TAG_TOKEN && e.tagName !== p.MGLYPH && e.tagName !== p.MALIGNMARK || i) && this._isIntegrationPoint(n, V.MATHML) || (e.type === y.START_TAG_TOKEN || i) && this._isIntegrationPoint(n, V.HTML) ? !1 : e.type !== y.EOF_TOKEN;
  }
  _processToken(e) {
    Sd[this.insertionMode][e.type](this, e);
  }
  _processTokenInBodyMode(e) {
    Sd[xn][e.type](this, e);
  }
  _processTokenInForeignContent(e) {
    e.type === y.CHARACTER_TOKEN ? aC(this, e) : e.type === y.NULL_CHARACTER_TOKEN ? oC(this, e) : e.type === y.WHITESPACE_CHARACTER_TOKEN ? At(this, e) : e.type === y.COMMENT_TOKEN ? je(this, e) : e.type === y.START_TAG_TOKEN ? lC(this, e) : e.type === y.END_TAG_TOKEN && uC(this, e);
  }
  _processInputToken(e) {
    this._shouldProcessTokenInForeignContent(e) ? this._processTokenInForeignContent(e) : this._processToken(e), e.type === y.START_TAG_TOKEN && e.selfClosing && !e.ackSelfClosing && this._err(it.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  //Integration points
  _isIntegrationPoint(e, n) {
    const r = this.treeAdapter.getTagName(e), i = this.treeAdapter.getNamespaceURI(e), s = this.treeAdapter.getAttrList(e);
    return Cn.isIntegrationPoint(r, i, s, n);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.length;
    if (e) {
      let n = e, r = null;
      do
        if (n--, r = this.activeFormattingElements.entries[n], r.type === Cd.MARKER_ENTRY || this.openElements.contains(r.element)) {
          n++;
          break;
        }
      while (n > 0);
      for (let i = n; i < e; i++)
        r = this.activeFormattingElements.entries[i], this._insertElement(r.token, this.treeAdapter.getNamespaceURI(r.element)), r.element = this.openElements.current;
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = zn;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(p.P), this.openElements.popUntilTagNamePopped(p.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop, n = !1; e >= 0; e--) {
      let r = this.openElements.items[e];
      e === 0 && (n = !0, this.fragmentContext && (r = this.fragmentContext));
      const i = this.treeAdapter.getTagName(r), s = Dy[i];
      if (s) {
        this.insertionMode = s;
        break;
      } else if (!n && (i === p.TD || i === p.TH)) {
        this.insertionMode = Qa;
        break;
      } else if (!n && i === p.HEAD) {
        this.insertionMode = zi;
        break;
      } else if (i === p.SELECT) {
        this._resetInsertionModeForSelect(e);
        break;
      } else if (i === p.TEMPLATE) {
        this.insertionMode = this.currentTmplInsertionMode;
        break;
      } else if (i === p.HTML) {
        this.insertionMode = this.headElement ? Wa : Ka;
        break;
      } else if (n) {
        this.insertionMode = xn;
        break;
      }
    }
  }
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.items[n], i = this.treeAdapter.getTagName(r);
        if (i === p.TEMPLATE)
          break;
        if (i === p.TABLE) {
          this.insertionMode = ic;
          return;
        }
      }
    this.insertionMode = rc;
  }
  _pushTmplInsertionMode(e) {
    this.tmplInsertionModeStack.push(e), this.tmplInsertionModeStackTop++, this.currentTmplInsertionMode = e;
  }
  _popTmplInsertionMode() {
    this.tmplInsertionModeStack.pop(), this.tmplInsertionModeStackTop--, this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
  }
  //Foster parenting
  _isElementCausesFosterParenting(e) {
    const n = this.treeAdapter.getTagName(e);
    return n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR;
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
  }
  _findFosterParentingLocation() {
    const e = {
      parent: null,
      beforeElement: null
    };
    for (let n = this.openElements.stackTop; n >= 0; n--) {
      const r = this.openElements.items[n], i = this.treeAdapter.getTagName(r), s = this.treeAdapter.getNamespaceURI(r);
      if (i === p.TEMPLATE && s === V.HTML) {
        e.parent = this.treeAdapter.getTemplateContent(r);
        break;
      } else if (i === p.TABLE) {
        e.parent = this.treeAdapter.getParentNode(r), e.parent ? e.beforeElement = r : e.parent = this.openElements.items[n - 1];
        break;
      }
    }
    return e.parent || (e.parent = this.openElements.items[0]), e;
  }
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  _fosterParentText(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertTextBefore(n.parent, e, n.beforeElement) : this.treeAdapter.insertText(n.parent, e);
  }
  //Special elements
  _isSpecialElement(e) {
    const n = this.treeAdapter.getTagName(e), r = this.treeAdapter.getNamespaceURI(e);
    return Xr.SPECIAL_ELEMENTS[r][n];
  }
}
var Ry = My;
function vy(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagName) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : nn(t, e), n;
}
function Ly(t, e) {
  let n = null;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.items[r];
    if (i === e.element)
      break;
    t._isSpecialElement(i) && (n = i);
  }
  return n || (t.openElements.popUntilElementPopped(e.element), t.activeFormattingElements.removeEntry(e)), n;
}
function Py(t, e, n) {
  let r = e, i = t.openElements.getCommonAncestor(e);
  for (let s = 0, o = i; o !== n; s++, o = i) {
    i = t.openElements.getCommonAncestor(o);
    const a = t.activeFormattingElements.getElementEntry(o), l = a && s >= wy;
    !a || l ? (l && t.activeFormattingElements.removeEntry(a), t.openElements.remove(o)) : (o = By(t, a), r === e && (t.activeFormattingElements.bookmark = a), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(o, r), r = o);
  }
  return r;
}
function By(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function Fy(t, e, n) {
  if (t._isElementCausesFosterParenting(e))
    t._fosterParentElement(n);
  else {
    const r = t.treeAdapter.getTagName(e), i = t.treeAdapter.getNamespaceURI(e);
    r === p.TEMPLATE && i === V.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function Hy(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), i = n.token, s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
  t._adoptNodes(e, s), t.treeAdapter.appendChild(e, s), t.activeFormattingElements.insertElementAfterBookmark(s, n.token), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, s);
}
function sr(t, e) {
  let n;
  for (let r = 0; r < Oy && (n = vy(t, e), !!n); r++) {
    const i = Ly(t, n);
    if (!i)
      break;
    t.activeFormattingElements.bookmark = n;
    const s = Py(t, i, n.element), o = t.openElements.getCommonAncestor(n.element);
    t.treeAdapter.detachNode(s), Fy(t, o, s), Hy(t, i, n);
  }
}
function ce() {
}
function bo(t) {
  t._err(it.misplacedDoctype);
}
function je(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContent || t.openElements.current);
}
function Uy(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function Nd(t, e) {
  t._appendCommentNode(e, t.document);
}
function At(t, e) {
  t._insertCharacters(e);
}
function ls(t) {
  t.stopped = !0;
}
function qy(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? Xr.DOCUMENT_MODE.QUIRKS : xd.getDocumentMode(e);
  xd.isConforming(e) || t._err(it.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = nc;
}
function us(t, e) {
  t._err(it.missingDoctype, { beforeToken: !0 }), t.treeAdapter.setDocumentMode(t.document, Xr.DOCUMENT_MODE.QUIRKS), t.insertionMode = nc, t._processToken(e);
}
function zy(t, e) {
  e.tagName === p.HTML ? (t._insertElement(e, V.HTML), t.insertionMode = Ka) : ks(t, e);
}
function $y(t, e) {
  const n = e.tagName;
  (n === p.HTML || n === p.HEAD || n === p.BODY || n === p.BR) && ks(t, e);
}
function ks(t, e) {
  t._insertFakeRootElement(), t.insertionMode = Ka, t._processToken(e);
}
function Gy(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.HEAD ? (t._insertElement(e, V.HTML), t.headElement = t.openElements.current, t.insertionMode = zi) : Os(t, e);
}
function jy(t, e) {
  const n = e.tagName;
  n === p.HEAD || n === p.BODY || n === p.HTML || n === p.BR ? Os(t, e) : t._err(it.endTagWithoutMatchingOpenElement);
}
function Os(t, e) {
  t._insertFakeElement(p.HEAD), t.headElement = t.openElements.current, t.insertionMode = zi, t._processToken(e);
}
function Je(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META ? (t._appendElement(e, V.HTML), e.ackSelfClosing = !0) : n === p.TITLE ? t._switchToTextParsing(e, y.MODE.RCDATA) : n === p.NOSCRIPT ? t.options.scriptingEnabled ? t._switchToTextParsing(e, y.MODE.RAWTEXT) : (t._insertElement(e, V.HTML), t.insertionMode = y9) : n === p.NOFRAMES || n === p.STYLE ? t._switchToTextParsing(e, y.MODE.RAWTEXT) : n === p.SCRIPT ? t._switchToTextParsing(e, y.MODE.SCRIPT_DATA) : n === p.TEMPLATE ? (t._insertTemplate(e, V.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = Sa, t._pushTmplInsertionMode(Sa)) : n === p.HEAD ? t._err(it.misplacedStartTagForHeadElement) : ws(t, e);
}
function Zr(t, e) {
  const n = e.tagName;
  n === p.HEAD ? (t.openElements.pop(), t.insertionMode = Wa) : n === p.BODY || n === p.BR || n === p.HTML ? ws(t, e) : n === p.TEMPLATE && t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagName !== p.TEMPLATE && t._err(it.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(p.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t._popTmplInsertionMode(), t._resetInsertionMode()) : t._err(it.endTagWithoutMatchingOpenElement);
}
function ws(t, e) {
  t.openElements.pop(), t.insertionMode = Wa, t._processToken(e);
}
function Vy(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.BASEFONT || n === p.BGSOUND || n === p.HEAD || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.STYLE ? Je(t, e) : n === p.NOSCRIPT ? t._err(it.nestedNoscriptInHead) : Ds(t, e);
}
function Ky(t, e) {
  const n = e.tagName;
  n === p.NOSCRIPT ? (t.openElements.pop(), t.insertionMode = zi) : n === p.BR ? Ds(t, e) : t._err(it.endTagWithoutMatchingOpenElement);
}
function Ds(t, e) {
  const n = e.type === y.EOF_TOKEN ? it.openElementsLeftAfterEof : it.disallowedContentInNoscriptInHead;
  t._err(n), t.openElements.pop(), t.insertionMode = zi, t._processToken(e);
}
function Wy(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.BODY ? (t._insertElement(e, V.HTML), t.framesetOk = !1, t.insertionMode = xn) : n === p.FRAMESET ? (t._insertElement(e, V.HTML), t.insertionMode = Ja) : n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.SCRIPT || n === p.STYLE || n === p.TEMPLATE || n === p.TITLE ? (t._err(it.abandonedHeadElementChild), t.openElements.push(t.headElement), Je(t, e), t.openElements.remove(t.headElement)) : n === p.HEAD ? t._err(it.misplacedStartTagForHeadElement) : Is(t, e);
}
function Yy(t, e) {
  const n = e.tagName;
  n === p.BODY || n === p.HTML || n === p.BR ? Is(t, e) : n === p.TEMPLATE ? Zr(t, e) : t._err(it.endTagWithoutMatchingOpenElement);
}
function Is(t, e) {
  t._insertFakeElement(p.BODY), t.insertionMode = xn, t._processToken(e);
}
function wr(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function xo(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function Qy(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function Jy(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function Xy(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, V.HTML), t.insertionMode = Ja);
}
function Mn(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML);
}
function Zy(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement();
  const n = t.openElements.currentTagName;
  (n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6) && t.openElements.pop(), t._insertElement(e, V.HTML);
}
function _d(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function e6(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML), n || (t.formElement = t.openElements.current));
}
function t6(t, e) {
  t.framesetOk = !1;
  const n = e.tagName;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.items[r], s = t.treeAdapter.getTagName(i);
    let o = null;
    if (n === p.LI && s === p.LI ? o = p.LI : (n === p.DD || n === p.DT) && (s === p.DD || s === p.DT) && (o = s), o) {
      t.openElements.generateImpliedEndTagsWithExclusion(o), t.openElements.popUntilTagNamePopped(o);
      break;
    }
    if (s !== p.ADDRESS && s !== p.DIV && s !== p.P && t._isSpecialElement(i))
      break;
  }
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML);
}
function n6(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML), t.tokenizer.state = y.MODE.PLAINTEXT;
}
function r6(t, e) {
  t.openElements.hasInScope(p.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML), t.framesetOk = !1;
}
function i6(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(p.A);
  n && (sr(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function ci(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function s6(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(p.NOBR) && (sr(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, V.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function kd(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function o6(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== Xr.DOCUMENT_MODE.QUIRKS && t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML), t.framesetOk = !1, t.insertionMode = ut;
}
function Ti(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, V.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function a6(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, V.HTML);
  const n = y.getTokenAttr(e, E9.TYPE);
  (!n || n.toLowerCase() !== T9) && (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function Od(t, e) {
  t._appendElement(e, V.HTML), e.ackSelfClosing = !0;
}
function l6(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._appendElement(e, V.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function u6(t, e) {
  e.tagName = p.IMG, Ti(t, e);
}
function c6(t, e) {
  t._insertElement(e, V.HTML), t.skipNextNewLine = !0, t.tokenizer.state = y.MODE.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = xa;
}
function f6(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, y.MODE.RAWTEXT);
}
function h6(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, y.MODE.RAWTEXT);
}
function wd(t, e) {
  t._switchToTextParsing(e, y.MODE.RAWTEXT);
}
function d6(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML), t.framesetOk = !1, t.insertionMode === ut || t.insertionMode === Ya || t.insertionMode === Gt || t.insertionMode === zn || t.insertionMode === Qa ? t.insertionMode = ic : t.insertionMode = rc;
}
function Dd(t, e) {
  t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML);
}
function Id(t, e) {
  t.openElements.hasInScope(p.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, V.HTML);
}
function p6(t, e) {
  t.openElements.hasInScope(p.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(p.RTC), t._insertElement(e, V.HTML);
}
function m6(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, V.HTML);
}
function g6(t, e) {
  t._reconstructActiveFormattingElements(), Cn.adjustTokenMathMLAttrs(e), Cn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, V.MATHML) : t._insertElement(e, V.MATHML), e.ackSelfClosing = !0;
}
function E6(t, e) {
  t._reconstructActiveFormattingElements(), Cn.adjustTokenSVGAttrs(e), Cn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, V.SVG) : t._insertElement(e, V.SVG), e.ackSelfClosing = !0;
}
function Bt(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, V.HTML);
}
function Nt(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 1:
      n === p.I || n === p.S || n === p.B || n === p.U ? ci(t, e) : n === p.P ? Mn(t, e) : n === p.A ? i6(t, e) : Bt(t, e);
      break;
    case 2:
      n === p.DL || n === p.OL || n === p.UL ? Mn(t, e) : n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6 ? Zy(t, e) : n === p.LI || n === p.DD || n === p.DT ? t6(t, e) : n === p.EM || n === p.TT ? ci(t, e) : n === p.BR ? Ti(t, e) : n === p.HR ? l6(t, e) : n === p.RB ? Id(t, e) : n === p.RT || n === p.RP ? p6(t, e) : n !== p.TH && n !== p.TD && n !== p.TR && Bt(t, e);
      break;
    case 3:
      n === p.DIV || n === p.DIR || n === p.NAV ? Mn(t, e) : n === p.PRE ? _d(t, e) : n === p.BIG ? ci(t, e) : n === p.IMG || n === p.WBR ? Ti(t, e) : n === p.XMP ? f6(t, e) : n === p.SVG ? E6(t, e) : n === p.RTC ? Id(t, e) : n !== p.COL && Bt(t, e);
      break;
    case 4:
      n === p.HTML ? Qy(t, e) : n === p.BASE || n === p.LINK || n === p.META ? Je(t, e) : n === p.BODY ? Jy(t, e) : n === p.MAIN || n === p.MENU ? Mn(t, e) : n === p.FORM ? e6(t, e) : n === p.CODE || n === p.FONT ? ci(t, e) : n === p.NOBR ? s6(t, e) : n === p.AREA ? Ti(t, e) : n === p.MATH ? g6(t, e) : n === p.MENU ? m6(t, e) : n !== p.HEAD && Bt(t, e);
      break;
    case 5:
      n === p.STYLE || n === p.TITLE ? Je(t, e) : n === p.ASIDE ? Mn(t, e) : n === p.SMALL ? ci(t, e) : n === p.TABLE ? o6(t, e) : n === p.EMBED ? Ti(t, e) : n === p.INPUT ? a6(t, e) : n === p.PARAM || n === p.TRACK ? Od(t, e) : n === p.IMAGE ? u6(t, e) : n !== p.FRAME && n !== p.TBODY && n !== p.TFOOT && n !== p.THEAD && Bt(t, e);
      break;
    case 6:
      n === p.SCRIPT ? Je(t, e) : n === p.CENTER || n === p.FIGURE || n === p.FOOTER || n === p.HEADER || n === p.HGROUP || n === p.DIALOG ? Mn(t, e) : n === p.BUTTON ? r6(t, e) : n === p.STRIKE || n === p.STRONG ? ci(t, e) : n === p.APPLET || n === p.OBJECT ? kd(t, e) : n === p.KEYGEN ? Ti(t, e) : n === p.SOURCE ? Od(t, e) : n === p.IFRAME ? h6(t, e) : n === p.SELECT ? d6(t, e) : n === p.OPTION ? Dd(t, e) : Bt(t, e);
      break;
    case 7:
      n === p.BGSOUND ? Je(t, e) : n === p.DETAILS || n === p.ADDRESS || n === p.ARTICLE || n === p.SECTION || n === p.SUMMARY ? Mn(t, e) : n === p.LISTING ? _d(t, e) : n === p.MARQUEE ? kd(t, e) : n === p.NOEMBED ? wd(t, e) : n !== p.CAPTION && Bt(t, e);
      break;
    case 8:
      n === p.BASEFONT ? Je(t, e) : n === p.FRAMESET ? Xy(t, e) : n === p.FIELDSET ? Mn(t, e) : n === p.TEXTAREA ? c6(t, e) : n === p.TEMPLATE ? Je(t, e) : n === p.NOSCRIPT ? t.options.scriptingEnabled ? wd(t, e) : Bt(t, e) : n === p.OPTGROUP ? Dd(t, e) : n !== p.COLGROUP && Bt(t, e);
      break;
    case 9:
      n === p.PLAINTEXT ? n6(t, e) : Bt(t, e);
      break;
    case 10:
      n === p.BLOCKQUOTE || n === p.FIGCAPTION ? Mn(t, e) : Bt(t, e);
      break;
    default:
      Bt(t, e);
  }
}
function T6(t) {
  t.openElements.hasInScope(p.BODY) && (t.insertionMode = sc);
}
function A6(t, e) {
  t.openElements.hasInScope(p.BODY) && (t.insertionMode = sc, t._processToken(e));
}
function Xn(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function y6(t) {
  const e = t.openElements.tmplCount > 0, n = t.formElement;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(p.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(p.FORM) : t.openElements.remove(n));
}
function C6(t) {
  t.openElements.hasInButtonScope(p.P) || t._insertFakeElement(p.P), t._closePElement();
}
function b6(t) {
  t.openElements.hasInListItemScope(p.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(p.LI), t.openElements.popUntilTagNamePopped(p.LI));
}
function x6(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function S6(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function Md(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function N6(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(p.BR), t.openElements.pop(), t.framesetOk = !1;
}
function nn(t, e) {
  const n = e.tagName;
  for (let r = t.openElements.stackTop; r > 0; r--) {
    const i = t.openElements.items[r];
    if (t.treeAdapter.getTagName(i) === n) {
      t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilElementPopped(i);
      break;
    }
    if (t._isSpecialElement(i))
      break;
  }
}
function oc(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 1:
      n === p.A || n === p.B || n === p.I || n === p.S || n === p.U ? sr(t, e) : n === p.P ? C6(t) : nn(t, e);
      break;
    case 2:
      n === p.DL || n === p.UL || n === p.OL ? Xn(t, e) : n === p.LI ? b6(t) : n === p.DD || n === p.DT ? x6(t, e) : n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6 ? S6(t) : n === p.BR ? N6(t) : n === p.EM || n === p.TT ? sr(t, e) : nn(t, e);
      break;
    case 3:
      n === p.BIG ? sr(t, e) : n === p.DIR || n === p.DIV || n === p.NAV || n === p.PRE ? Xn(t, e) : nn(t, e);
      break;
    case 4:
      n === p.BODY ? T6(t) : n === p.HTML ? A6(t, e) : n === p.FORM ? y6(t) : n === p.CODE || n === p.FONT || n === p.NOBR ? sr(t, e) : n === p.MAIN || n === p.MENU ? Xn(t, e) : nn(t, e);
      break;
    case 5:
      n === p.ASIDE ? Xn(t, e) : n === p.SMALL ? sr(t, e) : nn(t, e);
      break;
    case 6:
      n === p.CENTER || n === p.FIGURE || n === p.FOOTER || n === p.HEADER || n === p.HGROUP || n === p.DIALOG ? Xn(t, e) : n === p.APPLET || n === p.OBJECT ? Md(t, e) : n === p.STRIKE || n === p.STRONG ? sr(t, e) : nn(t, e);
      break;
    case 7:
      n === p.ADDRESS || n === p.ARTICLE || n === p.DETAILS || n === p.SECTION || n === p.SUMMARY || n === p.LISTING ? Xn(t, e) : n === p.MARQUEE ? Md(t, e) : nn(t, e);
      break;
    case 8:
      n === p.FIELDSET ? Xn(t, e) : n === p.TEMPLATE ? Zr(t, e) : nn(t, e);
      break;
    case 10:
      n === p.BLOCKQUOTE || n === p.FIGCAPTION ? Xn(t, e) : nn(t, e);
      break;
    default:
      nn(t, e);
  }
}
function Rn(t, e) {
  t.tmplInsertionModeStackTop > -1 ? k9(t, e) : t.stopped = !0;
}
function _6(t, e) {
  e.tagName === p.SCRIPT && (t.pendingScript = t.openElements.current), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function k6(t, e) {
  t._err(it.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
function vn(t, e) {
  const n = t.openElements.currentTagName;
  n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? (t.pendingCharacterTokens = [], t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = C9, t._processToken(e)) : Ft(t, e);
}
function O6(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, V.HTML), t.insertionMode = Ya;
}
function w6(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, V.HTML), t.insertionMode = Ks;
}
function D6(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(p.COLGROUP), t.insertionMode = Ks, t._processToken(e);
}
function I6(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, V.HTML), t.insertionMode = Gt;
}
function M6(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(p.TBODY), t.insertionMode = Gt, t._processToken(e);
}
function R6(t, e) {
  t.openElements.hasInTableScope(p.TABLE) && (t.openElements.popUntilTagNamePopped(p.TABLE), t._resetInsertionMode(), t._processToken(e));
}
function v6(t, e) {
  const n = y.getTokenAttr(e, E9.TYPE);
  n && n.toLowerCase() === T9 ? t._appendElement(e, V.HTML) : Ft(t, e), e.ackSelfClosing = !0;
}
function L6(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, V.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function ac(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 2:
      n === p.TD || n === p.TH || n === p.TR ? M6(t, e) : Ft(t, e);
      break;
    case 3:
      n === p.COL ? D6(t, e) : Ft(t, e);
      break;
    case 4:
      n === p.FORM ? L6(t, e) : Ft(t, e);
      break;
    case 5:
      n === p.TABLE ? R6(t, e) : n === p.STYLE ? Je(t, e) : n === p.TBODY || n === p.TFOOT || n === p.THEAD ? I6(t, e) : n === p.INPUT ? v6(t, e) : Ft(t, e);
      break;
    case 6:
      n === p.SCRIPT ? Je(t, e) : Ft(t, e);
      break;
    case 7:
      n === p.CAPTION ? O6(t, e) : Ft(t, e);
      break;
    case 8:
      n === p.COLGROUP ? w6(t, e) : n === p.TEMPLATE ? Je(t, e) : Ft(t, e);
      break;
    default:
      Ft(t, e);
  }
}
function lc(t, e) {
  const n = e.tagName;
  n === p.TABLE ? t.openElements.hasInTableScope(p.TABLE) && (t.openElements.popUntilTagNamePopped(p.TABLE), t._resetInsertionMode()) : n === p.TEMPLATE ? Zr(t, e) : n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && n !== p.TBODY && n !== p.TD && n !== p.TFOOT && n !== p.TH && n !== p.THEAD && n !== p.TR && Ft(t, e);
}
function Ft(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, t._processTokenInBodyMode(e), t.fosterParentingEnabled = n;
}
function P6(t, e) {
  t.pendingCharacterTokens.push(e);
}
function B6(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function cs(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      Ft(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
function F6(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TD || n === p.TFOOT || n === p.TH || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(p.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = ut, t._processToken(e)) : Nt(t, e);
}
function H6(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE ? t.openElements.hasInTableScope(p.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = ut, n === p.TABLE && t._processToken(e)) : n !== p.BODY && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && n !== p.TBODY && n !== p.TD && n !== p.TFOOT && n !== p.TH && n !== p.THEAD && n !== p.TR && oc(t, e);
}
function U6(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.COL ? (t._appendElement(e, V.HTML), e.ackSelfClosing = !0) : n === p.TEMPLATE ? Je(t, e) : Na(t, e);
}
function q6(t, e) {
  const n = e.tagName;
  n === p.COLGROUP ? t.openElements.currentTagName === p.COLGROUP && (t.openElements.pop(), t.insertionMode = ut) : n === p.TEMPLATE ? Zr(t, e) : n !== p.COL && Na(t, e);
}
function Na(t, e) {
  t.openElements.currentTagName === p.COLGROUP && (t.openElements.pop(), t.insertionMode = ut, t._processToken(e));
}
function z6(t, e) {
  const n = e.tagName;
  n === p.TR ? (t.openElements.clearBackToTableBodyContext(), t._insertElement(e, V.HTML), t.insertionMode = zn) : n === p.TH || n === p.TD ? (t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(p.TR), t.insertionMode = zn, t._processToken(e)) : n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TFOOT || n === p.THEAD ? t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = ut, t._processToken(e)) : ac(t, e);
}
function $6(t, e) {
  const n = e.tagName;
  n === p.TBODY || n === p.TFOOT || n === p.THEAD ? t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = ut) : n === p.TABLE ? t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = ut, t._processToken(e)) : (n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP || n !== p.HTML && n !== p.TD && n !== p.TH && n !== p.TR) && lc(t, e);
}
function G6(t, e) {
  const n = e.tagName;
  n === p.TH || n === p.TD ? (t.openElements.clearBackToTableRowContext(), t._insertElement(e, V.HTML), t.insertionMode = Qa, t.activeFormattingElements.insertMarker()) : n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Gt, t._processToken(e)) : ac(t, e);
}
function j6(t, e) {
  const n = e.tagName;
  n === p.TR ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Gt) : n === p.TABLE ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Gt, t._processToken(e)) : n === p.TBODY || n === p.TFOOT || n === p.THEAD ? (t.openElements.hasInTableScope(n) || t.openElements.hasInTableScope(p.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Gt, t._processToken(e)) : (n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP || n !== p.HTML && n !== p.TD && n !== p.TH) && lc(t, e);
}
function V6(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TD || n === p.TFOOT || n === p.TH || n === p.THEAD || n === p.TR ? (t.openElements.hasInTableScope(p.TD) || t.openElements.hasInTableScope(p.TH)) && (t._closeTableCell(), t._processToken(e)) : Nt(t, e);
}
function K6(t, e) {
  const n = e.tagName;
  n === p.TD || n === p.TH ? t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = zn) : n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(n) && (t._closeTableCell(), t._processToken(e)) : n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && oc(t, e);
}
function N9(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.OPTION ? (t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t._insertElement(e, V.HTML)) : n === p.OPTGROUP ? (t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t.openElements.currentTagName === p.OPTGROUP && t.openElements.pop(), t._insertElement(e, V.HTML)) : n === p.INPUT || n === p.KEYGEN || n === p.TEXTAREA || n === p.SELECT ? t.openElements.hasInSelectScope(p.SELECT) && (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), n !== p.SELECT && t._processToken(e)) : (n === p.SCRIPT || n === p.TEMPLATE) && Je(t, e);
}
function _9(t, e) {
  const n = e.tagName;
  if (n === p.OPTGROUP) {
    const r = t.openElements.items[t.openElements.stackTop - 1], i = r && t.treeAdapter.getTagName(r);
    t.openElements.currentTagName === p.OPTION && i === p.OPTGROUP && t.openElements.pop(), t.openElements.currentTagName === p.OPTGROUP && t.openElements.pop();
  } else
    n === p.OPTION ? t.openElements.currentTagName === p.OPTION && t.openElements.pop() : n === p.SELECT && t.openElements.hasInSelectScope(p.SELECT) ? (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode()) : n === p.TEMPLATE && Zr(t, e);
}
function W6(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR || n === p.TD || n === p.TH ? (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), t._processToken(e)) : N9(t, e);
}
function Y6(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR || n === p.TD || n === p.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), t._processToken(e)) : _9(t, e);
}
function Q6(t, e) {
  const n = e.tagName;
  if (n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.SCRIPT || n === p.STYLE || n === p.TEMPLATE || n === p.TITLE)
    Je(t, e);
  else {
    const r = Iy[n] || xn;
    t._popTmplInsertionMode(), t._pushTmplInsertionMode(r), t.insertionMode = r, t._processToken(e);
  }
}
function J6(t, e) {
  e.tagName === p.TEMPLATE && Zr(t, e);
}
function k9(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(p.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t._popTmplInsertionMode(), t._resetInsertionMode(), t._processToken(e)) : t.stopped = !0;
}
function X6(t, e) {
  e.tagName === p.HTML ? Nt(t, e) : _a(t, e);
}
function Z6(t, e) {
  e.tagName === p.HTML ? t.fragmentContext || (t.insertionMode = x9) : _a(t, e);
}
function _a(t, e) {
  t.insertionMode = xn, t._processToken(e);
}
function eC(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.FRAMESET ? t._insertElement(e, V.HTML) : n === p.FRAME ? (t._appendElement(e, V.HTML), e.ackSelfClosing = !0) : n === p.NOFRAMES && Je(t, e);
}
function tC(t, e) {
  e.tagName === p.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagName !== p.FRAMESET && (t.insertionMode = b9));
}
function nC(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.NOFRAMES && Je(t, e);
}
function rC(t, e) {
  e.tagName === p.HTML && (t.insertionMode = S9);
}
function iC(t, e) {
  e.tagName === p.HTML ? Nt(t, e) : Bo(t, e);
}
function Bo(t, e) {
  t.insertionMode = xn, t._processToken(e);
}
function sC(t, e) {
  const n = e.tagName;
  n === p.HTML ? Nt(t, e) : n === p.NOFRAMES && Je(t, e);
}
function oC(t, e) {
  e.chars = _y.REPLACEMENT_CHARACTER, t._insertCharacters(e);
}
function aC(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function lC(t, e) {
  if (Cn.causesExit(e) && !t.fragmentContext) {
    for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== V.HTML && !t._isIntegrationPoint(t.openElements.current); )
      t.openElements.pop();
    t._processToken(e);
  } else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === V.MATHML ? Cn.adjustTokenMathMLAttrs(e) : r === V.SVG && (Cn.adjustTokenSVGTagName(e), Cn.adjustTokenSVGAttrs(e)), Cn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function uC(t, e) {
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === V.HTML) {
      t._processToken(e);
      break;
    }
    if (t.treeAdapter.getTagName(r).toLowerCase() === e.tagName) {
      t.openElements.popUntilElementPopped(r);
      break;
    }
  }
}
const O9 = Ry;
class Ws {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(e, n, r) {
    this.property = e, this.normal = n, r && (this.space = r);
  }
}
Ws.prototype.property = {};
Ws.prototype.normal = {};
Ws.prototype.space = null;
function w9(t, e) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < t.length; )
    Object.assign(n, t[i].property), Object.assign(r, t[i].normal);
  return new Ws(n, r, e);
}
function qs(t) {
  return t.toLowerCase();
}
class Qt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(e, n) {
    this.property = e, this.attribute = n;
  }
}
Qt.prototype.space = null;
Qt.prototype.boolean = !1;
Qt.prototype.booleanish = !1;
Qt.prototype.overloadedBoolean = !1;
Qt.prototype.number = !1;
Qt.prototype.commaSeparated = !1;
Qt.prototype.spaceSeparated = !1;
Qt.prototype.commaOrSpaceSeparated = !1;
Qt.prototype.mustUseProperty = !1;
Qt.prototype.defined = !1;
let cC = 0;
const ie = ei(), ze = ei(), D9 = ei(), F = ei(), De = ei(), Ii = ei(), wt = ei();
function ei() {
  return 2 ** ++cC;
}
const pu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ie,
  booleanish: ze,
  commaOrSpaceSeparated: wt,
  commaSeparated: Ii,
  number: F,
  overloadedBoolean: D9,
  spaceSeparated: De
}, Symbol.toStringTag, { value: "Module" })), p1 = Object.keys(pu);
class uc extends Qt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), Rd(this, "space", i), typeof r == "number")
      for (; ++s < p1.length; ) {
        const o = p1[s];
        Rd(this, p1[s], (r & pu[o]) === pu[o]);
      }
  }
}
uc.prototype.defined = !0;
function Rd(t, e, n) {
  n && (t[e] = n);
}
const fC = {}.hasOwnProperty;
function $i(t) {
  const e = {}, n = {};
  let r;
  for (r in t.properties)
    if (fC.call(t.properties, r)) {
      const i = t.properties[r], s = new uc(
        r,
        t.transform(t.attributes || {}, r),
        i,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[qs(r)] = r, n[qs(s.attribute)] = r;
    }
  return new Ws(e, n, t.space);
}
const I9 = $i({
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), M9 = $i({
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function R9(t, e) {
  return e in t ? t[e] : e;
}
function v9(t, e) {
  return R9(t, e.toLowerCase());
}
const L9 = $i({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: v9,
  properties: { xmlns: null, xmlnsXLink: null }
}), P9 = $i({
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ze,
    ariaAutoComplete: null,
    ariaBusy: ze,
    ariaChecked: ze,
    ariaColCount: F,
    ariaColIndex: F,
    ariaColSpan: F,
    ariaControls: De,
    ariaCurrent: null,
    ariaDescribedBy: De,
    ariaDetails: null,
    ariaDisabled: ze,
    ariaDropEffect: De,
    ariaErrorMessage: null,
    ariaExpanded: ze,
    ariaFlowTo: De,
    ariaGrabbed: ze,
    ariaHasPopup: null,
    ariaHidden: ze,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: De,
    ariaLevel: F,
    ariaLive: null,
    ariaModal: ze,
    ariaMultiLine: ze,
    ariaMultiSelectable: ze,
    ariaOrientation: null,
    ariaOwns: De,
    ariaPlaceholder: null,
    ariaPosInSet: F,
    ariaPressed: ze,
    ariaReadOnly: ze,
    ariaRelevant: null,
    ariaRequired: ze,
    ariaRoleDescription: De,
    ariaRowCount: F,
    ariaRowIndex: F,
    ariaRowSpan: F,
    ariaSelected: ze,
    ariaSetSize: F,
    ariaSort: null,
    ariaValueMax: F,
    ariaValueMin: F,
    ariaValueNow: F,
    ariaValueText: null,
    role: null
  }
}), hC = $i({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: v9,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ii,
    acceptCharset: De,
    accessKey: De,
    action: null,
    allow: null,
    allowFullScreen: ie,
    allowPaymentRequest: ie,
    allowUserMedia: ie,
    alt: null,
    as: null,
    async: ie,
    autoCapitalize: null,
    autoComplete: De,
    autoFocus: ie,
    autoPlay: ie,
    capture: ie,
    charSet: null,
    checked: ie,
    cite: null,
    className: De,
    cols: F,
    colSpan: null,
    content: null,
    contentEditable: ze,
    controls: ie,
    controlsList: De,
    coords: F | Ii,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ie,
    defer: ie,
    dir: null,
    dirName: null,
    disabled: ie,
    download: D9,
    draggable: ze,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ie,
    formTarget: null,
    headers: De,
    height: F,
    hidden: ie,
    high: F,
    href: null,
    hrefLang: null,
    htmlFor: De,
    httpEquiv: De,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ie,
    itemId: null,
    itemProp: De,
    itemRef: De,
    itemScope: ie,
    itemType: De,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ie,
    low: F,
    manifest: null,
    max: null,
    maxLength: F,
    media: null,
    method: null,
    min: null,
    minLength: F,
    multiple: ie,
    muted: ie,
    name: null,
    nonce: null,
    noModule: ie,
    noValidate: ie,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ie,
    optimum: F,
    pattern: null,
    ping: De,
    placeholder: null,
    playsInline: ie,
    poster: null,
    preload: null,
    readOnly: ie,
    referrerPolicy: null,
    rel: De,
    required: ie,
    reversed: ie,
    rows: F,
    rowSpan: F,
    sandbox: De,
    scope: null,
    scoped: ie,
    seamless: ie,
    selected: ie,
    shape: null,
    size: F,
    sizes: null,
    slot: null,
    span: F,
    spellCheck: ze,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: F,
    step: null,
    style: null,
    tabIndex: F,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ie,
    useMap: null,
    value: ze,
    width: F,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: De,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: F,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: F,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ie,
    // Lists. Use CSS to reduce space between items instead
    declare: ie,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: F,
    // `<img>` and `<object>`
    leftMargin: F,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: F,
    // `<body>`
    marginWidth: F,
    // `<body>`
    noResize: ie,
    // `<frame>`
    noHref: ie,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ie,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ie,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: F,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ze,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: F,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: F,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ie,
    disableRemotePlayback: ie,
    prefix: null,
    property: null,
    results: F,
    security: null,
    unselectable: null
  }
}), dC = $i({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: R9,
  properties: {
    about: wt,
    accentHeight: F,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: F,
    amplitude: F,
    arabicForm: null,
    ascent: F,
    attributeName: null,
    attributeType: null,
    azimuth: F,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: F,
    by: null,
    calcMode: null,
    capHeight: F,
    className: De,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: F,
    diffuseConstant: F,
    direction: null,
    display: null,
    dur: null,
    divisor: F,
    dominantBaseline: null,
    download: ie,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: F,
    enableBackground: null,
    end: null,
    event: null,
    exponent: F,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: F,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ii,
    g2: Ii,
    glyphName: Ii,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: F,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: F,
    horizOriginX: F,
    horizOriginY: F,
    id: null,
    ideographic: F,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: F,
    k: F,
    k1: F,
    k2: F,
    k3: F,
    k4: F,
    kernelMatrix: wt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: F,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: F,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: F,
    overlineThickness: F,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: F,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: De,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: F,
    pointsAtY: F,
    pointsAtZ: F,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: wt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: wt,
    rev: wt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: wt,
    requiredFeatures: wt,
    requiredFonts: wt,
    requiredFormats: wt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: F,
    specularExponent: F,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: F,
    strikethroughThickness: F,
    string: null,
    stroke: null,
    strokeDashArray: wt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: F,
    strokeOpacity: F,
    strokeWidth: null,
    style: null,
    surfaceScale: F,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: wt,
    tabIndex: F,
    tableValues: null,
    target: null,
    targetX: F,
    targetY: F,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: wt,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: F,
    underlineThickness: F,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: F,
    values: null,
    vAlphabetic: F,
    vMathematical: F,
    vectorEffect: null,
    vHanging: F,
    vIdeographic: F,
    version: null,
    vertAdvY: F,
    vertOriginX: F,
    vertOriginY: F,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: F,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), pC = /^data[-\w.:]+$/i, vd = /-[a-z]/g, mC = /[A-Z]/g;
function Ys(t, e) {
  const n = qs(e);
  let r = e, i = Qt;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && pC.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(vd, EC);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!vd.test(s)) {
        let o = s.replace(mC, gC);
        o.charAt(0) !== "-" && (o = "-" + o), e = "data" + o;
      }
    }
    i = uc;
  }
  return new i(r, e);
}
function gC(t) {
  return "-" + t.toLowerCase();
}
function EC(t) {
  return t.charAt(1).toUpperCase();
}
const Gi = w9([M9, I9, L9, P9, hC], "html"), Gn = w9([M9, I9, L9, P9, dC], "svg"), Ld = /[#.]/g;
function TC(t, e) {
  const n = t || "", r = {};
  let i = 0, s, o;
  for (; i < n.length; ) {
    Ld.lastIndex = i;
    const a = Ld.exec(n), l = n.slice(i, a ? a.index : n.length);
    l && (s ? s === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : o = l, i += l.length), a && (s = a[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: fine.
    tagName: o || e || "div",
    properties: r,
    children: []
  };
}
function Pd(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function cc(t) {
  return t.join(" ").trim();
}
function mu(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), i = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = n.length, s = !0);
    const o = n.slice(i, r).trim();
    (o || !s) && e.push(o), i = r + 1, r = n.indexOf(",", i);
  }
  return e;
}
function fc(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const AC = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]), gu = {}.hasOwnProperty;
function B9(t, e, n) {
  const r = n && xC(n);
  return (
    /**
     * @type {{
     *   (): Root
     *   (selector: null | undefined, ...children: Array<HChild>): Root
     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
     *   (selector: string, ...children: Array<HChild>): Element
     * }}
     */
    /**
     * Hyperscript compatible DSL for creating virtual hast trees.
     *
     * @param {string | null} [selector]
     * @param {HProperties | HChild} [properties]
     * @param {Array<HChild>} children
     * @returns {HResult}
     */
    function(s, o, ...a) {
      let l = -1, u;
      if (s == null)
        u = { type: "root", children: [] }, a.unshift(o);
      else if (u = TC(s, e), u.tagName = u.tagName.toLowerCase(), r && gu.call(r, u.tagName) && (u.tagName = r[u.tagName]), yC(o, u.tagName)) {
        let c;
        for (c in o)
          gu.call(o, c) && CC(t, u.properties, c, o[c]);
      } else
        a.unshift(o);
      for (; ++l < a.length; )
        Eu(u.children, a[l]);
      return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
    }
  );
}
function yC(t, e) {
  return t == null || typeof t != "object" || Array.isArray(t) ? !1 : e === "input" || !t.type || typeof t.type != "string" ? !0 : "children" in t && Array.isArray(t.children) ? !1 : e === "button" ? AC.has(t.type.toLowerCase()) : !("value" in t);
}
function CC(t, e, n, r) {
  const i = Ys(t, n);
  let s = -1, o;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r))
        return;
      o = r;
    } else
      typeof r == "boolean" ? o = r : typeof r == "string" ? i.spaceSeparated ? o = Pd(r) : i.commaSeparated ? o = mu(r) : i.commaOrSpaceSeparated ? o = Pd(mu(r).join(" ")) : o = Bd(i, i.property, r) : Array.isArray(r) ? o = r.concat() : o = i.property === "style" ? bC(r) : String(r);
    if (Array.isArray(o)) {
      const a = [];
      for (; ++s < o.length; )
        a[s] = Bd(i, i.property, o[s]);
      o = a;
    }
    i.property === "className" && Array.isArray(e.className) && (o = e.className.concat(o)), e[i.property] = o;
  }
}
function Eu(t, e) {
  let n = -1;
  if (e != null)
    if (typeof e == "string" || typeof e == "number")
      t.push({ type: "text", value: String(e) });
    else if (Array.isArray(e))
      for (; ++n < e.length; )
        Eu(t, e[n]);
    else if (typeof e == "object" && "type" in e)
      e.type === "root" ? Eu(t, e.children) : t.push(e);
    else
      throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function Bd(t, e, n) {
  if (typeof n == "string") {
    if (t.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((t.boolean || t.overloadedBoolean) && (n === "" || qs(n) === qs(e)))
      return !0;
  }
  return n;
}
function bC(t) {
  const e = [];
  let n;
  for (n in t)
    gu.call(t, n) && e.push([n, t[n]].join(": "));
  return e.join("; ");
}
function xC(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    e[t[n].toLowerCase()] = t[n];
  return e;
}
const F9 = B9(Gi, "div"), SC = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], NC = B9(Gn, "g", SC);
function _C(t) {
  const e = String(t), n = [], r = /\r?\n|\r/g;
  for (; r.test(e); )
    n.push(r.lastIndex);
  return n.push(e.length + 1), { toPoint: i, toOffset: s };
  function i(o) {
    let a = -1;
    if (typeof o == "number" && o > -1 && o < n[n.length - 1]) {
      for (; ++a < n.length; )
        if (n[a] > o)
          return {
            line: a + 1,
            column: o - (a > 0 ? n[a - 1] : 0) + 1,
            offset: o
          };
    }
    return { line: void 0, column: void 0, offset: void 0 };
  }
  function s(o) {
    const a = o && o.line, l = o && o.column;
    if (typeof a == "number" && typeof l == "number" && !Number.isNaN(a) && !Number.isNaN(l) && a - 1 in n) {
      const u = (n[a - 2] || 0) + l - 1 || 0;
      if (u > -1 && u < n[n.length - 1])
        return u;
    }
    return -1;
  }
}
const zs = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, H9 = {}.hasOwnProperty, kC = Object.prototype;
function U9(t, e) {
  const n = e || {};
  let r, i;
  return DC(n) ? (i = n, r = {}) : (i = n.file || void 0, r = n), hc(
    {
      schema: r.space === "svg" ? Gn : Gi,
      file: i,
      verbose: r.verbose,
      location: !1
    },
    t
  );
}
function hc(t, e) {
  let n;
  switch (e.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        e
      );
      return n = { type: "comment", value: r.data }, Fo(t, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        e
      ), i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: q9(t, e.childNodes),
        data: { quirksMode: i }
      }, t.file && t.location) {
        const s = String(t.file), o = _C(s), a = o.toPoint(0), l = o.toPoint(s.length);
        n.position = { start: a, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        e
      );
      return n = { type: "doctype" }, Fo(t, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        e
      );
      return n = { type: "text", value: r.value }, Fo(t, r, n), n;
    }
    default:
      return n = OC(
        t,
        /** @type {P5Element} */
        e
      ), n;
  }
}
function q9(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    r[n] = hc(t, e[n]);
  return r;
}
function OC(t, e) {
  const n = t.schema;
  t.schema = e.namespaceURI === zs.svg ? Gn : Gi;
  let r = -1;
  const i = {};
  for (; ++r < e.attrs.length; ) {
    const a = e.attrs[r], l = (a.prefix ? a.prefix + ":" : "") + a.name;
    H9.call(kC, l) || (i[l] = a.value);
  }
  const o = (t.schema.space === "svg" ? NC : F9)(e.tagName, i, q9(t, e.childNodes));
  if (Fo(t, e, o), o.tagName === "template") {
    const a = (
      /** @type {P5Template} */
      e
    ), l = a.sourceCodeLocation, u = l && l.startTag && Si(l.startTag), c = l && l.endTag && Si(l.endTag), f = hc(t, a.content);
    u && c && t.file && (f.position = { start: u.end, end: c.start }), o.content = f;
  }
  return t.schema = n, o;
}
function Fo(t, e, n) {
  if ("sourceCodeLocation" in e && e.sourceCodeLocation && t.file) {
    const r = wC(t, n, e.sourceCodeLocation);
    r && (t.location = !0, n.position = r);
  }
}
function wC(t, e, n) {
  const r = Si(n);
  if (e.type === "element") {
    const i = e.children[e.children.length - 1];
    if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), t.verbose) {
      const s = {};
      let o;
      if (n.attrs)
        for (o in n.attrs)
          H9.call(n.attrs, o) && (s[Ys(t.schema, o).property] = Si(
            n.attrs[o]
          ));
      e.data = {
        position: {
          // @ts-expect-error: assume not `undefined`.
          opening: Si(n.startTag),
          closing: n.endTag ? Si(n.endTag) : null,
          properties: s
        }
      };
    }
  }
  return r;
}
function Si(t) {
  const e = Fd({
    line: t.startLine,
    column: t.startCol,
    offset: t.startOffset
  }), n = Fd({
    line: t.endLine,
    column: t.endCol,
    offset: t.endOffset
  });
  return e || n ? { start: e, end: n } : void 0;
}
function Fd(t) {
  return t.line && t.column ? t : void 0;
}
function DC(t) {
  return "messages" in t;
}
const IC = {
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: !1
  },
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: !1
  },
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: !1
  },
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: !1
  },
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: !1
  },
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: !1
  },
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: !1
  },
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: !1
  },
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: !1
  },
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: !1
  },
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: !1
  },
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
}, MC = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-", RC = { 2: !0, 1: !1, 0: null };
function z9(t) {
  const e = (
    /** @type {Options} */
    this.data("settings")
  ), n = Object.assign({}, e, t);
  Object.assign(this, { Parser: r });
  function r(i, s) {
    const o = n.fragment ? "parseFragment" : "parse", a = n.emitParseErrors ? u : null, l = new O9({
      sourceCodeLocationInfo: !0,
      onParseError: a,
      scriptingEnabled: !1
    });
    return U9(l[o](i), {
      space: n.space,
      file: s,
      verbose: n.verbose
    });
    function u(c) {
      const f = c.code, h = vC(f), d = n[h], m = d ?? !0, g = typeof m == "number" ? m : m ? 1 : 0, E = {
        line: c.startLine,
        column: c.startCol,
        offset: c.startOffset
      }, T = {
        line: c.endLine,
        column: c.endCol,
        offset: c.endOffset
      };
      if (g) {
        const _ = IC[h] || { reason: "", description: "", url: "" }, R = s.message(k(_.reason), { start: E, end: T });
        R.source = "parse-error", R.ruleId = f, R.fatal = RC[g], R.note = k(_.description), R.url = "url" in _ && _.url === !1 ? null : MC + f;
      }
      function k(_) {
        return _.replace(/%c(?:-(\d+))?/g, (R, M) => {
          const N = M ? -Number.parseInt(M, 10) : 0, S = i.charAt(c.startOffset + N);
          return S === "`" ? "` ` `" : S;
        }).replace(
          /%x/g,
          () => "0x" + i.charCodeAt(c.startOffset).toString(16).toUpperCase()
        );
      }
    }
  }
}
function vC(t) {
  return t.replace(/-[a-z]/g, (e) => e.charAt(1).toUpperCase());
}
const mr = (
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [node]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parent | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(t, e, n, r, i) {
    const s = _e(e);
    if (n != null && (typeof n != "number" || n < 0 || n === Number.POSITIVE_INFINITY))
      throw new Error("Expected positive finite index for child node");
    if (r != null && (!r.type || !r.children))
      throw new Error("Expected parent node");
    if (!t || !t.type || typeof t.type != "string")
      return !1;
    if (r == null != (n == null))
      throw new Error("Expected both parent and index");
    return s.call(i, t, n, r);
  }
), _e = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(t) {
    if (t == null)
      return dc;
    if (typeof t == "string")
      return PC(t);
    if (typeof t == "object")
      return LC(t);
    if (typeof t == "function")
      return $9(t);
    throw new Error("Expected function, string, or array as test");
  }
);
function LC(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = _e(t[n]);
  return $9(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].call(this, ...i))
        return !0;
    return !1;
  }
}
function PC(t) {
  return e;
  function e(n) {
    return dc(n) && n.tagName === t;
  }
}
function $9(t) {
  return e;
  function e(n, ...r) {
    return dc(n) && Boolean(t.call(this, n, ...r));
  }
}
function dc(t) {
  return Boolean(
    t && typeof t == "object" && // @ts-expect-error Looks like a node.
    t.type === "element" && // @ts-expect-error Looks like an element.
    typeof t.tagName == "string"
  );
}
const pc = _e([
  "audio",
  "canvas",
  "embed",
  "iframe",
  "img",
  "math",
  "object",
  "picture",
  "svg",
  "video"
]), ji = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(t) {
    if (t == null)
      return UC;
    if (typeof t == "string")
      return HC(t);
    if (typeof t == "object")
      return Array.isArray(t) ? BC(t) : FC(t);
    if (typeof t == "function")
      return Xa(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function BC(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = ji(t[n]);
  return Xa(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].call(this, ...i))
        return !0;
    return !1;
  }
}
function FC(t) {
  return Xa(e);
  function e(n) {
    let r;
    for (r in t)
      if (n[r] !== t[r])
        return !1;
    return !0;
  }
}
function HC(t) {
  return Xa(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Xa(t) {
  return e;
  function e(n, ...r) {
    return Boolean(
      n && typeof n == "object" && "type" in n && // @ts-expect-error: fine.
      Boolean(t.call(this, n, ...r))
    );
  }
}
function UC() {
  return !0;
}
function gr(t) {
  const e = (
    // @ts-expect-error looks like a node.
    t && typeof t == "object" && t.type === "text" ? (
      // @ts-expect-error looks like a text.
      t.value || ""
    ) : t
  );
  return typeof e == "string" && e.replace(/[ \t\n\f\r]/g, "") === "";
}
const qC = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
], zC = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
], $C = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
], mc = ji(["doctype", "comment"]);
function G9(t = {}) {
  const e = QC(
    t.newlines ? WC : YC
  );
  return (n) => {
    j9(n, { collapse: e, whitespace: "normal" });
  };
}
function j9(t, e) {
  if ("children" in t) {
    const n = Object.assign({}, e);
    return (t.type === "root" || W9(t)) && (n.before = !0, n.after = !0), n.whitespace = JC(t, e), jC(t, n);
  }
  if (t.type === "text") {
    if (e.whitespace === "normal")
      return GC(t, e);
    e.whitespace === "nowrap" && (t.value = e.collapse(t.value));
  }
  return { remove: !1, ignore: mc(t), stripAtStart: !1 };
}
function GC(t, e) {
  const n = e.collapse(t.value), r = { remove: !1, ignore: !1, stripAtStart: !1 };
  let i = 0, s = n.length;
  return e.before && Hd(n.charAt(0)) && i++, i !== s && Hd(n.charAt(s - 1)) && (e.after ? s-- : r.stripAtStart = !0), i === s ? r.remove = !0 : t.value = n.slice(i, s), r;
}
function jC(t, e) {
  let n = e.before;
  const r = e.after, i = t.children;
  let s = i.length, o = -1;
  for (; ++o < s; ) {
    const a = j9(
      i[o],
      Object.assign({}, e, {
        before: n,
        after: V9(i, o, r)
      })
    );
    a.remove ? (i.splice(o, 1), o--, s--) : a.ignore || (n = a.stripAtStart), K9(i[o]) && (n = !1);
  }
  return { remove: !1, ignore: !1, stripAtStart: Boolean(n || r) };
}
function V9(t, e, n) {
  for (; ++e < t.length; ) {
    const r = t[e];
    let i = VC(r);
    if (i === void 0 && "children" in r && !KC(r) && (i = V9(r.children, -1)), typeof i == "boolean")
      return i;
  }
  return n;
}
function VC(t) {
  if (t.type === "element") {
    if (K9(t))
      return !1;
    if (W9(t))
      return !0;
  } else if (t.type === "text") {
    if (!gr(t))
      return !1;
  } else if (!mc(t))
    return !1;
}
function K9(t) {
  return pc(t) || mr(t, zC);
}
function W9(t) {
  return mr(t, qC);
}
function KC(t) {
  return Boolean(
    "properties" in t && t.properties && t.properties.hidden
  ) || mc(t) || mr(t, $C);
}
function Hd(t) {
  return t === " " || t === `
`;
}
function WC(t) {
  const e = /\r?\n|\r/.exec(t);
  return e ? e[0] : " ";
}
function YC() {
  return " ";
}
function QC(t) {
  return e;
  function e(n) {
    return String(n).replace(/[\t\n\v\f\r ]+/g, t);
  }
}
function JC(t, e) {
  if ("tagName" in t && t.properties)
    switch (t.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return t.properties.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return t.properties.noWrap ? "nowrap" : e.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  return e.whitespace;
}
const XC = !0, $s = !1, Za = "skip", gc = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null);
    const i = ji(e), s = r ? -1 : 1;
    o(t, void 0, [])();
    function o(a, l, u) {
      const c = a && typeof a == "object" ? a : {};
      if (typeof c.type == "string") {
        const h = (
          // `hast`
          typeof c.tagName == "string" ? c.tagName : (
            // `xast`
            typeof c.name == "string" ? c.name : void 0
          )
        );
        Object.defineProperty(f, "name", {
          value: "node (" + (a.type + (h ? "<" + h + ">" : "")) + ")"
        });
      }
      return f;
      function f() {
        let h = [], d, m, g;
        if ((!e || i(a, l, u[u.length - 1] || null)) && (h = ZC(n(a, u)), h[0] === $s))
          return h;
        if (a.children && h[0] !== Za)
          for (m = (r ? a.children.length : -1) + s, g = u.concat(a); m > -1 && m < a.children.length; ) {
            if (d = o(a.children[m], m, g)(), d[0] === $s)
              return d;
            m = typeof d[1] == "number" ? d[1] : m + s;
          }
        return h;
      }
    }
  }
);
function ZC(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [XC, t] : [t];
}
const Kt = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null), gc(t, e, i, r);
    function i(s, o) {
      const a = o[o.length - 1];
      return n(
        s,
        a ? a.children.indexOf(s) : null,
        a
      );
    }
  }
);
function X(t, e) {
  const n = e.children || [], r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const a = Y9(t, n[i], e);
    Array.isArray(a) ? r.push(...a) : a && r.push(a);
  }
  let s = 0, o = r.length;
  for (; s < o && r[s].type === "break"; )
    s++;
  for (; o > s && r[o - 1].type === "break"; )
    o--;
  return s === 0 && o === r.length ? r : r.slice(s, o);
}
const ka = {}.hasOwnProperty;
function lt(t, e) {
  return t.wrapText ? e : e.replace(/\r?\n|\r/g, " ");
}
function Y9(t, e, n) {
  let r;
  if (e.type === "element") {
    if (e.properties && e.properties.dataMdast === "ignore")
      return;
    ka.call(t.handlers, e.tagName) && (r = t.handlers[e.tagName]);
  } else
    ka.call(t.handlers, e.type) && (r = t.handlers[e.type]);
  return typeof r == "function" ? r(t, e, n) : eb(t, e);
}
function eb(t, e) {
  return typeof e.value == "string" ? t(e, "text", lt(t, e.value)) : X(t, e);
}
const tb = {}.hasOwnProperty;
function We(t, e) {
  const n = typeof e == "string" && nb(t) && t.type === "element" && t.properties && tb.call(t.properties, e) && t.properties[e];
  return n != null && n !== !1;
}
function nb(t) {
  return Boolean(t && typeof t == "object" && "type" in t);
}
const rb = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function ib(t) {
  if (!mr(t, "link"))
    return !1;
  if (We(t, "itemProp"))
    return !0;
  const n = (t.properties || {}).rel || [];
  let r = -1;
  if (!Array.isArray(n) || n.length === 0)
    return !1;
  for (; ++r < n.length; )
    if (!rb.has(String(n[r])))
      return !1;
  return !0;
}
const sb = _e([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]), ob = _e("meta");
function Q9(t) {
  return Boolean(
    ab(t) && (t.type === "text" || sb(t) || pc(t) || ib(t) || ob(t) && We(t, "itemProp"))
  );
}
function ab(t) {
  return t && typeof t == "object" && "type" in t;
}
const J9 = (
  /** @type {AssertPredicatePhrasing} */
  ji([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function X9(t) {
  return Z9(t, e);
  function e(n) {
    const r = n[0];
    return n.length === 1 && r.type === "text" && (r.value === " " || r.value === `
`) ? [] : { type: "paragraph", children: n };
  }
}
function el(t) {
  let e = -1, n;
  for (; ++e < t.length; )
    if (n = t[e], !eg(n) || "children" in n && el(n.children))
      return !0;
  return !1;
}
function Z9(t, e, n) {
  const r = n || cb, i = lb(t);
  let s = [], o = -1, a, l;
  for (; ++o < i.length; )
    l = i[o], eg(l) ? (a || (a = []), a.push(l)) : (a && (s = s.concat(e(a)), a = void 0), s = s.concat(r(l)));
  return a && (s = s.concat(e(a))), s;
}
function lb(t) {
  let e = [], n = -1, r;
  for (; ++n < t.length; )
    r = t[n], (r.type === "delete" || r.type === "link") && el(r.children) ? e = e.concat(ub(r)) : e.push(r);
  return e;
}
function ub(t) {
  return Z9(t.children, n, e);
  function e(r) {
    if ("children" in r && "children" in t) {
      const { children: i, ...s } = t;
      return {
        ...r,
        // @ts-expect-error: assume matching parent & child.
        children: [{ ...ba(!0, {}, s), children: r.children }]
      };
    }
    return { ...r };
  }
  function n(r) {
    const { children: i, ...s } = t;
    return { ...ba(!0, {}, s), children: r };
  }
}
function eg(t) {
  return t.data && t.data.hName ? Q9({
    type: "element",
    tagName: t.data.hName,
    properties: {},
    children: []
  }) : J9(t);
}
function cb(t) {
  return t;
}
function Pe(t, e) {
  return X9(X(t, e));
}
function Jr(t, e) {
  return e == null ? "" : t.frozenBaseUrl ? String(new URL(e, t.frozenBaseUrl)) : e;
}
function fb(t, e) {
  const n = e.properties;
  return t(
    e,
    "link",
    {
      title: n.title || null,
      url: Jr(t, String(n.href || "") || null)
    },
    X(t, e)
  );
}
function hb(t, e) {
  t.baseFound || (t.frozenBaseUrl = String(e.properties && e.properties.href || "") || null, t.baseFound = !0);
}
function db(t, e) {
  return t(e, "blockquote", Pe(t, e));
}
function pb(t, e) {
  return t.wrapText ? t(e, "break") : t(e, "text", " ");
}
const Ud = (
  /**
   * @type {(
   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
   * )}
   */
  /**
   * @param {Parent} parent
   * @param {Node | number} index
   * @param {Test} [test]
   * @returns {Node | null}
   */
  function(t, e, n) {
    const r = ji(n);
    if (!t || !t.type || !t.children)
      throw new Error("Expected parent node");
    if (typeof e == "number") {
      if (e < 0 || e === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (e = t.children.indexOf(e), e < 0)
      throw new Error("Expected child node or index");
    for (; ++e < t.children.length; )
      if (r(t.children[e], e, t))
        return t.children[e];
    return null;
  }
), qd = /\n/g, zd = /[\t ]+/g, Tu = _e("br"), mb = _e("p"), $d = _e(["th", "td"]), Gd = _e("tr"), gb = _e([
  // List from: <https://html.spec.whatwg.org/#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  yb,
  // From: <https://html.spec.whatwg.org/#flow-content-3>
  Cb
]), tg = _e([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function Qs(t, e = {}) {
  const n = "children" in t ? t.children : [], r = tg(t), i = ig(t, {
    whitespace: e.whitespace || "normal",
    breakBefore: !1,
    breakAfter: !1
  }), s = [];
  (t.type === "text" || t.type === "comment") && s.push(
    ...rg(t, {
      whitespace: i,
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let o = -1;
  for (; ++o < n.length; )
    s.push(
      ...ng(n[o], t, {
        whitespace: i,
        breakBefore: o ? void 0 : r,
        breakAfter: o < n.length - 1 ? Tu(n[o + 1]) : r
      })
    );
  const a = [];
  let l;
  for (o = -1; ++o < s.length; ) {
    const u = s[o];
    typeof u == "number" ? l !== void 0 && u > l && (l = u) : u && (l !== void 0 && l > -1 && a.push(`
`.repeat(l) || " "), l = -1, a.push(u));
  }
  return a.join("");
}
function ng(t, e, n) {
  return t.type === "element" ? Eb(t, e, n) : t.type === "text" ? n.whitespace === "normal" ? rg(t, n) : Tb(t) : [];
}
function Eb(t, e, n) {
  const r = ig(t, n), i = t.children || [];
  let s = -1, o = [];
  if (gb(t))
    return o;
  let a, l;
  for (Tu(t) || Gd(t) && Ud(e, t, Gd) ? l = `
` : mb(t) ? (a = 2, l = 2) : tg(t) && (a = 1, l = 1); ++s < i.length; )
    o = o.concat(
      ng(i[s], t, {
        whitespace: r,
        breakBefore: s ? void 0 : a,
        breakAfter: s < i.length - 1 ? Tu(i[s + 1]) : l
      })
    );
  return $d(t) && Ud(e, t, $d) && o.push("	"), a && o.unshift(a), l && o.push(l), o;
}
function rg(t, e) {
  const n = String(t.value), r = [], i = [];
  let s = 0;
  for (; s <= n.length; ) {
    qd.lastIndex = s;
    const l = qd.exec(n), u = l && "index" in l ? l.index : n.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      Ab(
        // […] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        n.slice(s, u).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        s === 0 ? e.breakBefore : !0,
        u === n.length ? e.breakAfter : !0
      )
    ), s = u + 1;
  }
  let o = -1, a;
  for (; ++o < r.length; )
    r[o].charCodeAt(r[o].length - 1) === 8203 || o < r.length - 1 && r[o + 1].charCodeAt(0) === 8203 ? (i.push(r[o]), a = void 0) : r[o] ? (typeof a == "number" && i.push(a), i.push(r[o]), a = 0) : (o === 0 || o === r.length - 1) && i.push(0);
  return i;
}
function Tb(t) {
  return [String(t.value)];
}
function Ab(t, e, n) {
  const r = [];
  let i = 0, s;
  for (; i < t.length; ) {
    zd.lastIndex = i;
    const o = zd.exec(t);
    s = o ? o.index : t.length, !i && !s && o && !e && r.push(""), i !== s && r.push(t.slice(i, s)), i = o ? s + o[0].length : s;
  }
  return i !== s && !n && r.push(""), r.join(" ");
}
function ig(t, e) {
  if (t.type === "element") {
    const n = t.properties || {};
    switch (t.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return n.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return n.noWrap ? "nowrap" : e.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return e.whitespace;
}
function yb(t) {
  return Boolean((t.properties || {}).hidden);
}
function Cb(t) {
  return t.tagName === "dialog" && !(t.properties || {}).open;
}
function bb(t) {
  const e = String(t);
  let n = e.length;
  for (; n > 0; ) {
    const r = e.codePointAt(n - 1);
    if (r !== void 0 && (r === 10 || r === 13))
      n--;
    else
      break;
  }
  return e.slice(0, n);
}
const m1 = "language-", xb = _e("pre"), Sb = _e("code");
function So(t, e) {
  const n = e.children;
  let r = -1, i, s;
  if (xb(e))
    for (; ++r < n.length; ) {
      const o = n[r];
      if (Sb(o) && o.properties && o.properties.className && Array.isArray(o.properties.className)) {
        i = o.properties.className;
        break;
      }
    }
  if (i) {
    for (r = -1; ++r < i.length; )
      if (String(i[r]).slice(0, m1.length) === m1) {
        s = String(i[r]).slice(m1.length);
        break;
      }
  }
  return t(
    e,
    "code",
    { lang: s || null, meta: null },
    bb(lt(t, Qs(e)))
  );
}
function Nb(t, e) {
  return t(e, "html", "<!--" + lt(t, e.value) + "-->");
}
function g1(t, e) {
  return t(e, "delete", X(t, e));
}
function Ec(t) {
  let e = -1;
  if (t.length > 1) {
    for (; ++e < t.length; )
      if (t[e].spread)
        return !0;
  }
  return !1;
}
function sg(t, e) {
  const n = X(t, e);
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    i.type !== "listItem" && (n[r] = {
      type: "listItem",
      spread: !1,
      checked: null,
      // @ts-expect-error Assume `children[index]` is block content.
      children: [i]
    });
  }
  return n;
}
const _b = _e("div"), kb = _e("dt"), Ob = _e("dd");
function wb(t, e) {
  const n = e.children;
  let r = -1, i = [];
  const s = [];
  let o = { titles: [], definitions: [] }, a, l;
  for (; ++r < n.length; )
    a = n[r], i = i.concat(_b(a) ? a.children : a);
  for (r = -1; ++r < i.length; )
    a = i[r], kb(a) ? (Ob(i[r - 1]) && (s.push(o), o = { titles: [], definitions: [] }), o.titles.push(a)) : o.definitions.push(a);
  s.push(o), r = -1;
  const u = [];
  for (; ++r < s.length; )
    l = [
      ...jd(t, s[r].titles),
      ...jd(t, s[r].definitions)
    ], l.length > 0 && u.push({
      type: "listItem",
      spread: l.length > 1,
      checked: null,
      children: l
    });
  if (u.length > 0)
    return t(
      e,
      "list",
      { ordered: !1, start: null, spread: Ec(u) },
      u
    );
}
function jd(t, e) {
  const n = sg(t, { type: "element", tagName: "x", children: e });
  return n.length === 0 ? [] : n.length === 1 ? n[0].children : [
    {
      type: "list",
      ordered: !1,
      start: null,
      spread: Ec(n),
      children: n
    }
  ];
}
function No(t, e) {
  return t(e, "emphasis", X(t, e));
}
function fi(t, e) {
  const n = Number(e.tagName.charAt(1)) || 1, r = t.wrapText;
  t.wrapText = !1;
  const i = t(e, "heading", { depth: n }, X(t, e));
  return t.wrapText = r, i;
}
function Db(t, e) {
  return t(e, "thematicBreak");
}
function Ib(t, e) {
  const n = e.properties, r = String(n.src || ""), i = String(n.title || "");
  if (r && i)
    return {
      type: "link",
      title: null,
      url: Jr(t, r),
      children: [{ type: "text", value: lt(t, i) }]
    };
}
function Vd(t, e) {
  const n = e.properties;
  return t(e, "image", {
    url: Jr(t, String(n.src || "") || null),
    title: n.title || null,
    alt: n.alt || ""
  });
}
function fs(t, e) {
  return t(e, "inlineCode", lt(t, Qs(e)));
}
const Mb = _e("option");
function og(t, e, n) {
  const r = n || e.properties;
  let i = ag(e);
  const s = Math.min(Number.parseInt(String(r.size), 10), 0) || (r.multiple ? 4 : 1);
  let o = -1;
  const a = [], l = [];
  for (; ++o < i.length; )
    We(i[o], "selected") && a.push(i[o]);
  for (i = (a.length > 0 ? a : i).slice(0, s), o = -1; ++o < i.length; ) {
    const c = i[o], f = lt(t, Qs(c)), h = c.properties, d = f || String(h.label || ""), m = String(h.value || "") || f;
    l.push([m, d === m ? null : d]);
  }
  return l;
}
function ag(t) {
  const e = t.children;
  let n = -1, r = [], i;
  for (; ++n < e.length; )
    i = e[n], Array.isArray(i.children) && (r = r.concat(ag(i))), Mb(i) && !We(i, "disabled") && r.push(i);
  return r;
}
const Rb = _e("datalist");
function vb(t, e) {
  const n = e.properties;
  let r = String(n.value || n.placeholder || "");
  const i = [], s = [];
  let o = [], a = -1, l;
  if (!(n.disabled || n.type === "hidden" || n.type === "file")) {
    if (n.type === "checkbox" || n.type === "radio")
      return t(
        e,
        "text",
        lt(t, t[n.checked ? "checked" : "unchecked"])
      );
    if (n.type === "image")
      return n.alt || r ? t(e, "image", {
        url: Jr(t, String(n.src || "") || null),
        title: lt(t, String(n.title || "")) || null,
        alt: lt(t, String(n.alt || r))
      }) : [];
    if (r ? o = [[r, null]] : (
      // `list` is not supported on these types:
      n.type !== "password" && n.type !== "file" && n.type !== "submit" && n.type !== "reset" && n.type !== "button" && n.list && (l = String(n.list).toUpperCase(), ka.call(t.nodeById, l) && Rb(t.nodeById[l]) && (o = og(t, t.nodeById[l], n)))
    ), o.length !== 0) {
      if (n.type === "password" && (o[0] = ["•".repeat(o[0][0].length), null]), n.type === "url" || n.type === "email") {
        for (; ++a < o.length; )
          r = Jr(t, o[a][0]), i.push(
            t(
              e,
              "link",
              {
                title: null,
                url: lt(t, n.type === "email" ? "mailto:" + r : r)
              },
              [{ type: "text", value: lt(t, o[a][1] || r) }]
            )
          ), a !== o.length - 1 && i.push({ type: "text", value: ", " });
        return i;
      }
      for (; ++a < o.length; )
        s.push(
          o[a][1] ? o[a][1] + " (" + o[a][0] + ")" : o[a][0]
        );
      return t(e, "text", lt(t, s.join(", ")));
    }
  }
}
const Lb = _e("p"), Pb = _e("input");
function E1(t, e) {
  const n = e.children[0];
  let r = null, i, s;
  Lb(n) && (i = n.children[0], Pb(i) && i.properties && (i.properties.type === "checkbox" || i.properties.type === "radio") && (r = Boolean(i.properties.checked), s = {
    ...e,
    children: [
      { ...n, children: n.children.slice(1) },
      ...e.children.slice(1)
    ]
  }));
  const o = Pe(t, s || e);
  return t(e, "listItem", { spread: o.length > 1, checked: r }, o);
}
const Bb = _e("ol");
function T1(t, e) {
  const n = Bb(e), r = sg(t, e);
  let i = null;
  return n && (i = We(e, "start") ? (
    // @ts-expect-error: `props` exist.
    Number.parseInt(String(e.properties.start), 10)
  ) : 1), t(
    e,
    "list",
    { ordered: n, start: i, spread: Ec(r) },
    r
  );
}
function tl(t, e) {
  const n = (e || {}).includeImageAlt;
  return lg(
    t,
    typeof n == "boolean" ? n : !0
  );
}
function lg(t, e) {
  return Fb(t) && ("value" in t && t.value || e && "alt" in t && t.alt || "children" in t && Kd(t.children, e)) || Array.isArray(t) && Kd(t, e) || "";
}
function Kd(t, e) {
  const n = [];
  let r = -1;
  for (; ++r < t.length; )
    n[r] = lg(t[r], e);
  return n.join("");
}
function Fb(t) {
  return Boolean(t && typeof t == "object");
}
const Hb = _e("source"), Ub = _e("video");
function Wd(t, e) {
  let n = X(t, e);
  const r = e.properties, i = Ub(e) && String(r.poster || "");
  let s = String(r.src || ""), o = -1, a = !1, l;
  if (Kt({ type: "root", children: n }, "link", u), a || el(n))
    return n;
  for (; !s && ++o < e.children.length; )
    l = e.children[o], Hb(l) && (s = String(l.properties.src || ""));
  return i && (n = [
    {
      type: "image",
      title: null,
      url: Jr(t, i),
      alt: tl({ children: n })
    }
  ]), {
    type: "link",
    // @ts-expect-error Types are broken.
    title: e.properties.title || null,
    url: Jr(t, s),
    // @ts-expect-error Assume phrasing content.
    children: n
  };
  function u() {
    return a = !0, $s;
  }
}
function Yd(t, e) {
  const n = X(t, e);
  if (n.length > 0)
    return t(e, "paragraph", n);
}
function qb(t, e) {
  const n = t.quotes[t.qNesting % t.quotes.length];
  t.qNesting++;
  const r = X(t, e);
  return t.qNesting--, r.unshift({ type: "text", value: n.charAt(0) }), r.push({
    type: "text",
    value: n.length > 1 ? n.charAt(1) : n
  }), r;
}
function zb(t, e) {
  let n = X(t, e);
  return (t.document || el(n)) && (n = X9(n)), t(e, "root", n);
}
function $b(t, e) {
  const n = og(t, e);
  let r = -1;
  const i = [];
  let s;
  for (; ++r < n.length; )
    s = n[r], i.push(s[1] ? s[1] + " (" + s[0] + ")" : s[0]);
  if (i.length > 0)
    return t(e, "text", lt(t, i.join(", ")));
}
function Qd(t, e) {
  return t(e, "strong", X(t, e));
}
function Jd(t, e) {
  const n = t.wrapText;
  t.wrapText = !1;
  const r = t(e, "tableCell", X(t, e));
  if (e.properties && (e.properties.rowSpan || e.properties.colSpan)) {
    const i = r.data || (r.data = {});
    e.properties.rowSpan && (i.rowSpan = e.properties.rowSpan), e.properties.colSpan && (i.colSpan = e.properties.colSpan);
  }
  return t.wrapText = n, r;
}
function Gb(t, e) {
  return t(e, "tableRow", X(t, e));
}
const jb = _e("thead"), Vb = _e("tr"), Kb = _e(["th", "td"]);
function Wb(t, e) {
  if (t.inTable)
    return t(e, "text", lt(t, Qs(e)));
  t.inTable = !0;
  const { headless: n, align: r } = Yb(e), i = Qb(X(t, e), n);
  let s = 1, o = -1;
  for (; ++o < i.length; ) {
    const l = i[o].children;
    let u = -1;
    for (; ++u < l.length; ) {
      const c = l[u];
      if (c.data) {
        const f = Number.parseInt(String(c.data.colSpan), 10) || 1, h = Number.parseInt(String(c.data.rowSpan), 10) || 1;
        if (f > 1 || h > 1) {
          let d = o - 1;
          for (; ++d < o + h; ) {
            let m = u - 1;
            for (; ++m < u + f && i[d]; ) {
              const g = [];
              (d !== o || m !== u) && g.push({ type: "tableCell", children: [] }), i[d].children.splice(m, 0, ...g);
            }
          }
        }
        "colSpan" in c.data && delete c.data.colSpan, "rowSpan" in c.data && delete c.data.rowSpan, Object.keys(c.data).length === 0 && delete c.data;
      }
    }
    l.length > s && (s = l.length);
  }
  for (o = -1; ++o < i.length; ) {
    const l = i[o].children;
    let u = l.length - 1;
    for (; ++u < s; )
      l.push({ type: "tableCell", children: [] });
  }
  let a = r.length - 1;
  for (; ++a < s; )
    r.push(null);
  return t.inTable = !1, t(e, "table", { align: r }, i);
}
function Yb(t) {
  let e = !0, n = 0, r = 0;
  const i = [null];
  return Kt(t, "element", (s) => {
    if (s.tagName === "table" && t !== s)
      return Za;
    Kb(s) && s.properties ? (i[r] || (i[r] = String(s.properties.align || "") || null), e && n < 2 && s.tagName === "th" && (e = !1), r++) : jb(s) ? e = !1 : Vb(s) && (n++, r = 0);
  }), { align: i, headless: e };
}
function Qb(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (e && r.push({ type: "tableRow", children: [] }); ++n < t.length; ) {
    const s = t[n];
    s.type === "tableRow" ? (i && (s.children.unshift(...i), i = void 0), r.push(s)) : (i || (i = []), i.push(s));
  }
  for (i && r[r.length - 1].children.push(...i), n = -1; ++n < r.length; )
    r[n].children = Jb(r[n].children);
  return r;
}
function Jb(t) {
  const e = [];
  let n = -1, r, i;
  for (; ++n < t.length; )
    r = t[n], r.type === "tableCell" ? (i && (r.children.unshift(...i), i = void 0), e.push(r)) : (i || (i = []), i.push(r));
  return i && (r = e[e.length - 1], r || (r = { type: "tableCell", children: [] }, e.push(r)), r.children.push(...i)), e;
}
function Xb(t, e) {
  return t(e, "text", lt(t, e.value));
}
function Zb(t, e) {
  return t(e, "text", lt(t, Qs(e)));
}
function e7(t, e) {
  return t(e, "text", "​");
}
const Xd = {
  root: zb,
  text: Xb,
  comment: Nb,
  doctype: le,
  applet: le,
  area: le,
  basefont: le,
  bgsound: le,
  caption: le,
  col: le,
  colgroup: le,
  command: le,
  content: le,
  datalist: le,
  dialog: le,
  element: le,
  embed: le,
  frame: le,
  frameset: le,
  isindex: le,
  keygen: le,
  link: le,
  math: le,
  menu: le,
  menuitem: le,
  meta: le,
  nextid: le,
  noembed: le,
  noframes: le,
  optgroup: le,
  option: le,
  param: le,
  script: le,
  shadow: le,
  source: le,
  spacer: le,
  style: le,
  svg: le,
  template: le,
  title: le,
  track: le,
  abbr: X,
  acronym: X,
  bdi: X,
  bdo: X,
  big: X,
  blink: X,
  button: X,
  canvas: X,
  cite: X,
  data: X,
  details: X,
  dfn: X,
  font: X,
  ins: X,
  label: X,
  map: X,
  marquee: X,
  meter: X,
  nobr: X,
  noscript: X,
  object: X,
  output: X,
  progress: X,
  rb: X,
  rbc: X,
  rp: X,
  rt: X,
  rtc: X,
  ruby: X,
  slot: X,
  small: X,
  span: X,
  sup: X,
  sub: X,
  tbody: X,
  tfoot: X,
  thead: X,
  time: X,
  address: Pe,
  article: Pe,
  aside: Pe,
  body: Pe,
  center: Pe,
  div: Pe,
  fieldset: Pe,
  figcaption: Pe,
  figure: Pe,
  form: Pe,
  footer: Pe,
  header: Pe,
  hgroup: Pe,
  html: Pe,
  legend: Pe,
  main: Pe,
  multicol: Pe,
  nav: Pe,
  picture: Pe,
  section: Pe,
  a: fb,
  audio: Wd,
  b: Qd,
  base: hb,
  blockquote: db,
  br: pb,
  code: fs,
  dir: T1,
  dl: wb,
  dt: E1,
  dd: E1,
  del: g1,
  em: No,
  h1: fi,
  h2: fi,
  h3: fi,
  h4: fi,
  h5: fi,
  h6: fi,
  hr: Db,
  i: No,
  iframe: Ib,
  img: Vd,
  image: Vd,
  input: vb,
  kbd: fs,
  li: E1,
  listing: So,
  mark: No,
  ol: T1,
  p: Yd,
  plaintext: So,
  pre: So,
  q: qb,
  s: g1,
  samp: fs,
  select: $b,
  strike: g1,
  strong: Qd,
  summary: Yd,
  table: Wb,
  td: Jd,
  textarea: Zb,
  th: Jd,
  tr: Gb,
  tt: fs,
  u: No,
  ul: T1,
  var: fs,
  video: Wd,
  wbr: e7,
  xmp: So
};
function le() {
}
const t7 = ji(["heading", "paragraph", "root"]);
function ug(t, e = {}) {
  const n = {};
  let r;
  const i = Object.assign(
    /**
     * @type {HWithProps & HWithoutProps}
     */
    /**
     * @param {Node} node
     * @param {string} type
     * @param {Properties|string|Array<Node>} [props]
     * @param {string|Array<Node>} [children]
     */
    (a, l, u, c) => {
      let f;
      typeof u == "string" || Array.isArray(u) ? (c = u, f = {}) : f = u;
      const h = { type: l, ...f };
      return typeof c == "string" ? h.value = c : c && (h.children = c), a.position && (h.position = a.position), h;
    },
    {
      nodeById: n,
      baseFound: !1,
      inTable: !1,
      wrapText: !0,
      /** @type {string|null} */
      frozenBaseUrl: null,
      qNesting: 0,
      handlers: e.handlers ? { ...Xd, ...e.handlers } : Xd,
      document: e.document,
      checked: e.checked || "[x]",
      unchecked: e.unchecked || "[ ]",
      quotes: e.quotes || ['"']
    }
  );
  Kt(t, "element", (a) => {
    const l = a.properties && "id" in a.properties && String(a.properties.id).toUpperCase();
    l && !ka.call(n, l) && (n[l] = a);
  }), G9({ newlines: e.newlines === !0 })(t);
  const s = Y9(i, t, void 0);
  return s ? Array.isArray(s) ? r = { type: "root", children: s } : r = s : r = { type: "root", children: [] }, Kt(r, "text", o), r;
  function o(a, l, u) {
    if (l === null || !u)
      return;
    const c = u.children[l - 1];
    if (c && c.type === a.type)
      return c.value += a.value, u.children.splice(l, 1), c.position && a.position && (c.position.end = a.position.end), l - 1;
    if (a.value = a.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1"), u && t7(u) && (l || (a.value = a.value.replace(/^[\t ]+/, "")), l === u.children.length - 1 && (a.value = a.value.replace(/[\t ]+$/, ""))), !a.value)
      return u.children.splice(l, 1), l;
  }
}
const n7 = (
  /**
   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}
   */
  /**
   * @param {Processor|Options} [destination]
   * @param {Options} [options]
   */
  function(t, e) {
    let n, r;
    return typeof t == "function" ? (r = t, n = e || {}) : n = t || {}, (n.document === void 0 || n.document === null) && (n = Object.assign({}, n, { document: !0 })), r ? i7(r, n) : s7(n);
  }
), r7 = n7;
function i7(t, e) {
  return (n, r, i) => {
    t.run(ug(n, e), r, (s) => {
      i(s);
    });
  };
}
function s7(t = {}) {
  return (e) => (
    /** @type {MdastRoot} */
    ug(e, t)
  );
}
const Zd = {}.hasOwnProperty;
function Vi(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const a = r.handlers;
    if (i && Zd.call(i, t)) {
      const l = String(i[t]);
      o = Zd.call(a, l) ? a[l] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function Ho(t, e) {
  let n = -1, r;
  if (e.extensions)
    for (; ++n < e.extensions.length; )
      Ho(t, e.extensions[n]);
  for (r in e)
    r === "extensions" || (r === "unsafe" || r === "join" ? t[r] = [...t[r] || [], ...e[r] || []] : r === "handlers" ? t[r] = Object.assign(t[r], e[r] || {}) : t.options[r] = e[r]);
  return t;
}
function o7(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const o = n.indentLines(
    n.containerFlow(t, s.current()),
    a7
  );
  return i(), o;
}
function a7(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function cg(t, e) {
  return ep(t, e.inConstruct, !0) && !ep(t, e.notInConstruct, !1);
}
function ep(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function tp(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && cg(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function l7(t, e) {
  const n = String(t);
  let r = n.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = n.indexOf(e, i);
  return o;
}
function Au(t, e) {
  return Boolean(
    !e.options.fences && t.value && // If there’s no info…
    !t.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(t.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value)
  );
}
function u7(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function c7(t, e, n, r) {
  const i = u7(n), s = t.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (Au(t, n)) {
    const f = n.enter("codeIndented"), h = n.indentLines(s, f7);
    return f(), h;
  }
  const a = n.createTracker(r), l = i.repeat(Math.max(l7(s, i) + 1, 3)), u = n.enter("codeFenced");
  let c = a.move(l);
  if (t.lang) {
    const f = n.enter(`codeFencedLang${o}`);
    c += a.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  if (t.lang && t.meta) {
    const f = n.enter(`codeFencedMeta${o}`);
    c += a.move(" "), c += a.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  return c += a.move(`
`), s && (c += a.move(s + `
`)), c += a.move(l), u(), c;
}
function f7(t, e, n) {
  return (n ? "" : "    ") + t;
}
function nl(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function h7(t, e, n, r) {
  const i = nl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("[");
  return u += l.move(
    n.safe(n.associationId(t), {
      before: u,
      after: "]",
      ...l.current()
    })
  ), u += l.move("]: "), a(), // If there’s no url, or…
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(t.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (a = n.enter("destinationRaw"), u += l.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : `
`,
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${s}`), u += l.move(" " + i), u += l.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), a()), o(), u;
}
function d7(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
fg.peek = p7;
function fg(t, e, n, r) {
  const i = d7(n), s = n.enter("emphasis"), o = n.createTracker(r);
  let a = o.move(i);
  return a += o.move(
    n.containerPhrasing(t, {
      before: a,
      after: i,
      ...o.current()
    })
  ), a += o.move(i), s(), a;
}
function p7(t, e, n) {
  return n.options.emphasis || "*";
}
function hg(t, e) {
  let n = !1;
  return Kt(t, (r) => {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, $s;
  }), Boolean(
    (!t.depth || t.depth < 3) && tl(t) && (e.options.setext || n)
  );
}
function m7(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (hg(t, n)) {
    const c = n.enter("headingSetext"), f = n.enter("phrasing"), h = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return f(), c(), h + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      h.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), a = n.enter("headingAtx"), l = n.enter("phrasing");
  s.move(o + " ");
  let u = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)), u = u ? o + " " + u : o, n.options.closeAtx && (u += " " + o), l(), a(), u;
}
dg.peek = g7;
function dg(t) {
  return t.value || "";
}
function g7() {
  return "<";
}
pg.peek = E7;
function pg(t, e, n, r) {
  const i = nl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("![");
  return u += l.move(
    n.safe(t.alt, { before: u, after: "]", ...l.current() })
  ), u += l.move("]("), a(), // If there’s no url but there is a title…
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(t.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (a = n.enter("destinationRaw"), u += l.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : ")",
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${s}`), u += l.move(" " + i), u += l.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), a()), u += l.move(")"), o(), u;
}
function E7() {
  return "!";
}
mg.peek = T7;
function mg(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const u = n.safe(t.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(u + "]["), o();
  const c = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = c, s(), i === "full" || !u || u !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function T7() {
  return "!";
}
function gg(t) {
  if (!t._compiled) {
    const e = (t.atBreak ? "[\\r\\n][\\t ]*" : "") + (t.before ? "(?:" + t.before + ")" : "");
    t._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(t.character) ? "\\" : "") + t.character + (t.after ? "(?:" + t.after + ")" : ""),
      "g"
    );
  }
  return t._compiled;
}
Eg.peek = A7;
function Eg(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const o = n.unsafe[s], a = gg(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let u = l.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function A7() {
  return "`";
}
function Tg(t, e) {
  const n = tl(t);
  return Boolean(
    !e.options.resourceLink && // If there’s a url…
    t.url && // And there’s a no title…
    !t.title && // And the content of `node` is a single text node…
    t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content…
    (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(t.url)
  );
}
Ag.peek = y7;
function Ag(t, e, n, r) {
  const i = nl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let a, l;
  if (Tg(t, n)) {
    const c = n.stack;
    n.stack = [], a = n.enter("autolink");
    let f = o.move("<");
    return f += o.move(
      n.containerPhrasing(t, {
        before: f,
        after: ">",
        ...o.current()
      })
    ), f += o.move(">"), a(), n.stack = c, f;
  }
  a = n.enter("link"), l = n.enter("label");
  let u = o.move("[");
  return u += o.move(
    n.containerPhrasing(t, {
      before: u,
      after: "](",
      ...o.current()
    })
  ), u += o.move("]("), l(), // If there’s no url but there is a title…
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (l = n.enter("destinationLiteral"), u += o.move("<"), u += o.move(
    n.safe(t.url, { before: u, after: ">", ...o.current() })
  ), u += o.move(">")) : (l = n.enter("destinationRaw"), u += o.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : ")",
      ...o.current()
    })
  )), l(), t.title && (l = n.enter(`title${s}`), u += o.move(" " + i), u += o.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...o.current()
    })
  ), u += o.move(i), l()), u += o.move(")"), a(), u;
}
function y7(t, e, n) {
  return Tg(t, n) ? "<" : "[";
}
yg.peek = C7;
function yg(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const u = n.containerPhrasing(t, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(u + "]["), o();
  const c = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = c, s(), i === "full" || !u || u !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function C7() {
  return "[";
}
function Tc(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function b7(t) {
  const e = Tc(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function Cg(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function x7(t) {
  const e = Cg(t), n = t.options.bulletOrderedOther;
  if (!n)
    return e === "." ? ")" : ".";
  if (n !== "." && n !== ")")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bulletOrdered` (`" + e + "`) and `bulletOrderedOther` (`" + n + "`) to be different"
    );
  return n;
}
function bg(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function S7(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let o = t.ordered ? Cg(n) : Tc(n);
  const a = t.ordered ? x7(n) : b7(n), l = n.bulletLastUsed;
  let u = !1;
  if (e && // Explicit `other` set.
  (t.ordered ? n.options.bulletOrderedOther : n.options.bulletOther) && l && o === l && (u = !0), !t.ordered) {
    const f = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), bg(n) === o && f
    ) {
      let h = -1;
      for (; ++h < t.children.length; ) {
        const d = t.children[h];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (o = a), n.bulletCurrent = o;
  const c = n.containerFlow(t, r);
  return n.bulletLastUsed = o, n.bulletCurrent = s, i(), c;
}
function N7(t) {
  const e = t.options.listItemIndent || "tab";
  if (e === 1 || e === "1")
    return "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function _7(t, e, n, r) {
  const i = N7(n);
  let s = n.bulletCurrent || Tc(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(s + " ".repeat(o - s.length)), a.shift(o);
  const l = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(t, a.current()),
    c
  );
  return l(), u;
  function c(f, h, d) {
    return h ? (d ? "" : " ".repeat(o)) + f : (d ? s : s + " ".repeat(o - s.length)) + f;
  }
}
function k7(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), o = n.containerPhrasing(t, r);
  return s(), i(), o;
}
function O7(t, e, n, r) {
  return (t.children.some((o) => J9(o)) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function w7(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
xg.peek = D7;
function xg(t, e, n, r) {
  const i = w7(n), s = n.enter("strong"), o = n.createTracker(r);
  let a = o.move(i + i);
  return a += o.move(
    n.containerPhrasing(t, {
      before: a,
      after: i,
      ...o.current()
    })
  ), a += o.move(i + i), s(), a;
}
function D7(t, e, n) {
  return n.options.strong || "*";
}
function I7(t, e, n, r) {
  return n.safe(t.value, r);
}
function M7(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function R7(t, e, n) {
  const r = (bg(n) + (n.options.ruleSpaces ? " " : "")).repeat(M7(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const v7 = {
  blockquote: o7,
  break: tp,
  code: c7,
  definition: h7,
  emphasis: fg,
  hardBreak: tp,
  heading: m7,
  html: dg,
  image: pg,
  imageReference: mg,
  inlineCode: Eg,
  link: Ag,
  linkReference: yg,
  list: S7,
  listItem: _7,
  paragraph: k7,
  root: O7,
  strong: xg,
  text: I7,
  thematicBreak: R7
}, L7 = [P7];
function P7(t, e, n, r) {
  if (e.type === "code" && Au(e, r) && (t.type === "list" || t.type === e.type && Au(t, r)) || t.type === "list" && t.type === e.type && Boolean(t.ordered) === Boolean(e.ordered) && !(t.ordered ? r.options.bulletOrderedOther : r.options.bulletOther))
    return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return t.type === "paragraph" && // Two paragraphs.
    (t.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && hg(e, r)) ? void 0 : n.spread ? 1 : 0;
}
const Dr = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], B7 = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: Dr
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: Dr
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: Dr },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: Dr
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: Dr },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: Dr },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: Dr },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
], np = document.createElement("i");
function Gs(t) {
  const e = "&" + t + ";";
  np.innerHTML = e;
  const n = np.textContent;
  return n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n;
}
function Sg(t, e) {
  const n = Number.parseInt(t, e);
  return (
    // C0 except for HT, LF, FF, CR, space
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of the basic block and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || // Out of range
    n > 1114111 ? "�" : String.fromCharCode(n)
  );
}
const F7 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Ng(t) {
  return t.replace(F7, H7);
}
function H7(t, e, n) {
  if (e)
    return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), s = i === 120 || i === 88;
    return Sg(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Gs(n) || t;
}
function U7(t) {
  return t.label || !t.identifier ? t.label || "" : Ng(t.identifier);
}
function Ac(t, e, n) {
  const r = e.indexStack, i = t.children || [], s = [];
  let o = -1, a = n.before;
  r.push(-1);
  let l = e.createTracker(n);
  for (; ++o < i.length; ) {
    const u = i[o];
    let c;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let f = e.handle.handlers[i[o + 1].type];
      f && f.peek && (f = f.peek), c = f ? f(i[o + 1], t, e, {
        before: "",
        after: "",
        ...l.current()
      }).charAt(0) : "";
    } else
      c = n.after;
    s.length > 0 && (a === "\r" || a === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), a = " ", l = e.createTracker(n), l.move(s.join(""))), s.push(
      l.move(
        e.handle(u, t, e, {
          ...l.current(),
          before: a,
          after: c
        })
      )
    ), a = s[s.length - 1].slice(-1);
  }
  return r.pop(), s.join("");
}
function _g(t, e, n) {
  const r = e.indexStack, i = t.children || [], s = e.createTracker(n), o = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const l = i[a];
    r[r.length - 1] = a, o.push(
      s.move(
        e.handle(l, t, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), l.type !== "list" && (e.bulletLastUsed = void 0), a < i.length - 1 && o.push(
      s.move(q7(l, i[a + 1], t, e))
    );
  }
  return r.pop(), o.join("");
}
function q7(t, e, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](t, e, n, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const z7 = /\r?\n|\r/g;
function $7(t, e) {
  const n = [];
  let r = 0, i = 0, s;
  for (; s = z7.exec(t); )
    o(t.slice(r, s.index)), n.push(s[0]), r = s.index + s[0].length, i++;
  return o(t.slice(r)), n.join("");
  function o(a) {
    n.push(e(a, i, !a));
  }
}
function G7(t, e, n) {
  const r = (n.before || "") + (e || "") + (n.after || ""), i = [], s = [], o = {};
  let a = -1;
  for (; ++a < t.unsafe.length; ) {
    const c = t.unsafe[a];
    if (!cg(t.stack, c))
      continue;
    const f = gg(c);
    let h;
    for (; h = f.exec(r); ) {
      const d = "before" in c || Boolean(c.atBreak), m = "after" in c, g = h.index + (d ? h[1].length : 0);
      i.includes(g) ? (o[g].before && !d && (o[g].before = !1), o[g].after && !m && (o[g].after = !1)) : (i.push(g), o[g] = { before: d, after: m });
    }
  }
  i.sort(j7);
  let l = n.before ? n.before.length : 0;
  const u = r.length - (n.after ? n.after.length : 0);
  for (a = -1; ++a < i.length; ) {
    const c = i[a];
    c < l || c >= u || c + 1 < u && i[a + 1] === c + 1 && o[c].after && !o[c + 1].before && !o[c + 1].after || i[a - 1] === c - 1 && o[c].before && !o[c - 1].before && !o[c - 1].after || (l !== c && s.push(rp(r.slice(l, c), "\\")), l = c, /[!-/:-@[-`{-~]/.test(r.charAt(c)) && (!n.encode || !n.encode.includes(r.charAt(c))) ? s.push("\\") : (s.push(
      "&#x" + r.charCodeAt(c).toString(16).toUpperCase() + ";"
    ), l++));
  }
  return s.push(rp(r.slice(l, u), n.after)), s.join("");
}
function j7(t, e) {
  return t - e;
}
function rp(t, e) {
  const n = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = t + e;
  let o = -1, a = 0, l;
  for (; l = n.exec(s); )
    r.push(l.index);
  for (; ++o < r.length; )
    a !== r[o] && i.push(t.slice(a, r[o])), i.push("\\"), a = r[o];
  return i.push(t.slice(a)), i.join("");
}
function yc(t) {
  const e = t || {}, n = e.now || {};
  let r = e.lineShift || 0, i = n.line || 1, s = n.column || 1;
  return { move: l, current: o, shift: a };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function a(u) {
    r += u;
  }
  function l(u) {
    const c = u || "", f = c.split(/\r?\n|\r/g), h = f[f.length - 1];
    return i += f.length - 1, s = f.length === 1 ? s + h.length : 1 + h.length + r, c;
  }
}
function V7(t, e = {}) {
  const n = {
    enter: i,
    indentLines: $7,
    associationId: U7,
    containerPhrasing: Q7,
    containerFlow: J7,
    createTracker: yc,
    safe: X7,
    stack: [],
    unsafe: [],
    join: [],
    // @ts-expect-error: we’ll fill it next.
    handlers: {},
    options: {},
    indexStack: [],
    // @ts-expect-error: we’ll add `handle` later.
    handle: void 0
  };
  Ho(n, { unsafe: B7, join: L7, handlers: v7 }), Ho(n, e), n.options.tightDefinitions && Ho(n, { join: [Y7] }), n.handle = Vi("type", {
    invalid: K7,
    unknown: W7,
    handlers: n.handlers
  });
  let r = n.handle(t, void 0, n, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return r && r.charCodeAt(r.length - 1) !== 10 && r.charCodeAt(r.length - 1) !== 13 && (r += `
`), r;
  function i(s) {
    return n.stack.push(s), o;
    function o() {
      n.stack.pop();
    }
  }
}
function K7(t) {
  throw new Error("Cannot handle value `" + t + "`, expected node");
}
function W7(t) {
  throw new Error("Cannot handle unknown node `" + t.type + "`");
}
function Y7(t, e) {
  if (t.type === "definition" && t.type === e.type)
    return 0;
}
function Q7(t, e) {
  return Ac(t, this, e);
}
function J7(t, e) {
  return _g(t, this, e);
}
function X7(t, e) {
  return G7(this, t, e);
}
function Z7(t) {
  Object.assign(this, { Compiler: (n) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return V7(
      n,
      Object.assign({}, r, t, {
        // Note: this option is not in the readme.
        // The goal is for it to be set by plugins on `data` instead of being
        // passed by users.
        extensions: (
          /** @type {ToMarkdownOptions['extensions']} */
          this.data("toMarkdownExtensions") || []
        )
      })
    );
  } });
}
function Mt(t, e, n, r) {
  const i = t.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, n), [].splice.apply(t, o);
  else
    for (n && [].splice.apply(t, [e, n]); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), [].splice.apply(t, o), s += 1e4, e += 1e4;
}
function Ut(t, e) {
  return t.length > 0 ? (Mt(t, t.length, 0, e), t) : e;
}
const ip = {}.hasOwnProperty;
function kg(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    ex(e, t[n]);
  return e;
}
function ex(t, e) {
  let n;
  for (n in e) {
    const i = (ip.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let o;
    for (o in s) {
      ip.call(i, o) || (i[o] = []);
      const a = s[o];
      tx(
        // @ts-expect-error Looks like a list.
        i[o],
        Array.isArray(a) ? a : a ? [a] : []
      );
    }
  }
}
function tx(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  Mt(t, 0, 0, r);
}
const nx = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, $t = xr(/[A-Za-z]/), yu = xr(/\d/), rx = xr(/[\dA-Fa-f]/), pt = xr(/[\dA-Za-z]/), ix = xr(/[!-/:-@[-`{-~]/), sp = xr(/[#-'*+\--9=?A-Z^-~]/);
function Cu(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
function Ve(t) {
  return t !== null && (t < 0 || t === 32);
}
function Z(t) {
  return t !== null && t < -2;
}
function ve(t) {
  return t === -2 || t === -1 || t === 32;
}
const sx = xr(/\s/), ox = xr(nx);
function xr(t) {
  return e;
  function e(n) {
    return n !== null && t.test(String.fromCharCode(n));
  }
}
function Oa(t) {
  if (t === null || Ve(t) || sx(t))
    return 1;
  if (ox(t))
    return 2;
}
function rl(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
function ax(t = {}) {
  let e = t.singleTilde;
  const n = {
    tokenize: i,
    resolveAll: r
  };
  return e == null && (e = !0), {
    text: {
      [126]: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(s, o) {
    let a = -1;
    for (; ++a < s.length; )
      if (s[a][0] === "enter" && s[a][1].type === "strikethroughSequenceTemporary" && s[a][1]._close) {
        let l = a;
        for (; l--; )
          if (s[l][0] === "exit" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._open && // If the sizes are the same:
          s[a][1].end.offset - s[a][1].start.offset === s[l][1].end.offset - s[l][1].start.offset) {
            s[a][1].type = "strikethroughSequence", s[l][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, s[l][1].start),
              end: Object.assign({}, s[a][1].end)
            }, c = {
              type: "strikethroughText",
              start: Object.assign({}, s[l][1].end),
              end: Object.assign({}, s[a][1].start)
            }, f = [
              ["enter", u, o],
              ["enter", s[l][1], o],
              ["exit", s[l][1], o],
              ["enter", c, o]
            ];
            Mt(
              f,
              f.length,
              0,
              rl(
                o.parser.constructs.insideSpan.null,
                s.slice(l + 1, a),
                o
              )
            ), Mt(f, f.length, 0, [
              ["exit", c, o],
              ["enter", s[a][1], o],
              ["exit", s[a][1], o],
              ["exit", u, o]
            ]), Mt(s, l - 1, a - l + 3, f), a = l + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < s.length; )
      s[a][1].type === "strikethroughSequenceTemporary" && (s[a][1].type = "data");
    return s;
  }
  function i(s, o, a) {
    const l = this.previous, u = this.events;
    let c = 0;
    return f;
    function f(d) {
      return l === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(d) : (s.enter("strikethroughSequenceTemporary"), h(d));
    }
    function h(d) {
      const m = Oa(l);
      if (d === 126)
        return c > 1 ? a(d) : (s.consume(d), c++, h);
      if (c < 2 && !e)
        return a(d);
      const g = s.exit("strikethroughSequenceTemporary"), E = Oa(d);
      return g._open = !E || E === 2 && Boolean(m), g._close = !m || m === 2 && Boolean(E), o(d);
    }
  }
}
const lx = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Og.peek = dx;
const ux = {
  canContainEols: ["delete"],
  enter: { strikethrough: fx },
  exit: { strikethrough: hx }
}, cx = {
  unsafe: [
    {
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: lx
    }
  ],
  handlers: { delete: Og }
};
function fx(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function hx(t) {
  this.exit(t);
}
function Og(t, e, n, r) {
  const i = yc(r), s = n.enter("strikethrough");
  let o = i.move("~~");
  return o += Ac(t, n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function dx() {
  return "~";
}
function px(t) {
  return kg([ax(t)]);
}
function mx() {
  return [ux];
}
function gx() {
  return {
    extensions: [cx]
  };
}
function Ex(t = {}) {
  const e = this.data(), n = (r, i) => {
    (e[r] ? e[r] : e[r] = []).push(i);
  };
  n("micromarkExtensions", px(t)), n("fromMarkdownExtensions", mx()), n("toMarkdownExtensions", gx());
}
const wg = Ex, Dg = "֑-߿יִ-﷽ﹰ-ﻼ", Ig = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Tx = new RegExp("^[^" + Ig + "]*[" + Dg + "]"), Ax = new RegExp("^[^" + Dg + "]*[" + Ig + "]");
function yx(t) {
  const e = String(t || "");
  return Tx.test(e) ? "rtl" : Ax.test(e) ? "ltr" : "neutral";
}
function Cx(t) {
  return "children" in t ? Mg(t) : "value" in t ? t.value : "";
}
function bx(t) {
  return t.type === "text" ? t.value : "children" in t ? Mg(t) : "";
}
function Mg(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.children.length; )
    n[e] = bx(t.children[e]);
  return n.join("");
}
function xx(t, e) {
  const n = t.schema, r = t.language, i = t.direction, s = t.editableOrEditingHost;
  let o;
  if (e.type === "element" && e.properties) {
    const u = e.properties.xmlLang || e.properties.lang, c = e.properties.type || "text", f = op(e);
    u != null && (t.language = String(u)), n && n.space === "html" ? (e.properties.contentEditable === "true" && (t.editableOrEditingHost = !0), e.tagName === "svg" && (t.schema = Gn), f === "rtl" ? o = f : /* Explicit `[dir=ltr]`. */ f === "ltr" || // HTML with an invalid or no `[dir]`.
    f !== "auto" && e.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
    f !== "auto" && e.tagName === "input" && c === "tel" ? o = "ltr" : (f === "auto" || e.tagName === "bdi") && (e.tagName === "textarea" ? o = A1(Cx(e)) : e.tagName === "input" && (c === "email" || c === "search" || c === "tel" || c === "text") ? o = e.properties.value ? (
      // @ts-expect-error Assume string
      A1(e.properties.value)
    ) : "ltr" : Kt(e, l)), o && (t.direction = o)) : t.editableOrEditingHost && (t.editableOrEditingHost = !1);
  }
  return a;
  function a() {
    t.schema = n, t.language = r, t.direction = i, t.editableOrEditingHost = s;
  }
  function l(u) {
    if (u.type === "text")
      return o = A1(u.value), o ? $s : void 0;
    if (u !== e && u.type === "element" && (u.tagName === "bdi" || u.tagName === "script" || u.tagName === "style" || u.tagName === "textare" || op(u)))
      return Za;
  }
}
function A1(t) {
  const e = yx(t);
  return e === "neutral" ? void 0 : e;
}
function op(t) {
  const e = t.type === "element" && t.properties && typeof t.properties.dir == "string" ? t.properties.dir.toLowerCase() : void 0;
  return e === "auto" || e === "ltr" || e === "rtl" ? e : void 0;
}
const Sx = Vi("operator", {
  unknown: Rx,
  // @ts-expect-error: hush.
  invalid: _x,
  handlers: {
    "=": kx,
    "~=": Ox,
    "|=": wx,
    "^=": Dx,
    "$=": Ix,
    "*=": Mx
  }
});
function Nx(t, e, n) {
  const r = t.attrs;
  let i = -1;
  for (; ++i < r.length; )
    if (!Sx(r[i], e, Ys(n, r[i].name)))
      return !1;
  return !0;
}
function _x(t, e, n) {
  return We(e, n.property);
}
function kx(t, e, n) {
  return Boolean(
    We(e, n.property) && e.properties && Ki(e.properties[n.property], n) === t.value
  );
}
function Ox(t, e, n) {
  const r = e.properties && e.properties[n.property];
  return (
    // If this is a space-separated list, and the query is contained in it, return
    // true.
    !n.commaSeparated && r && typeof r == "object" && t.value && r.includes(t.value) || // For all other values (including comma-separated lists), return whether this
    // is an exact match.
    We(e, n.property) && Ki(r, n) === t.value
  );
}
function wx(t, e, n) {
  const r = Ki(
    e.properties && e.properties[n.property],
    n
  );
  return Boolean(
    We(e, n.property) && t.value && (r === t.value || r.slice(0, t.value.length) === t.value && r.charAt(t.value.length) === "-")
  );
}
function Dx(t, e, n) {
  return Boolean(
    We(e, n.property) && e.properties && t.value && Ki(e.properties[n.property], n).slice(
      0,
      t.value.length
    ) === t.value
  );
}
function Ix(t, e, n) {
  return Boolean(
    We(e, n.property) && e.properties && t.value && Ki(e.properties[n.property], n).slice(
      -t.value.length
    ) === t.value
  );
}
function Mx(t, e, n) {
  return Boolean(
    We(e, n.property) && e.properties && t.value && Ki(e.properties[n.property], n).includes(
      t.value
    )
  );
}
function Rx(t) {
  throw new Error("Unknown operator `" + t.operator + "`");
}
function Ki(t, e) {
  return typeof t == "boolean" ? e.attribute : Array.isArray(t) ? (e.commaSeparated ? fc : cc)(t) : String(t);
}
function vx(t, e) {
  const n = e.properties.className || [];
  let r = -1;
  if (t.classNames) {
    for (; ++r < t.classNames.length; )
      if (!n.includes(t.classNames[r]))
        return !1;
  }
  return !0;
}
function Lx(t, e) {
  return Boolean(e.properties && e.properties.id === t.id);
}
function Px(t, e) {
  return t.tagName === "*" || t.tagName === e.tagName;
}
function Bx(t, e) {
  return function(n, r) {
    let i = ap(n, "tag");
    const s = ap(
      r ?? "*",
      "range"
    ), o = [];
    let a = -1;
    for (; ++a < s.length; ) {
      const l = s[a].toLowerCase();
      if (!e && l === "*")
        continue;
      let u = -1;
      const c = [];
      for (; ++u < i.length; )
        if (t(i[u].toLowerCase(), l)) {
          if (!e)
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              i[u]
            );
          o.push(i[u]);
        } else
          c.push(i[u]);
      i = c;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      e ? o : void 0
    );
  };
}
const Fx = Bx(function(t, e) {
  const n = t.split("-"), r = e.split("-");
  let i = 0, s = 0;
  if (r[s] !== "*" && n[i] !== r[s])
    return !1;
  for (i++, s++; s < r.length; ) {
    if (r[s] === "*") {
      s++;
      continue;
    }
    if (!n[i])
      return !1;
    if (n[i] === r[s]) {
      i++, s++;
      continue;
    }
    if (n[i].length === 1)
      return !1;
    i++;
  }
  return !0;
}, !0);
function ap(t, e) {
  const n = t && typeof t == "string" ? [t] : t;
  if (!n || typeof n != "object" || !("length" in n))
    throw new Error(
      "Invalid " + e + " `" + n + "`, expected non-empty string"
    );
  return n;
}
const Hx = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]), lp = "0".charCodeAt(0), Ux = "9".charCodeAt(0);
function qx(t) {
  if (t = t.trim().toLowerCase(), t === "even")
    return [2, 0];
  if (t === "odd")
    return [2, 1];
  let e = 0, n = 0, r = s(), i = o();
  if (e < t.length && t.charAt(e) === "n" && (e++, n = r * (i ?? 1), a(), e < t.length ? (r = s(), a(), i = o()) : r = i = 0), i === null || e < t.length)
    throw new Error(`n-th rule couldn't be parsed ('${t}')`);
  return [n, r * i];
  function s() {
    return t.charAt(e) === "-" ? (e++, -1) : (t.charAt(e) === "+" && e++, 1);
  }
  function o() {
    const l = e;
    let u = 0;
    for (; e < t.length && t.charCodeAt(e) >= lp && t.charCodeAt(e) <= Ux; )
      u = u * 10 + (t.charCodeAt(e) - lp), e++;
    return e === l ? null : u;
  }
  function a() {
    for (; e < t.length && Hx.has(t.charCodeAt(e)); )
      e++;
  }
}
var up = {
  trueFunc: function() {
    return !0;
  },
  falseFunc: function() {
    return !1;
  }
};
function zx(t) {
  const e = t[0], n = t[1] - 1;
  if (n < 0 && e <= 0)
    return up.falseFunc;
  if (e === -1)
    return (s) => s <= n;
  if (e === 0)
    return (s) => s === n;
  if (e === 1)
    return n < 0 ? up.trueFunc : (s) => s >= n;
  const r = Math.abs(e), i = (n % r + r) % r;
  return e > 1 ? (s) => s >= n && s % r === i : (s) => s <= n && s % r === i;
}
function cp(t) {
  return zx(qx(t));
}
const $x = cp.default || cp, Gx = Vi("name", {
  unknown: mS,
  invalid: pS,
  handlers: {
    any: bu,
    "any-link": jx,
    blank: Vx,
    checked: Kx,
    dir: Wx,
    disabled: vg,
    empty: Yx,
    enabled: Qx,
    "first-child": Jx,
    "first-of-type": Xx,
    has: Zx,
    lang: eS,
    "last-child": tS,
    "last-of-type": nS,
    matches: bu,
    not: rS,
    "nth-child": iS,
    "nth-last-child": sS,
    "nth-of-type": aS,
    "nth-last-of-type": oS,
    "only-child": lS,
    "only-of-type": uS,
    optional: cS,
    "read-only": fS,
    "read-write": Lg,
    required: Pg,
    root: hS,
    scope: dS
  }
});
Rg.needsIndex = [
  "any",
  "first-child",
  "first-of-type",
  "last-child",
  "last-of-type",
  "matches",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-of-type",
  "nth-last-of-type",
  "only-child",
  "only-of-type"
];
function Rg(t, e, n, r, i) {
  const s = t.pseudos;
  let o = -1;
  for (; ++o < s.length; )
    if (!Gx(s[o], e, n, r, i))
      return !1;
  return !0;
}
function jx(t, e) {
  return (e.tagName === "a" || e.tagName === "area" || e.tagName === "link") && We(e, "href");
}
function Vx(t, e) {
  return !Bg(e, n);
  function n(r) {
    return r.type === "element" || r.type === "text" && !gr(r);
  }
}
function Kx(t, e) {
  return e.tagName === "input" || e.tagName === "menuitem" ? Boolean(
    e.properties && (e.properties.type === "checkbox" || e.properties.type === "radio") && We(e, "checked")
  ) : e.tagName === "option" ? We(e, "selected") : !1;
}
function Wx(t, e, n, r, i) {
  return i.direction === t.value;
}
function vg(t, e) {
  return (e.tagName === "button" || e.tagName === "input" || e.tagName === "select" || e.tagName === "textarea" || e.tagName === "optgroup" || e.tagName === "option" || e.tagName === "menuitem" || e.tagName === "fieldset") && We(e, "disabled");
}
function Yx(t, e) {
  return !Bg(e, n);
  function n(r) {
    return r.type === "element" || r.type === "text";
  }
}
function Qx(t, e) {
  return !vg(t, e);
}
function Jx(t, e, n, r, i) {
  return Nn(i, t), i.elementIndex === 0;
}
function Xx(t, e, n, r, i) {
  return Nn(i, t), i.typeIndex === 0;
}
function Zx(t, e, n, r, i) {
  const s = {
    ...i,
    // Not found yet.
    found: !1,
    // Do walk deep.
    shallow: !1,
    // One result is enough.
    one: !0,
    scopeElements: [e],
    results: [],
    rootQuery: Cc(t.value)
  };
  return bc(s, { type: "root", children: e.children }), s.results.length > 0;
}
function eS(t, e, n, r, i) {
  return i.language !== "" && i.language !== void 0 && // @ts-expect-error never `selectors`.
  Fx(i.language, mu(t.value)).length > 0;
}
function tS(t, e, n, r, i) {
  return Nn(i, t), Boolean(
    i.elementCount && i.elementIndex === i.elementCount - 1
  );
}
function nS(t, e, n, r, i) {
  return Nn(i, t), typeof i.typeIndex == "number" && typeof i.typeCount == "number" && i.typeIndex === i.typeCount - 1;
}
function bu(t, e, n, r, i) {
  const s = {
    ...i,
    // Not found yet.
    found: !1,
    // Do walk deep.
    shallow: !1,
    // One result is enough.
    one: !0,
    scopeElements: [e],
    results: [],
    rootQuery: Cc(t.value)
  };
  return bc(s, e), s.results[0] === e;
}
function rS(t, e, n, r, i) {
  return !bu(t, e, n, r, i);
}
function iS(t, e, n, r, i) {
  const s = il(t);
  return Nn(i, t), typeof i.elementIndex == "number" && s(i.elementIndex);
}
function sS(t, e, n, r, i) {
  const s = il(t);
  return Nn(i, t), Boolean(
    typeof i.elementCount == "number" && typeof i.elementIndex == "number" && s(i.elementCount - i.elementIndex - 1)
  );
}
function oS(t, e, n, r, i) {
  const s = il(t);
  return Nn(i, t), typeof i.typeCount == "number" && typeof i.typeIndex == "number" && s(i.typeCount - 1 - i.typeIndex);
}
function aS(t, e, n, r, i) {
  const s = il(t);
  return Nn(i, t), typeof i.typeIndex == "number" && s(i.typeIndex);
}
function lS(t, e, n, r, i) {
  return Nn(i, t), i.elementCount === 1;
}
function uS(t, e, n, r, i) {
  return Nn(i, t), i.typeCount === 1;
}
function cS(t, e) {
  return !Pg(t, e);
}
function fS(t, e, n, r, i) {
  return !Lg(t, e, n, r, i);
}
function Lg(t, e, n, r, i) {
  return e.tagName === "input" || e.tagName === "textarea" ? !We(e, "readOnly") && !We(e, "disabled") : Boolean(i.editableOrEditingHost);
}
function Pg(t, e) {
  return (e.tagName === "input" || e.tagName === "textarea" || e.tagName === "select") && We(e, "required");
}
function hS(t, e, n, r, i) {
  return Boolean(
    (!r || r.type === "root") && i.schema && (i.schema.space === "html" || i.schema.space === "svg") && (e.tagName === "html" || e.tagName === "svg")
  );
}
function dS(t, e, n, r, i) {
  return i.scopeElements.includes(e);
}
function pS() {
  throw new Error("Invalid pseudo-selector");
}
function mS(t) {
  throw t.name ? new Error("Unknown pseudo-selector `" + t.name + "`") : new Error("Unexpected pseudo-element or empty pseudo-class");
}
function Bg(t, e) {
  const n = t.children;
  let r = -1;
  for (; ++r < n.length; )
    if (e(n[r]))
      return !0;
  return !1;
}
function Nn(t, e) {
  if (t.shallow)
    throw new Error("Cannot use `:" + e.name + "` without parent");
}
function il(t) {
  let e = t._cachedFn;
  return e || (e = $x(t.value), t._cachedFn = e), e;
}
function gS(t, e, n, r, i) {
  return Boolean(
    (!t.tagName || Px(t, e)) && (!t.classNames || vx(t, e)) && (!t.id || Lx(t, e)) && (!t.attrs || Nx(t, e, i.schema)) && (!t.pseudos || Rg(t, e, n, r, i))
  );
}
const ES = [];
function Cc(t) {
  return t === null ? { type: "selectors", selectors: [] } : t.type === "ruleSet" ? { type: "selectors", selectors: [t] } : t;
}
function bc(t, e) {
  e && Fg(t, [], e, void 0, void 0);
}
function Fg(t, e, n, r, i) {
  let s = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  const o = xx(t, n);
  return n.type === "element" && (s = AS(
    t,
    // Try the root rules for this element too.
    Uo(e, t.rootQuery.selectors),
    n,
    r,
    i
  )), "children" in n && !t.shallow && !(t.one && t.found) && TS(t, s, n), o(), s;
}
function TS(t, e, n) {
  const r = Uo(e.descendant, e.directChild);
  let i, s = -1;
  const o = { count: 0, types: /* @__PURE__ */ new Map() }, a = { count: 0, types: /* @__PURE__ */ new Map() };
  for (; ++s < n.children.length; )
    fp(o, n.children[s]);
  for (s = -1; ++s < n.children.length; ) {
    const l = n.children[s], u = l.type === "element" ? l.tagName.toUpperCase() : void 0;
    if (t.elementIndex = a.count, t.typeIndex = u && a.types.get(u) || 0, t.elementCount = o.count, t.typeCount = u ? o.types.get(u) : 0, "children" in l) {
      const c = Uo(r, i), f = Fg(t, c, n.children[s], s, n);
      i = Uo(f.generalSibling, f.adjacentSibling);
    }
    if (t.one && t.found)
      break;
    fp(a, n.children[s]);
  }
}
function AS(t, e, n, r, i) {
  const s = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  let o = -1;
  for (; ++o < e.length; ) {
    const a = e[o];
    if (t.one && t.found)
      break;
    if (t.shallow && a.rule.rule)
      throw new Error("Expected selector without nesting");
    if (gS(a.rule, n, r, i, t)) {
      const l = a.rule.rule;
      if (l) {
        const u = { type: "ruleSet", rule: l }, c = l.nestingOperator === "+" ? "adjacentSibling" : l.nestingOperator === "~" ? "generalSibling" : l.nestingOperator === ">" ? "directChild" : "descendant";
        y1(s, c, u);
      } else
        t.found = !0, t.results.includes(n) || t.results.push(n);
    }
    a.rule.nestingOperator === null ? y1(s, "descendant", a) : a.rule.nestingOperator === "~" && y1(s, "generalSibling", a);
  }
  return s;
}
function Uo(t, e) {
  return t && e && t.length > 0 && e.length > 0 ? [...t, ...e] : t && t.length > 0 ? t : e && e.length > 0 ? e : ES;
}
function y1(t, e, n) {
  const r = t[e];
  r ? r.push(n) : t[e] = [n];
}
function fp(t, e) {
  if (e.type === "element") {
    const n = e.tagName.toUpperCase(), r = (t.types.get(n) || 0) + 1;
    t.count++, t.types.set(n, r);
  }
}
var Hg = {}, xc = {}, Sc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(o) {
    return o >= "a" && o <= "z" || o >= "A" && o <= "Z" || o === "-" || o === "_";
  }
  t.isIdentStart = e;
  function n(o) {
    return o >= "a" && o <= "z" || o >= "A" && o <= "Z" || o >= "0" && o <= "9" || o === "-" || o === "_";
  }
  t.isIdent = n;
  function r(o) {
    return o >= "a" && o <= "f" || o >= "A" && o <= "F" || o >= "0" && o <= "9";
  }
  t.isHex = r;
  function i(o) {
    for (var a = o.length, l = "", u = 0; u < a; ) {
      var c = o.charAt(u);
      if (t.identSpecialChars[c])
        l += "\\" + c;
      else if (c === "_" || c === "-" || c >= "A" && c <= "Z" || c >= "a" && c <= "z" || u !== 0 && c >= "0" && c <= "9")
        l += c;
      else {
        var f = c.charCodeAt(0);
        if ((f & 63488) === 55296) {
          var h = o.charCodeAt(u++);
          if ((f & 64512) !== 55296 || (h & 64512) !== 56320)
            throw Error("UCS-2(decode): illegal sequence");
          f = ((f & 1023) << 10) + (h & 1023) + 65536;
        }
        l += "\\" + f.toString(16) + " ";
      }
      u++;
    }
    return l;
  }
  t.escapeIdentifier = i;
  function s(o) {
    for (var a = o.length, l = "", u = 0, c; u < a; ) {
      var f = o.charAt(u);
      f === '"' ? f = '\\"' : f === "\\" ? f = "\\\\" : (c = t.strReplacementsRev[f]) !== void 0 && (f = c), l += f, u++;
    }
    return '"' + l + '"';
  }
  t.escapeStr = s, t.identSpecialChars = {
    "!": !0,
    '"': !0,
    "#": !0,
    $: !0,
    "%": !0,
    "&": !0,
    "'": !0,
    "(": !0,
    ")": !0,
    "*": !0,
    "+": !0,
    ",": !0,
    ".": !0,
    "/": !0,
    ";": !0,
    "<": !0,
    "=": !0,
    ">": !0,
    "?": !0,
    "@": !0,
    "[": !0,
    "\\": !0,
    "]": !0,
    "^": !0,
    "`": !0,
    "{": !0,
    "|": !0,
    "}": !0,
    "~": !0
  }, t.strReplacementsRev = {
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\f": "\\f",
    "\v": "\\v"
  }, t.singleQuoteEscapeChars = {
    n: `
`,
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    "'": "'"
  }, t.doubleQuotesEscapeChars = {
    n: `
`,
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    '"': '"'
  };
})(Sc);
Object.defineProperty(xc, "__esModule", { value: !0 });
var en = Sc;
function yS(t, e, n, r, i, s) {
  var o = t.length, a = "";
  function l(g, E) {
    var T = "";
    for (e++, a = t.charAt(e); e < o; ) {
      if (a === g)
        return e++, T;
      if (a === "\\") {
        e++, a = t.charAt(e);
        var k = void 0;
        if (a === g)
          T += g;
        else if ((k = E[a]) !== void 0)
          T += k;
        else if (en.isHex(a)) {
          var _ = a;
          for (e++, a = t.charAt(e); en.isHex(a); )
            _ += a, e++, a = t.charAt(e);
          a === " " && (e++, a = t.charAt(e)), T += String.fromCharCode(parseInt(_, 16));
          continue;
        } else
          T += a;
      } else
        T += a;
      e++, a = t.charAt(e);
    }
    return T;
  }
  function u() {
    var g = "";
    for (a = t.charAt(e); e < o; ) {
      if (en.isIdent(a))
        g += a;
      else if (a === "\\") {
        if (e++, e >= o)
          throw Error("Expected symbol but end of file reached.");
        if (a = t.charAt(e), en.identSpecialChars[a])
          g += a;
        else if (en.isHex(a)) {
          var E = a;
          for (e++, a = t.charAt(e); en.isHex(a); )
            E += a, e++, a = t.charAt(e);
          a === " " && (e++, a = t.charAt(e)), g += String.fromCharCode(parseInt(E, 16));
          continue;
        } else
          g += a;
      } else
        return g;
      e++, a = t.charAt(e);
    }
    return g;
  }
  function c() {
    a = t.charAt(e);
    for (var g = !1; a === " " || a === "	" || a === `
` || a === "\r" || a === "\f"; )
      g = !0, e++, a = t.charAt(e);
    return g;
  }
  function f() {
    var g = h();
    if (e < o)
      throw Error('Rule expected but "' + t.charAt(e) + '" found.');
    return g;
  }
  function h() {
    var g = d();
    if (!g)
      return null;
    var E = g;
    for (a = t.charAt(e); a === ","; ) {
      if (e++, c(), E.type !== "selectors" && (E = {
        type: "selectors",
        selectors: [g]
      }), g = d(), !g)
        throw Error('Rule expected after ",".');
      E.selectors.push(g);
    }
    return E;
  }
  function d() {
    c();
    var g = {
      type: "ruleSet"
    }, E = m();
    if (!E)
      return null;
    for (var T = g; E && (E.type = "rule", T.rule = E, T = E, c(), a = t.charAt(e), !(e >= o || a === "," || a === ")")); )
      if (i[a]) {
        var k = a;
        if (e++, c(), E = m(), !E)
          throw Error('Rule expected after "' + k + '".');
        E.nestingOperator = k;
      } else
        E = m(), E && (E.nestingOperator = null);
    return g;
  }
  function m() {
    for (var g = null; e < o; )
      if (a = t.charAt(e), a === "*")
        e++, (g = g || {}).tagName = "*";
      else if (en.isIdentStart(a) || a === "\\")
        (g = g || {}).tagName = u();
      else if (a === ".")
        e++, g = g || {}, (g.classNames = g.classNames || []).push(u());
      else if (a === "#")
        e++, (g = g || {}).id = u();
      else if (a === "[") {
        e++, c();
        var E = {
          name: u()
        };
        if (c(), a === "]")
          e++;
        else {
          var T = "";
          if (r[a] && (T = a, e++, a = t.charAt(e)), e >= o)
            throw Error('Expected "=" but end of file reached.');
          if (a !== "=")
            throw Error('Expected "=" but "' + a + '" found.');
          E.operator = T + "=", e++, c();
          var k = "";
          if (E.valueType = "string", a === '"')
            k = l('"', en.doubleQuotesEscapeChars);
          else if (a === "'")
            k = l("'", en.singleQuoteEscapeChars);
          else if (s && a === "$")
            e++, k = u(), E.valueType = "substitute";
          else {
            for (; e < o && a !== "]"; )
              k += a, e++, a = t.charAt(e);
            k = k.trim();
          }
          if (c(), e >= o)
            throw Error('Expected "]" but end of file reached.');
          if (a !== "]")
            throw Error('Expected "]" but "' + a + '" found.');
          e++, E.value = k;
        }
        g = g || {}, (g.attrs = g.attrs || []).push(E);
      } else if (a === ":") {
        e++;
        var _ = u(), R = {
          name: _
        };
        if (a === "(") {
          e++;
          var M = "";
          if (c(), n[_] === "selector")
            R.valueType = "selector", M = h();
          else {
            if (R.valueType = n[_] || "string", a === '"')
              M = l('"', en.doubleQuotesEscapeChars);
            else if (a === "'")
              M = l("'", en.singleQuoteEscapeChars);
            else if (s && a === "$")
              e++, M = u(), R.valueType = "substitute";
            else {
              for (; e < o && a !== ")"; )
                M += a, e++, a = t.charAt(e);
              M = M.trim();
            }
            c();
          }
          if (e >= o)
            throw Error('Expected ")" but end of file reached.');
          if (a !== ")")
            throw Error('Expected ")" but "' + a + '" found.');
          e++, R.value = M;
        }
        g = g || {}, (g.pseudos = g.pseudos || []).push(R);
      } else
        break;
    return g;
  }
  return f();
}
xc.parseCssSelector = yS;
var Nc = {};
Object.defineProperty(Nc, "__esModule", { value: !0 });
var Ot = Sc;
function qo(t) {
  var e = "";
  switch (t.type) {
    case "ruleSet":
      for (var n = t.rule, r = []; n; )
        n.nestingOperator && r.push(n.nestingOperator), r.push(qo(n)), n = n.rule;
      e = r.join(" ");
      break;
    case "selectors":
      e = t.selectors.map(qo).join(", ");
      break;
    case "rule":
      t.tagName && (t.tagName === "*" ? e = "*" : e = Ot.escapeIdentifier(t.tagName)), t.id && (e += "#" + Ot.escapeIdentifier(t.id)), t.classNames && (e += t.classNames.map(function(i) {
        return "." + Ot.escapeIdentifier(i);
      }).join("")), t.attrs && (e += t.attrs.map(function(i) {
        return "operator" in i ? i.valueType === "substitute" ? "[" + Ot.escapeIdentifier(i.name) + i.operator + "$" + i.value + "]" : "[" + Ot.escapeIdentifier(i.name) + i.operator + Ot.escapeStr(i.value) + "]" : "[" + Ot.escapeIdentifier(i.name) + "]";
      }).join("")), t.pseudos && (e += t.pseudos.map(function(i) {
        return i.valueType ? i.valueType === "selector" ? ":" + Ot.escapeIdentifier(i.name) + "(" + qo(i.value) + ")" : i.valueType === "substitute" ? ":" + Ot.escapeIdentifier(i.name) + "($" + i.value + ")" : i.valueType === "numeric" ? ":" + Ot.escapeIdentifier(i.name) + "(" + i.value + ")" : ":" + Ot.escapeIdentifier(i.name) + "(" + Ot.escapeIdentifier(i.value) + ")" : ":" + Ot.escapeIdentifier(i.name);
      }).join(""));
      break;
    default:
      throw Error('Unknown entity type: "' + t.type + '".');
  }
  return e;
}
Nc.renderEntity = qo;
Object.defineProperty(Hg, "__esModule", { value: !0 });
var CS = xc, bS = Nc, xS = (
  /** @class */
  function() {
    function t() {
      this.pseudos = {}, this.attrEqualityMods = {}, this.ruleNestingOperators = {}, this.substitutesEnabled = !1;
    }
    return t.prototype.registerSelectorPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.pseudos[s] = "selector";
      }
      return this;
    }, t.prototype.unregisterSelectorPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.pseudos[s];
      }
      return this;
    }, t.prototype.registerNumericPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.pseudos[s] = "numeric";
      }
      return this;
    }, t.prototype.unregisterNumericPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.pseudos[s];
      }
      return this;
    }, t.prototype.registerNestingOperators = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.ruleNestingOperators[s] = !0;
      }
      return this;
    }, t.prototype.unregisterNestingOperators = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.ruleNestingOperators[s];
      }
      return this;
    }, t.prototype.registerAttrEqualityMods = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.attrEqualityMods[s] = !0;
      }
      return this;
    }, t.prototype.unregisterAttrEqualityMods = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.attrEqualityMods[s];
      }
      return this;
    }, t.prototype.enableSubstitutes = function() {
      return this.substitutesEnabled = !0, this;
    }, t.prototype.disableSubstitutes = function() {
      return this.substitutesEnabled = !1, this;
    }, t.prototype.parse = function(e) {
      return CS.parseCssSelector(e, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    }, t.prototype.render = function(e) {
      return bS.renderEntity(e).trim();
    }, t;
  }()
), SS = Hg.CssSelectorParser = xS;
const sl = new SS();
sl.registerAttrEqualityMods("~", "|", "^", "$", "*");
sl.registerSelectorPseudos("any", "matches", "not", "has");
sl.registerNestingOperators(">", "+", "~");
function NS(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `string` as selector, not `" + t + "`");
  return sl.parse(t);
}
function _S(t, e, n) {
  const r = kS(t, e, n);
  return bc(r, e || void 0), r.results;
}
function kS(t, e, n) {
  return {
    // State of the query.
    rootQuery: Cc(NS(t)),
    results: [],
    // @ts-expect-error assume elements.
    scopeElements: e ? e.type === "root" ? e.children : [e] : [],
    one: !1,
    shallow: !1,
    found: !1,
    // State in the tree.
    schema: n === "svg" ? Gn : Gi,
    language: void 0,
    direction: "ltr",
    editableOrEditingHost: !1,
    typeIndex: void 0,
    elementIndex: void 0,
    typeCount: void 0,
    elementCount: void 0
  };
}
const OS = (t) => {
  const { selector: e, rewrite: n } = t || {};
  return (r) => {
    if (!(!n || typeof n != "function")) {
      if (e && typeof e == "string") {
        const i = _S(e, r);
        i && i.length > 0 && Kt(r, i, (s, o, a) => {
          n(s, o, a);
        });
        return;
      }
      Kt(r, (i, s, o) => {
        n(i, s, o);
      });
    }
  };
}, Ug = OS, Ms = {
  strip: ["script"],
  clobberPrefix: "user-content-",
  clobber: ["name", "id"],
  ancestors: {
    tbody: ["table"],
    tfoot: ["table"],
    thead: ["table"],
    td: ["table"],
    th: ["table"],
    tr: ["table"]
  },
  protocols: {
    href: ["http", "https", "mailto", "xmpp", "irc", "ircs"],
    cite: ["http", "https"],
    src: ["http", "https"],
    longDesc: ["http", "https"]
  },
  tagNames: [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "br",
    "b",
    "i",
    "strong",
    "em",
    "a",
    "pre",
    "code",
    "img",
    "tt",
    "div",
    "ins",
    "del",
    "sup",
    "sub",
    "p",
    "ol",
    "ul",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "blockquote",
    "dl",
    "dt",
    "dd",
    "kbd",
    "q",
    "samp",
    "var",
    "hr",
    "ruby",
    "rt",
    "rp",
    "li",
    "tr",
    "td",
    "th",
    "s",
    "strike",
    "summary",
    "details",
    "caption",
    "figure",
    "figcaption",
    "abbr",
    "bdo",
    "cite",
    "dfn",
    "mark",
    "small",
    "span",
    "time",
    "wbr",
    "input"
  ],
  attributes: {
    a: ["href"],
    img: ["src", "longDesc"],
    input: [
      ["type", "checkbox"],
      ["disabled", !0]
    ],
    li: [["className", "task-list-item"]],
    div: ["itemScope", "itemType"],
    blockquote: ["cite"],
    del: ["cite"],
    ins: ["cite"],
    q: ["cite"],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "ariaDescribedBy",
      "ariaHidden",
      "ariaLabel",
      "ariaLabelledBy",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "cols",
      "colSpan",
      "color",
      "compact",
      "coords",
      "dateTime",
      "dir",
      "disabled",
      "encType",
      "htmlFor",
      "frame",
      "headers",
      "height",
      "hrefLang",
      "hSpace",
      "isMap",
      "id",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rel",
      "rev",
      "rows",
      "rowSpan",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "vAlign",
      "value",
      "vSpace",
      "width",
      "itemProp"
    ]
  },
  required: {
    input: {
      type: "checkbox",
      disabled: !0
    }
  }
}, An = {}.hasOwnProperty, C1 = {
  root: { children: hp },
  doctype: DS,
  comment: IS,
  element: {
    tagName: zg,
    properties: MS,
    children: hp
  },
  text: { value: LS },
  "*": { data: dp, position: dp }
};
function wS(t, e) {
  let n = { type: "root", children: [] };
  if (t && typeof t == "object" && t.type) {
    const r = qg(
      Object.assign({}, Ms, e || {}),
      t,
      []
    );
    r && (Array.isArray(r) ? r.length === 1 ? n = r[0] : n.children = r : n = r);
  }
  return n;
}
function qg(t, e, n) {
  const r = e && e.type, i = { type: e.type };
  let s;
  if (An.call(C1, r)) {
    let o = C1[r];
    if (typeof o == "function" && (o = o(t, e)), o) {
      const a = Object.assign({}, o, C1["*"]);
      let l;
      s = !0;
      for (l in a)
        if (An.call(a, l)) {
          const u = a[l](t, e[l], e, n);
          u === !1 ? (s = void 0, i[l] = e[l]) : u != null && (i[l] = u);
        }
    }
  }
  return s ? i : i.type === "element" && t.strip && !t.strip.includes(i.tagName) ? i.children : void 0;
}
function hp(t, e, n, r) {
  const i = [];
  if (Array.isArray(e)) {
    let s = -1;
    for (n.type === "element" && r.push(n.tagName); ++s < e.length; ) {
      const o = qg(t, e[s], r);
      o && (Array.isArray(o) ? i.push(...o) : i.push(o));
    }
    n.type === "element" && r.pop();
  }
  return i;
}
function DS(t) {
  return t.allowDoctypes ? { name: RS } : void 0;
}
function IS(t) {
  return t.allowComments ? { value: vS } : void 0;
}
function MS(t, e, n, r) {
  const i = zg(t, n.tagName, n, r), s = t.attributes || {}, o = t.required || {}, a = e || {}, l = Object.assign(
    {},
    pp(s["*"]),
    pp(i && An.call(s, i) ? s[i] : [])
  ), u = {};
  let c;
  for (c in a)
    if (An.call(a, c)) {
      let f = a[c], h;
      if (An.call(l, c))
        h = l[c];
      else if (FS(c) && An.call(l, "data*"))
        h = l["data*"];
      else
        continue;
      f = Array.isArray(f) ? PS(t, f, c, h) : $g(t, f, c, h), f != null && (u[c] = f);
    }
  if (i && An.call(o, i))
    for (c in o[i])
      An.call(u, c) || (u[c] = o[i][c]);
  return u;
}
function RS() {
  return "html";
}
function zg(t, e, n, r) {
  const i = typeof e == "string" ? e : "";
  let s = -1;
  if (!i || i === "*" || t.tagNames && !t.tagNames.includes(i))
    return !1;
  if (t.ancestors && An.call(t.ancestors, i)) {
    for (; ++s < t.ancestors[i].length; )
      if (r.includes(t.ancestors[i][s]))
        return i;
    return !1;
  }
  return i;
}
function vS(t, e) {
  const n = typeof e == "string" ? e : "", r = n.indexOf("-->");
  return r < 0 ? n : n.slice(0, r);
}
function LS(t, e) {
  return typeof e == "string" ? e : "";
}
function dp(t, e) {
  return e;
}
function PS(t, e, n, r) {
  let i = -1;
  const s = [];
  for (; ++i < e.length; ) {
    const o = $g(t, e[i], n, r);
    o != null && s.push(o);
  }
  return s;
}
function $g(t, e, n, r) {
  if ((typeof e == "boolean" || typeof e == "number" || typeof e == "string") && BS(t, e, n) && (r.length === 0 || r.some(
    (i) => i && typeof i == "object" && "flags" in i ? i.test(String(e)) : i === e
  )))
    return t.clobberPrefix && t.clobber && t.clobber.includes(n) ? t.clobberPrefix + e : e;
}
function BS(t, e, n) {
  const r = String(e), i = r.indexOf(":"), s = r.indexOf("?"), o = r.indexOf("#"), a = r.indexOf("/"), l = t.protocols && An.call(t.protocols, n) ? t.protocols[n].concat() : [];
  let u = -1;
  if (l.length === 0 || i < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
  a > -1 && i > a || s > -1 && i > s || o > -1 && i > o)
    return !0;
  for (; ++u < l.length; )
    if (i === l[u].length && r.slice(0, l[u].length) === l[u])
      return !0;
  return !1;
}
function pp(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? e[r[0]] = r.slice(1) : e[r] = [];
  }
  return e;
}
function FS(t) {
  return t.length > 4 && t.slice(0, 4).toLowerCase() === "data";
}
function Gg(t = Ms) {
  return (e) => wS(e, t);
}
const jg = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
function Vg(t, e) {
  if (t = t.replace(
    e.subset ? HS(e.subset) : /["&'<>`]/g,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, n).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    r
  );
  function n(i, s, o) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      o.charCodeAt(s + 2),
      e
    );
  }
  function r(i, s, o) {
    return e.format(
      i.charCodeAt(0),
      o.charCodeAt(s + 1),
      e
    );
  }
}
function HS(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
function US(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !/[\dA-Fa-f]/.test(String.fromCharCode(e)) ? r : r + ";";
}
function qS(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !/\d/.test(String.fromCharCode(e)) ? r : r + ";";
}
const Kg = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], b1 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, zS = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], Wg = {}.hasOwnProperty, xu = {};
let _o;
for (_o in b1)
  Wg.call(b1, _o) && (xu[b1[_o]] = _o);
function $S(t, e, n, r) {
  const i = String.fromCharCode(t);
  if (Wg.call(xu, i)) {
    const s = xu[i], o = "&" + s;
    return n && Kg.includes(s) && !zS.includes(s) && (!r || e && e !== 61 && /[^\da-z]/i.test(String.fromCharCode(e))) ? o : o + ";";
  }
  return "";
}
function GS(t, e, n) {
  let r = US(t, e, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = $S(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const s = qS(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function jS(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function Mi(t, e) {
  return Vg(t, Object.assign({ format: GS }, e));
}
function VS(t, e) {
  return Vg(t, Object.assign({ format: jS }, e));
}
function KS(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Mi(
    t.value,
    Object.assign({}, r.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + t.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, i) + "-->";
  function i(s) {
    return Mi(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function WS(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
function mp(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(e);
  for (; i !== -1; )
    r++, i = n.indexOf(e, i + e.length);
  return r;
}
const Ge = Qg(1), Yg = Qg(-1);
function Qg(t) {
  return e;
  function e(n, r, i) {
    const s = n ? n.children : [];
    let o = (r || 0) + t, a = s && s[o];
    if (!i)
      for (; a && gr(a); )
        o += t, a = s[o];
    return a;
  }
}
const YS = {}.hasOwnProperty;
function Jg(t) {
  return e;
  function e(n, r, i) {
    return YS.call(t, n.tagName) && t[n.tagName](n, r, i);
  }
}
const _c = Jg({
  html: QS,
  head: x1,
  body: JS,
  p: XS,
  li: ZS,
  dt: eN,
  dd: tN,
  rt: gp,
  rp: gp,
  optgroup: nN,
  option: rN,
  menuitem: iN,
  colgroup: x1,
  caption: x1,
  thead: sN,
  tbody: oN,
  tfoot: aN,
  tr: lN,
  td: Ep,
  th: Ep
});
function x1(t, e, n) {
  const r = Ge(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && gr(r.value.charAt(0)));
}
function QS(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type !== "comment";
}
function JS(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type !== "comment";
}
function XS(t, e, n) {
  const r = Ge(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function ZS(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function eN(t, e, n) {
  const r = Ge(n, e);
  return r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function tN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function gp(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function nN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function rN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function iN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "menuitem" || r.tagName === "hr" || r.tagName === "menu");
}
function sN(t, e, n) {
  const r = Ge(n, e);
  return r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function oN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function aN(t, e, n) {
  return !Ge(n, e);
}
function lN(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function Ep(t, e, n) {
  const r = Ge(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const uN = Jg({
  html: cN,
  head: fN,
  body: hN,
  colgroup: dN,
  tbody: pN
});
function cN(t) {
  const e = Ge(t, -1);
  return !e || e.type !== "comment";
}
function fN(t) {
  const e = t.children, n = [];
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r];
    if (i.type === "element" && (i.tagName === "title" || i.tagName === "base")) {
      if (n.includes(i.tagName))
        return !1;
      n.push(i.tagName);
    }
  }
  return e.length > 0;
}
function hN(t) {
  const e = Ge(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && gr(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function dN(t, e, n) {
  const r = Yg(n, e), i = Ge(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && _c(r, n.children.indexOf(r), n) ? !1 : i && i.type === "element" && i.tagName === "col";
}
function pN(t, e, n) {
  const r = Yg(n, e), i = Ge(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && _c(r, n.children.indexOf(r), n) ? !1 : i && i.type === "element" && i.tagName === "tr";
}
const ko = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function mN(t, e, n, r) {
  const i = r.schema, s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let o = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const a = [];
  let l;
  i.space === "html" && t.tagName === "svg" && (r.schema = Gn);
  const u = gN(r, t.properties), c = r.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = i, c && (o = !1), (u || !s || !uN(t, e, n)) && (a.push("<", t.tagName, u ? " " + u : ""), o && (i.space === "svg" || r.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(c), !o && (!s || !_c(t, e, n)) && a.push("</" + t.tagName + ">"), a.join("");
}
function gN(t, e) {
  const n = [];
  let r = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== void 0 && e[i] !== null) {
        const s = EN(t, i, e[i]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : null;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function EN(t, e, n) {
  const r = Ys(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let o = t.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean && typeof n != "string") && (n = Boolean(n)), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const l = Mi(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: ko.name[i][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? fc : cc)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? l : (t.settings.preferUnquoted && (a = Mi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      subset: ko.unquoted[i][s],
      attribute: !0
    })
  )), a !== n && (t.settings.quoteSmart && mp(n, o) > mp(n, t.alternative) && (o = t.alternative), a = o + Mi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (o === "'" ? ko.single : ko.double)[i][s],
      attribute: !0
    })
  ) + o), l + (a && "=" + a));
}
function Xg(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Mi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function TN(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : Xg(t, e, n, r);
}
function AN(t, e, n, r) {
  return r.all(t);
}
const yN = Vi("type", {
  invalid: CN,
  unknown: bN,
  handlers: { comment: KS, doctype: WS, element: mN, raw: TN, root: AN, text: Xg }
});
function CN(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function bN(t) {
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
function Zg(t, e) {
  const n = e || {}, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: xN,
    all: SN,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || jg,
      characterReferences: n.characterReferences || n.entities || {},
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Gn : Gi,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function xN(t, e, n) {
  return yN(t, e, n, this);
}
function SN(t) {
  const e = [], n = t && t.children || [];
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
const NN = {
  bullet: "*",
  listItemIndent: "one",
  rule: "-",
  emphasis: "_"
}, _N = { allowDangerousHtml: !0 }, e2 = { fragment: !0 }, kN = {
  handlers: {
    figure(t, e) {
      return t(
        e,
        "html",
        Zg(e, {
          closeSelfClosing: !1,
          closeEmptyElements: !0
        })
      );
    }
  }
}, t2 = {
  closeSelfClosing: !1,
  closeEmptyElements: !0
}, n2 = {
  rewrite: (t, e, n) => {
    t.type == "element" && t.tagName == "a" && t.properties && (t.properties.target = "_blank", t.properties.rel = "noopener noreferrer nofollow"), t.type == "element" && t.tagName == "del" && (t.tagName = "s"), t.type == "element" && t.tagName == "u" && (t.tagName = "strong");
  }
}, r2 = {
  tagNames: [
    ...Ms.tagNames,
    "iframe",
    "footer",
    "header",
    "audio",
    "source"
  ],
  protocols: {
    ...Ms.protocols,
    href: ["http", "https", "mailto", "tel"]
  },
  attributes: {
    ...Ms.attributes,
    a: ["href", "ref", "target"],
    img: ["src", "srcSet", "data*"],
    audio: ["controls", "data*", ["preload", "metadata"]],
    source: ["src", "type", "data*"],
    figure: [["className", "image", "audio", "embed-code", "embed-video"]],
    div: [
      [
        "className",
        "player",
        "progress-bar",
        "meta",
        "time",
        "iframe-container"
      ],
      "data*"
    ],
    h4: [["className", "title"]],
    span: [["className", "play", "current", "duration"], "data*"],
    iframe: [
      "src",
      "allowFullScreen",
      ["loading", "lazy"],
      ["frameBorder", "0"],
      ["sandbox", "allow-scripts", "allow-same-origin", "allow-popups"]
    ]
  }
}, ON = Ju().use(z9, e2).use(Ug, n2).use(r7, kN).use(wg).use(Z7, NN), hD = async (t) => {
  const e = await ON.process(t);
  return String(e);
};
function he(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(l) {
    return ve(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return ve(l) && s++ < i ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
const wN = {
  tokenize: DN
};
function DN(t) {
  const e = t.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), he(t, e, "linePrefix");
  }
  function i(a) {
    return t.enter("paragraph"), s(a);
  }
  function s(a) {
    const l = t.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(a);
  }
  function o(a) {
    if (a === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(a);
      return;
    }
    return Z(a) ? (t.consume(a), t.exit("chunkText"), s) : (t.consume(a), o);
  }
}
const IN = {
  tokenize: MN
}, Tp = {
  tokenize: RN
};
function MN(t) {
  const e = this, n = [];
  let r = 0, i, s, o;
  return a;
  function a(_) {
    if (r < n.length) {
      const R = n[r];
      return e.containerState = R[1], t.attempt(
        R[0].continuation,
        l,
        u
      )(_);
    }
    return u(_);
  }
  function l(_) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && k();
      const R = e.events.length;
      let M = R, N;
      for (; M--; )
        if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") {
          N = e.events[M][1].end;
          break;
        }
      T(r);
      let S = R;
      for (; S < e.events.length; )
        e.events[S][1].end = Object.assign({}, N), S++;
      return Mt(
        e.events,
        M + 1,
        0,
        e.events.slice(R)
      ), e.events.length = S, u(_);
    }
    return a(_);
  }
  function u(_) {
    if (r === n.length) {
      if (!i)
        return h(_);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(_);
      e.interrupt = Boolean(
        i.currentConstruct && !i._gfmTableDynamicInterruptHack
      );
    }
    return e.containerState = {}, t.check(
      Tp,
      c,
      f
    )(_);
  }
  function c(_) {
    return i && k(), T(r), h(_);
  }
  function f(_) {
    return e.parser.lazy[e.now().line] = r !== n.length, o = e.now().offset, m(_);
  }
  function h(_) {
    return e.containerState = {}, t.attempt(
      Tp,
      d,
      m
    )(_);
  }
  function d(_) {
    return r++, n.push([e.currentConstruct, e.containerState]), h(_);
  }
  function m(_) {
    if (_ === null) {
      i && k(), T(0), t.consume(_);
      return;
    }
    return i = i || e.parser.flow(e.now()), t.enter("chunkFlow", {
      contentType: "flow",
      previous: s,
      _tokenizer: i
    }), g(_);
  }
  function g(_) {
    if (_ === null) {
      E(t.exit("chunkFlow"), !0), T(0), t.consume(_);
      return;
    }
    return Z(_) ? (t.consume(_), E(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, a) : (t.consume(_), g);
  }
  function E(_, R) {
    const M = e.sliceStream(_);
    if (R && M.push(null), _.previous = s, s && (s.next = _), s = _, i.defineSkip(_.start), i.write(M), e.parser.lazy[_.start.line]) {
      let N = i.events.length;
      for (; N--; )
        if (
          // The token starts before the line ending…
          i.events[N][1].start.offset < o && // …and either is not ended yet…
          (!i.events[N][1].end || // …or ends after it.
          i.events[N][1].end.offset > o)
        )
          return;
      const S = e.events.length;
      let O = S, $, J;
      for (; O--; )
        if (e.events[O][0] === "exit" && e.events[O][1].type === "chunkFlow") {
          if ($) {
            J = e.events[O][1].end;
            break;
          }
          $ = !0;
        }
      for (T(r), N = S; N < e.events.length; )
        e.events[N][1].end = Object.assign({}, J), N++;
      Mt(
        e.events,
        O + 1,
        0,
        e.events.slice(S)
      ), e.events.length = N;
    }
  }
  function T(_) {
    let R = n.length;
    for (; R-- > _; ) {
      const M = n[R];
      e.containerState = M[1], M[0].exit.call(e, t);
    }
    n.length = _;
  }
  function k() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function RN(t, e, n) {
  return he(
    t,
    t.attempt(this.parser.constructs.document, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const Su = {
  name: "attention",
  tokenize: LN,
  resolveAll: vN
};
function vN(t, e) {
  let n = -1, r, i, s, o, a, l, u, c;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
            continue;
          l = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, t[r][1].end), h = Object.assign({}, t[n][1].start);
          Ap(f, -l), Ap(h, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, t[r][1].end)
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, t[n][1].start),
            end: h
          }, s = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, t[r][1].end),
            end: Object.assign({}, t[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, a.end)
          }, t[r][1].end = Object.assign({}, o.start), t[n][1].start = Object.assign({}, a.end), u = [], t[r][1].end.offset - t[r][1].start.offset && (u = Ut(u, [
            ["enter", t[r][1], e],
            ["exit", t[r][1], e]
          ])), u = Ut(u, [
            ["enter", i, e],
            ["enter", o, e],
            ["exit", o, e],
            ["enter", s, e]
          ]), u = Ut(
            u,
            rl(
              e.parser.constructs.insideSpan.null,
              t.slice(r + 1, n),
              e
            )
          ), u = Ut(u, [
            ["exit", s, e],
            ["enter", a, e],
            ["exit", a, e],
            ["exit", i, e]
          ]), t[n][1].end.offset - t[n][1].start.offset ? (c = 2, u = Ut(u, [
            ["enter", t[n][1], e],
            ["exit", t[n][1], e]
          ])) : c = 0, Mt(t, r - 1, n - r + 3, u), n = r + u.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < t.length; )
    t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function LN(t, e) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Oa(r);
  let s;
  return o;
  function o(l) {
    return t.enter("attentionSequence"), s = l, a(l);
  }
  function a(l) {
    if (l === s)
      return t.consume(l), a;
    const u = t.exit("attentionSequence"), c = Oa(l), f = !c || c === 2 && i || n.includes(l), h = !i || i === 2 && c || n.includes(r);
    return u._open = Boolean(s === 42 ? f : f && (i || !h)), u._close = Boolean(s === 42 ? h : h && (c || !f)), e(l);
  }
}
function Ap(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
const PN = {
  name: "autolink",
  tokenize: BN
};
function BN(t, e, n) {
  let r = 1;
  return i;
  function i(m) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(m), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), s;
  }
  function s(m) {
    return $t(m) ? (t.consume(m), o) : sp(m) ? u(m) : n(m);
  }
  function o(m) {
    return m === 43 || m === 45 || m === 46 || pt(m) ? a(m) : u(m);
  }
  function a(m) {
    return m === 58 ? (t.consume(m), l) : (m === 43 || m === 45 || m === 46 || pt(m)) && r++ < 32 ? (t.consume(m), a) : u(m);
  }
  function l(m) {
    return m === 62 ? (t.exit("autolinkProtocol"), d(m)) : m === null || m === 32 || m === 60 || Cu(m) ? n(m) : (t.consume(m), l);
  }
  function u(m) {
    return m === 64 ? (t.consume(m), r = 0, c) : sp(m) ? (t.consume(m), u) : n(m);
  }
  function c(m) {
    return pt(m) ? f(m) : n(m);
  }
  function f(m) {
    return m === 46 ? (t.consume(m), r = 0, c) : m === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", d(m)) : h(m);
  }
  function h(m) {
    return (m === 45 || pt(m)) && r++ < 63 ? (t.consume(m), m === 45 ? h : f) : n(m);
  }
  function d(m) {
    return t.enter("autolinkMarker"), t.consume(m), t.exit("autolinkMarker"), t.exit("autolink"), e;
  }
}
const ol = {
  tokenize: FN,
  partial: !0
};
function FN(t, e, n) {
  return he(t, r, "linePrefix");
  function r(i) {
    return i === null || Z(i) ? e(i) : n(i);
  }
}
const i2 = {
  name: "blockQuote",
  tokenize: HN,
  continuation: {
    tokenize: UN
  },
  exit: qN
};
function HN(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (t.enter("blockQuote", {
        _container: !0
      }), a.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(o), t.exit("blockQuoteMarker"), s;
    }
    return n(o);
  }
  function s(o) {
    return ve(o) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(o), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(o));
  }
}
function UN(t, e, n) {
  return he(
    t,
    t.attempt(i2, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function qN(t) {
  t.exit("blockQuote");
}
const s2 = {
  name: "characterEscape",
  tokenize: zN
};
function zN(t, e, n) {
  return r;
  function r(s) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(s), t.exit("escapeMarker"), i;
  }
  function i(s) {
    return ix(s) ? (t.enter("characterEscapeValue"), t.consume(s), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(s);
  }
}
const o2 = {
  name: "characterReference",
  tokenize: $N
};
function $N(t, e, n) {
  const r = this;
  let i = 0, s, o;
  return a;
  function a(f) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(f), t.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(f), t.exit("characterReferenceMarkerNumeric"), u) : (t.enter("characterReferenceValue"), s = 31, o = pt, c(f));
  }
  function u(f) {
    return f === 88 || f === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(f), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), s = 6, o = rx, c) : (t.enter("characterReferenceValue"), s = 7, o = yu, c(f));
  }
  function c(f) {
    let h;
    return f === 59 && i ? (h = t.exit("characterReferenceValue"), o === pt && !Gs(r.sliceSerialize(h)) ? n(f) : (t.enter("characterReferenceMarker"), t.consume(f), t.exit("characterReferenceMarker"), t.exit("characterReference"), e)) : o(f) && i++ < s ? (t.consume(f), c) : n(f);
  }
}
const yp = {
  name: "codeFenced",
  tokenize: GN,
  concrete: !0
};
function GN(t, e, n) {
  const r = this, i = {
    tokenize: M,
    partial: !0
  }, s = {
    tokenize: R,
    partial: !0
  }, o = this.events[this.events.length - 1], a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;
  let l = 0, u;
  return c;
  function c(N) {
    return t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), u = N, f(N);
  }
  function f(N) {
    return N === u ? (t.consume(N), l++, f) : (t.exit("codeFencedFenceSequence"), l < 3 ? n(N) : he(t, h, "whitespace")(N));
  }
  function h(N) {
    return N === null || Z(N) ? E(N) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), d(N));
  }
  function d(N) {
    return N === null || Ve(N) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), he(t, m, "whitespace")(N)) : N === 96 && N === u ? n(N) : (t.consume(N), d);
  }
  function m(N) {
    return N === null || Z(N) ? E(N) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), g(N));
  }
  function g(N) {
    return N === null || Z(N) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), E(N)) : N === 96 && N === u ? n(N) : (t.consume(N), g);
  }
  function E(N) {
    return t.exit("codeFencedFence"), r.interrupt ? e(N) : T(N);
  }
  function T(N) {
    return N === null ? _(N) : Z(N) ? t.attempt(
      s,
      t.attempt(
        i,
        _,
        a ? he(
          t,
          T,
          "linePrefix",
          a + 1
        ) : T
      ),
      _
    )(N) : (t.enter("codeFlowValue"), k(N));
  }
  function k(N) {
    return N === null || Z(N) ? (t.exit("codeFlowValue"), T(N)) : (t.consume(N), k);
  }
  function _(N) {
    return t.exit("codeFenced"), e(N);
  }
  function R(N, S, O) {
    const $ = this;
    return J;
    function J(P) {
      return N.enter("lineEnding"), N.consume(P), N.exit("lineEnding"), v;
    }
    function v(P) {
      return $.parser.lazy[$.now().line] ? O(P) : S(P);
    }
  }
  function M(N, S, O) {
    let $ = 0;
    return he(
      N,
      J,
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
    function J(ee) {
      return N.enter("codeFencedFence"), N.enter("codeFencedFenceSequence"), v(ee);
    }
    function v(ee) {
      return ee === u ? (N.consume(ee), $++, v) : $ < l ? O(ee) : (N.exit("codeFencedFenceSequence"), he(N, P, "whitespace")(ee));
    }
    function P(ee) {
      return ee === null || Z(ee) ? (N.exit("codeFencedFence"), S(ee)) : O(ee);
    }
  }
}
const S1 = {
  name: "codeIndented",
  tokenize: VN
}, jN = {
  tokenize: KN,
  partial: !0
};
function VN(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return t.enter("codeIndented"), he(t, s, "linePrefix", 4 + 1)(u);
  }
  function s(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? o(u) : n(u);
  }
  function o(u) {
    return u === null ? l(u) : Z(u) ? t.attempt(jN, o, l)(u) : (t.enter("codeFlowValue"), a(u));
  }
  function a(u) {
    return u === null || Z(u) ? (t.exit("codeFlowValue"), o(u)) : (t.consume(u), a);
  }
  function l(u) {
    return t.exit("codeIndented"), e(u);
  }
}
function KN(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : Z(o) ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), i) : he(t, s, "linePrefix", 4 + 1)(o);
  }
  function s(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : Z(o) ? i(o) : n(o);
  }
}
const WN = {
  name: "codeText",
  tokenize: JN,
  resolve: YN,
  previous: QN
};
function YN(t) {
  let e = t.length - 4, n = 3, r, i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2;
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData", r !== i + 2 && (t[i][1].end = t[r - 1][1].end, t.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return t;
}
function QN(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function JN(t, e, n) {
  let r = 0, i, s;
  return o;
  function o(f) {
    return t.enter("codeText"), t.enter("codeTextSequence"), a(f);
  }
  function a(f) {
    return f === 96 ? (t.consume(f), r++, a) : (t.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 96 ? (s = t.enter("codeTextSequence"), i = 0, c(f)) : f === 32 ? (t.enter("space"), t.consume(f), t.exit("space"), l) : Z(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), l) : (t.enter("codeTextData"), u(f));
  }
  function u(f) {
    return f === null || f === 32 || f === 96 || Z(f) ? (t.exit("codeTextData"), l(f)) : (t.consume(f), u);
  }
  function c(f) {
    return f === 96 ? (t.consume(f), i++, c) : i === r ? (t.exit("codeTextSequence"), t.exit("codeText"), e(f)) : (s.type = "codeTextData", u(f));
  }
}
function a2(t) {
  const e = {};
  let n = -1, r, i, s, o, a, l, u;
  for (; ++n < t.length; ) {
    for (; n in e; )
      n = e[n];
    if (r = t[n], n && r[1].type === "chunkFlow" && t[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content"))
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, XN(t, n)), n = e[n], u = !0);
    else if (r[1]._container) {
      for (s = n, i = void 0; s-- && (o = t[s], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (t[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
      i && (r[1].end = Object.assign({}, t[i][1].start), a = t.slice(i, n), a.unshift(r), Mt(t, i, n - i + 1, a));
    }
  }
  return !u;
}
function XN(t, e) {
  const n = t[e][1], r = t[e][2];
  let i = e - 1;
  const s = [], o = n._tokenizer || r.parser[n.contentType](n.start), a = o.events, l = [], u = {};
  let c, f, h = -1, d = n, m = 0, g = 0;
  const E = [g];
  for (; d; ) {
    for (; t[++i][1] !== d; )
      ;
    s.push(i), d._tokenizer || (c = r.sliceStream(d), d.next || c.push(null), f && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(c), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = n; ++h < a.length; )
    // Find a void token that includes a break.
    a[h][0] === "exit" && a[h - 1][0] === "enter" && a[h][1].type === a[h - 1][1].type && a[h][1].start.line !== a[h][1].end.line && (g = h + 1, E.push(g), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : E.pop(), h = E.length; h--; ) {
    const T = a.slice(E[h], E[h + 1]), k = s.pop();
    l.unshift([k, k + T.length - 1]), Mt(t, k, 2, T);
  }
  for (h = -1; ++h < l.length; )
    u[m + l[h][0]] = m + l[h][1], m += l[h][1] - l[h][0] - 1;
  return u;
}
const ZN = {
  tokenize: n_,
  resolve: t_
}, e_ = {
  tokenize: r_,
  partial: !0
};
function t_(t) {
  return a2(t), t;
}
function n_(t, e) {
  let n;
  return r;
  function r(a) {
    return t.enter("content"), n = t.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? s(a) : Z(a) ? t.check(
      e_,
      o,
      s
    )(a) : (t.consume(a), i);
  }
  function s(a) {
    return t.exit("chunkContent"), t.exit("content"), e(a);
  }
  function o(a) {
    return t.consume(a), t.exit("chunkContent"), n.next = t.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function r_(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), he(t, s, "linePrefix");
  }
  function s(o) {
    if (o === null || Z(o))
      return n(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : t.interrupt(r.parser.constructs.flow, n, e)(o);
  }
}
function l2(t, e, n, r, i, s, o, a, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return f;
  function f(T) {
    return T === 60 ? (t.enter(r), t.enter(i), t.enter(s), t.consume(T), t.exit(s), h) : T === null || T === 41 || Cu(T) ? n(T) : (t.enter(r), t.enter(o), t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), g(T));
  }
  function h(T) {
    return T === 62 ? (t.enter(s), t.consume(T), t.exit(s), t.exit(i), t.exit(r), e) : (t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), d(T));
  }
  function d(T) {
    return T === 62 ? (t.exit("chunkString"), t.exit(a), h(T)) : T === null || T === 60 || Z(T) ? n(T) : (t.consume(T), T === 92 ? m : d);
  }
  function m(T) {
    return T === 60 || T === 62 || T === 92 ? (t.consume(T), d) : d(T);
  }
  function g(T) {
    return T === 40 ? ++c > u ? n(T) : (t.consume(T), g) : T === 41 ? c-- ? (t.consume(T), g) : (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(T)) : T === null || Ve(T) ? c ? n(T) : (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(T)) : Cu(T) ? n(T) : (t.consume(T), T === 92 ? E : g);
  }
  function E(T) {
    return T === 40 || T === 41 || T === 92 ? (t.consume(T), g) : g(T);
  }
}
function u2(t, e, n, r, i, s) {
  const o = this;
  let a = 0, l;
  return u;
  function u(d) {
    return t.enter(r), t.enter(i), t.consume(d), t.exit(i), t.enter(s), c;
  }
  function c(d) {
    return d === null || d === 91 || d === 93 && !l || /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */
    /* Hidden footnotes hook */
    /* c8 ignore next 3 */
    d === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs || a > 999 ? n(d) : d === 93 ? (t.exit(s), t.enter(i), t.consume(d), t.exit(i), t.exit(r), e) : Z(d) ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), c) : (t.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || Z(d) || a++ > 999 ? (t.exit("chunkString"), c(d)) : (t.consume(d), l = l || !ve(d), d === 92 ? h : f);
  }
  function h(d) {
    return d === 91 || d === 92 || d === 93 ? (t.consume(d), a++, f) : f(d);
  }
}
function c2(t, e, n, r, i, s) {
  let o;
  return a;
  function a(h) {
    return t.enter(r), t.enter(i), t.consume(h), t.exit(i), o = h === 40 ? 41 : h, l;
  }
  function l(h) {
    return h === o ? (t.enter(i), t.consume(h), t.exit(i), t.exit(r), e) : (t.enter(s), u(h));
  }
  function u(h) {
    return h === o ? (t.exit(s), l(o)) : h === null ? n(h) : Z(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), he(t, u, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), c(h));
  }
  function c(h) {
    return h === o || h === null || Z(h) ? (t.exit("chunkString"), u(h)) : (t.consume(h), h === 92 ? f : c);
  }
  function f(h) {
    return h === o || h === 92 ? (t.consume(h), c) : c(h);
  }
}
function Un(t, e) {
  let n;
  return r;
  function r(i) {
    return Z(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), n = !0, r) : ve(i) ? he(
      t,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : e(i);
  }
}
function Ri(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const i_ = {
  name: "definition",
  tokenize: o_
}, s_ = {
  tokenize: a_,
  partial: !0
};
function o_(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(l) {
    return t.enter("definition"), u2.call(
      r,
      t,
      o,
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(l);
  }
  function o(l) {
    return i = Ri(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), l === 58 ? (t.enter("definitionMarker"), t.consume(l), t.exit("definitionMarker"), Un(
      t,
      l2(
        t,
        t.attempt(
          s_,
          he(t, a, "whitespace"),
          he(t, a, "whitespace")
        ),
        n,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )
    )) : n(l);
  }
  function a(l) {
    return l === null || Z(l) ? (t.exit("definition"), r.parser.defined.includes(i) || r.parser.defined.push(i), e(l)) : n(l);
  }
}
function a_(t, e, n) {
  return r;
  function r(o) {
    return Ve(o) ? Un(t, i)(o) : n(o);
  }
  function i(o) {
    return o === 34 || o === 39 || o === 40 ? c2(
      t,
      he(t, s, "whitespace"),
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o) : n(o);
  }
  function s(o) {
    return o === null || Z(o) ? e(o) : n(o);
  }
}
const l_ = {
  name: "hardBreakEscape",
  tokenize: u_
};
function u_(t, e, n) {
  return r;
  function r(s) {
    return t.enter("hardBreakEscape"), t.enter("escapeMarker"), t.consume(s), i;
  }
  function i(s) {
    return Z(s) ? (t.exit("escapeMarker"), t.exit("hardBreakEscape"), e(s)) : n(s);
  }
}
const c_ = {
  name: "headingAtx",
  tokenize: h_,
  resolve: f_
};
function f_(t, e) {
  let n = t.length - 2, r = 3, i, s;
  return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[n][1].end
  }, s = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[n][1].end,
    // @ts-expect-error Constants are fine to assign.
    contentType: "text"
  }, Mt(t, r, n - r + 1, [
    ["enter", i, e],
    ["enter", s, e],
    ["exit", s, e],
    ["exit", i, e]
  ])), t;
}
function h_(t, e, n) {
  const r = this;
  let i = 0;
  return s;
  function s(c) {
    return t.enter("atxHeading"), t.enter("atxHeadingSequence"), o(c);
  }
  function o(c) {
    return c === 35 && i++ < 6 ? (t.consume(c), o) : c === null || Ve(c) ? (t.exit("atxHeadingSequence"), r.interrupt ? e(c) : a(c)) : n(c);
  }
  function a(c) {
    return c === 35 ? (t.enter("atxHeadingSequence"), l(c)) : c === null || Z(c) ? (t.exit("atxHeading"), e(c)) : ve(c) ? he(t, a, "whitespace")(c) : (t.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (t.consume(c), l) : (t.exit("atxHeadingSequence"), a(c));
  }
  function u(c) {
    return c === null || c === 35 || Ve(c) ? (t.exit("atxHeadingText"), a(c)) : (t.consume(c), u);
  }
}
const d_ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Cp = ["pre", "script", "style", "textarea"], p_ = {
  name: "htmlFlow",
  tokenize: E_,
  resolveTo: g_,
  concrete: !0
}, m_ = {
  tokenize: T_,
  partial: !0
};
function g_(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t;
}
function E_(t, e, n) {
  const r = this;
  let i, s, o, a, l;
  return u;
  function u(b) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(b), c;
  }
  function c(b) {
    return b === 33 ? (t.consume(b), f) : b === 47 ? (t.consume(b), m) : b === 63 ? (t.consume(b), i = 3, r.interrupt ? e : Te) : $t(b) ? (t.consume(b), o = String.fromCharCode(b), s = !0, g) : n(b);
  }
  function f(b) {
    return b === 45 ? (t.consume(b), i = 2, h) : b === 91 ? (t.consume(b), i = 5, o = "CDATA[", a = 0, d) : $t(b) ? (t.consume(b), i = 4, r.interrupt ? e : Te) : n(b);
  }
  function h(b) {
    return b === 45 ? (t.consume(b), r.interrupt ? e : Te) : n(b);
  }
  function d(b) {
    return b === o.charCodeAt(a++) ? (t.consume(b), a === o.length ? r.interrupt ? e : v : d) : n(b);
  }
  function m(b) {
    return $t(b) ? (t.consume(b), o = String.fromCharCode(b), g) : n(b);
  }
  function g(b) {
    return b === null || b === 47 || b === 62 || Ve(b) ? b !== 47 && s && Cp.includes(o.toLowerCase()) ? (i = 1, r.interrupt ? e(b) : v(b)) : d_.includes(o.toLowerCase()) ? (i = 6, b === 47 ? (t.consume(b), E) : r.interrupt ? e(b) : v(b)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(b) : s ? k(b) : T(b)) : b === 45 || pt(b) ? (t.consume(b), o += String.fromCharCode(b), g) : n(b);
  }
  function E(b) {
    return b === 62 ? (t.consume(b), r.interrupt ? e : v) : n(b);
  }
  function T(b) {
    return ve(b) ? (t.consume(b), T) : $(b);
  }
  function k(b) {
    return b === 47 ? (t.consume(b), $) : b === 58 || b === 95 || $t(b) ? (t.consume(b), _) : ve(b) ? (t.consume(b), k) : $(b);
  }
  function _(b) {
    return b === 45 || b === 46 || b === 58 || b === 95 || pt(b) ? (t.consume(b), _) : R(b);
  }
  function R(b) {
    return b === 61 ? (t.consume(b), M) : ve(b) ? (t.consume(b), R) : k(b);
  }
  function M(b) {
    return b === null || b === 60 || b === 61 || b === 62 || b === 96 ? n(b) : b === 34 || b === 39 ? (t.consume(b), l = b, N) : ve(b) ? (t.consume(b), M) : (l = null, S(b));
  }
  function N(b) {
    return b === null || Z(b) ? n(b) : b === l ? (t.consume(b), O) : (t.consume(b), N);
  }
  function S(b) {
    return b === null || b === 34 || b === 39 || b === 60 || b === 61 || b === 62 || b === 96 || Ve(b) ? R(b) : (t.consume(b), S);
  }
  function O(b) {
    return b === 47 || b === 62 || ve(b) ? k(b) : n(b);
  }
  function $(b) {
    return b === 62 ? (t.consume(b), J) : n(b);
  }
  function J(b) {
    return ve(b) ? (t.consume(b), J) : b === null || Z(b) ? v(b) : n(b);
  }
  function v(b) {
    return b === 45 && i === 2 ? (t.consume(b), w) : b === 60 && i === 1 ? (t.consume(b), ke) : b === 62 && i === 4 ? (t.consume(b), Ae) : b === 63 && i === 3 ? (t.consume(b), Te) : b === 93 && i === 5 ? (t.consume(b), me) : Z(b) && (i === 6 || i === 7) ? t.check(
      m_,
      Ae,
      P
    )(b) : b === null || Z(b) ? P(b) : (t.consume(b), v);
  }
  function P(b) {
    return t.exit("htmlFlowData"), ee(b);
  }
  function ee(b) {
    return b === null ? C(b) : Z(b) ? t.attempt(
      {
        tokenize: Y,
        partial: !0
      },
      ee,
      C
    )(b) : (t.enter("htmlFlowData"), v(b));
  }
  function Y(b, _n, Sr) {
    return jn;
    function jn(ft) {
      return b.enter("lineEnding"), b.consume(ft), b.exit("lineEnding"), Ie;
    }
    function Ie(ft) {
      return r.parser.lazy[r.now().line] ? Sr(ft) : _n(ft);
    }
  }
  function w(b) {
    return b === 45 ? (t.consume(b), Te) : v(b);
  }
  function ke(b) {
    return b === 47 ? (t.consume(b), o = "", Ee) : v(b);
  }
  function Ee(b) {
    return b === 62 && Cp.includes(o.toLowerCase()) ? (t.consume(b), Ae) : $t(b) && o.length < 8 ? (t.consume(b), o += String.fromCharCode(b), Ee) : v(b);
  }
  function me(b) {
    return b === 93 ? (t.consume(b), Te) : v(b);
  }
  function Te(b) {
    return b === 62 ? (t.consume(b), Ae) : b === 45 && i === 2 ? (t.consume(b), Te) : v(b);
  }
  function Ae(b) {
    return b === null || Z(b) ? (t.exit("htmlFlowData"), C(b)) : (t.consume(b), Ae);
  }
  function C(b) {
    return t.exit("htmlFlow"), e(b);
  }
}
function T_(t, e, n) {
  return r;
  function r(i) {
    return t.exit("htmlFlowData"), t.enter("lineEndingBlank"), t.consume(i), t.exit("lineEndingBlank"), t.attempt(ol, e, n);
  }
}
const A_ = {
  name: "htmlText",
  tokenize: y_
};
function y_(t, e, n) {
  const r = this;
  let i, s, o, a;
  return l;
  function l(C) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(C), u;
  }
  function u(C) {
    return C === 33 ? (t.consume(C), c) : C === 47 ? (t.consume(C), S) : C === 63 ? (t.consume(C), M) : $t(C) ? (t.consume(C), J) : n(C);
  }
  function c(C) {
    return C === 45 ? (t.consume(C), f) : C === 91 ? (t.consume(C), s = "CDATA[", o = 0, E) : $t(C) ? (t.consume(C), R) : n(C);
  }
  function f(C) {
    return C === 45 ? (t.consume(C), h) : n(C);
  }
  function h(C) {
    return C === null || C === 62 ? n(C) : C === 45 ? (t.consume(C), d) : m(C);
  }
  function d(C) {
    return C === null || C === 62 ? n(C) : m(C);
  }
  function m(C) {
    return C === null ? n(C) : C === 45 ? (t.consume(C), g) : Z(C) ? (a = m, me(C)) : (t.consume(C), m);
  }
  function g(C) {
    return C === 45 ? (t.consume(C), Ae) : m(C);
  }
  function E(C) {
    return C === s.charCodeAt(o++) ? (t.consume(C), o === s.length ? T : E) : n(C);
  }
  function T(C) {
    return C === null ? n(C) : C === 93 ? (t.consume(C), k) : Z(C) ? (a = T, me(C)) : (t.consume(C), T);
  }
  function k(C) {
    return C === 93 ? (t.consume(C), _) : T(C);
  }
  function _(C) {
    return C === 62 ? Ae(C) : C === 93 ? (t.consume(C), _) : T(C);
  }
  function R(C) {
    return C === null || C === 62 ? Ae(C) : Z(C) ? (a = R, me(C)) : (t.consume(C), R);
  }
  function M(C) {
    return C === null ? n(C) : C === 63 ? (t.consume(C), N) : Z(C) ? (a = M, me(C)) : (t.consume(C), M);
  }
  function N(C) {
    return C === 62 ? Ae(C) : M(C);
  }
  function S(C) {
    return $t(C) ? (t.consume(C), O) : n(C);
  }
  function O(C) {
    return C === 45 || pt(C) ? (t.consume(C), O) : $(C);
  }
  function $(C) {
    return Z(C) ? (a = $, me(C)) : ve(C) ? (t.consume(C), $) : Ae(C);
  }
  function J(C) {
    return C === 45 || pt(C) ? (t.consume(C), J) : C === 47 || C === 62 || Ve(C) ? v(C) : n(C);
  }
  function v(C) {
    return C === 47 ? (t.consume(C), Ae) : C === 58 || C === 95 || $t(C) ? (t.consume(C), P) : Z(C) ? (a = v, me(C)) : ve(C) ? (t.consume(C), v) : Ae(C);
  }
  function P(C) {
    return C === 45 || C === 46 || C === 58 || C === 95 || pt(C) ? (t.consume(C), P) : ee(C);
  }
  function ee(C) {
    return C === 61 ? (t.consume(C), Y) : Z(C) ? (a = ee, me(C)) : ve(C) ? (t.consume(C), ee) : v(C);
  }
  function Y(C) {
    return C === null || C === 60 || C === 61 || C === 62 || C === 96 ? n(C) : C === 34 || C === 39 ? (t.consume(C), i = C, w) : Z(C) ? (a = Y, me(C)) : ve(C) ? (t.consume(C), Y) : (t.consume(C), i = void 0, Ee);
  }
  function w(C) {
    return C === i ? (t.consume(C), ke) : C === null ? n(C) : Z(C) ? (a = w, me(C)) : (t.consume(C), w);
  }
  function ke(C) {
    return C === 62 || C === 47 || Ve(C) ? v(C) : n(C);
  }
  function Ee(C) {
    return C === null || C === 34 || C === 39 || C === 60 || C === 61 || C === 96 ? n(C) : C === 62 || Ve(C) ? v(C) : (t.consume(C), Ee);
  }
  function me(C) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(C), t.exit("lineEnding"), he(
      t,
      Te,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function Te(C) {
    return t.enter("htmlTextData"), a(C);
  }
  function Ae(C) {
    return C === 62 ? (t.consume(C), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(C);
  }
}
const kc = {
  name: "labelEnd",
  tokenize: __,
  resolveTo: N_,
  resolveAll: S_
}, C_ = {
  tokenize: k_
}, b_ = {
  tokenize: O_
}, x_ = {
  tokenize: w_
};
function S_(t) {
  let e = -1, n;
  for (; ++e < t.length; )
    n = t[e][1], (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (t.splice(e + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", e++);
  return t;
}
function N_(t, e) {
  let n = t.length, r = 0, i, s, o, a;
  for (; n--; )
    if (i = t[n][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = n);
  const l = {
    type: t[s][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, t[s][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, t[s][1].start),
    end: Object.assign({}, t[o][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, t[s + r + 2][1].end),
    end: Object.assign({}, t[o - 2][1].start)
  };
  return a = [
    ["enter", l, e],
    ["enter", u, e]
  ], a = Ut(a, t.slice(s + 1, s + r + 3)), a = Ut(a, [["enter", c, e]]), a = Ut(
    a,
    rl(
      e.parser.constructs.insideSpan.null,
      t.slice(s + r + 4, o - 3),
      e
    )
  ), a = Ut(a, [
    ["exit", c, e],
    t[o - 2],
    t[o - 1],
    ["exit", u, e]
  ]), a = Ut(a, t.slice(o + 1)), a = Ut(a, [["exit", l, e]]), Mt(t, s, t.length, a), t;
}
function __(t, e, n) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return a;
  function a(c) {
    return s ? s._inactive ? u(c) : (o = r.parser.defined.includes(
      Ri(
        r.sliceSerialize({
          start: s.end,
          end: r.now()
        })
      )
    ), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(c), t.exit("labelMarker"), t.exit("labelEnd"), l) : n(c);
  }
  function l(c) {
    return c === 40 ? t.attempt(
      C_,
      e,
      o ? e : u
    )(c) : c === 91 ? t.attempt(
      b_,
      e,
      o ? t.attempt(x_, e, u) : u
    )(c) : o ? e(c) : u(c);
  }
  function u(c) {
    return s._balanced = !0, n(c);
  }
}
function k_(t, e, n) {
  return r;
  function r(l) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(l), t.exit("resourceMarker"), Un(t, i);
  }
  function i(l) {
    return l === 41 ? a(l) : l2(
      t,
      s,
      n,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(l);
  }
  function s(l) {
    return Ve(l) ? Un(t, o)(l) : a(l);
  }
  function o(l) {
    return l === 34 || l === 39 || l === 40 ? c2(
      t,
      Un(t, a),
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(l) : a(l);
  }
  function a(l) {
    return l === 41 ? (t.enter("resourceMarker"), t.consume(l), t.exit("resourceMarker"), t.exit("resource"), e) : n(l);
  }
}
function O_(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return u2.call(
      r,
      t,
      s,
      n,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function s(o) {
    return r.parser.defined.includes(
      Ri(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? e(o) : n(o);
  }
}
function w_(t, e, n) {
  return r;
  function r(s) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), t.exit("reference"), e) : n(s);
  }
}
const D_ = {
  name: "labelStartImage",
  tokenize: I_,
  resolveAll: kc.resolveAll
};
function I_(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(a), t.exit("labelImageMarker"), s;
  }
  function s(a) {
    return a === 91 ? (t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelImage"), o) : n(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const M_ = {
  name: "labelStartLink",
  tokenize: R_,
  resolveAll: kc.resolveAll
};
function R_(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const N1 = {
  name: "lineEnding",
  tokenize: v_
};
function v_(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), he(t, e, "linePrefix");
  }
}
const zo = {
  name: "thematicBreak",
  tokenize: L_
};
function L_(t, e, n) {
  let r = 0, i;
  return s;
  function s(l) {
    return t.enter("thematicBreak"), i = l, o(l);
  }
  function o(l) {
    return l === i ? (t.enter("thematicBreakSequence"), a(l)) : ve(l) ? he(t, o, "whitespace")(l) : r < 3 || l !== null && !Z(l) ? n(l) : (t.exit("thematicBreak"), e(l));
  }
  function a(l) {
    return l === i ? (t.consume(l), r++, a) : (t.exit("thematicBreakSequence"), o(l));
  }
}
const yt = {
  name: "list",
  tokenize: F_,
  continuation: {
    tokenize: H_
  },
  exit: q_
}, P_ = {
  tokenize: z_,
  partial: !0
}, B_ = {
  tokenize: U_,
  partial: !0
};
function F_(t, e, n) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return a;
  function a(d) {
    const m = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : yu(d)) {
      if (r.containerState.type || (r.containerState.type = m, t.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return t.enter("listItemPrefix"), d === 42 || d === 45 ? t.check(zo, n, u)(d) : u(d);
      if (!r.interrupt || d === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return yu(d) && ++o < 10 ? (t.consume(d), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (t.exit("listItemValue"), u(d)) : n(d);
  }
  function u(d) {
    return t.enter("listItemMarker"), t.consume(d), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, t.check(
      ol,
      // Can’t be empty when interrupting.
      r.interrupt ? n : c,
      t.attempt(
        P_,
        h,
        f
      )
    );
  }
  function c(d) {
    return r.containerState.initialBlankLine = !0, s++, h(d);
  }
  function f(d) {
    return ve(d) ? (t.enter("listItemPrefixWhitespace"), t.consume(d), t.exit("listItemPrefixWhitespace"), h) : n(d);
  }
  function h(d) {
    return r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(d);
  }
}
function H_(t, e, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(ol, i, s);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, he(
      t,
      e,
      "listItemIndent",
      r.containerState.size + 1
    )(a);
  }
  function s(a) {
    return r.containerState.furtherBlankLines || !ve(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(B_, e, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, he(
      t,
      t.attempt(yt, e, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a);
  }
}
function U_(t, e, n) {
  const r = this;
  return he(
    t,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : n(s);
  }
}
function q_(t) {
  t.exit(this.containerState.type);
}
function z_(t, e, n) {
  const r = this;
  return he(
    t,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !ve(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : n(s);
  }
}
const bp = {
  name: "setextUnderline",
  tokenize: G_,
  resolveTo: $_
};
function $_(t, e) {
  let n = t.length, r, i, s;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else
      t[n][1].type === "content" && t.splice(n, 1), !s && t[n][1].type === "definition" && (s = n);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, t[i][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  };
  return t[i][1].type = "setextHeadingText", s ? (t.splice(i, 0, ["enter", o, e]), t.splice(s + 1, 0, ["exit", t[r][1], e]), t[r][1].end = Object.assign({}, t[s][1].end)) : t[r][1] = o, t.push(["exit", o, e]), t;
}
function G_(t, e, n) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if (r.events[i][1].type !== "lineEnding" && r.events[i][1].type !== "linePrefix" && r.events[i][1].type !== "content") {
      o = r.events[i][1].type === "paragraph";
      break;
    }
  return a;
  function a(c) {
    return !r.parser.lazy[r.now().line] && (r.interrupt || o) ? (t.enter("setextHeadingLine"), t.enter("setextHeadingLineSequence"), s = c, l(c)) : n(c);
  }
  function l(c) {
    return c === s ? (t.consume(c), l) : (t.exit("setextHeadingLineSequence"), he(t, u, "lineSuffix")(c));
  }
  function u(c) {
    return c === null || Z(c) ? (t.exit("setextHeadingLine"), e(c)) : n(c);
  }
}
const j_ = {
  tokenize: V_
};
function V_(t) {
  const e = this, n = t.attempt(
    // Try to parse a blank line.
    ol,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(
      this.parser.constructs.flowInitial,
      i,
      he(
        t,
        t.attempt(
          this.parser.constructs.flow,
          i,
          t.attempt(ZN, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(s), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n;
  }
  function i(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), e.currentConstruct = void 0, n;
  }
}
const K_ = {
  resolveAll: h2()
}, W_ = f2("string"), Y_ = f2("text");
function f2(t) {
  return {
    tokenize: e,
    resolveAll: h2(
      t === "text" ? Q_ : void 0
    )
  };
  function e(n) {
    const r = this, i = this.parser.constructs[t], s = n.attempt(i, o, a);
    return o;
    function o(c) {
      return u(c) ? s(c) : a(c);
    }
    function a(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), l;
    }
    function l(c) {
      return u(c) ? (n.exit("data"), s(c)) : (n.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const f = i[c];
      let h = -1;
      if (f)
        for (; ++h < f.length; ) {
          const d = f[h];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function h2(t) {
  return e;
  function e(n, r) {
    let i = -1, s;
    for (; ++i <= n.length; )
      s === void 0 ? n[i] && n[i][1].type === "data" && (s = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end, n.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return t ? t(n, r) : n;
  }
}
function Q_(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, a = 0, l;
      for (; s--; ) {
        const u = i[s];
        if (typeof u == "string") {
          for (o = u.length; u.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o)
            break;
          o = -1;
        } else if (u === -2)
          l = !0, a++;
        else if (u !== -1) {
          s++;
          break;
        }
      }
      if (a) {
        const u = {
          type: n === t.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + s,
            _bufferIndex: s ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, u.start), r.start.offset === r.end.offset ? Object.assign(r, u) : (t.splice(
          n,
          0,
          ["enter", u, e],
          ["exit", u, e]
        ), n += 2);
      }
      n++;
    }
  return t;
}
function J_(t, e, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, s = [];
  let o = [], a = [];
  const l = {
    consume: k,
    enter: _,
    exit: R,
    attempt: S(M),
    check: S(N),
    interrupt: S(N, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: t,
    sliceStream: d,
    sliceSerialize: h,
    now: m,
    defineSkip: g,
    write: f
  };
  let c = e.tokenize.call(u, l);
  return e.resolveAll && s.push(e), u;
  function f(v) {
    return o = Ut(o, v), E(), o[o.length - 1] !== null ? [] : (O(e, 0), u.events = rl(s, u.events, u), u.events);
  }
  function h(v, P) {
    return Z_(d(v), P);
  }
  function d(v) {
    return X_(o, v);
  }
  function m() {
    return Object.assign({}, r);
  }
  function g(v) {
    i[v.line] = v.column, J();
  }
  function E() {
    let v;
    for (; r._index < o.length; ) {
      const P = o[r._index];
      if (typeof P == "string")
        for (v = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === v && r._bufferIndex < P.length; )
          T(P.charCodeAt(r._bufferIndex));
      else
        T(P);
    }
  }
  function T(v) {
    c = c(v);
  }
  function k(v) {
    Z(v) ? (r.line++, r.column = 1, r.offset += v === -3 ? 2 : 1, J()) : v !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = v;
  }
  function _(v, P) {
    const ee = P || {};
    return ee.type = v, ee.start = m(), u.events.push(["enter", ee, u]), a.push(ee), ee;
  }
  function R(v) {
    const P = a.pop();
    return P.end = m(), u.events.push(["exit", P, u]), P;
  }
  function M(v, P) {
    O(v, P.from);
  }
  function N(v, P) {
    P.restore();
  }
  function S(v, P) {
    return ee;
    function ee(Y, w, ke) {
      let Ee, me, Te, Ae;
      return Array.isArray(Y) ? (
        /* c8 ignore next 1 */
        b(Y)
      ) : "tokenize" in Y ? b([Y]) : C(Y);
      function C(Ie) {
        return ft;
        function ft(_t) {
          const dn = _t !== null && Ie[_t], Jt = _t !== null && Ie.null, Qi = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(dn) ? dn : dn ? [dn] : [],
            ...Array.isArray(Jt) ? Jt : Jt ? [Jt] : []
          ];
          return b(Qi)(_t);
        }
      }
      function b(Ie) {
        return Ee = Ie, me = 0, Ie.length === 0 ? ke : _n(Ie[me]);
      }
      function _n(Ie) {
        return ft;
        function ft(_t) {
          return Ae = $(), Te = Ie, Ie.partial || (u.currentConstruct = Ie), Ie.name && u.parser.constructs.disable.null.includes(Ie.name) ? jn() : Ie.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            P ? Object.assign(Object.create(u), P) : u,
            l,
            Sr,
            jn
          )(_t);
        }
      }
      function Sr(Ie) {
        return v(Te, Ae), w;
      }
      function jn(Ie) {
        return Ae.restore(), ++me < Ee.length ? _n(Ee[me]) : ke;
      }
    }
  }
  function O(v, P) {
    v.resolveAll && !s.includes(v) && s.push(v), v.resolve && Mt(
      u.events,
      P,
      u.events.length - P,
      v.resolve(u.events.slice(P), u)
    ), v.resolveTo && (u.events = v.resolveTo(u.events, u));
  }
  function $() {
    const v = m(), P = u.previous, ee = u.currentConstruct, Y = u.events.length, w = Array.from(a);
    return {
      restore: ke,
      from: Y
    };
    function ke() {
      r = v, u.previous = P, u.currentConstruct = ee, u.events.length = Y, a = w, J();
    }
  }
  function J() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function X_(t, e) {
  const n = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  return n === i ? o = [t[n].slice(r, s)] : (o = t.slice(n, i), r > -1 && (o[0] = o[0].slice(r)), s > 0 && o.push(t[i].slice(0, s))), o;
}
function Z_(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const s = t[n];
    let o;
    if (typeof s == "string")
      o = s;
    else
      switch (s) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = e ? " " : "	";
          break;
        }
        case -1: {
          if (!e && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(s);
      }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
const ek = {
  [42]: yt,
  [43]: yt,
  [45]: yt,
  [48]: yt,
  [49]: yt,
  [50]: yt,
  [51]: yt,
  [52]: yt,
  [53]: yt,
  [54]: yt,
  [55]: yt,
  [56]: yt,
  [57]: yt,
  [62]: i2
}, tk = {
  [91]: i_
}, nk = {
  [-2]: S1,
  [-1]: S1,
  [32]: S1
}, rk = {
  [35]: c_,
  [42]: zo,
  [45]: [bp, zo],
  [60]: p_,
  [61]: bp,
  [95]: zo,
  [96]: yp,
  [126]: yp
}, ik = {
  [38]: o2,
  [92]: s2
}, sk = {
  [-5]: N1,
  [-4]: N1,
  [-3]: N1,
  [33]: D_,
  [38]: o2,
  [42]: Su,
  [60]: [PN, A_],
  [91]: M_,
  [92]: [l_, s2],
  [93]: kc,
  [95]: Su,
  [96]: WN
}, ok = {
  null: [Su, K_]
}, ak = {
  null: [42, 95]
}, lk = {
  null: []
}, uk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: ak,
  contentInitial: tk,
  disable: lk,
  document: ek,
  flow: rk,
  flowInitial: nk,
  insideSpan: ok,
  string: ik,
  text: sk
}, Symbol.toStringTag, { value: "Module" }));
function ck(t = {}) {
  const e = kg(
    // @ts-expect-error Same as above.
    [uk].concat(t.extensions || [])
  ), n = {
    defined: [],
    lazy: {},
    constructs: e,
    content: r(wN),
    document: r(IN),
    flow: r(j_),
    string: r(W_),
    text: r(Y_)
  };
  return n;
  function r(i) {
    return s;
    function s(o) {
      return J_(n, i, o);
    }
  }
}
const xp = /[\0\t\n\r]/g;
function fk() {
  let t = 1, e = "", n = !0, r;
  return i;
  function i(s, o, a) {
    const l = [];
    let u, c, f, h, d;
    for (s = e + s.toString(o), f = 0, e = "", n && (s.charCodeAt(0) === 65279 && f++, n = void 0); f < s.length; ) {
      if (xp.lastIndex = f, u = xp.exec(s), h = u && u.index !== void 0 ? u.index : s.length, d = s.charCodeAt(h), !u) {
        e = s.slice(f);
        break;
      }
      if (d === 10 && f === h && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < h && (l.push(s.slice(f, h)), t += h - f), d) {
          case 0: {
            l.push(65533), t++;
            break;
          }
          case 9: {
            for (c = Math.ceil(t / 4) * 4, l.push(-2); t++ < c; )
              l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      f = h + 1;
    }
    return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
  }
}
function hk(t) {
  for (; !a2(t); )
    ;
  return t;
}
const d2 = {}.hasOwnProperty, dk = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(t, e, n) {
    return typeof e != "string" && (n = e, e = void 0), pk(n)(
      hk(
        // @ts-expect-error: micromark types need to accept `null`.
        ck(n).document().write(fk()(t, e, !0))
      )
    );
  }
);
function pk(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(Vn),
      autolinkProtocol: v,
      autolinkEmail: v,
      atxHeading: a(Xi),
      blockQuote: a(Qi),
      characterEscape: v,
      characterReference: v,
      codeFenced: a(Ji),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: a(Ji, l),
      codeText: a(Xs, l),
      codeTextData: v,
      data: v,
      codeFlowValue: v,
      definition: a(fl),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: a(ti),
      hardBreakEscape: a(Zi),
      hardBreakTrailing: a(Zi),
      htmlFlow: a(Nr, l),
      htmlFlowData: v,
      htmlText: a(Nr, l),
      htmlTextData: v,
      image: a(hl),
      label: l,
      link: a(Vn),
      listItem: a(dl),
      listItemValue: m,
      listOrdered: a(ni, d),
      listUnordered: a(ni),
      paragraph: a(Zs),
      reference: jn,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: a(Xi),
      strong: a(eo),
      thematicBreak: a(pl)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: S,
      autolink: c(),
      autolinkEmail: Jt,
      autolinkProtocol: dn,
      blockQuote: c(),
      characterEscapeValue: P,
      characterReferenceMarkerHexadecimal: ft,
      characterReferenceMarkerNumeric: ft,
      characterReferenceValue: _t,
      codeFenced: c(k),
      codeFencedFence: T,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: E,
      codeFlowValue: P,
      codeIndented: c(_),
      codeText: c(Ee),
      codeTextData: P,
      data: P,
      definition: c(),
      definitionDestinationString: N,
      definitionLabelString: R,
      definitionTitleString: M,
      emphasis: c(),
      hardBreakEscape: c(Y),
      hardBreakTrailing: c(Y),
      htmlFlow: c(w),
      htmlFlowData: P,
      htmlText: c(ke),
      htmlTextData: P,
      image: c(Te),
      label: C,
      labelText: Ae,
      lineEnding: ee,
      link: c(me),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: Ie,
      resourceDestinationString: b,
      resourceTitleString: _n,
      resource: Sr,
      setextHeading: c(J),
      setextHeadingLineSequence: $,
      setextHeadingText: O,
      strong: c(),
      thematicBreak: c()
    }
  };
  p2(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(D) {
    let z = {
      type: "root",
      children: []
    };
    const te = {
      stack: [z],
      tokenStack: [],
      config: e,
      enter: u,
      exit: f,
      buffer: l,
      resume: h,
      setData: s,
      getData: o
    }, ge = [];
    let ye = -1;
    for (; ++ye < D.length; )
      if (D[ye][1].type === "listOrdered" || D[ye][1].type === "listUnordered")
        if (D[ye][0] === "enter")
          ge.push(ye);
        else {
          const kt = ge.pop();
          ye = i(D, kt, ye);
        }
    for (ye = -1; ++ye < D.length; ) {
      const kt = e[D[ye][0]];
      d2.call(kt, D[ye][1].type) && kt[D[ye][1].type].call(
        Object.assign(
          {
            sliceSerialize: D[ye][2].sliceSerialize
          },
          te
        ),
        D[ye][1]
      );
    }
    if (te.tokenStack.length > 0) {
      const kt = te.tokenStack[te.tokenStack.length - 1];
      (kt[1] || Sp).call(te, void 0, kt[0]);
    }
    for (z.position = {
      start: Zn(
        D.length > 0 ? D[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Zn(
        D.length > 0 ? D[D.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, ye = -1; ++ye < e.transforms.length; )
      z = e.transforms[ye](z) || z;
    return z;
  }
  function i(D, z, te) {
    let ge = z - 1, ye = -1, kt = !1, Rt, vt, Lt, kn;
    for (; ++ge <= te; ) {
      const Oe = D[ge];
      if (Oe[1].type === "listUnordered" || Oe[1].type === "listOrdered" || Oe[1].type === "blockQuote" ? (Oe[0] === "enter" ? ye++ : ye--, kn = void 0) : Oe[1].type === "lineEndingBlank" ? Oe[0] === "enter" && (Rt && !kn && !ye && !Lt && (Lt = ge), kn = void 0) : Oe[1].type === "linePrefix" || Oe[1].type === "listItemValue" || Oe[1].type === "listItemMarker" || Oe[1].type === "listItemPrefix" || Oe[1].type === "listItemPrefixWhitespace" || (kn = void 0), !ye && Oe[0] === "enter" && Oe[1].type === "listItemPrefix" || ye === -1 && Oe[0] === "exit" && (Oe[1].type === "listUnordered" || Oe[1].type === "listOrdered")) {
        if (Rt) {
          let ri = ge;
          for (vt = void 0; ri--; ) {
            const Xt = D[ri];
            if (Xt[1].type === "lineEnding" || Xt[1].type === "lineEndingBlank") {
              if (Xt[0] === "exit")
                continue;
              vt && (D[vt][1].type = "lineEndingBlank", kt = !0), Xt[1].type = "lineEnding", vt = ri;
            } else if (!(Xt[1].type === "linePrefix" || Xt[1].type === "blockQuotePrefix" || Xt[1].type === "blockQuotePrefixWhitespace" || Xt[1].type === "blockQuoteMarker" || Xt[1].type === "listItemIndent"))
              break;
          }
          Lt && (!vt || Lt < vt) && (Rt._spread = !0), Rt.end = Object.assign(
            {},
            vt ? D[vt][1].start : Oe[1].end
          ), D.splice(vt || ge, 0, ["exit", Rt, Oe[2]]), ge++, te++;
        }
        Oe[1].type === "listItemPrefix" && (Rt = {
          type: "listItem",
          // @ts-expect-error Patched
          _spread: !1,
          start: Object.assign({}, Oe[1].start)
        }, D.splice(ge, 0, ["enter", Rt, Oe[2]]), ge++, te++, Lt = void 0, kn = !0);
      }
    }
    return D[z][1]._spread = kt, te;
  }
  function s(D, z) {
    n[D] = z;
  }
  function o(D) {
    return n[D];
  }
  function a(D, z) {
    return te;
    function te(ge) {
      u.call(this, D(ge), ge), z && z.call(this, ge);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(D, z, te) {
    return this.stack[this.stack.length - 1].children.push(D), this.stack.push(D), this.tokenStack.push([z, te]), D.position = {
      start: Zn(z.start)
    }, D;
  }
  function c(D) {
    return z;
    function z(te) {
      D && D.call(this, te), f.call(this, te);
    }
  }
  function f(D, z) {
    const te = this.stack.pop(), ge = this.tokenStack.pop();
    if (ge)
      ge[0].type !== D.type && (z ? z.call(this, D, ge[0]) : (ge[1] || Sp).call(this, D, ge[0]));
    else
      throw new Error(
        "Cannot close `" + D.type + "` (" + Ns({
          start: D.start,
          end: D.end
        }) + "): it’s not open"
      );
    return te.position.end = Zn(D.end), te;
  }
  function h() {
    return tl(this.stack.pop());
  }
  function d() {
    s("expectingFirstListItemValue", !0);
  }
  function m(D) {
    if (o("expectingFirstListItemValue")) {
      const z = this.stack[this.stack.length - 2];
      z.start = Number.parseInt(this.sliceSerialize(D), 10), s("expectingFirstListItemValue");
    }
  }
  function g() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.lang = D;
  }
  function E() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.meta = D;
  }
  function T() {
    o("flowCodeInside") || (this.buffer(), s("flowCodeInside", !0));
  }
  function k() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = D.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), s("flowCodeInside");
  }
  function _() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = D.replace(/(\r?\n|\r)$/g, "");
  }
  function R(D) {
    const z = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = z, te.identifier = Ri(
      this.sliceSerialize(D)
    ).toLowerCase();
  }
  function M() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.title = D;
  }
  function N() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.url = D;
  }
  function S(D) {
    const z = this.stack[this.stack.length - 1];
    if (!z.depth) {
      const te = this.sliceSerialize(D).length;
      z.depth = te;
    }
  }
  function O() {
    s("setextHeadingSlurpLineEnding", !0);
  }
  function $(D) {
    const z = this.stack[this.stack.length - 1];
    z.depth = this.sliceSerialize(D).charCodeAt(0) === 61 ? 1 : 2;
  }
  function J() {
    s("setextHeadingSlurpLineEnding");
  }
  function v(D) {
    const z = this.stack[this.stack.length - 1];
    let te = z.children[z.children.length - 1];
    (!te || te.type !== "text") && (te = es(), te.position = {
      start: Zn(D.start)
    }, z.children.push(te)), this.stack.push(te);
  }
  function P(D) {
    const z = this.stack.pop();
    z.value += this.sliceSerialize(D), z.position.end = Zn(D.end);
  }
  function ee(D) {
    const z = this.stack[this.stack.length - 1];
    if (o("atHardBreak")) {
      const te = z.children[z.children.length - 1];
      te.position.end = Zn(D.end), s("atHardBreak");
      return;
    }
    !o("setextHeadingSlurpLineEnding") && e.canContainEols.includes(z.type) && (v.call(this, D), P.call(this, D));
  }
  function Y() {
    s("atHardBreak", !0);
  }
  function w() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = D;
  }
  function ke() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = D;
  }
  function Ee() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = D;
  }
  function me() {
    const D = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const z = o("referenceType") || "shortcut";
      D.type += "Reference", D.referenceType = z, delete D.url, delete D.title;
    } else
      delete D.identifier, delete D.label;
    s("referenceType");
  }
  function Te() {
    const D = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const z = o("referenceType") || "shortcut";
      D.type += "Reference", D.referenceType = z, delete D.url, delete D.title;
    } else
      delete D.identifier, delete D.label;
    s("referenceType");
  }
  function Ae(D) {
    const z = this.sliceSerialize(D), te = this.stack[this.stack.length - 2];
    te.label = Ng(z), te.identifier = Ri(z).toLowerCase();
  }
  function C() {
    const D = this.stack[this.stack.length - 1], z = this.resume(), te = this.stack[this.stack.length - 1];
    if (s("inReference", !0), te.type === "link") {
      const ge = D.children;
      te.children = ge;
    } else
      te.alt = z;
  }
  function b() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.url = D;
  }
  function _n() {
    const D = this.resume(), z = this.stack[this.stack.length - 1];
    z.title = D;
  }
  function Sr() {
    s("inReference");
  }
  function jn() {
    s("referenceType", "collapsed");
  }
  function Ie(D) {
    const z = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = z, te.identifier = Ri(
      this.sliceSerialize(D)
    ).toLowerCase(), s("referenceType", "full");
  }
  function ft(D) {
    s("characterReferenceType", D.type);
  }
  function _t(D) {
    const z = this.sliceSerialize(D), te = o("characterReferenceType");
    let ge;
    te ? (ge = Sg(
      z,
      te === "characterReferenceMarkerNumeric" ? 10 : 16
    ), s("characterReferenceType")) : ge = Gs(z);
    const ye = this.stack.pop();
    ye.value += ge, ye.position.end = Zn(D.end);
  }
  function dn(D) {
    P.call(this, D);
    const z = this.stack[this.stack.length - 1];
    z.url = this.sliceSerialize(D);
  }
  function Jt(D) {
    P.call(this, D);
    const z = this.stack[this.stack.length - 1];
    z.url = "mailto:" + this.sliceSerialize(D);
  }
  function Qi() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ji() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Xs() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function fl() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ti() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Xi() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function Zi() {
    return {
      type: "break"
    };
  }
  function Nr() {
    return {
      type: "html",
      value: ""
    };
  }
  function hl() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Vn() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function ni(D) {
    return {
      type: "list",
      ordered: D.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: D._spread,
      children: []
    };
  }
  function dl(D) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: D._spread,
      checked: null,
      children: []
    };
  }
  function Zs() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function eo() {
    return {
      type: "strong",
      children: []
    };
  }
  function es() {
    return {
      type: "text",
      value: ""
    };
  }
  function pl() {
    return {
      type: "thematicBreak"
    };
  }
}
function Zn(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function p2(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? p2(t, r) : mk(t, r);
  }
}
function mk(t, e) {
  let n;
  for (n in e)
    if (d2.call(e, n)) {
      if (n === "canContainEols") {
        const r = e[n];
        r && t[n].push(...r);
      } else if (n === "transforms") {
        const r = e[n];
        r && t[n].push(...r);
      } else if (n === "enter" || n === "exit") {
        const r = e[n];
        r && Object.assign(t[n], r);
      }
    }
}
function Sp(t, e) {
  throw t ? new Error(
    "Cannot close `" + t.type + "` (" + Ns({
      start: t.start,
      end: t.end
    }) + "): a different token (`" + e.type + "`, " + Ns({
      start: e.start,
      end: e.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + e.type + "`, " + Ns({
      start: e.start,
      end: e.end
    }) + ") is still open"
  );
}
function gk(t) {
  Object.assign(this, { Parser: (n) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return dk(
      n,
      Object.assign({}, r, t, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
function Ek(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function Tk(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function Ak(t, e) {
  const n = e.value ? e.value + `
` : "", r = e.lang ? e.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, i = {};
  r && (i.className = ["language-" + r]);
  let s = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (s.data = { meta: e.meta }), t.patch(e, s), s = t.applyData(e, s), s = { type: "element", tagName: "pre", properties: {}, children: [s] }, t.patch(e, s), s;
}
function yk(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function Ck(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function Wi(t) {
  const e = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < t.length; ) {
    const s = t.charCodeAt(n);
    let o = "";
    if (s === 37 && pt(t.charCodeAt(n + 1)) && pt(t.charCodeAt(n + 2)))
      i = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (o = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const a = t.charCodeAt(n + 1);
      s < 56320 && a > 56319 && a < 57344 ? (o = String.fromCharCode(s, a), i = 1) : o = "�";
    } else
      o = String.fromCharCode(s);
    o && (e.push(t.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return e.join("") + t.slice(r);
}
function m2(t, e) {
  const n = String(e.identifier).toUpperCase(), r = Wi(n.toLowerCase()), i = t.footnoteOrder.indexOf(n);
  let s;
  i === -1 ? (t.footnoteOrder.push(n), t.footnoteCounts[n] = 1, s = t.footnoteOrder.length) : (t.footnoteCounts[n]++, s = i + 1);
  const o = t.footnoteCounts[n], a = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + t.clobberPrefix + "fn-" + r,
      id: t.clobberPrefix + "fnref-" + r + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  t.patch(e, a);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [a]
  };
  return t.patch(e, l), t.applyData(e, l);
}
function bk(t, e) {
  const n = t.footnoteById;
  let r = 1;
  for (; r in n; )
    r++;
  const i = String(r);
  return n[i] = {
    type: "footnoteDefinition",
    identifier: i,
    children: [{ type: "paragraph", children: e.children }],
    position: e.position
  }, m2(t, {
    type: "footnoteReference",
    identifier: i,
    position: e.position
  });
}
function xk(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function Sk(t, e) {
  if (t.dangerous) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
  return null;
}
function g2(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return { type: "text", value: "![" + e.alt + r };
  const i = t.all(e), s = i[0];
  s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function Nk(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return g2(t, e);
  const r = { src: Wi(n.url || ""), alt: e.alt };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = { type: "element", tagName: "img", properties: r, children: [] };
  return t.patch(e, i), t.applyData(e, i);
}
function _k(t, e) {
  const n = { src: Wi(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function kk(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function Ok(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return g2(t, e);
  const r = { href: Wi(n.url || "") };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: r,
    children: t.all(e)
  };
  return t.patch(e, i), t.applyData(e, i);
}
function wk(t, e) {
  const n = { href: Wi(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function Dk(t, e, n) {
  const r = t.all(e), i = n ? Ik(n) : E2(e), s = {}, o = [];
  if (typeof e.checked == "boolean") {
    const c = r[0];
    let f;
    c && c.type === "element" && c.tagName === "p" ? f = c : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const c = r[a];
    (i || a !== 0 || c.type !== "element" || c.tagName !== "p") && o.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? o.push(...c.children) : o.push(c);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: s, children: o };
  return t.patch(e, u), t.applyData(e, u);
}
function Ik(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = E2(n[r]);
  }
  return e;
}
function E2(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function Mk(t, e) {
  const n = {}, r = t.all(e);
  let i = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function Rk(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function vk(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function Lk(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Js = T2("start"), al = T2("end");
function Pk(t) {
  return { start: Js(t), end: al(t) };
}
function T2(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: r.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: r.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: r.offset > -1 ? r.offset : null
    };
  }
}
function Bk(t, e) {
  const n = t.all(e), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, a = Js(e.children[1]), l = al(e.children[e.children.length - 1]);
    a.line && l.line && (o.position = { start: a, end: l }), i.push(o);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(i, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function Fk(t, e, n) {
  const r = n ? n.children : void 0, s = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, a = o ? o.length : e.children.length;
  let l = -1;
  const u = [];
  for (; ++l < a; ) {
    const f = e.children[l], h = {}, d = o ? o[l] : void 0;
    d && (h.align = d);
    let m = { type: "element", tagName: s, properties: h, children: [] };
    f && (m.children = t.all(f), t.patch(f, m), m = t.applyData(e, m)), u.push(m);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(u, !0)
  };
  return t.patch(e, c), t.applyData(e, c);
}
function Hk(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Np = 9, _p = 32;
function Uk(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), i = 0;
  const s = [];
  for (; r; )
    s.push(
      kp(e.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(e);
  return s.push(kp(e.slice(i), i > 0, !1)), s.join("");
}
function kp(t, e, n) {
  let r = 0, i = t.length;
  if (e) {
    let s = t.codePointAt(r);
    for (; s === Np || s === _p; )
      r++, s = t.codePointAt(r);
  }
  if (n) {
    let s = t.codePointAt(i - 1);
    for (; s === Np || s === _p; )
      i--, s = t.codePointAt(i - 1);
  }
  return i > r ? t.slice(r, i) : "";
}
function qk(t, e) {
  const n = { type: "text", value: Uk(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function zk(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const $k = {
  blockquote: Ek,
  break: Tk,
  code: Ak,
  delete: yk,
  emphasis: Ck,
  footnoteReference: m2,
  footnote: bk,
  heading: xk,
  html: Sk,
  imageReference: Nk,
  image: _k,
  inlineCode: kk,
  linkReference: Ok,
  link: wk,
  listItem: Dk,
  list: Mk,
  paragraph: Rk,
  root: vk,
  strong: Lk,
  table: Bk,
  tableCell: Hk,
  tableRow: Fk,
  text: qk,
  thematicBreak: zk,
  toml: Oo,
  yaml: Oo,
  definition: Oo,
  footnoteDefinition: Oo
};
function Oo() {
  return null;
}
function Gk(t) {
  return !t || !t.position || !t.position.start || !t.position.start.line || !t.position.start.column || !t.position.end || !t.position.end.line || !t.position.end.column;
}
const Op = {}.hasOwnProperty;
function jk(t) {
  const e = /* @__PURE__ */ Object.create(null);
  if (!t || !t.type)
    throw new Error("mdast-util-definitions expected node");
  return Kt(t, "definition", (r) => {
    const i = wp(r.identifier);
    i && !Op.call(e, i) && (e[i] = r);
  }), n;
  function n(r) {
    const i = wp(r);
    return i && Op.call(e, i) ? e[i] : null;
  }
}
function wp(t) {
  return String(t || "").toUpperCase();
}
const wa = {}.hasOwnProperty;
function Vk(t, e) {
  const n = e || {}, r = n.allowDangerousHtml || !1, i = {};
  return o.dangerous = r, o.clobberPrefix = n.clobberPrefix === void 0 || n.clobberPrefix === null ? "user-content-" : n.clobberPrefix, o.footnoteLabel = n.footnoteLabel || "Footnotes", o.footnoteLabelTagName = n.footnoteLabelTagName || "h2", o.footnoteLabelProperties = n.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o.footnoteBackLabel = n.footnoteBackLabel || "Back to content", o.unknownHandler = n.unknownHandler, o.passThrough = n.passThrough, o.handlers = { ...$k, ...n.handlers }, o.definition = jk(t), o.footnoteById = i, o.footnoteOrder = [], o.footnoteCounts = {}, o.patch = Kk, o.applyData = Wk, o.one = a, o.all = l, o.wrap = Qk, o.augment = s, Kt(t, "footnoteDefinition", (u) => {
    const c = String(u.identifier).toUpperCase();
    wa.call(i, c) || (i[c] = u);
  }), o;
  function s(u, c) {
    if (u && "data" in u && u.data) {
      const f = u.data;
      f.hName && (c.type !== "element" && (c = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), c.tagName = f.hName), c.type === "element" && f.hProperties && (c.properties = { ...c.properties, ...f.hProperties }), "children" in c && c.children && f.hChildren && (c.children = f.hChildren);
    }
    if (u) {
      const f = "type" in u ? u : { position: u };
      Gk(f) || (c.position = { start: Js(f), end: al(f) });
    }
    return c;
  }
  function o(u, c, f, h) {
    return Array.isArray(f) && (h = f, f = {}), s(u, {
      type: "element",
      tagName: c,
      properties: f || {},
      children: h || []
    });
  }
  function a(u, c) {
    return A2(o, u, c);
  }
  function l(u) {
    return Oc(o, u);
  }
}
function Kk(t, e) {
  t.position && (e.position = Pk(t));
}
function Wk(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, i = t.data.hChildren, s = t.data.hProperties;
    typeof r == "string" && (n.type === "element" ? n.tagName = r : n = {
      type: "element",
      tagName: r,
      properties: {},
      children: []
    }), n.type === "element" && s && (n.properties = { ...n.properties, ...s }), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function A2(t, e, n) {
  const r = e && e.type;
  if (!r)
    throw new Error("Expected node, got `" + e + "`");
  return wa.call(t.handlers, r) ? t.handlers[r](t, e, n) : t.passThrough && t.passThrough.includes(r) ? "children" in e ? { ...e, children: Oc(t, e) } : e : t.unknownHandler ? t.unknownHandler(t, e, n) : Yk(t, e);
}
function Oc(t, e) {
  const n = [];
  if ("children" in e) {
    const r = e.children;
    let i = -1;
    for (; ++i < r.length; ) {
      const s = A2(t, r[i], e);
      if (s) {
        if (i && r[i - 1].type === "break" && (!Array.isArray(s) && s.type === "text" && (s.value = s.value.replace(/^\s+/, "")), !Array.isArray(s) && s.type === "element")) {
          const o = s.children[0];
          o && o.type === "text" && (o.value = o.value.replace(/^\s+/, ""));
        }
        Array.isArray(s) ? n.push(...s) : n.push(s);
      }
    }
  }
  return n;
}
function Yk(t, e) {
  const n = e.data || {}, r = "value" in e && !(wa.call(n, "hProperties") || wa.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: Oc(t, e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function Qk(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Jk(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.footnoteOrder.length; ) {
    const r = t.footnoteById[t.footnoteOrder[n]];
    if (!r)
      continue;
    const i = t.all(r), s = String(r.identifier).toUpperCase(), o = Wi(s.toLowerCase());
    let a = 0;
    const l = [];
    for (; ++a <= t.footnoteCounts[s]; ) {
      const f = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t.clobberPrefix + "fnref-" + o + (a > 1 ? "-" + a : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: t.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      a > 1 && f.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(a) }]
      }), l.length > 0 && l.push({ type: "text", value: " " }), l.push(f);
    }
    const u = i[i.length - 1];
    if (u && u.type === "element" && u.tagName === "p") {
      const f = u.children[u.children.length - 1];
      f && f.type === "text" ? f.value += " " : u.children.push({ type: "text", value: " " }), u.children.push(...l);
    } else
      i.push(...l);
    const c = {
      type: "element",
      tagName: "li",
      properties: { id: t.clobberPrefix + "fn-" + o },
      children: t.wrap(i, !0)
    };
    t.patch(r, c), e.push(c);
  }
  if (e.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: t.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(t.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: t.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(e, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function y2(t, e) {
  const n = Vk(t, e), r = n.one(t, null), i = Jk(n);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
const Xk = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(t, e) {
    return t && "run" in t ? eO(t, e) : tO(t || e);
  }
), Zk = Xk;
function eO(t, e) {
  return (n, r, i) => {
    t.run(y2(n, e), r, (s) => {
      i(s);
    });
  };
}
function tO(t) {
  return (e) => y2(e, t);
}
function C2(t) {
  const e = (
    /** @type {Options} */
    this.data("settings")
  ), n = Object.assign({}, e, t);
  Object.assign(this, { Compiler: r });
  function r(i) {
    return Zg(i, n);
  }
}
const nO = {}.hasOwnProperty, b2 = Vi("type", { handlers: { root: iO, element: uO, text: aO, comment: lO, doctype: oO } });
function rO(t, e) {
  const n = e && typeof e == "object" ? e.space : e;
  return b2(t, n === "svg" ? Gn : Gi);
}
function iO(t, e) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = wc(t.children, n, e), Yi(t, n), n;
}
function sO(t, e) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = wc(t.children, n, e), Yi(t, n), n;
}
function oO(t) {
  const e = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    // @ts-expect-error: change to `null` in a major?
    parentNode: void 0
  };
  return Yi(t, e), e;
}
function aO(t) {
  const e = {
    nodeName: "#text",
    value: t.value,
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return Yi(t, e), e;
}
function lO(t) {
  const e = {
    nodeName: "#comment",
    data: t.value,
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return Yi(t, e), e;
}
function uO(t, e) {
  const n = e;
  let r = n;
  t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Gn);
  const i = [];
  let s;
  if (t.properties) {
    for (s in t.properties)
      if (s !== "children" && nO.call(t.properties, s)) {
        const a = cO(
          r,
          s,
          t.properties[s]
        );
        a && i.push(a);
      }
  }
  const o = {
    nodeName: t.tagName,
    tagName: t.tagName,
    attrs: i,
    // @ts-expect-error: html and svg both have a space.
    namespaceURI: zs[r.space],
    childNodes: [],
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return o.childNodes = wc(t.children, o, r), Yi(t, o), t.tagName === "template" && t.content && (o.content = sO(t.content, r)), o;
}
function cO(t, e, n) {
  const r = Ys(t, e);
  if (n == null || n === !1 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? fc(n) : cc(n));
  const i = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const s = i.name.indexOf(":");
    s < 0 ? i.prefix = "" : (i.name = i.name.slice(s + 1), i.prefix = r.attribute.slice(0, s)), i.namespace = zs[r.space];
  }
  return i;
}
function wc(t, e, n) {
  let r = -1;
  const i = [];
  if (t)
    for (; ++r < t.length; ) {
      const s = b2(t[r], n);
      s.parentNode = e, i.push(s);
    }
  return i;
}
function Yi(t, e) {
  const n = t.position;
  n && n.start && n.end && (e.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    // @ts-expect-error assume this is set.
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    // @ts-expect-error assume this is set.
    endOffset: n.end.offset
  });
}
const fO = "IN_TEMPLATE_MODE", hO = "DATA_STATE", dO = "CHARACTER_TOKEN", pO = "START_TAG_TOKEN", mO = "END_TAG_TOKEN", gO = "COMMENT_TOKEN", EO = "DOCTYPE_TOKEN", TO = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }, x2 = (
  /**
   * @type {(
   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &
   *   ((tree: Node, options?: Options) => Node)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {VFile} [file]
   * @param {Options} [options]
   */
  function(t, e, n) {
    let r = -1;
    const i = new O9(TO), s = Vi("type", {
      handlers: { root: g, element: E, text: T, comment: _, doctype: k, raw: R },
      // @ts-expect-error: hush.
      unknown: bO
    });
    let o, a, l, u, c;
    if (SO(e) && (n = e, e = void 0), n && n.passThrough)
      for (; ++r < n.passThrough.length; )
        s.handlers[n.passThrough[r]] = M;
    const f = U9(
      xO(t) ? d() : h(),
      e
    );
    if (o && Kt(f, "comment", (S, O, $) => {
      const J = (
        /** @type {Stitch} */
        /** @type {unknown} */
        S
      );
      if (J.value.stitch && $ !== null && O !== null)
        return $.children[O] = J.value.stitch, O;
    }), t.type !== "root" && f.type === "root" && f.children.length === 1)
      return f.children[0];
    return f;
    function h() {
      const S = {
        nodeName: "template",
        tagName: "template",
        attrs: [],
        namespaceURI: zs.html,
        childNodes: []
      }, O = {
        nodeName: "documentmock",
        tagName: "documentmock",
        attrs: [],
        namespaceURI: zs.html,
        childNodes: []
      }, $ = { nodeName: "#document-fragment", childNodes: [] };
      if (i._bootstrap(O, S), i._pushTmplInsertionMode(fO), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), a = i.tokenizer, !a)
        throw new Error("Expected `tokenizer`");
      return l = a.preprocessor, c = a.__mixins[0], u = c.posTracker, s(t), N(), i._adoptNodes(O.childNodes[0], $), $;
    }
    function d() {
      const S = i.treeAdapter.createDocument();
      if (i._bootstrap(S, void 0), a = i.tokenizer, !a)
        throw new Error("Expected `tokenizer`");
      return l = a.preprocessor, c = a.__mixins[0], u = c.posTracker, s(t), N(), S;
    }
    function m(S) {
      let O = -1;
      if (S)
        for (; ++O < S.length; )
          s(S[O]);
    }
    function g(S) {
      m(S.children);
    }
    function E(S) {
      N(), i._processInputToken(AO(S)), m(S.children), jg.includes(S.tagName) || (N(), i._processInputToken(CO(S)));
    }
    function T(S) {
      N(), i._processInputToken({
        type: dO,
        chars: S.value,
        location: Ni(S)
      });
    }
    function k(S) {
      N(), i._processInputToken({
        type: EO,
        name: "html",
        forceQuirks: !1,
        publicId: "",
        systemId: "",
        location: Ni(S)
      });
    }
    function _(S) {
      N(), i._processInputToken({
        type: gO,
        data: S.value,
        location: Ni(S)
      });
    }
    function R(S) {
      const O = Js(S), $ = O.line || 1, J = O.column || 1, v = O.offset || 0;
      if (!l)
        throw new Error("Expected `preprocessor`");
      if (!a)
        throw new Error("Expected `tokenizer`");
      if (!u)
        throw new Error("Expected `posTracker`");
      if (!c)
        throw new Error("Expected `locationTracker`");
      l.html = void 0, l.pos = -1, l.lastGapPos = -1, l.lastCharPos = -1, l.gapStack = [], l.skipNextNewLine = !1, l.lastChunkWritten = !1, l.endOfChunkHit = !1, u.isEol = !1, u.lineStartPos = -J + 1, u.droppedBufferSize = v, u.offset = 0, u.col = 1, u.line = $, c.currentAttrLocation = void 0, c.ctLoc = Ni(S), a.write(S.value), i._runParsingLoop(null), (a.state === "NAMED_CHARACTER_REFERENCE_STATE" || a.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") && (l.lastChunkWritten = !0, a[a.state](a._consume()));
    }
    function M(S) {
      o = !0;
      let O;
      "children" in S ? O = {
        ...S,
        children: x2(
          { type: "root", children: S.children },
          e,
          n
          // @ts-expect-error Assume a given parent yields a parent.
        ).children
      } : O = { ...S }, _({ type: "comment", value: { stitch: O } });
    }
    function N() {
      if (!a)
        throw new Error("Expected `tokenizer`");
      if (!u)
        throw new Error("Expected `posTracker`");
      const S = a.currentCharacterToken;
      S && (S.location.endLine = u.line, S.location.endCol = u.col + 1, S.location.endOffset = u.offset + 1, i._processInputToken(S)), a.tokenQueue = [], a.state = hO, a.returnState = "", a.charRefCode = -1, a.tempBuff = [], a.lastStartTagName = "", a.consumedAfterSnapshot = -1, a.active = !1, a.currentCharacterToken = void 0, a.currentToken = void 0, a.currentAttr = void 0;
    }
  }
);
function AO(t) {
  const e = Object.assign(Ni(t));
  return e.startTag = Object.assign({}, e), {
    type: pO,
    tagName: t.tagName,
    selfClosing: !1,
    attrs: yO(t),
    location: e
  };
}
function yO(t) {
  return rO({
    tagName: t.tagName,
    type: "element",
    properties: t.properties,
    children: []
    // @ts-expect-error Assume element.
  }).attrs;
}
function CO(t) {
  const e = Object.assign(Ni(t));
  return e.startTag = Object.assign({}, e), {
    type: mO,
    tagName: t.tagName,
    attrs: [],
    location: e
  };
}
function bO(t) {
  throw new Error("Cannot compile `" + t.type + "` node");
}
function xO(t) {
  const e = t.type === "root" ? t.children[0] : t;
  return Boolean(
    e && (e.type === "doctype" || e.type === "element" && e.tagName === "html")
  );
}
function Ni(t) {
  const e = Js(t), n = al(t);
  return {
    startLine: e.line,
    startCol: e.column,
    startOffset: e.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function SO(t) {
  return Boolean(t && !("message" in t && "messages" in t));
}
function S2(t = {}) {
  return (e, n) => (
    /** @type {Root} */
    x2(e, n, t)
  );
}
const NO = [
  "pre",
  "script",
  "style",
  "textarea"
], _O = G9({ newlines: !0 });
function N2(t = {}) {
  let e = t.indent || 2, n = t.indentInitial;
  return typeof e == "number" && (e = " ".repeat(e)), n == null && (n = !0), (s) => {
    let o;
    _O(s), gc(s, (a, l) => {
      let u = -1;
      if (!("children" in a))
        return;
      if (mr(a, "head") && (o = !0), o && mr(a, "body") && (o = void 0), mr(a, NO))
        return Za;
      const c = a.children;
      let f = l.length;
      if (c.length === 0 || !_1(a, o))
        return;
      n || f--;
      let h;
      for (; ++u < c.length; ) {
        const g = c[u];
        (g.type === "text" || g.type === "comment") && (g.value.includes(`
`) && (h = !0), g.value = g.value.replace(
          / *\n/g,
          "$&" + String(e).repeat(f)
        ));
      }
      const d = [];
      let m;
      for (u = -1; ++u < c.length; ) {
        const g = c[u];
        (_1(g, o) || h && !u) && (r(d, f, g), h = !0), m = g, d.push(g);
      }
      m && (h || _1(m, o)) && (gr(m) && (d.pop(), m = d[d.length - 1]), r(d, f - 1)), a.children = d;
    });
  };
  function r(s, o, a) {
    const l = s[s.length - 1], u = gr(l) ? s[s.length - 2] : l, c = (i(u) && i(a) ? `

` : `
`) + String(e).repeat(Math.max(o, 0));
    l && l.type === "text" ? l.value = gr(l) ? c : l.value + c : s.push({ type: "text", value: c });
  }
  function i(s) {
    return Boolean(
      s && s.type === "element" && t.blanks && t.blanks.length > 0 && t.blanks.includes(s.tagName)
    );
  }
}
function _1(t, e) {
  return t.type === "root" || (t.type === "element" ? e || mr(t, "script") || pc(t) || !Q9(t) : !1);
}
const k1 = /[\t ]*(?:\r?\n|\r)/g;
function kO() {
  return (t) => {
    Kt(t, "text", (e, n, r) => {
      const i = [];
      let s = 0;
      k1.lastIndex = 0;
      let o = k1.exec(e.value);
      for (; o; ) {
        const a = o.index;
        s !== a && i.push({ type: "text", value: e.value.slice(s, a) }), i.push({ type: "break" }), s = a + o[0].length, o = k1.exec(e.value);
      }
      if (i.length > 0 && r && typeof n == "number")
        return s < e.value.length && i.push({ type: "text", value: e.value.slice(s) }), r.children.splice(n, 1, ...i), n + i.length;
    });
  };
}
function Dc(t, e, n, r, i, s, o, a, l, u, c, f, h, d, m) {
  let g, E;
  return T;
  function T(w) {
    return t.enter(r), t.enter(i), t.consume(w), t.exit(i), k;
  }
  function k(w) {
    return w === 35 ? (g = o, _(w)) : w === 46 ? (g = a, _(w)) : w === 58 || w === 95 || $t(w) ? (t.enter(s), t.enter(l), t.consume(w), N) : m && ve(w) ? he(t, k, "whitespace")(w) : !m && Ve(w) ? Un(t, k)(w) : Y(w);
  }
  function _(w) {
    return t.enter(s), t.enter(g), t.enter(g + "Marker"), t.consume(w), t.exit(g + "Marker"), R;
  }
  function R(w) {
    return w === null || w === 34 || w === 35 || w === 39 || w === 46 || w === 60 || w === 61 || w === 62 || w === 96 || w === 125 || Ve(w) ? n(w) : (t.enter(g + "Value"), t.consume(w), M);
  }
  function M(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 35 || w === 46 || w === 125 || Ve(w) ? (t.exit(g + "Value"), t.exit(g), t.exit(s), k(w)) : (t.consume(w), M);
  }
  function N(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || pt(w) ? (t.consume(w), N) : (t.exit(l), m && ve(w) ? he(t, S, "whitespace")(w) : !m && Ve(w) ? Un(t, S)(w) : S(w));
  }
  function S(w) {
    return w === 61 ? (t.enter(u), t.consume(w), t.exit(u), O) : (t.exit(s), k(w));
  }
  function O(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 || w === 125 || m && Z(w) ? n(w) : w === 34 || w === 39 ? (t.enter(c), t.enter(h), t.consume(w), t.exit(h), E = w, J) : m && ve(w) ? he(t, O, "whitespace")(w) : !m && Ve(w) ? Un(t, O)(w) : (t.enter(f), t.enter(d), t.consume(w), E = void 0, $);
  }
  function $(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 125 || Ve(w) ? (t.exit(d), t.exit(f), t.exit(s), k(w)) : (t.consume(w), $);
  }
  function J(w) {
    return w === E ? (t.enter(h), t.consume(w), t.exit(h), t.exit(c), t.exit(s), ee) : (t.enter(f), v(w));
  }
  function v(w) {
    return w === E ? (t.exit(f), J(w)) : w === null ? n(w) : Z(w) ? m ? n(w) : Un(t, v)(w) : (t.enter(d), t.consume(w), P);
  }
  function P(w) {
    return w === E || w === null || Z(w) ? (t.exit(d), v(w)) : (t.consume(w), P);
  }
  function ee(w) {
    return w === 125 || Ve(w) ? k(w) : Y(w);
  }
  function Y(w) {
    return w === 125 ? (t.enter(i), t.consume(w), t.exit(i), t.exit(r), e) : n(w);
  }
}
function Ic(t, e, n, r, i, s, o) {
  let a = 0, l = 0, u;
  return c;
  function c(E) {
    return t.enter(r), t.enter(i), t.consume(E), t.exit(i), f;
  }
  function f(E) {
    return E === 93 ? (t.enter(i), t.consume(E), t.exit(i), t.exit(r), e) : (t.enter(s), h(E));
  }
  function h(E) {
    if (E === 93 && !l)
      return g(E);
    const T = t.enter("chunkText", {
      contentType: "text",
      previous: u
    });
    return u && (u.next = T), u = T, d(E);
  }
  function d(E) {
    return E === null || a > 999 || E === 91 && ++l > 32 ? n(E) : E === 93 && !l-- ? (t.exit("chunkText"), g(E)) : Z(E) ? o ? n(E) : (t.consume(E), t.exit("chunkText"), h) : (t.consume(E), E === 92 ? m : d);
  }
  function m(E) {
    return E === 91 || E === 92 || E === 93 ? (t.consume(E), a++, d) : d(E);
  }
  function g(E) {
    return t.exit(s), t.enter(i), t.consume(E), t.exit(i), t.exit(r), e;
  }
}
function Mc(t, e, n, r) {
  const i = this;
  return s;
  function s(a) {
    return $t(a) ? (t.enter(r), t.consume(a), o) : n(a);
  }
  function o(a) {
    return a === 45 || a === 95 || pt(a) ? (t.consume(a), o) : (t.exit(r), i.previous === 45 || i.previous === 95 ? n(a) : e(a));
  }
}
const OO = {
  tokenize: IO,
  concrete: !0
}, wO = {
  tokenize: MO,
  partial: !0
}, DO = {
  tokenize: RO,
  partial: !0
}, Dp = {
  tokenize: vO,
  partial: !0
};
function IO(t, e, n) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0, a;
  return l;
  function l(S) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), u(S);
  }
  function u(S) {
    return S === 58 ? (t.consume(S), o++, u) : o < 3 ? n(S) : (t.exit("directiveContainerSequence"), Mc.call(
      r,
      t,
      c,
      n,
      "directiveContainerName"
    )(S));
  }
  function c(S) {
    return S === 91 ? t.attempt(wO, f, f)(S) : f(S);
  }
  function f(S) {
    return S === 123 ? t.attempt(DO, h, h)(S) : h(S);
  }
  function h(S) {
    return he(t, d, "whitespace")(S);
  }
  function d(S) {
    return t.exit("directiveContainerFence"), S === null ? m(S) : Z(S) ? r.interrupt ? e(S) : t.attempt(Dp, g, m)(S) : n(S);
  }
  function m(S) {
    return t.exit("directiveContainer"), e(S);
  }
  function g(S) {
    return S === null ? (t.exit("directiveContainer"), e(S)) : (t.enter("directiveContainerContent"), E(S));
  }
  function E(S) {
    return S === null ? M(S) : t.attempt(
      {
        tokenize: N,
        partial: !0
      },
      M,
      s ? he(t, T, "linePrefix", s + 1) : T
    )(S);
  }
  function T(S) {
    if (S === null)
      return M(S);
    const O = t.enter("chunkDocument", {
      contentType: "document",
      previous: a
    });
    return a && (a.next = O), a = O, k(S);
  }
  function k(S) {
    if (S === null) {
      const O = t.exit("chunkDocument");
      return r.parser.lazy[O.start.line] = !1, M(S);
    }
    return Z(S) ? t.check(Dp, _, R)(S) : (t.consume(S), k);
  }
  function _(S) {
    t.consume(S);
    const O = t.exit("chunkDocument");
    return r.parser.lazy[O.start.line] = !1, E;
  }
  function R(S) {
    const O = t.exit("chunkDocument");
    return r.parser.lazy[O.start.line] = !1, M(S);
  }
  function M(S) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), e(S);
  }
  function N(S, O, $) {
    let J = 0;
    return he(S, v, "linePrefix", 4);
    function v(Y) {
      return S.enter("directiveContainerFence"), S.enter("directiveContainerSequence"), P(Y);
    }
    function P(Y) {
      return Y === 58 ? (S.consume(Y), J++, P) : J < o ? $(Y) : (S.exit("directiveContainerSequence"), he(S, ee, "whitespace")(Y));
    }
    function ee(Y) {
      return Y === null || Z(Y) ? (S.exit("directiveContainerFence"), O(Y)) : $(Y);
    }
  }
}
function MO(t, e, n) {
  return Ic(
    t,
    e,
    n,
    "directiveContainerLabel",
    "directiveContainerLabelMarker",
    "directiveContainerLabelString",
    !0
  );
}
function RO(t, e, n) {
  return Dc(
    t,
    e,
    n,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    !0
  );
}
function vO(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s;
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
const LO = {
  tokenize: FO
}, PO = {
  tokenize: HO,
  partial: !0
}, BO = {
  tokenize: UO,
  partial: !0
};
function FO(t, e, n) {
  const r = this;
  return i;
  function i(c) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(c), s;
  }
  function s(c) {
    return c === 58 ? (t.consume(c), t.exit("directiveLeafSequence"), Mc.call(
      r,
      t,
      o,
      n,
      "directiveLeafName"
    )) : n(c);
  }
  function o(c) {
    return c === 91 ? t.attempt(PO, a, a)(c) : a(c);
  }
  function a(c) {
    return c === 123 ? t.attempt(BO, l, l)(c) : l(c);
  }
  function l(c) {
    return he(t, u, "whitespace")(c);
  }
  function u(c) {
    return c === null || Z(c) ? (t.exit("directiveLeaf"), e(c)) : n(c);
  }
}
function HO(t, e, n) {
  return Ic(
    t,
    e,
    n,
    "directiveLeafLabel",
    "directiveLeafLabelMarker",
    "directiveLeafLabelString",
    !0
  );
}
function UO(t, e, n) {
  return Dc(
    t,
    e,
    n,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    !0
  );
}
const qO = {
  tokenize: jO,
  previous: GO
}, zO = {
  tokenize: VO,
  partial: !0
}, $O = {
  tokenize: KO,
  partial: !0
};
function GO(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function jO(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return t.enter("directiveText"), t.enter("directiveTextMarker"), t.consume(l), t.exit("directiveTextMarker"), Mc.call(r, t, s, n, "directiveTextName");
  }
  function s(l) {
    return l === 58 ? n(l) : l === 91 ? t.attempt(zO, o, o)(l) : o(l);
  }
  function o(l) {
    return l === 123 ? t.attempt($O, a, a)(l) : a(l);
  }
  function a(l) {
    return t.exit("directiveText"), e(l);
  }
}
function VO(t, e, n) {
  return Ic(
    t,
    e,
    n,
    "directiveTextLabel",
    "directiveTextLabelMarker",
    "directiveTextLabelString"
  );
}
function KO(t, e, n) {
  return Dc(
    t,
    e,
    n,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}
function WO() {
  return {
    text: {
      [58]: qO
    },
    flow: {
      [58]: [OO, LO]
    }
  };
}
const Ip = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function _2(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 48 && e <= 57;
}
function YO(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 102 || e >= 65 && e <= 70 || e >= 48 && e <= 57;
}
function QO(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function Mp(t) {
  return QO(t) || _2(t);
}
const hi = String.fromCharCode, JO = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function Rc(t, e = {}) {
  const n = typeof e.additional == "string" ? e.additional.charCodeAt(0) : e.additional, r = [];
  let i = 0, s = -1, o = "", a, l;
  e.position && ("start" in e.position || "indent" in e.position ? (l = e.position.indent, a = e.position.start) : a = e.position);
  let u = (a ? a.line : 0) || 1, c = (a ? a.column : 0) || 1, f = d(), h;
  for (i--; ++i <= t.length; )
    if (h === 10 && (c = (l ? l[s] : 0) || 1), h = t.charCodeAt(i), h === 38) {
      const E = t.charCodeAt(i + 1);
      if (E === 9 || E === 10 || E === 12 || E === 32 || E === 38 || E === 60 || Number.isNaN(E) || n && E === n) {
        o += hi(h), c++;
        continue;
      }
      const T = i + 1;
      let k = T, _ = T, R;
      if (E === 35) {
        _ = ++k;
        const P = t.charCodeAt(_);
        P === 88 || P === 120 ? (R = "hexadecimal", _ = ++k) : R = "decimal";
      } else
        R = "named";
      let M = "", N = "", S = "";
      const O = R === "named" ? Mp : R === "decimal" ? _2 : YO;
      for (_--; ++_ <= t.length; ) {
        const P = t.charCodeAt(_);
        if (!O(P))
          break;
        S += hi(P), R === "named" && Kg.includes(S) && (M = S, N = Gs(S));
      }
      let $ = t.charCodeAt(_) === 59;
      if ($) {
        _++;
        const P = R === "named" ? Gs(S) : !1;
        P && (M = S, N = P);
      }
      let J = 1 + _ - T, v = "";
      if (!(!$ && e.nonTerminated === !1))
        if (!S)
          R !== "named" && m(4, J);
        else if (R === "named") {
          if ($ && !N)
            m(5, 1);
          else if (M !== S && (_ = k + M.length, J = 1 + _ - k, $ = !1), !$) {
            const P = M ? 1 : 3;
            if (e.attribute) {
              const ee = t.charCodeAt(_);
              ee === 61 ? (m(P, J), N = "") : Mp(ee) ? N = "" : m(P, J);
            } else
              m(P, J);
          }
          v = N;
        } else {
          $ || m(2, J);
          let P = Number.parseInt(
            S,
            R === "hexadecimal" ? 16 : 10
          );
          if (XO(P))
            m(7, J), v = hi(
              65533
              /* `�` */
            );
          else if (P in Ip)
            m(6, J), v = Ip[P];
          else {
            let ee = "";
            ZO(P) && m(6, J), P > 65535 && (P -= 65536, ee += hi(P >>> 10 | 55296), P = 56320 | P & 1023), v = ee + hi(P);
          }
        }
      if (v) {
        g(), f = d(), i = _ - 1, c += _ - T + 1, r.push(v);
        const P = d();
        P.offset++, e.reference && e.reference.call(
          e.referenceContext,
          v,
          { start: f, end: P },
          t.slice(T - 1, _)
        ), f = P;
      } else
        S = t.slice(T - 1, _), o += S, c += S.length, i = _ - 1;
    } else
      h === 10 && (u++, s++, c = 0), Number.isNaN(h) ? g() : (o += hi(h), c++);
  return r.join("");
  function d() {
    return {
      line: u,
      column: c,
      offset: i + ((a ? a.offset : 0) || 0)
    };
  }
  function m(E, T) {
    let k;
    e.warning && (k = d(), k.column += T, k.offset += T, e.warning.call(
      e.warningContext,
      JO[E],
      k,
      E
    ));
  }
  function g() {
    o && (r.push(o), e.text && e.text.call(e.textContext, o, {
      start: f,
      end: d()
    }), o = "");
  }
}
function XO(t) {
  return t >= 55296 && t <= 57343 || t > 1114111;
}
function ZO(t) {
  return t >= 1 && t <= 8 || t === 11 || t >= 13 && t <= 31 || t >= 127 && t <= 159 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534;
}
const ew = {}.hasOwnProperty, Rp = /^[^\t\n\r "#'.<=>`}]+$/;
$o.peek = lw;
const tw = {
  canContainEols: ["textDirective"],
  enter: {
    directiveContainer: rw,
    directiveContainerAttributes: w1,
    directiveContainerLabel: ow,
    directiveLeaf: iw,
    directiveLeafAttributes: w1,
    directiveText: sw,
    directiveTextAttributes: w1
  },
  exit: {
    directiveContainer: L1,
    directiveContainerAttributeClassValue: I1,
    directiveContainerAttributeIdValue: D1,
    directiveContainerAttributeName: R1,
    directiveContainerAttributeValue: M1,
    directiveContainerAttributes: v1,
    directiveContainerLabel: aw,
    directiveContainerName: O1,
    directiveLeaf: L1,
    directiveLeafAttributeClassValue: I1,
    directiveLeafAttributeIdValue: D1,
    directiveLeafAttributeName: R1,
    directiveLeafAttributeValue: M1,
    directiveLeafAttributes: v1,
    directiveLeafName: O1,
    directiveText: L1,
    directiveTextAttributeClassValue: I1,
    directiveTextAttributeIdValue: D1,
    directiveTextAttributeName: R1,
    directiveTextAttributeValue: M1,
    directiveTextAttributes: v1,
    directiveTextName: O1
  }
}, nw = {
  unsafe: [
    {
      character: "\r",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      character: `
`,
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      before: "[^:]",
      character: ":",
      after: "[A-Za-z]",
      inConstruct: ["phrasing"]
    },
    { atBreak: !0, character: ":", after: ":" }
  ],
  handlers: {
    containerDirective: $o,
    leafDirective: $o,
    textDirective: $o
  }
};
function rw(t) {
  vc.call(this, "containerDirective", t);
}
function iw(t) {
  vc.call(this, "leafDirective", t);
}
function sw(t) {
  vc.call(this, "textDirective", t);
}
function vc(t, e) {
  this.enter({ type: t, name: "", attributes: {}, children: [] }, e);
}
function O1(t) {
  const e = (
    /** @type {Directive} */
    this.stack[this.stack.length - 1]
  );
  e.name = this.sliceSerialize(t);
}
function ow(t) {
  this.enter(
    { type: "paragraph", data: { directiveLabel: !0 }, children: [] },
    t
  );
}
function aw(t) {
  this.exit(t);
}
function w1() {
  this.setData("directiveAttributes", []), this.buffer();
}
function D1(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([
    "id",
    Rc(this.sliceSerialize(t), {
      attribute: !0
    })
  ]);
}
function I1(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([
    "class",
    Rc(this.sliceSerialize(t), {
      attribute: !0
    })
  ]);
}
function M1(t) {
  const e = (
    /** @type {Array<[string, string]>} */
    this.getData("directiveAttributes")
  );
  e[e.length - 1][1] = Rc(this.sliceSerialize(t), {
    attribute: !0
  });
}
function R1(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([this.sliceSerialize(t), ""]);
}
function v1() {
  const t = (
    /** @type {Array<[string, string]>} */
    this.getData("directiveAttributes")
  ), e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n];
    i[0] === "class" && e.class ? e.class += " " + i[1] : e[i[0]] = i[1];
  }
  this.setData("directiveAttributes"), this.resume();
  const r = (
    /** @type {Directive} */
    this.stack[this.stack.length - 1]
  );
  r.attributes = e;
}
function L1(t) {
  this.exit(t);
}
function $o(t, e, n, r) {
  const i = yc(r), s = cw(t), o = n.enter(t.type);
  let a = i.move(s + (t.name || "")), l;
  if (t.type === "containerDirective") {
    const u = (t.children || [])[0];
    l = vp(u) ? u : void 0;
  } else
    l = t;
  if (l && l.children && l.children.length > 0) {
    const u = n.enter("label"), c = `${t.type}Label`, f = n.enter(c);
    a += i.move("["), a += i.move(
      Ac(l, n, {
        ...i.current(),
        before: a,
        after: "]"
      })
    ), a += i.move("]"), f(), u();
  }
  if (a += i.move(uw(t, n)), t.type === "containerDirective") {
    const u = (t.children || [])[0];
    let c = t;
    vp(u) && (c = Object.assign({}, t, { children: t.children.slice(1) })), c && c.children && c.children.length > 0 && (a += i.move(`
`), a += i.move(_g(c, n, i.current()))), a += i.move(`
` + s);
  }
  return o(), a;
}
function lw() {
  return ":";
}
function uw(t, e) {
  const n = nl(e), r = t.type === "textDirective" ? [n] : [n, `
`, "\r"], i = t.attributes || {}, s = [];
  let o, a, l, u;
  for (u in i)
    if (ew.call(i, u) && i[u] !== void 0 && i[u] !== null) {
      const f = String(i[u]);
      if (u === "id")
        l = Rp.test(f) ? "#" + f : c("id", f);
      else if (u === "class") {
        const h = f.split(/[\t\n\r ]+/g), d = [], m = [];
        let g = -1;
        for (; ++g < h.length; )
          (Rp.test(h[g]) ? m : d).push(
            h[g]
          );
        o = d.length > 0 ? c("class", d.join(" ")) : "", a = m.length > 0 ? "." + m.join(".") : "";
      } else
        s.push(c(u, f));
    }
  return o && s.unshift(o), a && s.unshift(a), l && s.unshift(l), s.length > 0 ? "{" + s.join(" ") + "}" : "";
  function c(f, h) {
    return f + (h ? "=" + n + VS(h, { subset: r }) + n : "");
  }
}
function vp(t) {
  return Boolean(
    t && t.type === "paragraph" && t.data && t.data.directiveLabel
  );
}
function cw(t) {
  let e = 0;
  return t.type === "containerDirective" ? (gc(t, function(n, r) {
    if (n.type === "containerDirective") {
      let i = r.length, s = 0;
      for (; i--; )
        r[i].type === "containerDirective" && s++;
      s > e && (e = s);
    }
  }), e += 3) : t.type === "leafDirective" ? e = 2 : e = 1, ":".repeat(e);
}
function fw() {
  const t = this.data();
  e("micromarkExtensions", WO()), e("fromMarkdownExtensions", tw), e("toMarkdownExtensions", nw);
  function e(n, r) {
    /** @type {unknown[]} */
    // Other extensions
    /* c8 ignore next 2 */
    (t[n] ? t[n] : t[n] = []).push(r);
  }
}
function hw(t, e) {
  return n(t, null, null);
  function n(r, i, s) {
    const o = Object.assign({}, e(r, i, s));
    return "children" in r && (o.children = r.children.map(function(a, l) {
      return n(a, l, r);
    })), o;
  }
}
const dw = (t) => {
  const { type: e } = t;
  return e === "textDirective" || e === "leafDirective" || e === "containerDirective";
}, pw = (t) => {
  if (dw(t)) {
    const { properties: e, tagName: n } = F9(t.name, t.attributes);
    return Object.assign(Object.assign({}, t), { data: {
      hName: n,
      hProperties: e
    } });
  }
  return t;
}, mw = (t) => hw(t, pw), gw = () => mw, Ew = Ju().use(gk).use(fw).use(gw).use(kO).use(wg).use(Zk, _N).use(Ug, n2).use(S2).use(Gg, r2).use(N2).use(C2, t2), dD = async (t) => {
  const e = await Ew.process(t);
  return String(e);
}, Tw = Ju().use(z9, e2).use(S2).use(Gg, r2).use(N2).use(C2, t2), pD = async (t) => {
  const e = await Tw.process(t);
  return String(e);
};
var Me;
(function(t) {
  t.Attribute = "attribute", t.Pseudo = "pseudo", t.PseudoElement = "pseudo-element", t.Tag = "tag", t.Universal = "universal", t.Adjacent = "adjacent", t.Child = "child", t.Descendant = "descendant", t.Parent = "parent", t.Sibling = "sibling", t.ColumnCombinator = "column-combinator";
})(Me || (Me = {}));
var qt;
(function(t) {
  t.Any = "any", t.Element = "element", t.End = "end", t.Equals = "equals", t.Exists = "exists", t.Hyphen = "hyphen", t.Not = "not", t.Start = "start";
})(qt || (qt = {}));
const Lp = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, Aw = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, yw = /* @__PURE__ */ new Map([
  [126, qt.Element],
  [94, qt.Start],
  [36, qt.End],
  [42, qt.Any],
  [33, qt.Not],
  [124, qt.Hyphen]
]), Cw = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function bw(t) {
  switch (t.type) {
    case Me.Adjacent:
    case Me.Child:
    case Me.Descendant:
    case Me.Parent:
    case Me.Sibling:
    case Me.ColumnCombinator:
      return !0;
    default:
      return !1;
  }
}
const xw = /* @__PURE__ */ new Set(["contains", "icontains"]);
function Sw(t, e, n) {
  const r = parseInt(e, 16) - 65536;
  return r !== r || n ? e : r < 0 ? (
    // BMP codepoint
    String.fromCharCode(r + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(r >> 10 | 55296, r & 1023 | 56320)
  );
}
function hs(t) {
  return t.replace(Aw, Sw);
}
function P1(t) {
  return t === 39 || t === 34;
}
function Pp(t) {
  return t === 32 || t === 9 || t === 10 || t === 12 || t === 13;
}
function Nw(t) {
  const e = [], n = k2(e, `${t}`, 0);
  if (n < t.length)
    throw new Error(`Unmatched selector: ${t.slice(n)}`);
  return e;
}
function k2(t, e, n) {
  let r = [];
  function i(h) {
    const d = e.slice(n + h).match(Lp);
    if (!d)
      throw new Error(`Expected name, found ${e.slice(n)}`);
    const [m] = d;
    return n += h + m.length, hs(m);
  }
  function s(h) {
    for (n += h; n < e.length && Pp(e.charCodeAt(n)); )
      n++;
  }
  function o() {
    n += 1;
    const h = n;
    let d = 1;
    for (; d > 0 && n < e.length; n++)
      e.charCodeAt(n) === 40 && !a(n) ? d++ : e.charCodeAt(n) === 41 && !a(n) && d--;
    if (d)
      throw new Error("Parenthesis not matched");
    return hs(e.slice(h, n - 1));
  }
  function a(h) {
    let d = 0;
    for (; e.charCodeAt(--h) === 92; )
      d++;
    return (d & 1) === 1;
  }
  function l() {
    if (r.length > 0 && bw(r[r.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function u(h) {
    if (r.length > 0 && r[r.length - 1].type === Me.Descendant) {
      r[r.length - 1].type = h;
      return;
    }
    l(), r.push({ type: h });
  }
  function c(h, d) {
    r.push({
      type: Me.Attribute,
      name: h,
      action: d,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function f() {
    if (r.length && r[r.length - 1].type === Me.Descendant && r.pop(), r.length === 0)
      throw new Error("Empty sub-selector");
    t.push(r);
  }
  if (s(0), e.length === n)
    return n;
  e:
    for (; n < e.length; ) {
      const h = e.charCodeAt(n);
      switch (h) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          (r.length === 0 || r[0].type !== Me.Descendant) && (l(), r.push({ type: Me.Descendant })), s(1);
          break;
        }
        case 62: {
          u(Me.Child), s(1);
          break;
        }
        case 60: {
          u(Me.Parent), s(1);
          break;
        }
        case 126: {
          u(Me.Sibling), s(1);
          break;
        }
        case 43: {
          u(Me.Adjacent), s(1);
          break;
        }
        case 46: {
          c("class", qt.Element);
          break;
        }
        case 35: {
          c("id", qt.Equals);
          break;
        }
        case 91: {
          s(1);
          let d, m = null;
          e.charCodeAt(n) === 124 ? d = i(1) : e.startsWith("*|", n) ? (m = "*", d = i(2)) : (d = i(0), e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 61 && (m = d, d = i(1))), s(0);
          let g = qt.Exists;
          const E = yw.get(e.charCodeAt(n));
          if (E) {
            if (g = E, e.charCodeAt(n + 1) !== 61)
              throw new Error("Expected `=`");
            s(2);
          } else
            e.charCodeAt(n) === 61 && (g = qt.Equals, s(1));
          let T = "", k = null;
          if (g !== "exists") {
            if (P1(e.charCodeAt(n))) {
              const M = e.charCodeAt(n);
              let N = n + 1;
              for (; N < e.length && (e.charCodeAt(N) !== M || a(N)); )
                N += 1;
              if (e.charCodeAt(N) !== M)
                throw new Error("Attribute value didn't end");
              T = hs(e.slice(n + 1, N)), n = N + 1;
            } else {
              const M = n;
              for (; n < e.length && (!Pp(e.charCodeAt(n)) && e.charCodeAt(n) !== 93 || a(n)); )
                n += 1;
              T = hs(e.slice(M, n));
            }
            s(0);
            const R = e.charCodeAt(n) | 32;
            R === 115 ? (k = !1, s(1)) : R === 105 && (k = !0, s(1));
          }
          if (e.charCodeAt(n) !== 93)
            throw new Error("Attribute selector didn't terminate");
          n += 1;
          const _ = {
            type: Me.Attribute,
            name: d,
            action: g,
            value: T,
            namespace: m,
            ignoreCase: k
          };
          r.push(_);
          break;
        }
        case 58: {
          if (e.charCodeAt(n + 1) === 58) {
            r.push({
              type: Me.PseudoElement,
              name: i(2).toLowerCase(),
              data: e.charCodeAt(n) === 40 ? o() : null
            });
            continue;
          }
          const d = i(1).toLowerCase();
          let m = null;
          if (e.charCodeAt(n) === 40)
            if (Cw.has(d)) {
              if (P1(e.charCodeAt(n + 1)))
                throw new Error(`Pseudo-selector ${d} cannot be quoted`);
              if (m = [], n = k2(m, e, n + 1), e.charCodeAt(n) !== 41)
                throw new Error(`Missing closing parenthesis in :${d} (${e})`);
              n += 1;
            } else {
              if (m = o(), xw.has(d)) {
                const g = m.charCodeAt(0);
                g === m.charCodeAt(m.length - 1) && P1(g) && (m = m.slice(1, -1));
              }
              m = hs(m);
            }
          r.push({ type: Me.Pseudo, name: d, data: m });
          break;
        }
        case 44: {
          f(), r = [], s(1);
          break;
        }
        default: {
          if (e.startsWith("/*", n)) {
            const g = e.indexOf("*/", n + 2);
            if (g < 0)
              throw new Error("Comment was not terminated");
            n = g + 2, r.length === 0 && s(0);
            break;
          }
          let d = null, m;
          if (h === 42)
            n += 1, m = "*";
          else if (h === 124) {
            if (m = "", e.charCodeAt(n + 1) === 124) {
              u(Me.ColumnCombinator), s(2);
              break;
            }
          } else if (Lp.test(e.slice(n)))
            m = i(0);
          else
            break e;
          e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 124 && (d = m, e.charCodeAt(n + 1) === 42 ? (m = "*", n += 2) : m = i(1)), r.push(m === "*" ? { type: Me.Universal, namespace: d } : { type: Me.Tag, name: m, namespace: d });
        }
      }
    }
  return f(), n;
}
var _w = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/, kw = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g, Ow = {
  aacute: "á",
  Aacute: "Á",
  abreve: "ă",
  Abreve: "Ă",
  ac: "∾",
  acd: "∿",
  acE: "∾̳",
  acirc: "â",
  Acirc: "Â",
  acute: "´",
  acy: "а",
  Acy: "А",
  aelig: "æ",
  AElig: "Æ",
  af: "⁡",
  afr: "𝔞",
  Afr: "𝔄",
  agrave: "à",
  Agrave: "À",
  alefsym: "ℵ",
  aleph: "ℵ",
  alpha: "α",
  Alpha: "Α",
  amacr: "ā",
  Amacr: "Ā",
  amalg: "⨿",
  amp: "&",
  AMP: "&",
  and: "∧",
  And: "⩓",
  andand: "⩕",
  andd: "⩜",
  andslope: "⩘",
  andv: "⩚",
  ang: "∠",
  ange: "⦤",
  angle: "∠",
  angmsd: "∡",
  angmsdaa: "⦨",
  angmsdab: "⦩",
  angmsdac: "⦪",
  angmsdad: "⦫",
  angmsdae: "⦬",
  angmsdaf: "⦭",
  angmsdag: "⦮",
  angmsdah: "⦯",
  angrt: "∟",
  angrtvb: "⊾",
  angrtvbd: "⦝",
  angsph: "∢",
  angst: "Å",
  angzarr: "⍼",
  aogon: "ą",
  Aogon: "Ą",
  aopf: "𝕒",
  Aopf: "𝔸",
  ap: "≈",
  apacir: "⩯",
  ape: "≊",
  apE: "⩰",
  apid: "≋",
  apos: "'",
  ApplyFunction: "⁡",
  approx: "≈",
  approxeq: "≊",
  aring: "å",
  Aring: "Å",
  ascr: "𝒶",
  Ascr: "𝒜",
  Assign: "≔",
  ast: "*",
  asymp: "≈",
  asympeq: "≍",
  atilde: "ã",
  Atilde: "Ã",
  auml: "ä",
  Auml: "Ä",
  awconint: "∳",
  awint: "⨑",
  backcong: "≌",
  backepsilon: "϶",
  backprime: "‵",
  backsim: "∽",
  backsimeq: "⋍",
  Backslash: "∖",
  Barv: "⫧",
  barvee: "⊽",
  barwed: "⌅",
  Barwed: "⌆",
  barwedge: "⌅",
  bbrk: "⎵",
  bbrktbrk: "⎶",
  bcong: "≌",
  bcy: "б",
  Bcy: "Б",
  bdquo: "„",
  becaus: "∵",
  because: "∵",
  Because: "∵",
  bemptyv: "⦰",
  bepsi: "϶",
  bernou: "ℬ",
  Bernoullis: "ℬ",
  beta: "β",
  Beta: "Β",
  beth: "ℶ",
  between: "≬",
  bfr: "𝔟",
  Bfr: "𝔅",
  bigcap: "⋂",
  bigcirc: "◯",
  bigcup: "⋃",
  bigodot: "⨀",
  bigoplus: "⨁",
  bigotimes: "⨂",
  bigsqcup: "⨆",
  bigstar: "★",
  bigtriangledown: "▽",
  bigtriangleup: "△",
  biguplus: "⨄",
  bigvee: "⋁",
  bigwedge: "⋀",
  bkarow: "⤍",
  blacklozenge: "⧫",
  blacksquare: "▪",
  blacktriangle: "▴",
  blacktriangledown: "▾",
  blacktriangleleft: "◂",
  blacktriangleright: "▸",
  blank: "␣",
  blk12: "▒",
  blk14: "░",
  blk34: "▓",
  block: "█",
  bne: "=⃥",
  bnequiv: "≡⃥",
  bnot: "⌐",
  bNot: "⫭",
  bopf: "𝕓",
  Bopf: "𝔹",
  bot: "⊥",
  bottom: "⊥",
  bowtie: "⋈",
  boxbox: "⧉",
  boxdl: "┐",
  boxdL: "╕",
  boxDl: "╖",
  boxDL: "╗",
  boxdr: "┌",
  boxdR: "╒",
  boxDr: "╓",
  boxDR: "╔",
  boxh: "─",
  boxH: "═",
  boxhd: "┬",
  boxhD: "╥",
  boxHd: "╤",
  boxHD: "╦",
  boxhu: "┴",
  boxhU: "╨",
  boxHu: "╧",
  boxHU: "╩",
  boxminus: "⊟",
  boxplus: "⊞",
  boxtimes: "⊠",
  boxul: "┘",
  boxuL: "╛",
  boxUl: "╜",
  boxUL: "╝",
  boxur: "└",
  boxuR: "╘",
  boxUr: "╙",
  boxUR: "╚",
  boxv: "│",
  boxV: "║",
  boxvh: "┼",
  boxvH: "╪",
  boxVh: "╫",
  boxVH: "╬",
  boxvl: "┤",
  boxvL: "╡",
  boxVl: "╢",
  boxVL: "╣",
  boxvr: "├",
  boxvR: "╞",
  boxVr: "╟",
  boxVR: "╠",
  bprime: "‵",
  breve: "˘",
  Breve: "˘",
  brvbar: "¦",
  bscr: "𝒷",
  Bscr: "ℬ",
  bsemi: "⁏",
  bsim: "∽",
  bsime: "⋍",
  bsol: "\\",
  bsolb: "⧅",
  bsolhsub: "⟈",
  bull: "•",
  bullet: "•",
  bump: "≎",
  bumpe: "≏",
  bumpE: "⪮",
  bumpeq: "≏",
  Bumpeq: "≎",
  cacute: "ć",
  Cacute: "Ć",
  cap: "∩",
  Cap: "⋒",
  capand: "⩄",
  capbrcup: "⩉",
  capcap: "⩋",
  capcup: "⩇",
  capdot: "⩀",
  CapitalDifferentialD: "ⅅ",
  caps: "∩︀",
  caret: "⁁",
  caron: "ˇ",
  Cayleys: "ℭ",
  ccaps: "⩍",
  ccaron: "č",
  Ccaron: "Č",
  ccedil: "ç",
  Ccedil: "Ç",
  ccirc: "ĉ",
  Ccirc: "Ĉ",
  Cconint: "∰",
  ccups: "⩌",
  ccupssm: "⩐",
  cdot: "ċ",
  Cdot: "Ċ",
  cedil: "¸",
  Cedilla: "¸",
  cemptyv: "⦲",
  cent: "¢",
  centerdot: "·",
  CenterDot: "·",
  cfr: "𝔠",
  Cfr: "ℭ",
  chcy: "ч",
  CHcy: "Ч",
  check: "✓",
  checkmark: "✓",
  chi: "χ",
  Chi: "Χ",
  cir: "○",
  circ: "ˆ",
  circeq: "≗",
  circlearrowleft: "↺",
  circlearrowright: "↻",
  circledast: "⊛",
  circledcirc: "⊚",
  circleddash: "⊝",
  CircleDot: "⊙",
  circledR: "®",
  circledS: "Ⓢ",
  CircleMinus: "⊖",
  CirclePlus: "⊕",
  CircleTimes: "⊗",
  cire: "≗",
  cirE: "⧃",
  cirfnint: "⨐",
  cirmid: "⫯",
  cirscir: "⧂",
  ClockwiseContourIntegral: "∲",
  CloseCurlyDoubleQuote: "”",
  CloseCurlyQuote: "’",
  clubs: "♣",
  clubsuit: "♣",
  colon: ":",
  Colon: "∷",
  colone: "≔",
  Colone: "⩴",
  coloneq: "≔",
  comma: ",",
  commat: "@",
  comp: "∁",
  compfn: "∘",
  complement: "∁",
  complexes: "ℂ",
  cong: "≅",
  congdot: "⩭",
  Congruent: "≡",
  conint: "∮",
  Conint: "∯",
  ContourIntegral: "∮",
  copf: "𝕔",
  Copf: "ℂ",
  coprod: "∐",
  Coproduct: "∐",
  copy: "©",
  COPY: "©",
  copysr: "℗",
  CounterClockwiseContourIntegral: "∳",
  crarr: "↵",
  cross: "✗",
  Cross: "⨯",
  cscr: "𝒸",
  Cscr: "𝒞",
  csub: "⫏",
  csube: "⫑",
  csup: "⫐",
  csupe: "⫒",
  ctdot: "⋯",
  cudarrl: "⤸",
  cudarrr: "⤵",
  cuepr: "⋞",
  cuesc: "⋟",
  cularr: "↶",
  cularrp: "⤽",
  cup: "∪",
  Cup: "⋓",
  cupbrcap: "⩈",
  cupcap: "⩆",
  CupCap: "≍",
  cupcup: "⩊",
  cupdot: "⊍",
  cupor: "⩅",
  cups: "∪︀",
  curarr: "↷",
  curarrm: "⤼",
  curlyeqprec: "⋞",
  curlyeqsucc: "⋟",
  curlyvee: "⋎",
  curlywedge: "⋏",
  curren: "¤",
  curvearrowleft: "↶",
  curvearrowright: "↷",
  cuvee: "⋎",
  cuwed: "⋏",
  cwconint: "∲",
  cwint: "∱",
  cylcty: "⌭",
  dagger: "†",
  Dagger: "‡",
  daleth: "ℸ",
  darr: "↓",
  dArr: "⇓",
  Darr: "↡",
  dash: "‐",
  dashv: "⊣",
  Dashv: "⫤",
  dbkarow: "⤏",
  dblac: "˝",
  dcaron: "ď",
  Dcaron: "Ď",
  dcy: "д",
  Dcy: "Д",
  dd: "ⅆ",
  DD: "ⅅ",
  ddagger: "‡",
  ddarr: "⇊",
  DDotrahd: "⤑",
  ddotseq: "⩷",
  deg: "°",
  Del: "∇",
  delta: "δ",
  Delta: "Δ",
  demptyv: "⦱",
  dfisht: "⥿",
  dfr: "𝔡",
  Dfr: "𝔇",
  dHar: "⥥",
  dharl: "⇃",
  dharr: "⇂",
  DiacriticalAcute: "´",
  DiacriticalDot: "˙",
  DiacriticalDoubleAcute: "˝",
  DiacriticalGrave: "`",
  DiacriticalTilde: "˜",
  diam: "⋄",
  diamond: "⋄",
  Diamond: "⋄",
  diamondsuit: "♦",
  diams: "♦",
  die: "¨",
  DifferentialD: "ⅆ",
  digamma: "ϝ",
  disin: "⋲",
  div: "÷",
  divide: "÷",
  divideontimes: "⋇",
  divonx: "⋇",
  djcy: "ђ",
  DJcy: "Ђ",
  dlcorn: "⌞",
  dlcrop: "⌍",
  dollar: "$",
  dopf: "𝕕",
  Dopf: "𝔻",
  dot: "˙",
  Dot: "¨",
  DotDot: "⃜",
  doteq: "≐",
  doteqdot: "≑",
  DotEqual: "≐",
  dotminus: "∸",
  dotplus: "∔",
  dotsquare: "⊡",
  doublebarwedge: "⌆",
  DoubleContourIntegral: "∯",
  DoubleDot: "¨",
  DoubleDownArrow: "⇓",
  DoubleLeftArrow: "⇐",
  DoubleLeftRightArrow: "⇔",
  DoubleLeftTee: "⫤",
  DoubleLongLeftArrow: "⟸",
  DoubleLongLeftRightArrow: "⟺",
  DoubleLongRightArrow: "⟹",
  DoubleRightArrow: "⇒",
  DoubleRightTee: "⊨",
  DoubleUpArrow: "⇑",
  DoubleUpDownArrow: "⇕",
  DoubleVerticalBar: "∥",
  downarrow: "↓",
  Downarrow: "⇓",
  DownArrow: "↓",
  DownArrowBar: "⤓",
  DownArrowUpArrow: "⇵",
  DownBreve: "̑",
  downdownarrows: "⇊",
  downharpoonleft: "⇃",
  downharpoonright: "⇂",
  DownLeftRightVector: "⥐",
  DownLeftTeeVector: "⥞",
  DownLeftVector: "↽",
  DownLeftVectorBar: "⥖",
  DownRightTeeVector: "⥟",
  DownRightVector: "⇁",
  DownRightVectorBar: "⥗",
  DownTee: "⊤",
  DownTeeArrow: "↧",
  drbkarow: "⤐",
  drcorn: "⌟",
  drcrop: "⌌",
  dscr: "𝒹",
  Dscr: "𝒟",
  dscy: "ѕ",
  DScy: "Ѕ",
  dsol: "⧶",
  dstrok: "đ",
  Dstrok: "Đ",
  dtdot: "⋱",
  dtri: "▿",
  dtrif: "▾",
  duarr: "⇵",
  duhar: "⥯",
  dwangle: "⦦",
  dzcy: "џ",
  DZcy: "Џ",
  dzigrarr: "⟿",
  eacute: "é",
  Eacute: "É",
  easter: "⩮",
  ecaron: "ě",
  Ecaron: "Ě",
  ecir: "≖",
  ecirc: "ê",
  Ecirc: "Ê",
  ecolon: "≕",
  ecy: "э",
  Ecy: "Э",
  eDDot: "⩷",
  edot: "ė",
  eDot: "≑",
  Edot: "Ė",
  ee: "ⅇ",
  efDot: "≒",
  efr: "𝔢",
  Efr: "𝔈",
  eg: "⪚",
  egrave: "è",
  Egrave: "È",
  egs: "⪖",
  egsdot: "⪘",
  el: "⪙",
  Element: "∈",
  elinters: "⏧",
  ell: "ℓ",
  els: "⪕",
  elsdot: "⪗",
  emacr: "ē",
  Emacr: "Ē",
  empty: "∅",
  emptyset: "∅",
  EmptySmallSquare: "◻",
  emptyv: "∅",
  EmptyVerySmallSquare: "▫",
  emsp: " ",
  emsp13: " ",
  emsp14: " ",
  eng: "ŋ",
  ENG: "Ŋ",
  ensp: " ",
  eogon: "ę",
  Eogon: "Ę",
  eopf: "𝕖",
  Eopf: "𝔼",
  epar: "⋕",
  eparsl: "⧣",
  eplus: "⩱",
  epsi: "ε",
  epsilon: "ε",
  Epsilon: "Ε",
  epsiv: "ϵ",
  eqcirc: "≖",
  eqcolon: "≕",
  eqsim: "≂",
  eqslantgtr: "⪖",
  eqslantless: "⪕",
  Equal: "⩵",
  equals: "=",
  EqualTilde: "≂",
  equest: "≟",
  Equilibrium: "⇌",
  equiv: "≡",
  equivDD: "⩸",
  eqvparsl: "⧥",
  erarr: "⥱",
  erDot: "≓",
  escr: "ℯ",
  Escr: "ℰ",
  esdot: "≐",
  esim: "≂",
  Esim: "⩳",
  eta: "η",
  Eta: "Η",
  eth: "ð",
  ETH: "Ð",
  euml: "ë",
  Euml: "Ë",
  euro: "€",
  excl: "!",
  exist: "∃",
  Exists: "∃",
  expectation: "ℰ",
  exponentiale: "ⅇ",
  ExponentialE: "ⅇ",
  fallingdotseq: "≒",
  fcy: "ф",
  Fcy: "Ф",
  female: "♀",
  ffilig: "ﬃ",
  fflig: "ﬀ",
  ffllig: "ﬄ",
  ffr: "𝔣",
  Ffr: "𝔉",
  filig: "ﬁ",
  FilledSmallSquare: "◼",
  FilledVerySmallSquare: "▪",
  fjlig: "fj",
  flat: "♭",
  fllig: "ﬂ",
  fltns: "▱",
  fnof: "ƒ",
  fopf: "𝕗",
  Fopf: "𝔽",
  forall: "∀",
  ForAll: "∀",
  fork: "⋔",
  forkv: "⫙",
  Fouriertrf: "ℱ",
  fpartint: "⨍",
  frac12: "½",
  frac13: "⅓",
  frac14: "¼",
  frac15: "⅕",
  frac16: "⅙",
  frac18: "⅛",
  frac23: "⅔",
  frac25: "⅖",
  frac34: "¾",
  frac35: "⅗",
  frac38: "⅜",
  frac45: "⅘",
  frac56: "⅚",
  frac58: "⅝",
  frac78: "⅞",
  frasl: "⁄",
  frown: "⌢",
  fscr: "𝒻",
  Fscr: "ℱ",
  gacute: "ǵ",
  gamma: "γ",
  Gamma: "Γ",
  gammad: "ϝ",
  Gammad: "Ϝ",
  gap: "⪆",
  gbreve: "ğ",
  Gbreve: "Ğ",
  Gcedil: "Ģ",
  gcirc: "ĝ",
  Gcirc: "Ĝ",
  gcy: "г",
  Gcy: "Г",
  gdot: "ġ",
  Gdot: "Ġ",
  ge: "≥",
  gE: "≧",
  gel: "⋛",
  gEl: "⪌",
  geq: "≥",
  geqq: "≧",
  geqslant: "⩾",
  ges: "⩾",
  gescc: "⪩",
  gesdot: "⪀",
  gesdoto: "⪂",
  gesdotol: "⪄",
  gesl: "⋛︀",
  gesles: "⪔",
  gfr: "𝔤",
  Gfr: "𝔊",
  gg: "≫",
  Gg: "⋙",
  ggg: "⋙",
  gimel: "ℷ",
  gjcy: "ѓ",
  GJcy: "Ѓ",
  gl: "≷",
  gla: "⪥",
  glE: "⪒",
  glj: "⪤",
  gnap: "⪊",
  gnapprox: "⪊",
  gne: "⪈",
  gnE: "≩",
  gneq: "⪈",
  gneqq: "≩",
  gnsim: "⋧",
  gopf: "𝕘",
  Gopf: "𝔾",
  grave: "`",
  GreaterEqual: "≥",
  GreaterEqualLess: "⋛",
  GreaterFullEqual: "≧",
  GreaterGreater: "⪢",
  GreaterLess: "≷",
  GreaterSlantEqual: "⩾",
  GreaterTilde: "≳",
  gscr: "ℊ",
  Gscr: "𝒢",
  gsim: "≳",
  gsime: "⪎",
  gsiml: "⪐",
  gt: ">",
  Gt: "≫",
  GT: ">",
  gtcc: "⪧",
  gtcir: "⩺",
  gtdot: "⋗",
  gtlPar: "⦕",
  gtquest: "⩼",
  gtrapprox: "⪆",
  gtrarr: "⥸",
  gtrdot: "⋗",
  gtreqless: "⋛",
  gtreqqless: "⪌",
  gtrless: "≷",
  gtrsim: "≳",
  gvertneqq: "≩︀",
  gvnE: "≩︀",
  Hacek: "ˇ",
  hairsp: " ",
  half: "½",
  hamilt: "ℋ",
  hardcy: "ъ",
  HARDcy: "Ъ",
  harr: "↔",
  hArr: "⇔",
  harrcir: "⥈",
  harrw: "↭",
  Hat: "^",
  hbar: "ℏ",
  hcirc: "ĥ",
  Hcirc: "Ĥ",
  hearts: "♥",
  heartsuit: "♥",
  hellip: "…",
  hercon: "⊹",
  hfr: "𝔥",
  Hfr: "ℌ",
  HilbertSpace: "ℋ",
  hksearow: "⤥",
  hkswarow: "⤦",
  hoarr: "⇿",
  homtht: "∻",
  hookleftarrow: "↩",
  hookrightarrow: "↪",
  hopf: "𝕙",
  Hopf: "ℍ",
  horbar: "―",
  HorizontalLine: "─",
  hscr: "𝒽",
  Hscr: "ℋ",
  hslash: "ℏ",
  hstrok: "ħ",
  Hstrok: "Ħ",
  HumpDownHump: "≎",
  HumpEqual: "≏",
  hybull: "⁃",
  hyphen: "‐",
  iacute: "í",
  Iacute: "Í",
  ic: "⁣",
  icirc: "î",
  Icirc: "Î",
  icy: "и",
  Icy: "И",
  Idot: "İ",
  iecy: "е",
  IEcy: "Е",
  iexcl: "¡",
  iff: "⇔",
  ifr: "𝔦",
  Ifr: "ℑ",
  igrave: "ì",
  Igrave: "Ì",
  ii: "ⅈ",
  iiiint: "⨌",
  iiint: "∭",
  iinfin: "⧜",
  iiota: "℩",
  ijlig: "ĳ",
  IJlig: "Ĳ",
  Im: "ℑ",
  imacr: "ī",
  Imacr: "Ī",
  image: "ℑ",
  ImaginaryI: "ⅈ",
  imagline: "ℐ",
  imagpart: "ℑ",
  imath: "ı",
  imof: "⊷",
  imped: "Ƶ",
  Implies: "⇒",
  in: "∈",
  incare: "℅",
  infin: "∞",
  infintie: "⧝",
  inodot: "ı",
  int: "∫",
  Int: "∬",
  intcal: "⊺",
  integers: "ℤ",
  Integral: "∫",
  intercal: "⊺",
  Intersection: "⋂",
  intlarhk: "⨗",
  intprod: "⨼",
  InvisibleComma: "⁣",
  InvisibleTimes: "⁢",
  iocy: "ё",
  IOcy: "Ё",
  iogon: "į",
  Iogon: "Į",
  iopf: "𝕚",
  Iopf: "𝕀",
  iota: "ι",
  Iota: "Ι",
  iprod: "⨼",
  iquest: "¿",
  iscr: "𝒾",
  Iscr: "ℐ",
  isin: "∈",
  isindot: "⋵",
  isinE: "⋹",
  isins: "⋴",
  isinsv: "⋳",
  isinv: "∈",
  it: "⁢",
  itilde: "ĩ",
  Itilde: "Ĩ",
  iukcy: "і",
  Iukcy: "І",
  iuml: "ï",
  Iuml: "Ï",
  jcirc: "ĵ",
  Jcirc: "Ĵ",
  jcy: "й",
  Jcy: "Й",
  jfr: "𝔧",
  Jfr: "𝔍",
  jmath: "ȷ",
  jopf: "𝕛",
  Jopf: "𝕁",
  jscr: "𝒿",
  Jscr: "𝒥",
  jsercy: "ј",
  Jsercy: "Ј",
  jukcy: "є",
  Jukcy: "Є",
  kappa: "κ",
  Kappa: "Κ",
  kappav: "ϰ",
  kcedil: "ķ",
  Kcedil: "Ķ",
  kcy: "к",
  Kcy: "К",
  kfr: "𝔨",
  Kfr: "𝔎",
  kgreen: "ĸ",
  khcy: "х",
  KHcy: "Х",
  kjcy: "ќ",
  KJcy: "Ќ",
  kopf: "𝕜",
  Kopf: "𝕂",
  kscr: "𝓀",
  Kscr: "𝒦",
  lAarr: "⇚",
  lacute: "ĺ",
  Lacute: "Ĺ",
  laemptyv: "⦴",
  lagran: "ℒ",
  lambda: "λ",
  Lambda: "Λ",
  lang: "⟨",
  Lang: "⟪",
  langd: "⦑",
  langle: "⟨",
  lap: "⪅",
  Laplacetrf: "ℒ",
  laquo: "«",
  larr: "←",
  lArr: "⇐",
  Larr: "↞",
  larrb: "⇤",
  larrbfs: "⤟",
  larrfs: "⤝",
  larrhk: "↩",
  larrlp: "↫",
  larrpl: "⤹",
  larrsim: "⥳",
  larrtl: "↢",
  lat: "⪫",
  latail: "⤙",
  lAtail: "⤛",
  late: "⪭",
  lates: "⪭︀",
  lbarr: "⤌",
  lBarr: "⤎",
  lbbrk: "❲",
  lbrace: "{",
  lbrack: "[",
  lbrke: "⦋",
  lbrksld: "⦏",
  lbrkslu: "⦍",
  lcaron: "ľ",
  Lcaron: "Ľ",
  lcedil: "ļ",
  Lcedil: "Ļ",
  lceil: "⌈",
  lcub: "{",
  lcy: "л",
  Lcy: "Л",
  ldca: "⤶",
  ldquo: "“",
  ldquor: "„",
  ldrdhar: "⥧",
  ldrushar: "⥋",
  ldsh: "↲",
  le: "≤",
  lE: "≦",
  LeftAngleBracket: "⟨",
  leftarrow: "←",
  Leftarrow: "⇐",
  LeftArrow: "←",
  LeftArrowBar: "⇤",
  LeftArrowRightArrow: "⇆",
  leftarrowtail: "↢",
  LeftCeiling: "⌈",
  LeftDoubleBracket: "⟦",
  LeftDownTeeVector: "⥡",
  LeftDownVector: "⇃",
  LeftDownVectorBar: "⥙",
  LeftFloor: "⌊",
  leftharpoondown: "↽",
  leftharpoonup: "↼",
  leftleftarrows: "⇇",
  leftrightarrow: "↔",
  Leftrightarrow: "⇔",
  LeftRightArrow: "↔",
  leftrightarrows: "⇆",
  leftrightharpoons: "⇋",
  leftrightsquigarrow: "↭",
  LeftRightVector: "⥎",
  LeftTee: "⊣",
  LeftTeeArrow: "↤",
  LeftTeeVector: "⥚",
  leftthreetimes: "⋋",
  LeftTriangle: "⊲",
  LeftTriangleBar: "⧏",
  LeftTriangleEqual: "⊴",
  LeftUpDownVector: "⥑",
  LeftUpTeeVector: "⥠",
  LeftUpVector: "↿",
  LeftUpVectorBar: "⥘",
  LeftVector: "↼",
  LeftVectorBar: "⥒",
  leg: "⋚",
  lEg: "⪋",
  leq: "≤",
  leqq: "≦",
  leqslant: "⩽",
  les: "⩽",
  lescc: "⪨",
  lesdot: "⩿",
  lesdoto: "⪁",
  lesdotor: "⪃",
  lesg: "⋚︀",
  lesges: "⪓",
  lessapprox: "⪅",
  lessdot: "⋖",
  lesseqgtr: "⋚",
  lesseqqgtr: "⪋",
  LessEqualGreater: "⋚",
  LessFullEqual: "≦",
  LessGreater: "≶",
  lessgtr: "≶",
  LessLess: "⪡",
  lesssim: "≲",
  LessSlantEqual: "⩽",
  LessTilde: "≲",
  lfisht: "⥼",
  lfloor: "⌊",
  lfr: "𝔩",
  Lfr: "𝔏",
  lg: "≶",
  lgE: "⪑",
  lHar: "⥢",
  lhard: "↽",
  lharu: "↼",
  lharul: "⥪",
  lhblk: "▄",
  ljcy: "љ",
  LJcy: "Љ",
  ll: "≪",
  Ll: "⋘",
  llarr: "⇇",
  llcorner: "⌞",
  Lleftarrow: "⇚",
  llhard: "⥫",
  lltri: "◺",
  lmidot: "ŀ",
  Lmidot: "Ŀ",
  lmoust: "⎰",
  lmoustache: "⎰",
  lnap: "⪉",
  lnapprox: "⪉",
  lne: "⪇",
  lnE: "≨",
  lneq: "⪇",
  lneqq: "≨",
  lnsim: "⋦",
  loang: "⟬",
  loarr: "⇽",
  lobrk: "⟦",
  longleftarrow: "⟵",
  Longleftarrow: "⟸",
  LongLeftArrow: "⟵",
  longleftrightarrow: "⟷",
  Longleftrightarrow: "⟺",
  LongLeftRightArrow: "⟷",
  longmapsto: "⟼",
  longrightarrow: "⟶",
  Longrightarrow: "⟹",
  LongRightArrow: "⟶",
  looparrowleft: "↫",
  looparrowright: "↬",
  lopar: "⦅",
  lopf: "𝕝",
  Lopf: "𝕃",
  loplus: "⨭",
  lotimes: "⨴",
  lowast: "∗",
  lowbar: "_",
  LowerLeftArrow: "↙",
  LowerRightArrow: "↘",
  loz: "◊",
  lozenge: "◊",
  lozf: "⧫",
  lpar: "(",
  lparlt: "⦓",
  lrarr: "⇆",
  lrcorner: "⌟",
  lrhar: "⇋",
  lrhard: "⥭",
  lrm: "‎",
  lrtri: "⊿",
  lsaquo: "‹",
  lscr: "𝓁",
  Lscr: "ℒ",
  lsh: "↰",
  Lsh: "↰",
  lsim: "≲",
  lsime: "⪍",
  lsimg: "⪏",
  lsqb: "[",
  lsquo: "‘",
  lsquor: "‚",
  lstrok: "ł",
  Lstrok: "Ł",
  lt: "<",
  Lt: "≪",
  LT: "<",
  ltcc: "⪦",
  ltcir: "⩹",
  ltdot: "⋖",
  lthree: "⋋",
  ltimes: "⋉",
  ltlarr: "⥶",
  ltquest: "⩻",
  ltri: "◃",
  ltrie: "⊴",
  ltrif: "◂",
  ltrPar: "⦖",
  lurdshar: "⥊",
  luruhar: "⥦",
  lvertneqq: "≨︀",
  lvnE: "≨︀",
  macr: "¯",
  male: "♂",
  malt: "✠",
  maltese: "✠",
  map: "↦",
  Map: "⤅",
  mapsto: "↦",
  mapstodown: "↧",
  mapstoleft: "↤",
  mapstoup: "↥",
  marker: "▮",
  mcomma: "⨩",
  mcy: "м",
  Mcy: "М",
  mdash: "—",
  mDDot: "∺",
  measuredangle: "∡",
  MediumSpace: " ",
  Mellintrf: "ℳ",
  mfr: "𝔪",
  Mfr: "𝔐",
  mho: "℧",
  micro: "µ",
  mid: "∣",
  midast: "*",
  midcir: "⫰",
  middot: "·",
  minus: "−",
  minusb: "⊟",
  minusd: "∸",
  minusdu: "⨪",
  MinusPlus: "∓",
  mlcp: "⫛",
  mldr: "…",
  mnplus: "∓",
  models: "⊧",
  mopf: "𝕞",
  Mopf: "𝕄",
  mp: "∓",
  mscr: "𝓂",
  Mscr: "ℳ",
  mstpos: "∾",
  mu: "μ",
  Mu: "Μ",
  multimap: "⊸",
  mumap: "⊸",
  nabla: "∇",
  nacute: "ń",
  Nacute: "Ń",
  nang: "∠⃒",
  nap: "≉",
  napE: "⩰̸",
  napid: "≋̸",
  napos: "ŉ",
  napprox: "≉",
  natur: "♮",
  natural: "♮",
  naturals: "ℕ",
  nbsp: " ",
  nbump: "≎̸",
  nbumpe: "≏̸",
  ncap: "⩃",
  ncaron: "ň",
  Ncaron: "Ň",
  ncedil: "ņ",
  Ncedil: "Ņ",
  ncong: "≇",
  ncongdot: "⩭̸",
  ncup: "⩂",
  ncy: "н",
  Ncy: "Н",
  ndash: "–",
  ne: "≠",
  nearhk: "⤤",
  nearr: "↗",
  neArr: "⇗",
  nearrow: "↗",
  nedot: "≐̸",
  NegativeMediumSpace: "​",
  NegativeThickSpace: "​",
  NegativeThinSpace: "​",
  NegativeVeryThinSpace: "​",
  nequiv: "≢",
  nesear: "⤨",
  nesim: "≂̸",
  NestedGreaterGreater: "≫",
  NestedLessLess: "≪",
  NewLine: `
`,
  nexist: "∄",
  nexists: "∄",
  nfr: "𝔫",
  Nfr: "𝔑",
  nge: "≱",
  ngE: "≧̸",
  ngeq: "≱",
  ngeqq: "≧̸",
  ngeqslant: "⩾̸",
  nges: "⩾̸",
  nGg: "⋙̸",
  ngsim: "≵",
  ngt: "≯",
  nGt: "≫⃒",
  ngtr: "≯",
  nGtv: "≫̸",
  nharr: "↮",
  nhArr: "⇎",
  nhpar: "⫲",
  ni: "∋",
  nis: "⋼",
  nisd: "⋺",
  niv: "∋",
  njcy: "њ",
  NJcy: "Њ",
  nlarr: "↚",
  nlArr: "⇍",
  nldr: "‥",
  nle: "≰",
  nlE: "≦̸",
  nleftarrow: "↚",
  nLeftarrow: "⇍",
  nleftrightarrow: "↮",
  nLeftrightarrow: "⇎",
  nleq: "≰",
  nleqq: "≦̸",
  nleqslant: "⩽̸",
  nles: "⩽̸",
  nless: "≮",
  nLl: "⋘̸",
  nlsim: "≴",
  nlt: "≮",
  nLt: "≪⃒",
  nltri: "⋪",
  nltrie: "⋬",
  nLtv: "≪̸",
  nmid: "∤",
  NoBreak: "⁠",
  NonBreakingSpace: " ",
  nopf: "𝕟",
  Nopf: "ℕ",
  not: "¬",
  Not: "⫬",
  NotCongruent: "≢",
  NotCupCap: "≭",
  NotDoubleVerticalBar: "∦",
  NotElement: "∉",
  NotEqual: "≠",
  NotEqualTilde: "≂̸",
  NotExists: "∄",
  NotGreater: "≯",
  NotGreaterEqual: "≱",
  NotGreaterFullEqual: "≧̸",
  NotGreaterGreater: "≫̸",
  NotGreaterLess: "≹",
  NotGreaterSlantEqual: "⩾̸",
  NotGreaterTilde: "≵",
  NotHumpDownHump: "≎̸",
  NotHumpEqual: "≏̸",
  notin: "∉",
  notindot: "⋵̸",
  notinE: "⋹̸",
  notinva: "∉",
  notinvb: "⋷",
  notinvc: "⋶",
  NotLeftTriangle: "⋪",
  NotLeftTriangleBar: "⧏̸",
  NotLeftTriangleEqual: "⋬",
  NotLess: "≮",
  NotLessEqual: "≰",
  NotLessGreater: "≸",
  NotLessLess: "≪̸",
  NotLessSlantEqual: "⩽̸",
  NotLessTilde: "≴",
  NotNestedGreaterGreater: "⪢̸",
  NotNestedLessLess: "⪡̸",
  notni: "∌",
  notniva: "∌",
  notnivb: "⋾",
  notnivc: "⋽",
  NotPrecedes: "⊀",
  NotPrecedesEqual: "⪯̸",
  NotPrecedesSlantEqual: "⋠",
  NotReverseElement: "∌",
  NotRightTriangle: "⋫",
  NotRightTriangleBar: "⧐̸",
  NotRightTriangleEqual: "⋭",
  NotSquareSubset: "⊏̸",
  NotSquareSubsetEqual: "⋢",
  NotSquareSuperset: "⊐̸",
  NotSquareSupersetEqual: "⋣",
  NotSubset: "⊂⃒",
  NotSubsetEqual: "⊈",
  NotSucceeds: "⊁",
  NotSucceedsEqual: "⪰̸",
  NotSucceedsSlantEqual: "⋡",
  NotSucceedsTilde: "≿̸",
  NotSuperset: "⊃⃒",
  NotSupersetEqual: "⊉",
  NotTilde: "≁",
  NotTildeEqual: "≄",
  NotTildeFullEqual: "≇",
  NotTildeTilde: "≉",
  NotVerticalBar: "∤",
  npar: "∦",
  nparallel: "∦",
  nparsl: "⫽⃥",
  npart: "∂̸",
  npolint: "⨔",
  npr: "⊀",
  nprcue: "⋠",
  npre: "⪯̸",
  nprec: "⊀",
  npreceq: "⪯̸",
  nrarr: "↛",
  nrArr: "⇏",
  nrarrc: "⤳̸",
  nrarrw: "↝̸",
  nrightarrow: "↛",
  nRightarrow: "⇏",
  nrtri: "⋫",
  nrtrie: "⋭",
  nsc: "⊁",
  nsccue: "⋡",
  nsce: "⪰̸",
  nscr: "𝓃",
  Nscr: "𝒩",
  nshortmid: "∤",
  nshortparallel: "∦",
  nsim: "≁",
  nsime: "≄",
  nsimeq: "≄",
  nsmid: "∤",
  nspar: "∦",
  nsqsube: "⋢",
  nsqsupe: "⋣",
  nsub: "⊄",
  nsube: "⊈",
  nsubE: "⫅̸",
  nsubset: "⊂⃒",
  nsubseteq: "⊈",
  nsubseteqq: "⫅̸",
  nsucc: "⊁",
  nsucceq: "⪰̸",
  nsup: "⊅",
  nsupe: "⊉",
  nsupE: "⫆̸",
  nsupset: "⊃⃒",
  nsupseteq: "⊉",
  nsupseteqq: "⫆̸",
  ntgl: "≹",
  ntilde: "ñ",
  Ntilde: "Ñ",
  ntlg: "≸",
  ntriangleleft: "⋪",
  ntrianglelefteq: "⋬",
  ntriangleright: "⋫",
  ntrianglerighteq: "⋭",
  nu: "ν",
  Nu: "Ν",
  num: "#",
  numero: "№",
  numsp: " ",
  nvap: "≍⃒",
  nvdash: "⊬",
  nvDash: "⊭",
  nVdash: "⊮",
  nVDash: "⊯",
  nvge: "≥⃒",
  nvgt: ">⃒",
  nvHarr: "⤄",
  nvinfin: "⧞",
  nvlArr: "⤂",
  nvle: "≤⃒",
  nvlt: "<⃒",
  nvltrie: "⊴⃒",
  nvrArr: "⤃",
  nvrtrie: "⊵⃒",
  nvsim: "∼⃒",
  nwarhk: "⤣",
  nwarr: "↖",
  nwArr: "⇖",
  nwarrow: "↖",
  nwnear: "⤧",
  oacute: "ó",
  Oacute: "Ó",
  oast: "⊛",
  ocir: "⊚",
  ocirc: "ô",
  Ocirc: "Ô",
  ocy: "о",
  Ocy: "О",
  odash: "⊝",
  odblac: "ő",
  Odblac: "Ő",
  odiv: "⨸",
  odot: "⊙",
  odsold: "⦼",
  oelig: "œ",
  OElig: "Œ",
  ofcir: "⦿",
  ofr: "𝔬",
  Ofr: "𝔒",
  ogon: "˛",
  ograve: "ò",
  Ograve: "Ò",
  ogt: "⧁",
  ohbar: "⦵",
  ohm: "Ω",
  oint: "∮",
  olarr: "↺",
  olcir: "⦾",
  olcross: "⦻",
  oline: "‾",
  olt: "⧀",
  omacr: "ō",
  Omacr: "Ō",
  omega: "ω",
  Omega: "Ω",
  omicron: "ο",
  Omicron: "Ο",
  omid: "⦶",
  ominus: "⊖",
  oopf: "𝕠",
  Oopf: "𝕆",
  opar: "⦷",
  OpenCurlyDoubleQuote: "“",
  OpenCurlyQuote: "‘",
  operp: "⦹",
  oplus: "⊕",
  or: "∨",
  Or: "⩔",
  orarr: "↻",
  ord: "⩝",
  order: "ℴ",
  orderof: "ℴ",
  ordf: "ª",
  ordm: "º",
  origof: "⊶",
  oror: "⩖",
  orslope: "⩗",
  orv: "⩛",
  oS: "Ⓢ",
  oscr: "ℴ",
  Oscr: "𝒪",
  oslash: "ø",
  Oslash: "Ø",
  osol: "⊘",
  otilde: "õ",
  Otilde: "Õ",
  otimes: "⊗",
  Otimes: "⨷",
  otimesas: "⨶",
  ouml: "ö",
  Ouml: "Ö",
  ovbar: "⌽",
  OverBar: "‾",
  OverBrace: "⏞",
  OverBracket: "⎴",
  OverParenthesis: "⏜",
  par: "∥",
  para: "¶",
  parallel: "∥",
  parsim: "⫳",
  parsl: "⫽",
  part: "∂",
  PartialD: "∂",
  pcy: "п",
  Pcy: "П",
  percnt: "%",
  period: ".",
  permil: "‰",
  perp: "⊥",
  pertenk: "‱",
  pfr: "𝔭",
  Pfr: "𝔓",
  phi: "φ",
  Phi: "Φ",
  phiv: "ϕ",
  phmmat: "ℳ",
  phone: "☎",
  pi: "π",
  Pi: "Π",
  pitchfork: "⋔",
  piv: "ϖ",
  planck: "ℏ",
  planckh: "ℎ",
  plankv: "ℏ",
  plus: "+",
  plusacir: "⨣",
  plusb: "⊞",
  pluscir: "⨢",
  plusdo: "∔",
  plusdu: "⨥",
  pluse: "⩲",
  PlusMinus: "±",
  plusmn: "±",
  plussim: "⨦",
  plustwo: "⨧",
  pm: "±",
  Poincareplane: "ℌ",
  pointint: "⨕",
  popf: "𝕡",
  Popf: "ℙ",
  pound: "£",
  pr: "≺",
  Pr: "⪻",
  prap: "⪷",
  prcue: "≼",
  pre: "⪯",
  prE: "⪳",
  prec: "≺",
  precapprox: "⪷",
  preccurlyeq: "≼",
  Precedes: "≺",
  PrecedesEqual: "⪯",
  PrecedesSlantEqual: "≼",
  PrecedesTilde: "≾",
  preceq: "⪯",
  precnapprox: "⪹",
  precneqq: "⪵",
  precnsim: "⋨",
  precsim: "≾",
  prime: "′",
  Prime: "″",
  primes: "ℙ",
  prnap: "⪹",
  prnE: "⪵",
  prnsim: "⋨",
  prod: "∏",
  Product: "∏",
  profalar: "⌮",
  profline: "⌒",
  profsurf: "⌓",
  prop: "∝",
  Proportion: "∷",
  Proportional: "∝",
  propto: "∝",
  prsim: "≾",
  prurel: "⊰",
  pscr: "𝓅",
  Pscr: "𝒫",
  psi: "ψ",
  Psi: "Ψ",
  puncsp: " ",
  qfr: "𝔮",
  Qfr: "𝔔",
  qint: "⨌",
  qopf: "𝕢",
  Qopf: "ℚ",
  qprime: "⁗",
  qscr: "𝓆",
  Qscr: "𝒬",
  quaternions: "ℍ",
  quatint: "⨖",
  quest: "?",
  questeq: "≟",
  quot: '"',
  QUOT: '"',
  rAarr: "⇛",
  race: "∽̱",
  racute: "ŕ",
  Racute: "Ŕ",
  radic: "√",
  raemptyv: "⦳",
  rang: "⟩",
  Rang: "⟫",
  rangd: "⦒",
  range: "⦥",
  rangle: "⟩",
  raquo: "»",
  rarr: "→",
  rArr: "⇒",
  Rarr: "↠",
  rarrap: "⥵",
  rarrb: "⇥",
  rarrbfs: "⤠",
  rarrc: "⤳",
  rarrfs: "⤞",
  rarrhk: "↪",
  rarrlp: "↬",
  rarrpl: "⥅",
  rarrsim: "⥴",
  rarrtl: "↣",
  Rarrtl: "⤖",
  rarrw: "↝",
  ratail: "⤚",
  rAtail: "⤜",
  ratio: "∶",
  rationals: "ℚ",
  rbarr: "⤍",
  rBarr: "⤏",
  RBarr: "⤐",
  rbbrk: "❳",
  rbrace: "}",
  rbrack: "]",
  rbrke: "⦌",
  rbrksld: "⦎",
  rbrkslu: "⦐",
  rcaron: "ř",
  Rcaron: "Ř",
  rcedil: "ŗ",
  Rcedil: "Ŗ",
  rceil: "⌉",
  rcub: "}",
  rcy: "р",
  Rcy: "Р",
  rdca: "⤷",
  rdldhar: "⥩",
  rdquo: "”",
  rdquor: "”",
  rdsh: "↳",
  Re: "ℜ",
  real: "ℜ",
  realine: "ℛ",
  realpart: "ℜ",
  reals: "ℝ",
  rect: "▭",
  reg: "®",
  REG: "®",
  ReverseElement: "∋",
  ReverseEquilibrium: "⇋",
  ReverseUpEquilibrium: "⥯",
  rfisht: "⥽",
  rfloor: "⌋",
  rfr: "𝔯",
  Rfr: "ℜ",
  rHar: "⥤",
  rhard: "⇁",
  rharu: "⇀",
  rharul: "⥬",
  rho: "ρ",
  Rho: "Ρ",
  rhov: "ϱ",
  RightAngleBracket: "⟩",
  rightarrow: "→",
  Rightarrow: "⇒",
  RightArrow: "→",
  RightArrowBar: "⇥",
  RightArrowLeftArrow: "⇄",
  rightarrowtail: "↣",
  RightCeiling: "⌉",
  RightDoubleBracket: "⟧",
  RightDownTeeVector: "⥝",
  RightDownVector: "⇂",
  RightDownVectorBar: "⥕",
  RightFloor: "⌋",
  rightharpoondown: "⇁",
  rightharpoonup: "⇀",
  rightleftarrows: "⇄",
  rightleftharpoons: "⇌",
  rightrightarrows: "⇉",
  rightsquigarrow: "↝",
  RightTee: "⊢",
  RightTeeArrow: "↦",
  RightTeeVector: "⥛",
  rightthreetimes: "⋌",
  RightTriangle: "⊳",
  RightTriangleBar: "⧐",
  RightTriangleEqual: "⊵",
  RightUpDownVector: "⥏",
  RightUpTeeVector: "⥜",
  RightUpVector: "↾",
  RightUpVectorBar: "⥔",
  RightVector: "⇀",
  RightVectorBar: "⥓",
  ring: "˚",
  risingdotseq: "≓",
  rlarr: "⇄",
  rlhar: "⇌",
  rlm: "‏",
  rmoust: "⎱",
  rmoustache: "⎱",
  rnmid: "⫮",
  roang: "⟭",
  roarr: "⇾",
  robrk: "⟧",
  ropar: "⦆",
  ropf: "𝕣",
  Ropf: "ℝ",
  roplus: "⨮",
  rotimes: "⨵",
  RoundImplies: "⥰",
  rpar: ")",
  rpargt: "⦔",
  rppolint: "⨒",
  rrarr: "⇉",
  Rrightarrow: "⇛",
  rsaquo: "›",
  rscr: "𝓇",
  Rscr: "ℛ",
  rsh: "↱",
  Rsh: "↱",
  rsqb: "]",
  rsquo: "’",
  rsquor: "’",
  rthree: "⋌",
  rtimes: "⋊",
  rtri: "▹",
  rtrie: "⊵",
  rtrif: "▸",
  rtriltri: "⧎",
  RuleDelayed: "⧴",
  ruluhar: "⥨",
  rx: "℞",
  sacute: "ś",
  Sacute: "Ś",
  sbquo: "‚",
  sc: "≻",
  Sc: "⪼",
  scap: "⪸",
  scaron: "š",
  Scaron: "Š",
  sccue: "≽",
  sce: "⪰",
  scE: "⪴",
  scedil: "ş",
  Scedil: "Ş",
  scirc: "ŝ",
  Scirc: "Ŝ",
  scnap: "⪺",
  scnE: "⪶",
  scnsim: "⋩",
  scpolint: "⨓",
  scsim: "≿",
  scy: "с",
  Scy: "С",
  sdot: "⋅",
  sdotb: "⊡",
  sdote: "⩦",
  searhk: "⤥",
  searr: "↘",
  seArr: "⇘",
  searrow: "↘",
  sect: "§",
  semi: ";",
  seswar: "⤩",
  setminus: "∖",
  setmn: "∖",
  sext: "✶",
  sfr: "𝔰",
  Sfr: "𝔖",
  sfrown: "⌢",
  sharp: "♯",
  shchcy: "щ",
  SHCHcy: "Щ",
  shcy: "ш",
  SHcy: "Ш",
  ShortDownArrow: "↓",
  ShortLeftArrow: "←",
  shortmid: "∣",
  shortparallel: "∥",
  ShortRightArrow: "→",
  ShortUpArrow: "↑",
  shy: "­",
  sigma: "σ",
  Sigma: "Σ",
  sigmaf: "ς",
  sigmav: "ς",
  sim: "∼",
  simdot: "⩪",
  sime: "≃",
  simeq: "≃",
  simg: "⪞",
  simgE: "⪠",
  siml: "⪝",
  simlE: "⪟",
  simne: "≆",
  simplus: "⨤",
  simrarr: "⥲",
  slarr: "←",
  SmallCircle: "∘",
  smallsetminus: "∖",
  smashp: "⨳",
  smeparsl: "⧤",
  smid: "∣",
  smile: "⌣",
  smt: "⪪",
  smte: "⪬",
  smtes: "⪬︀",
  softcy: "ь",
  SOFTcy: "Ь",
  sol: "/",
  solb: "⧄",
  solbar: "⌿",
  sopf: "𝕤",
  Sopf: "𝕊",
  spades: "♠",
  spadesuit: "♠",
  spar: "∥",
  sqcap: "⊓",
  sqcaps: "⊓︀",
  sqcup: "⊔",
  sqcups: "⊔︀",
  Sqrt: "√",
  sqsub: "⊏",
  sqsube: "⊑",
  sqsubset: "⊏",
  sqsubseteq: "⊑",
  sqsup: "⊐",
  sqsupe: "⊒",
  sqsupset: "⊐",
  sqsupseteq: "⊒",
  squ: "□",
  square: "□",
  Square: "□",
  SquareIntersection: "⊓",
  SquareSubset: "⊏",
  SquareSubsetEqual: "⊑",
  SquareSuperset: "⊐",
  SquareSupersetEqual: "⊒",
  SquareUnion: "⊔",
  squarf: "▪",
  squf: "▪",
  srarr: "→",
  sscr: "𝓈",
  Sscr: "𝒮",
  ssetmn: "∖",
  ssmile: "⌣",
  sstarf: "⋆",
  star: "☆",
  Star: "⋆",
  starf: "★",
  straightepsilon: "ϵ",
  straightphi: "ϕ",
  strns: "¯",
  sub: "⊂",
  Sub: "⋐",
  subdot: "⪽",
  sube: "⊆",
  subE: "⫅",
  subedot: "⫃",
  submult: "⫁",
  subne: "⊊",
  subnE: "⫋",
  subplus: "⪿",
  subrarr: "⥹",
  subset: "⊂",
  Subset: "⋐",
  subseteq: "⊆",
  subseteqq: "⫅",
  SubsetEqual: "⊆",
  subsetneq: "⊊",
  subsetneqq: "⫋",
  subsim: "⫇",
  subsub: "⫕",
  subsup: "⫓",
  succ: "≻",
  succapprox: "⪸",
  succcurlyeq: "≽",
  Succeeds: "≻",
  SucceedsEqual: "⪰",
  SucceedsSlantEqual: "≽",
  SucceedsTilde: "≿",
  succeq: "⪰",
  succnapprox: "⪺",
  succneqq: "⪶",
  succnsim: "⋩",
  succsim: "≿",
  SuchThat: "∋",
  sum: "∑",
  Sum: "∑",
  sung: "♪",
  sup: "⊃",
  Sup: "⋑",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  supdot: "⪾",
  supdsub: "⫘",
  supe: "⊇",
  supE: "⫆",
  supedot: "⫄",
  Superset: "⊃",
  SupersetEqual: "⊇",
  suphsol: "⟉",
  suphsub: "⫗",
  suplarr: "⥻",
  supmult: "⫂",
  supne: "⊋",
  supnE: "⫌",
  supplus: "⫀",
  supset: "⊃",
  Supset: "⋑",
  supseteq: "⊇",
  supseteqq: "⫆",
  supsetneq: "⊋",
  supsetneqq: "⫌",
  supsim: "⫈",
  supsub: "⫔",
  supsup: "⫖",
  swarhk: "⤦",
  swarr: "↙",
  swArr: "⇙",
  swarrow: "↙",
  swnwar: "⤪",
  szlig: "ß",
  Tab: "	",
  target: "⌖",
  tau: "τ",
  Tau: "Τ",
  tbrk: "⎴",
  tcaron: "ť",
  Tcaron: "Ť",
  tcedil: "ţ",
  Tcedil: "Ţ",
  tcy: "т",
  Tcy: "Т",
  tdot: "⃛",
  telrec: "⌕",
  tfr: "𝔱",
  Tfr: "𝔗",
  there4: "∴",
  therefore: "∴",
  Therefore: "∴",
  theta: "θ",
  Theta: "Θ",
  thetasym: "ϑ",
  thetav: "ϑ",
  thickapprox: "≈",
  thicksim: "∼",
  ThickSpace: "  ",
  thinsp: " ",
  ThinSpace: " ",
  thkap: "≈",
  thksim: "∼",
  thorn: "þ",
  THORN: "Þ",
  tilde: "˜",
  Tilde: "∼",
  TildeEqual: "≃",
  TildeFullEqual: "≅",
  TildeTilde: "≈",
  times: "×",
  timesb: "⊠",
  timesbar: "⨱",
  timesd: "⨰",
  tint: "∭",
  toea: "⤨",
  top: "⊤",
  topbot: "⌶",
  topcir: "⫱",
  topf: "𝕥",
  Topf: "𝕋",
  topfork: "⫚",
  tosa: "⤩",
  tprime: "‴",
  trade: "™",
  TRADE: "™",
  triangle: "▵",
  triangledown: "▿",
  triangleleft: "◃",
  trianglelefteq: "⊴",
  triangleq: "≜",
  triangleright: "▹",
  trianglerighteq: "⊵",
  tridot: "◬",
  trie: "≜",
  triminus: "⨺",
  TripleDot: "⃛",
  triplus: "⨹",
  trisb: "⧍",
  tritime: "⨻",
  trpezium: "⏢",
  tscr: "𝓉",
  Tscr: "𝒯",
  tscy: "ц",
  TScy: "Ц",
  tshcy: "ћ",
  TSHcy: "Ћ",
  tstrok: "ŧ",
  Tstrok: "Ŧ",
  twixt: "≬",
  twoheadleftarrow: "↞",
  twoheadrightarrow: "↠",
  uacute: "ú",
  Uacute: "Ú",
  uarr: "↑",
  uArr: "⇑",
  Uarr: "↟",
  Uarrocir: "⥉",
  ubrcy: "ў",
  Ubrcy: "Ў",
  ubreve: "ŭ",
  Ubreve: "Ŭ",
  ucirc: "û",
  Ucirc: "Û",
  ucy: "у",
  Ucy: "У",
  udarr: "⇅",
  udblac: "ű",
  Udblac: "Ű",
  udhar: "⥮",
  ufisht: "⥾",
  ufr: "𝔲",
  Ufr: "𝔘",
  ugrave: "ù",
  Ugrave: "Ù",
  uHar: "⥣",
  uharl: "↿",
  uharr: "↾",
  uhblk: "▀",
  ulcorn: "⌜",
  ulcorner: "⌜",
  ulcrop: "⌏",
  ultri: "◸",
  umacr: "ū",
  Umacr: "Ū",
  uml: "¨",
  UnderBar: "_",
  UnderBrace: "⏟",
  UnderBracket: "⎵",
  UnderParenthesis: "⏝",
  Union: "⋃",
  UnionPlus: "⊎",
  uogon: "ų",
  Uogon: "Ų",
  uopf: "𝕦",
  Uopf: "𝕌",
  uparrow: "↑",
  Uparrow: "⇑",
  UpArrow: "↑",
  UpArrowBar: "⤒",
  UpArrowDownArrow: "⇅",
  updownarrow: "↕",
  Updownarrow: "⇕",
  UpDownArrow: "↕",
  UpEquilibrium: "⥮",
  upharpoonleft: "↿",
  upharpoonright: "↾",
  uplus: "⊎",
  UpperLeftArrow: "↖",
  UpperRightArrow: "↗",
  upsi: "υ",
  Upsi: "ϒ",
  upsih: "ϒ",
  upsilon: "υ",
  Upsilon: "Υ",
  UpTee: "⊥",
  UpTeeArrow: "↥",
  upuparrows: "⇈",
  urcorn: "⌝",
  urcorner: "⌝",
  urcrop: "⌎",
  uring: "ů",
  Uring: "Ů",
  urtri: "◹",
  uscr: "𝓊",
  Uscr: "𝒰",
  utdot: "⋰",
  utilde: "ũ",
  Utilde: "Ũ",
  utri: "▵",
  utrif: "▴",
  uuarr: "⇈",
  uuml: "ü",
  Uuml: "Ü",
  uwangle: "⦧",
  vangrt: "⦜",
  varepsilon: "ϵ",
  varkappa: "ϰ",
  varnothing: "∅",
  varphi: "ϕ",
  varpi: "ϖ",
  varpropto: "∝",
  varr: "↕",
  vArr: "⇕",
  varrho: "ϱ",
  varsigma: "ς",
  varsubsetneq: "⊊︀",
  varsubsetneqq: "⫋︀",
  varsupsetneq: "⊋︀",
  varsupsetneqq: "⫌︀",
  vartheta: "ϑ",
  vartriangleleft: "⊲",
  vartriangleright: "⊳",
  vBar: "⫨",
  Vbar: "⫫",
  vBarv: "⫩",
  vcy: "в",
  Vcy: "В",
  vdash: "⊢",
  vDash: "⊨",
  Vdash: "⊩",
  VDash: "⊫",
  Vdashl: "⫦",
  vee: "∨",
  Vee: "⋁",
  veebar: "⊻",
  veeeq: "≚",
  vellip: "⋮",
  verbar: "|",
  Verbar: "‖",
  vert: "|",
  Vert: "‖",
  VerticalBar: "∣",
  VerticalLine: "|",
  VerticalSeparator: "❘",
  VerticalTilde: "≀",
  VeryThinSpace: " ",
  vfr: "𝔳",
  Vfr: "𝔙",
  vltri: "⊲",
  vnsub: "⊂⃒",
  vnsup: "⊃⃒",
  vopf: "𝕧",
  Vopf: "𝕍",
  vprop: "∝",
  vrtri: "⊳",
  vscr: "𝓋",
  Vscr: "𝒱",
  vsubne: "⊊︀",
  vsubnE: "⫋︀",
  vsupne: "⊋︀",
  vsupnE: "⫌︀",
  Vvdash: "⊪",
  vzigzag: "⦚",
  wcirc: "ŵ",
  Wcirc: "Ŵ",
  wedbar: "⩟",
  wedge: "∧",
  Wedge: "⋀",
  wedgeq: "≙",
  weierp: "℘",
  wfr: "𝔴",
  Wfr: "𝔚",
  wopf: "𝕨",
  Wopf: "𝕎",
  wp: "℘",
  wr: "≀",
  wreath: "≀",
  wscr: "𝓌",
  Wscr: "𝒲",
  xcap: "⋂",
  xcirc: "◯",
  xcup: "⋃",
  xdtri: "▽",
  xfr: "𝔵",
  Xfr: "𝔛",
  xharr: "⟷",
  xhArr: "⟺",
  xi: "ξ",
  Xi: "Ξ",
  xlarr: "⟵",
  xlArr: "⟸",
  xmap: "⟼",
  xnis: "⋻",
  xodot: "⨀",
  xopf: "𝕩",
  Xopf: "𝕏",
  xoplus: "⨁",
  xotime: "⨂",
  xrarr: "⟶",
  xrArr: "⟹",
  xscr: "𝓍",
  Xscr: "𝒳",
  xsqcup: "⨆",
  xuplus: "⨄",
  xutri: "△",
  xvee: "⋁",
  xwedge: "⋀",
  yacute: "ý",
  Yacute: "Ý",
  yacy: "я",
  YAcy: "Я",
  ycirc: "ŷ",
  Ycirc: "Ŷ",
  ycy: "ы",
  Ycy: "Ы",
  yen: "¥",
  yfr: "𝔶",
  Yfr: "𝔜",
  yicy: "ї",
  YIcy: "Ї",
  yopf: "𝕪",
  Yopf: "𝕐",
  yscr: "𝓎",
  Yscr: "𝒴",
  yucy: "ю",
  YUcy: "Ю",
  yuml: "ÿ",
  Yuml: "Ÿ",
  zacute: "ź",
  Zacute: "Ź",
  zcaron: "ž",
  Zcaron: "Ž",
  zcy: "з",
  Zcy: "З",
  zdot: "ż",
  Zdot: "Ż",
  zeetrf: "ℨ",
  ZeroWidthSpace: "​",
  zeta: "ζ",
  Zeta: "Ζ",
  zfr: "𝔷",
  Zfr: "ℨ",
  zhcy: "ж",
  ZHcy: "Ж",
  zigrarr: "⇝",
  zopf: "𝕫",
  Zopf: "ℤ",
  zscr: "𝓏",
  Zscr: "𝒵",
  zwj: "‍",
  zwnj: "‌"
}, ww = {
  aacute: "á",
  Aacute: "Á",
  acirc: "â",
  Acirc: "Â",
  acute: "´",
  aelig: "æ",
  AElig: "Æ",
  agrave: "à",
  Agrave: "À",
  amp: "&",
  AMP: "&",
  aring: "å",
  Aring: "Å",
  atilde: "ã",
  Atilde: "Ã",
  auml: "ä",
  Auml: "Ä",
  brvbar: "¦",
  ccedil: "ç",
  Ccedil: "Ç",
  cedil: "¸",
  cent: "¢",
  copy: "©",
  COPY: "©",
  curren: "¤",
  deg: "°",
  divide: "÷",
  eacute: "é",
  Eacute: "É",
  ecirc: "ê",
  Ecirc: "Ê",
  egrave: "è",
  Egrave: "È",
  eth: "ð",
  ETH: "Ð",
  euml: "ë",
  Euml: "Ë",
  frac12: "½",
  frac14: "¼",
  frac34: "¾",
  gt: ">",
  GT: ">",
  iacute: "í",
  Iacute: "Í",
  icirc: "î",
  Icirc: "Î",
  iexcl: "¡",
  igrave: "ì",
  Igrave: "Ì",
  iquest: "¿",
  iuml: "ï",
  Iuml: "Ï",
  laquo: "«",
  lt: "<",
  LT: "<",
  macr: "¯",
  micro: "µ",
  middot: "·",
  nbsp: " ",
  not: "¬",
  ntilde: "ñ",
  Ntilde: "Ñ",
  oacute: "ó",
  Oacute: "Ó",
  ocirc: "ô",
  Ocirc: "Ô",
  ograve: "ò",
  Ograve: "Ò",
  ordf: "ª",
  ordm: "º",
  oslash: "ø",
  Oslash: "Ø",
  otilde: "õ",
  Otilde: "Õ",
  ouml: "ö",
  Ouml: "Ö",
  para: "¶",
  plusmn: "±",
  pound: "£",
  quot: '"',
  QUOT: '"',
  raquo: "»",
  reg: "®",
  REG: "®",
  sect: "§",
  shy: "­",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  szlig: "ß",
  thorn: "þ",
  THORN: "Þ",
  times: "×",
  uacute: "ú",
  Uacute: "Ú",
  ucirc: "û",
  Ucirc: "Û",
  ugrave: "ù",
  Ugrave: "Ù",
  uml: "¨",
  uuml: "ü",
  Uuml: "Ü",
  yacute: "ý",
  Yacute: "Ý",
  yen: "¥",
  yuml: "ÿ"
}, Bp = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
}, Dw = [
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  11,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  64976,
  64977,
  64978,
  64979,
  64980,
  64981,
  64982,
  64983,
  64984,
  64985,
  64986,
  64987,
  64988,
  64989,
  64990,
  64991,
  64992,
  64993,
  64994,
  64995,
  64996,
  64997,
  64998,
  64999,
  65e3,
  65001,
  65002,
  65003,
  65004,
  65005,
  65006,
  65007,
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
], Fp = String.fromCharCode, Iw = function(t, e) {
  let n = -1;
  const r = t.length;
  for (; ++n < r; )
    if (t[n] === e)
      return !0;
  return !1;
};
function Mw(t, e) {
  if (!t)
    return e;
  const n = {};
  let r;
  for (r in e)
    n[r] = cl(t, r) ? t[r] : e[r];
  return n;
}
var Hp = function(t, e) {
  let n = "";
  return t >= 55296 && t <= 57343 || t > 1114111 ? (e && Hn("character reference outside the permissible Unicode range"), "�") : cl(Bp, t) ? (e && Hn("disallowed character reference"), Bp[t]) : (e && Iw(Dw, t) && Hn("disallowed character reference"), t > 65535 && (t -= 65536, n += Fp(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), n += Fp(t), n);
};
function Hn(t) {
  throw new Error(`Parse error: ${t}`);
}
function Lc(t, e) {
  e = Mw(e, Lc.options);
  const n = e.strict;
  return n && _w.test(t) && Hn("malformed character reference"), t.replace(
    kw,
    (r, i, s, o, a, l, u, c, f) => {
      let h, d, m, g, E, T;
      return i ? (E = i, Ow[E]) : s ? (E = s, T = o, T && e.isAttributeValue ? (n && T === "=" && Hn("`&` did not start a character reference"), r) : (n && Hn(
        "named character reference was not terminated by a semicolon"
      ), ww[E] + (T || ""))) : a ? (m = a, d = l, n && !d && Hn("character reference was not terminated by a semicolon"), h = parseInt(m, 10), Hp(h, n)) : u ? (g = u, d = c, n && !d && Hn("character reference was not terminated by a semicolon"), h = parseInt(g, 16), Hp(h, n)) : (n && Hn(
        "named character reference was not terminated by a semicolon"
      ), r);
    }
  );
}
Lc.options = {
  isAttributeValue: !1,
  strict: !1
};
var Nu = (t) => t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;"), Up = (t) => Lc(t);
function Rw(t, e, n, r) {
  if (typeof e == "function")
    return e({
      props: { ...n, children: r },
      attrs: n,
      children: r,
      h: t.h,
      context: t
    });
  {
    let i = !0, s;
    if (e ? e.toLowerCase() === "fragment" ? (s = t.document.createDocumentFragment(), i = !1) : s = t.document.createElement(e) : s = t.document.createElement("div"), n && i) {
      const o = s;
      for (let [a, l] of Object.entries(n)) {
        a = a.toString();
        const u = a.toLowerCase();
        u === "classname" ? o.className = l : u === "on" ? Object.entries(l).forEach(([c, f]) => {
          o.setAttribute(`on${c}`, String(f));
        }) : l !== !1 && l != null && (l === !0 ? o.setAttribute(a, a) : o.setAttribute(a, l.toString()));
      }
    }
    if (r)
      for (const o of r) {
        const a = Array.isArray(o) ? [...o] : [o];
        for (const l of a)
          l && l !== !1 && l != null && (typeof l != "object" ? s.appendChild(
            t.document.createTextNode(l.toString())
          ) : s.appendChild(l));
      }
    return s;
  }
}
function O2(t, e, ...n) {
  return typeof t == "object" && (t = "fragment", n = t.children, e = t.attrs), Array.isArray(e) ? (n = [e], e = {}) : e ? e.attrs && (e = { ...e.attrs, ...e }, delete e.attrs) : e = {}, {
    tag: t,
    attrs: e,
    children: typeof n[0] == "string" ? n : n.flat(1 / 0)
  };
}
function vw(t) {
  return t.h = function(n, r, ...i) {
    const { tag: s, attrs: o, children: a } = O2(n, r, i);
    return Rw(t, s, o, a);
  }, t.h;
}
var w2 = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
  "command"
];
function D2(t, e, n = {}, r) {
  const i = !(typeof r == "string" && r === "" || Array.isArray(r) && (r.length === 0 || r.length === 1 && r[0] === "") || r == null), s = [];
  if (e = e.replace(/__/g, ":"), e !== "noop" && e !== "") {
    e !== "cdata" ? s.push(`<${e}`) : s.push("<![CDATA[");
    for (let o in n)
      if (o && cl(n, o)) {
        const a = n[o];
        if (o === "html")
          continue;
        o.toLowerCase() === "classname" && (o = "class"), o = o.replace(/__/g, ":"), a === !0 ? s.push(` ${o}`) : o === "style" && typeof a == "object" ? s.push(
          ` ${o}="${Object.keys(a).filter((l) => a[l] != null).map((l) => {
            let u = a[l];
            return u = typeof u == "number" ? `${u}px` : u, `${l.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${u}`;
          }).join(";")}"`
        ) : a !== !1 && a != null && s.push(` ${o}="${Nu(a.toString())}"`);
      }
    if (e !== "cdata") {
      if (t && !i)
        return s.push(" />"), s.join("");
      s.push(">");
    }
    if (!t && w2.includes(e))
      return s.join("");
  }
  if (i) {
    if (typeof r == "string")
      s.push(r);
    else if (r && r.length > 0) {
      for (let o of r)
        if (o != null && o !== !1) {
          Array.isArray(o) || (o = [o]);
          for (const a of o)
            a.startsWith("<") && a.endsWith(">") || e === "script" || e === "style" ? s.push(a) : s.push(Nu(a.toString()));
        }
    }
  }
  return n.html && s.push(n.html), e !== "noop" && e !== "" && (e !== "cdata" ? s.push(`</${e}>`) : s.push("]]>")), s.join("");
}
function ll(t, e, ...n) {
  const { tag: r, attrs: i, children: s } = O2(t, e, n);
  return D2(!1, r, i, s);
}
var Da = D2.bind(null, !1);
ll.firstLine = "<!DOCTYPE html>";
ll.html = !0;
var qp = {};
function Lw(t) {
  let e = qp[t];
  return e == null && (e = Nw(t), qp[t] = e), e;
}
function Pw(t, e, { debug: n = !1 } = {}) {
  for (const r of Lw(t)) {
    const i = (s, o) => {
      var l, u, c;
      let a = !1;
      for (const f of o) {
        const { type: h, name: d, action: m, value: g, ignoreCase: E = !0, data: T } = f;
        if (h === "attribute")
          m === "equals" ? a = s.getAttribute(d) === g : m === "start" ? a = !!((l = s.getAttribute(d)) != null && l.startsWith(g)) : m === "end" ? a = !!((u = s.getAttribute(d)) != null && u.endsWith(g)) : m === "element" ? d === "class" ? a = s.classList.contains(g) : a = !!((c = s.getAttribute(d)) != null && c.includes(g)) : m === "exists" ? a = s.hasAttribute(d) : console.warn("Unknown CSS selector action", m);
        else if (h === "tag")
          a = s.tagName === d.toUpperCase();
        else if (h === "universal")
          a = !0;
        else if (h === "pseudo") {
          if (d === "not") {
            let k = !0;
            T.forEach((_) => {
              i(s, _) || (k = !1);
            }), a = !k;
          }
        } else
          console.warn("Unknown CSS selector type", h, t, o);
        if (!a)
          break;
      }
      return a;
    };
    if (i(e, r))
      return !0;
  }
  return !1;
}
var Bw = Symbol.for("nodejs.util.inspect.custom"), zp = { fontWeight: "bold" }, $p = { fontStyle: "italic" }, Gp = { backgroundColor: "rgb(255, 250, 165)" }, jp = { textDecorations: "underline" }, B1 = { textDecorations: "line-through" }, Fw = {
  b: zp,
  strong: zp,
  em: $p,
  i: $p,
  mark: Gp,
  u: jp,
  a: jp,
  s: B1,
  del: B1,
  ins: Gp,
  strike: B1
  // 'code': C,
  // 'tt': C
}, Hw = (t) => t.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (e, n) => n.toUpperCase()), Go = class {
  constructor() {
    this.append = this.appendChild, this._parentNode = null, this._childNodes = [];
  }
  get nodeType() {
    return console.error("Subclasses should define nodeType!"), 0;
  }
  get nodeName() {
    return console.error("Subclasses should define nodeName!"), "";
  }
  get nodeValue() {
    return null;
  }
  cloneNode(t = !1) {
    const e = new this.constructor();
    return t && (e._childNodes = this._childNodes.map((n) => n.cloneNode(!0)), e._fixChildNodesParent()), e;
  }
  _fixChildNodesParent() {
    this._childNodes.forEach((t) => t._parentNode = this);
  }
  insertBefore(t, e) {
    if (t !== e) {
      let n = e ? this._childNodes.indexOf(e) : 0;
      n < 0 && (n = 0), this._childNodes.splice(n, 0, t), this._fixChildNodesParent();
    }
  }
  appendChild(t) {
    if (t != null) {
      if (t === this) {
        console.warn("Cannot appendChild to self");
        return;
      }
      if (t instanceof Bc && console.warn("No defined how to append a document to a node!", t), t instanceof ul)
        for (const e of [...t._childNodes])
          this.appendChild(e);
      else if (Array.isArray(t))
        for (const e of [...t])
          this.appendChild(e);
      else if (t instanceof Go)
        t.remove(), this._childNodes.push(t);
      else
        try {
          const e = typeof t == "string" ? t : JSON.stringify(t, null, 2);
          this._childNodes.push(new _i(e));
        } catch (e) {
          console.error(
            `The data ${t} to be added to ${this.render()} is problematic: ${e}`
          );
        }
      this._fixChildNodesParent();
    }
  }
  removeChild(t) {
    const e = this._childNodes.indexOf(t);
    e >= 0 && (t._parentNode = null, this._childNodes.splice(e, 1), this._fixChildNodesParent());
  }
  remove() {
    var t;
    return (t = this == null ? void 0 : this.parentNode) == null || t.removeChild(this), this;
  }
  replaceChildren(...t) {
    this._childNodes = t.map(
      (e) => typeof e == "string" ? new _i(e) : e.remove()
    ), this._fixChildNodesParent();
  }
  replaceWith(...t) {
    const e = this._parentNode;
    if (e) {
      const n = this._indexInParent();
      n >= 0 && (t = t.map(
        (r) => typeof r == "string" ? new _i(r) : r.remove()
      ), e._childNodes.splice(n, 1, ...t), this._parentNode = null, e._fixChildNodesParent());
    }
  }
  _indexInParent() {
    return this._parentNode ? this._parentNode.childNodes.indexOf(this) : -1;
  }
  get parentNode() {
    return this._parentNode;
  }
  get childNodes() {
    return this._childNodes || [];
  }
  get children() {
    return this._childNodes || [];
  }
  get firstChild() {
    return this._childNodes[0];
  }
  get lastChild() {
    return this._childNodes[this._childNodes.length - 1];
  }
  get nextSibling() {
    const t = this._indexInParent();
    return t != null && this.parentNode.childNodes[t + 1] || null;
  }
  get previousSibling() {
    const t = this._indexInParent();
    return t > 0 && this.parentNode.childNodes[t - 1] || null;
  }
  flatten() {
    const t = [];
    this instanceof rn && t.push(this);
    for (const e of this._childNodes)
      t.push(...e.flatten());
    return t;
  }
  flattenNodes() {
    const t = [];
    t.push(this);
    for (const e of this._childNodes)
      t.push(...e.flattenNodes());
    return t;
  }
  render() {
    return "";
  }
  get textContent() {
    return this._childNodes.map((t) => t.textContent).join("");
  }
  set textContent(t) {
    this._childNodes = [], t && this.appendChild(new _i(t.toString()));
  }
  contains(t) {
    return t === this ? !0 : this._childNodes.some((e) => e.contains(t));
  }
  get ownerDocument() {
    var t;
    return this.nodeType === Go.DOCUMENT_NODE || this.nodeType === Go.DOCUMENT_FRAGMENT_NODE ? this : (t = this == null ? void 0 : this._parentNode) == null ? void 0 : t.ownerDocument;
  }
  toString() {
    return `${this.nodeName}`;
  }
  [Bw]() {
    return `${this.constructor.name} "${this.render()}"`;
  }
}, ct = Go;
ct.ELEMENT_NODE = 1;
ct.TEXT_NODE = 3;
ct.CDATA_SECTION_NODE = 4;
ct.PROCESSING_INSTRUCTION_NODE = 7;
ct.COMMENT_NODE = 8;
ct.DOCUMENT_NODE = 9;
ct.DOCUMENT_TYPE_NODE = 10;
ct.DOCUMENT_FRAGMENT_NODE = 11;
var _i = class extends ct {
  constructor(t = "") {
    super(), this._text = t;
  }
  get nodeType() {
    return ct.TEXT_NODE;
  }
  get nodeName() {
    return "#text";
  }
  get nodeValue() {
    return this._text || "";
  }
  get textContent() {
    return this.nodeValue;
  }
  render() {
    var e;
    const t = (e = this.parentNode) == null ? void 0 : e.tagName;
    return t === "SCRIPT" || t === "STYLE" ? this._text : Nu(this._text);
  }
  cloneNode(t = !1) {
    const e = super.cloneNode(t);
    return e._text = this._text, e;
  }
}, I2 = class extends ct {
  getElementById(t) {
    return this.flatten().find((e) => e._attributes.id === t);
  }
  getElementsByClassName(t) {
    return this.flatten().filter((e) => e.classList.contains(t));
  }
  matches(t) {
    return Pw(t, this);
  }
  querySelectorAll(t) {
    return this.flatten().filter((e) => e.matches(t));
  }
  querySelector(t) {
    return this.flatten().find((e) => e.matches(t));
  }
  //
  parent(t) {
    var e;
    return this.matches(t) ? this : this.parentNode == null ? null : (e = this.parentNode) == null ? void 0 : e.parent(t);
  }
  handle(t, e) {
    let n = 0;
    for (const r of this.querySelectorAll(t))
      e(r, n++);
  }
}, rn = class extends I2 {
  constructor(t = "div", e = {}) {
    super(), this._originalTagName = t, this._nodeName = (t || "").toUpperCase(), this._attributes = e || {}, this._styles = null;
  }
  get nodeType() {
    return ct.ELEMENT_NODE;
  }
  get nodeName() {
    return this._nodeName;
  }
  cloneNode(t = !1) {
    const e = super.cloneNode(t);
    return e._originalTagName = this._originalTagName, e._nodeName = this._nodeName, e._attributes = Object.assign({}, this._attributes), e;
  }
  get attributes() {
    return this._attributes;
  }
  _findAttributeName(t) {
    const e = t.toLowerCase();
    return Object.keys(this._attributes).find(
      (n) => e === n.toLowerCase()
    ) || null;
  }
  setAttribute(t, e) {
    this.removeAttribute(t), this._attributes[t] = e, this._styles = null;
  }
  getAttribute(t) {
    const e = this._findAttributeName(t);
    return e ? this._attributes[e] : null;
  }
  removeAttribute(t) {
    this._findAttributeName(String(t)) && delete this._attributes[t];
  }
  hasAttribute(t) {
    const e = this._findAttributeName(t);
    return e ? this._attributes[e] != null : !1;
  }
  get style() {
    if (this._styles == null) {
      const t = Object.assign({}, Fw[this.tagName.toLowerCase()] || {}), e = this.getAttribute("style");
      if (e) {
        let n;
        const r = /\s*([\w-]+)\s*:\s*([^;]+)/g;
        for (; n = r.exec(e); ) {
          const i = n[1], s = n[2].trim();
          t[i] = s, t[Hw(i)] = s;
        }
      }
      this._styles = t;
    }
    return this._styles;
  }
  get tagName() {
    return this._nodeName;
  }
  get id() {
    return this._attributes.id || null;
  }
  set id(t) {
    t == null ? delete this._attributes.id : this._attributes.id = t;
  }
  get src() {
    return this._attributes.src;
  }
  set src(t) {
    t == null ? delete this._attributes.src : this._attributes.src = t;
  }
  //
  getElementsByTagName(t) {
    t = t.toUpperCase();
    const e = this.flatten();
    return t !== "*" ? e.filter((n) => n.tagName === t) : e;
  }
  // html
  setInnerHTML(t) {
  }
  get innerHTML() {
    return this._childNodes.map((t) => t.render(ll)).join("");
  }
  set innerHTML(t) {
    this.setInnerHTML(t);
  }
  get outerHTML() {
    return this.render(Da);
  }
  // class
  get className() {
    return this._attributes.class || "";
  }
  set className(t) {
    Array.isArray(t) ? t = t.filter((e) => !!e).join(" ") : typeof t == "object" && (t = Object.entries(t).filter(([e, n]) => !!n).map(([e, n]) => e).join(" ")), this._attributes.class = t;
  }
  get classList() {
    const t = this, e = (this.className || "").trim().split(/\s+/g) || [];
    return {
      contains(n) {
        return e.includes(n);
      },
      add(n) {
        e.includes(n) || (e.push(n), t.className = e);
      },
      remove(n) {
        const r = e.indexOf(n);
        r >= 0 && (e.splice(r, 1), t.className = e);
      }
    };
  }
  //
  render(t = Da) {
    return t(
      this._originalTagName || this.tagName,
      this.attributes,
      this._childNodes.map((e) => e.render(t)).join("")
      // children:string is not escaped again
    );
  }
}, Pc = class extends ct {
  get nodeName() {
    return super.nodeName;
  }
  get nodeValue() {
    return super.nodeValue;
  }
  get nodeType() {
    return Pc.DOCUMENT_TYPE_NODE;
  }
  render() {
    return "<!DOCTYPE html>";
  }
}, ul = class extends I2 {
  get nodeType() {
    return ct.DOCUMENT_FRAGMENT_NODE;
  }
  get nodeName() {
    return "#document-fragment";
  }
  render(t = Da) {
    return this._childNodes.map((e) => e.render(t) || []).join("");
  }
  get innerHTML() {
    return this._childNodes.map((t) => t.render(ll)).join("");
  }
  createElement(t, e = {}) {
    return new rn(t, e);
  }
  createDocumentFragment() {
    return new ul();
  }
  createTextNode(t) {
    return new _i(t);
  }
}, Bc = class extends ul {
  get nodeType() {
    return ct.DOCUMENT_NODE;
  }
  get nodeName() {
    return "#document";
  }
  get documentElement() {
    return this.firstChild;
  }
  render(t = Da) {
    let e = super.render(t);
    return this.docType && (e = this.docType.render() + e), e;
  }
}, M2 = class extends Bc {
  constructor(t = !1) {
    if (super(), this.docType = new Pc(), !t) {
      const e = new rn("html"), n = new rn("body"), r = new rn("head"), i = new rn("title");
      e.appendChild(r), r.appendChild(i), e.appendChild(n), this.appendChild(e);
    }
  }
  get body() {
    let t = this.querySelector("body");
    if (!t) {
      let e = this.querySelector("html");
      e || (e = new rn("html"), this.appendChild(e)), t = new rn("body"), e.appendChild(e);
    }
    return t;
  }
  get title() {
    var t;
    return ((t = this.querySelector("title")) == null ? void 0 : t.textContent) || "";
  }
  set title(t) {
    const e = this.querySelector("title");
    e && (e.textContent = t);
  }
  get head() {
    let t = this.querySelector("head");
    if (!t) {
      let e = this.querySelector("html");
      e || (e = new rn("html"), this.appendChild(e)), t = new rn("head"), e.insertBefore(e);
    }
    return t;
  }
};
function Uw() {
  return new Bc();
}
function qw() {
  return new M2();
}
var R2 = Uw();
vw({ document: R2 });
var zw = {}, $w = zw.hasOwnProperty;
function cl(t, e) {
  return $w.call(t, e);
}
/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var Gw = /([^=\s]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^>\s]+))?/gm, jw = /^<\/([^>\s]+)[^>]*>/m, Vw = /^<([^>\s\/]+)((\s+[^=>\s]+(\s*=\s*(("[^"]*")|('[^']*')|[^>\s]+))?)*)\s*\/?\s*>/m, Kw = /\s*\/\s*>\s*$/m, Ww = class {
  constructor(t = {}) {
    this.attrRe = Gw, this.endTagRe = jw, this.startTagRe = Vw, this.defaults = { ignoreWhitespaceText: !1 }, t.scanner && (this.scanner = t.scanner), this.options = Object.assign({}, this.defaults, t);
  }
  parse(t) {
    let e = !1, n, r, i;
    for (; t.length; )
      t.substring(0, 4) === "<!--" ? (n = t.indexOf("-->"), n !== -1 ? (this.scanner.comment(t.substring(4, n)), t = t.substring(n + 3), e = !1) : e = !0) : t.substring(0, 2) === "</" ? (r = this.endTagRe.exec(t), r ? (t = RegExp.rightContext, e = !1, this.parseEndTag(RegExp.lastMatch, r[1])) : e = !0) : t.charAt(0) === "<" && (r = this.startTagRe.exec(t), r ? (t = RegExp.rightContext, e = !1, this.parseStartTag(RegExp.lastMatch, r[1], r)) : e = !0), e && (n = t.indexOf("<"), n === 0 && (n = t.substring(1).indexOf("<")), n === -1 ? (i = t, t = "") : (i = t.substring(0, n), t = t.substring(n)), (!this.options.ignoreWhitespaceText || !/^\s*$/.test(i)) && this.scanner.characters(i)), e = !0, r = null;
  }
  parseStartTag(t, e, n) {
    const r = Kw.test(t);
    let i = n[2];
    r && (i = i.replace(/\s*\/\s*$/, ""));
    const s = this.parseAttributes(e, i);
    this.scanner.startElement(e, s, r, n[0]);
  }
  parseEndTag(t, e) {
    this.scanner.endElement(e);
  }
  parseAttributes(t, e) {
    const n = {};
    return e.replace(this.attrRe, (...r) => {
      const [i, s, o, a, l, u, c, f] = r;
      n[s] = f ?? u ?? a ?? !0;
    }), n;
  }
};
function v2(t) {
  if (typeof t != "string")
    throw console.error("parseHTML requires string, found", t), new Error("parseHTML requires string");
  const e = t.indexOf("<!") === 0 ? new M2(!0) : new ul(), n = [e];
  return new Ww({
    // the for methods must be implemented yourself
    scanner: {
      startElement(i, s, o) {
        if (i.toLowerCase() === "!doctype") {
          e.docType = new Pc();
          return;
        }
        for (const u in s)
          if (cl(s, u)) {
            const c = s[u];
            typeof c == "string" && (s[u] = Up(c));
          }
        const l = n[n.length - 1];
        if (l) {
          const u = R2.createElement(i, s);
          l.appendChild(u), w2.includes(i.toLowerCase()) || o || n.push(u);
        }
      },
      endElement(i) {
        n.pop();
      },
      characters(i) {
        var o;
        i = Up(i);
        const s = n[n.length - 1];
        ((o = s == null ? void 0 : s.lastChild) == null ? void 0 : o.nodeType) === ct.TEXT_NODE ? s.lastChild._text += i : s && s.appendChild(new _i(i));
      },
      comment(i) {
      }
    }
  }).parse(t), e;
}
rn.prototype.setInnerHTML = function(t) {
  const e = v2(t);
  this._childNodes = e._childNodes, this._fixChildNodesParent();
};
const L2 = (t) => {
  const e = e8(t);
  return (n) => {
    const r = v2(n), i = Vr.fromSchema(e).parse(r).toJSON(), s = fr.fromJSON(e, i);
    return an.fromSchema(e).serializeFragment(
      s.content,
      {
        document: qw()
      }
    ).render();
  };
}, mD = (t) => {
  const e = Qm({});
  return L2(e)(t);
}, gD = (t) => {
  const e = Jm({});
  return L2(e)(t);
};
export {
  Zw as ArticleEditor,
  eD as CommentEditor,
  hD as html2md,
  Qm as makeArticleEditorExtensions,
  Jm as makeCommentEditorExtensions,
  L2 as makeNormalizer,
  dD as md2html,
  mD as normalizeArticleHTML,
  gD as normalizeCommentHTML,
  pD as sanitizeHTML
};
