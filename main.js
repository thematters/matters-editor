import Mt, { useState as pl, useEffect as Ec, createContext as _4, useContext as O4 } from "react";
import w4, { flushSync as v4 } from "react-dom";
function Ze(t) {
  this.content = t;
}
Ze.prototype = {
  constructor: Ze,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), s = r.content.slice();
    return i == -1 ? s.push(n || t, e) : (s[i + 1] = e, n && (s[i] = n)), new Ze(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1)
      return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Ze(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Ze([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Ze(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(t);
    return i.splice(s == -1 ? i.length : s, 0, e, n), new Ze(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Ze.from(t), t.size ? new Ze(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Ze.from(t), t.size ? new Ze(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Ze.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Ze.from = function(t) {
  if (t instanceof Ze)
    return t;
  var e = [];
  if (t)
    for (var n in t)
      e.push(n, t[n]);
  return new Ze(e);
};
function h0(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), s = e.child(r);
    if (i == s) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return n;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (i.content.size || s.content.size) {
      let o = h0(i.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += i.nodeSize;
  }
}
function p0(t, e, n, r) {
  for (let i = t.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: n, b: r };
    let o = t.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: r };
    if (o.isText && o.text != a.text) {
      let u = 0, c = Math.min(o.text.length, a.text.length);
      for (; u < c && o.text[o.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (o.content.size || a.content.size) {
      let u = p0(o.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= l, r -= l;
  }
}
class B {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], u = a + l.nodeSize;
      if (u > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, n - c), r, i + c);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      a.isText ? (s += a.text.slice(Math.max(e, l) - l, n - l), o = !r) : a.isLeaf ? (i ? s += typeof i == "function" ? i(a) : i : a.type.spec.leafText && (s += a.type.spec.leafText(a)), o = !r) : !o && a.isBlock && (s += r, o = !0);
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new B(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new B(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? B.empty : e == 0 && n == this.content.length ? this : new B(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new B(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new B([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new B(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return h0(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return p0(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return Io(0, e);
    if (e == this.size)
      return Io(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let s = this.child(r), o = i + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? Io(r + 1, o) : Io(r, i);
      i = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return B.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new B(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return B.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new B(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return B.empty;
    if (e instanceof B)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new B([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
B.empty = new B([], 0);
const Zl = { index: 0, offset: 0 };
function Io(t, e) {
  return Zl.index = t, Zl.offset = e, Zl;
}
function ka(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!ka(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !ka(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let Se = class Nu {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        n || (n = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(s);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && ka(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    return r.create(n.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Nu.none;
    if (e instanceof Nu)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
Se.none = [];
class _a extends Error {
}
class G {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = g0(this.content, e + this.openStart, n);
    return r && new G(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new G(m0(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return G.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new G(B.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new G(e, r, i);
  }
}
G.empty = new G(B.empty, 0, 0);
function m0(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: o, offset: a } = t.findIndex(n);
  if (i == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, s.copy(m0(s.content, e - i - 1, n - i - 1)));
}
function g0(t, e, n, r) {
  let { index: i, offset: s } = t.findIndex(e), o = t.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = g0(o.content, e - s - 1, n);
  return a && t.replaceChild(i, o.copy(a));
}
function D4(t, e, n) {
  if (n.openStart > t.depth)
    throw new _a("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new _a("Inconsistent open depths");
  return T0(t, e, n, 0);
}
function T0(t, e, n, r) {
  let i = t.index(r), s = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let o = T0(t, e, n, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let o = t.parent, a = o.content;
      return ri(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = M4(n, t);
      return ri(s, y0(t, o, a, e, r));
    }
  else
    return ri(s, Oa(t, e, r));
}
function E0(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new _a("Cannot join " + e.type.name + " onto " + t.type.name);
}
function ku(t, e, n) {
  let r = t.node(n);
  return E0(r, e.node(n)), r;
}
function ni(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function Us(t, e, n, r) {
  let i = (e || t).node(n), s = 0, o = e ? e.index(n) : i.childCount;
  t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (ni(t.nodeAfter, r), s++));
  for (let a = s; a < o; a++)
    ni(i.child(a), r);
  e && e.depth == n && e.textOffset && ni(e.nodeBefore, r);
}
function ri(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function y0(t, e, n, r, i) {
  let s = t.depth > i && ku(t, e, i + 1), o = r.depth > i && ku(n, r, i + 1), a = [];
  return Us(null, t, i, a), s && o && e.index(i) == n.index(i) ? (E0(s, o), ni(ri(s, y0(t, e, n, r, i + 1)), a)) : (s && ni(ri(s, Oa(t, e, i + 1)), a), Us(e, n, i, a), o && ni(ri(o, Oa(n, r, i + 1)), a)), Us(r, null, i, a), new B(a);
}
function Oa(t, e, n) {
  let r = [];
  if (Us(null, t, n, r), t.depth > n) {
    let i = ku(t, e, n + 1);
    ni(ri(i, Oa(t, e, n + 1)), r);
  }
  return Us(e, null, n, r), new B(r);
}
function M4(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let s = n - 1; s >= 0; s--)
    i = e.node(s).copy(B.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class so {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Se.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new wa(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, s = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), u = s - l;
      if (r.push(o, a, i + l), !u || (o = o.child(a), o.isText))
        break;
      s = u - 1, i += l + 1;
    }
    return new so(n, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    for (let i = 0; i < e1.length; i++) {
      let s = e1[i];
      if (s.pos == n && s.doc == e)
        return s;
    }
    let r = e1[t1] = so.resolve(e, n);
    return t1 = (t1 + 1) % I4, r;
  }
}
let e1 = [], t1 = 0, I4 = 12;
class wa {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const R4 = /* @__PURE__ */ Object.create(null);
let Ar = class _u {
  /**
  @internal
  */
  constructor(e, n, r, i = Se.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || B.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  parent-relative position, its parent node, and its child index.
  When the callback returns false for a given node, that node's
  children will not be recursed over. The last parameter can be
  used to specify a starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && ka(this.attrs, n || e.defaultAttrs || R4) && Se.sameSet(this.marks, r || Se.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new _u(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new _u(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return G.empty;
    let i = this.resolve(e), s = this.resolve(n), o = r ? 0 : i.sharedDepth(n), a = i.start(o), u = i.node(o).content.cut(i.pos - a, s.pos - a);
    return new G(u, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return D4(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return so.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return so.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), A0(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = B.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < s; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, n);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let e = Se.none;
    for (let n = 0; n < this.marks.length; n++)
      e = this.marks[n].addToSet(e);
    if (!Se.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r = null;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = B.fromJSON(e, n.content);
    return e.nodeType(n.type).create(n.attrs, i, r);
  }
};
Ar.prototype.text = void 0;
class va extends Ar {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : A0(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new va(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new va(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function A0(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class ai {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new L4(e, n);
    if (r.next == null)
      return ai.empty;
    let i = b0(r);
    r.next && r.err("Unexpected trailing text");
    let s = z4(q4(i));
    return $4(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let s = n; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function s(o, a) {
      let l = o.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return B.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < o.next.length; u++) {
        let { type: c, next: f } = o.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(f) == -1) {
          i.push(f);
          let d = s(f, a.concat(c));
          if (d)
            return d;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = i; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
ai.empty = new ai(!0);
class L4 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function b0(t) {
  let e = [];
  do
    e.push(P4(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function P4(t) {
  let e = [];
  do
    e.push(B4(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function B4(t) {
  let e = U4(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = F4(t, e);
    else
      break;
  return e;
}
function qf(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function F4(t, e) {
  let n = qf(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = qf(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function H4(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let s in n) {
    let o = n[s];
    o.groups.indexOf(e) > -1 && i.push(o);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function U4(t) {
  if (t.eat("(")) {
    let e = b0(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = H4(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function q4(t) {
  let e = [[]];
  return i(s(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(o, a, l) {
    let u = { term: l, to: a };
    return e[o].push(u), u;
  }
  function i(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, u) => l.concat(s(u, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let u = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (o.type == "star") {
      let l = n();
      return r(a, l), i(s(o.expr, l), l), [r(l)];
    } else if (o.type == "plus") {
      let l = n();
      return i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)];
    } else {
      if (o.type == "opt")
        return [r(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let u = 0; u < o.min; u++) {
          let c = n();
          i(s(o.expr, l), c), l = c;
        }
        if (o.max == -1)
          i(s(o.expr, l), l);
        else
          for (let u = o.min; u < o.max; u++) {
            let c = n();
            r(l, c), i(s(o.expr, l), c), l = c;
          }
        return [r(l)];
      } else {
        if (o.type == "name")
          return [r(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function C0(t, e) {
  return e - t;
}
function zf(t, e) {
  let n = [];
  return r(e), n.sort(C0);
  function r(i) {
    let s = t[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    n.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function z4(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(zf(t, 0));
  function n(r) {
    let i = [];
    r.forEach((o) => {
      t[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let u;
        for (let c = 0; c < i.length; c++)
          i[c][0] == a && (u = i[c][1]);
        zf(t, l).forEach((c) => {
          u || i.push([a, u = []]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let s = e[r.join(",")] = new ai(r.indexOf(t.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(C0);
      s.next.push({ type: i[o][0], next: e[a.join(",")] || n(a) });
    }
    return s;
  }
}
function $4(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], s = !i.validEnd, o = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: u } = i.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), r.indexOf(u) == -1 && r.push(u);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function x0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function S0(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let s = t[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function N0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let n in t)
      e[n] = new V4(t[n]);
  return e;
}
let $f = class k0 {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = N0(r.attrs), this.defaultAttrs = x0(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ai.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : S0(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Ar(this, this.computeAttrs(e), B.from(n), Se.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = B.from(n), this.checkContent(n), new Ar(this, this.computeAttrs(e), n, Se.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = B.from(n), n.size) {
      let o = this.contentMatch.fillBefore(n);
      if (!o)
        return null;
      n = o.append(n);
    }
    let i = this.contentMatch.matchFragment(n), s = i && i.fillBefore(B.empty, !0);
    return s ? new Ar(this, e, n.append(s), Se.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : Se.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new k0(s, n, o));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
class V4 {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class ml {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = N0(i.attrs), this.excluded = null;
    let s = x0(this.attrs);
    this.instance = s ? new Se(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Se(this, S0(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new ml(s, i++, n, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
let G4 = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = Ze.from(e.nodes), n.marks = Ze.from(e.marks || {}), this.nodes = $f.compile(this.spec.nodes, this), this.marks = ml.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", a = s.spec.marks;
      s.contentMatch = r[o] || (r[o] = ai.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.markSet = a == "_" ? null : a ? Vf(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : Vf(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof $f) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new va(r, r.defaultAttrs, e, Se.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Ar.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Se.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
};
function Vf(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = t.marks[i], o = s;
    if (s)
      n.push(s);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
class li {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [], n.forEach((r) => {
      r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new jf(this, n, !1);
    return r.addAll(e, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new jf(this, n, !0);
    return r.addAll(e, n.from, n.to), G.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (W4(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      n.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Kf(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = Kf(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new li(e, li.schemaRules(e)));
  }
}
const _0 = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, j4 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, O0 = { ol: !0, ul: !0 }, Da = 1, Ma = 2, qs = 4;
function Gf(t, e, n) {
  return e != null ? (e ? Da : 0) | (e === "full" ? Ma : 0) : t && t.whitespace == "pre" ? Da | Ma : n & ~qs;
}
class Ro {
  constructor(e, n, r, i, s, o, a) {
    this.type = e, this.attrs = n, this.marks = r, this.pendingMarks = i, this.solid = s, this.options = a, this.content = [], this.activeMarks = Se.none, this.stashMarks = [], this.match = o || (a & qs ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(B.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Da)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let n = B.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(B.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  popFromStashMark(e) {
    for (let n = this.stashMarks.length - 1; n >= 0; n--)
      if (e.eq(this.stashMarks[n]))
        return this.stashMarks.splice(n, 1)[0];
  }
  applyPending(e) {
    for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
      let i = r[n];
      (this.type ? this.type.allowsMarkType(i.type) : Q4(i.type, e)) && !i.isInSet(this.activeMarks) && (this.activeMarks = i.addToSet(this.activeMarks), this.pendingMarks = i.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !_0.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class jf {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0;
    let i = n.topNode, s, o = Gf(null, n.preserveWhitespace, 0) | (r ? qs : 0);
    i ? s = new Ro(i.type, i.attrs, Se.none, Se.none, !0, n.topMatch || i.type.contentMatch, o) : r ? s = new Ro(null, null, Se.none, Se.none, !0, null, o) : s = new Ro(e.schema.topNodeType, null, Se.none, Se.none, !0, null, o), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    if (e.nodeType == 3)
      this.addTextNode(e);
    else if (e.nodeType == 1) {
      let n = e.getAttribute("style");
      if (!n)
        this.addElement(e);
      else {
        let r = this.readStyles(Y4(n));
        if (!r)
          return;
        let [i, s] = r, o = this.top;
        for (let a = 0; a < s.length; a++)
          this.removePendingMark(s[a], o);
        for (let a = 0; a < i.length; a++)
          this.addPendingMark(i[a]);
        this.addElement(e);
        for (let a = 0; a < i.length; a++)
          this.removePendingMark(i[a], o);
        for (let a = 0; a < s.length; a++)
          this.addPendingMark(s[a]);
      }
    }
  }
  addTextNode(e) {
    let n = e.nodeValue, r = this.top;
    if (r.options & Ma || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (r.options & Da)
        r.options & Ma ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let i = r.content[r.content.length - 1], s = e.previousSibling;
        (!i || s && s.nodeName == "BR" || i.isText && /[ \t\r\n\u000c]$/.test(i.text)) && (n = n.slice(1));
      }
      n && this.insertNode(this.parser.schema.text(n)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n) {
    let r = e.nodeName.toLowerCase(), i;
    O0.hasOwnProperty(r) && this.parser.normalizeLists && K4(e);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, n));
    if (s ? s.ignore : j4.hasOwnProperty(r))
      this.findInside(e), this.ignoreFallback(e);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
      let o, a = this.top, l = this.needsBlock;
      if (_0.hasOwnProperty(r))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), o = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      this.addAll(e), o && this.sync(a), this.needsBlock = l;
    } else
      this.addElementByRule(e, s, s.consuming === !1 ? i : void 0);
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let n = Se.none, r = Se.none;
    e:
      for (let i = 0; i < e.length; i += 2)
        for (let s = void 0; ; ) {
          let o = this.parser.matchStyle(e[i], e[i + 1], this, s);
          if (!o)
            continue e;
          if (o.ignore)
            return null;
          if (o.clearMark ? this.top.pendingMarks.forEach((a) => {
            o.clearMark(a) && (r = a.addToSet(r));
          }) : n = this.parser.schema.marks[o.mark].create(o.attrs).addToSet(n), o.consuming === !1)
            s = o;
          else
            break;
        }
    return [n, r];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r) {
    let i, s, o;
    n.node ? (s = this.parser.schema.nodes[n.node], s.isLeaf ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e) : i = this.enter(s, n.attrs || null, n.preserveWhitespace)) : (o = this.parser.schema.marks[n.mark].create(n.attrs), this.addPendingMark(o));
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l);
    }
    i && this.sync(a) && this.open--, o && this.removePendingMark(o, a);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r) {
    let i = n || 0;
    for (let s = n ? e.childNodes[n] : e.firstChild, o = r == null ? null : e.childNodes[r]; s != o; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let n, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], o = s.findWrapping(e);
      if (o && (!n || n.length > o.length) && (n = o, r = s, !o.length) || s.solid)
        break;
    }
    if (!n)
      return !1;
    this.sync(r);
    for (let i = 0; i < n.length; i++)
      this.enterInner(n[i], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let n = this.textblockFromContext();
      n && this.enterInner(n);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let n = this.top;
      n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type));
      let r = n.activeMarks;
      for (let i = 0; i < e.marks.length; i++)
        (!n.type || n.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
      return n.content.push(e.mark(r)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r) {
    let i = this.findPlace(e.create(n));
    return i && this.enterInner(e, n, !0, r), i;
  }
  // Open a node of the given type
  enterInner(e, n = null, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.applyPending(e), s.match = s.match && s.match.matchType(e);
    let o = Gf(e, i, s.options);
    s.options & qs && s.content.length == 0 && (o |= qs), this.nodes.push(new Ro(e, n, s.activeMarks, s.pendingMarks, r, null, o)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
          if (!c || c.name != u && c.groups.indexOf(u) == -1)
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
  addPendingMark(e) {
    let n = J4(e, this.top.pendingMarks);
    n && this.top.stashMarks.push(n), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, n) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r];
      if (i.pendingMarks.lastIndexOf(e) > -1)
        i.pendingMarks = e.removeFromSet(i.pendingMarks);
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks);
        let o = i.popFromStashMark(e);
        o && i.type && i.type.allowsMarkType(o.type) && (i.activeMarks = o.addToSet(i.activeMarks));
      }
      if (i == n)
        break;
    }
  }
}
function K4(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && O0.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function W4(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function Y4(t) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, n, r = [];
  for (; n = e.exec(t); )
    r.push(n[1], n[2].trim());
  return r;
}
function Kf(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function Q4(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: u, next: c } = a.edge(l);
        if (u == e || s.indexOf(c) < 0 && o(c))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
function J4(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.eq(e[n]))
      return e[n];
}
class fn {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = n1(n).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let u = o.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(s[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          i = s.pop()[1];
        for (; l < o.marks.length; ) {
          let u = o.marks[l++], c = this.serializeMark(u, o.isInline, n);
          c && (s.push([u, i]), i.appendChild(c.dom), i = c.contentDOM || c.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = fn.renderSpec(n1(n), this.nodes[e.type.name](e));
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, n);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && fn.renderSpec(n1(r), i(e, n));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(e, n, r = null) {
    if (typeof n == "string")
      return { dom: e.createTextNode(n) };
    if (n.nodeType != null)
      return { dom: n };
    if (n.dom && n.dom.nodeType != null)
      return n;
    let i = n[0], s = i.indexOf(" ");
    s > 0 && (r = i.slice(0, s), i = i.slice(s + 1));
    let o, a = r ? e.createElementNS(r, i) : e.createElement(i), l = n[1], u = 1;
    if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
      u = 2;
      for (let c in l)
        if (l[c] != null) {
          let f = c.indexOf(" ");
          f > 0 ? a.setAttributeNS(c.slice(0, f), c.slice(f + 1), l[c]) : a.setAttribute(c, l[c]);
        }
    }
    for (let c = u; c < n.length; c++) {
      let f = n[c];
      if (f === 0) {
        if (c < n.length - 1 || c > u)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: a, contentDOM: a };
      } else {
        let { dom: d, contentDOM: h } = fn.renderSpec(e, f, r);
        if (a.appendChild(d), h) {
          if (o)
            throw new RangeError("Multiple content holes");
          o = h;
        }
      }
    }
    return { dom: a, contentDOM: o };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new fn(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Wf(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Wf(e.marks);
  }
}
function Wf(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function n1(t) {
  return t.document || window.document;
}
const w0 = 65535, v0 = Math.pow(2, 16);
function X4(t, e) {
  return t + e * v0;
}
function Yf(t) {
  return t & w0;
}
function Z4(t) {
  return (t - (t & w0)) / v0;
}
const D0 = 1, M0 = 2, ua = 4, I0 = 8;
class Ou {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & I0) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (D0 | ua)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (M0 | ua)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & ua) > 0;
  }
}
class Gt {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Gt.empty)
      return Gt.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = Yf(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + Z4(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let u = this.ranges[a + s], c = this.ranges[a + o], f = l + u;
      if (e <= f) {
        let d = u ? e == l ? -1 : e == f ? 1 : n : n, h = l + i + (d < 0 ? 0 : c);
        if (r)
          return h;
        let m = e == (n < 0 ? l : f) ? null : X4(a / 3, e - l), g = e == l ? M0 : e == f ? D0 : ua;
        return (n < 0 ? e != l : e != f) && (g |= I0), new Ou(h, g, m);
      }
      i += c - u;
    }
    return r ? e + i : new Ou(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = Yf(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let u = this.ranges[a + s], c = l + u;
      if (e <= c && a == i * 3)
        return !0;
      r += this.ranges[a + o] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), u = this.ranges[i + n], c = this.ranges[i + r];
      e(a, a + u, l, l + c), s += c - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Gt(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Gt.empty : new Gt(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Gt.empty = new Gt([]);
class Wi {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new Wi(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new Wi(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Wi();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new Ou(e, i, null);
  }
}
const r1 = /* @__PURE__ */ Object.create(null);
class kt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Gt.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = r1[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in r1)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return r1[e] = n, n.prototype.jsonID = e, n;
  }
}
class $e {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new $e(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new $e(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return $e.ok(e.replace(n, r, i));
    } catch (s) {
      if (s instanceof _a)
        return $e.fail(s.message);
      throw s;
    }
  }
}
function yc(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let s = t.child(i);
    s.content.size && (s = s.copy(yc(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s);
  }
  return B.fromArray(r);
}
class Tr extends kt {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new G(yc(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), n.openStart, n.openEnd);
    return $e.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new vn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new Tr(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Tr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Tr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Tr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
kt.jsonID("addMark", Tr);
class vn extends kt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new G(yc(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return $e.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Tr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new vn(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof vn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new vn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new vn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
kt.jsonID("removeMark", vn);
class Er extends kt {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return $e.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return $e.fromReplace(e, this.pos, this.pos + 1, new G(B.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new Er(this.pos, n.marks[i]);
        return new Er(this.pos, this.mark);
      }
    }
    return new ts(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Er(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Er(n.pos, e.markFromJSON(n.mark));
  }
}
kt.jsonID("addNodeMark", Er);
class ts extends kt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return $e.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return $e.fromReplace(e, this.pos, this.pos + 1, new G(B.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new Er(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ts(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new ts(n.pos, e.markFromJSON(n.mark));
  }
}
kt.jsonID("removeNodeMark", ts);
class st extends kt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && wu(e, this.from, this.to) ? $e.fail("Structure replace would overwrite content") : $e.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Gt([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new st(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new st(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof st) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? G.empty : new G(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new st(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? G.empty : new G(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new st(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new st(n.from, n.to, G.fromJSON(e, n.slice), !!n.structure);
  }
}
kt.jsonID("replace", st);
class Je extends kt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (wu(e, this.from, this.gapFrom) || wu(e, this.gapTo, this.to)))
      return $e.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return $e.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? $e.fromReplace(e, this.from, this.to, r) : $e.fail("Content does not fit in gap");
  }
  getMap() {
    return new Gt([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Je(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = e.map(this.gapFrom, -1), s = e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new Je(n.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Je(n.from, n.to, n.gapFrom, n.gapTo, G.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
kt.jsonID("replaceAround", Je);
function wu(t, e, n) {
  let r = t.resolve(e), i = n - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function eT(t, e, n, r) {
  let i = [], s = [], o, a;
  t.doc.nodesBetween(e, n, (l, u, c) => {
    if (!l.isInline)
      return;
    let f = l.marks;
    if (!r.isInSet(f) && c.type.allowsMarkType(r.type)) {
      let d = Math.max(u, e), h = Math.min(u + l.nodeSize, n), m = r.addToSet(f);
      for (let g = 0; g < f.length; g++)
        f[g].isInSet(m) || (o && o.to == d && o.mark.eq(f[g]) ? o.to = h : i.push(o = new vn(d, h, f[g])));
      a && a.to == d ? a.to = h : s.push(a = new Tr(d, h, r));
    }
  }), i.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function tT(t, e, n, r) {
  let i = [], s = 0;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (r instanceof ml) {
      let u = o.marks, c;
      for (; c = r.isInSet(u); )
        (l || (l = [])).push(c), u = c.removeFromSet(u);
    } else
      r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let u = Math.min(a + o.nodeSize, n);
      for (let c = 0; c < l.length; c++) {
        let f = l[c], d;
        for (let h = 0; h < i.length; h++) {
          let m = i[h];
          m.step == s - 1 && f.eq(i[h].style) && (d = m);
        }
        d ? (d.to = u, d.step = s) : i.push({ style: f, from: Math.max(a, e), to: u, step: s });
      }
    }
  }), i.forEach((o) => t.step(new vn(o.from, o.to, o.style)));
}
function nT(t, e, n, r = n.contentMatch) {
  let i = t.doc.nodeAt(e), s = [], o = e + 1;
  for (let a = 0; a < i.childCount; a++) {
    let l = i.child(a), u = o + l.nodeSize, c = r.matchType(l.type);
    if (!c)
      s.push(new st(o, u, G.empty));
    else {
      r = c;
      for (let f = 0; f < l.marks.length; f++)
        n.allowsMarkType(l.marks[f].type) || t.step(new vn(o, u, l.marks[f]));
    }
    o = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(B.empty, !0);
    t.replace(o, o, new G(a, 0, 0));
  }
  for (let a = s.length - 1; a >= 0; a--)
    t.step(s[a]);
}
function rT(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function hs(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), s = t.$from.index(r), o = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(s, o, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !rT(i, s, o))
      break;
  }
  return null;
}
function iT(t, e, n) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), l = o, u = a, c = B.empty, f = 0;
  for (let m = s, g = !1; m > n; m--)
    g || r.index(m) > 0 ? (g = !0, c = B.from(r.node(m).copy(c)), f++) : l--;
  let d = B.empty, h = 0;
  for (let m = s, g = !1; m > n; m--)
    g || i.after(m + 1) < i.end(m) ? (g = !0, d = B.from(i.node(m).copy(d)), h++) : u++;
  t.step(new Je(l, u, o, a, new G(c.append(d), f, h), c.size - f, !0));
}
function Ac(t, e, n = null, r = t) {
  let i = sT(t, e), s = i && oT(r, e);
  return s ? i.map(Qf).concat({ type: e, attrs: n }).concat(s.map(Qf)) : null;
}
function Qf(t) {
  return { type: t, attrs: null };
}
function sT(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return n.canReplaceWith(r, i, o) ? s : null;
}
function oT(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, s = n.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let u = r; l && u < i; u++)
    l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : o;
}
function aT(t, e, n) {
  let r = B.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = n[o].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = B.from(n[o].type.create(n[o].attrs, r));
  }
  let i = e.start, s = e.end;
  t.step(new Je(i, s, i, s, new G(r, 0, 0), n.length, !0));
}
function lT(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (o.isTextblock && !o.hasMarkup(r, i) && uT(t.doc, t.mapping.slice(s).map(a), r)) {
      t.clearIncompatible(t.mapping.slice(s).map(a, 1), r);
      let l = t.mapping.slice(s), u = l.map(a, 1), c = l.map(a + o.nodeSize, 1);
      return t.step(new Je(u, c, u + 1, c - 1, new G(B.from(r.create(i, null, o.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function uT(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function cT(t, e, n, r, i) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  n || (n = s.type);
  let o = n.create(r, null, i || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, o);
  if (!n.validContent(s.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Je(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new G(B.from(o), 0, 0), 1, !0));
}
function Yi(t, e, n = 1, r) {
  let i = t.resolve(e), s = i.depth - n, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, c = n - 2; u > s; u--, c--) {
    let f = i.node(u), d = i.index(u);
    if (f.type.spec.isolating)
      return !1;
    let h = f.content.cutByIndex(d, f.childCount), m = r && r[c] || f;
    if (m != f && (h = h.replaceChild(0, m.type.create(m.attrs))), !f.canReplace(d + 1, f.childCount) || !m.type.validContent(h))
      return !1;
  }
  let a = i.indexAfter(s), l = r && r[0];
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type);
}
function fT(t, e, n = 1, r) {
  let i = t.doc.resolve(e), s = B.empty, o = B.empty;
  for (let a = i.depth, l = i.depth - n, u = n - 1; a > l; a--, u--) {
    s = B.from(i.node(a).copy(s));
    let c = r && r[u];
    o = B.from(c ? c.type.create(c.attrs, o) : i.node(a).copy(o));
  }
  t.step(new st(e, e, new G(s.append(o), n, n), !0));
}
function Or(t, e) {
  let n = t.resolve(e), r = n.index();
  return R0(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function R0(t, e) {
  return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function L0(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let s, o, a = r.index(i);
    if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : n > 0 ? (s = r.node(i + 1), a++, o = r.node(i).maybeChild(a)) : (s = r.node(i).maybeChild(a - 1), o = r.node(i + 1)), s && !s.isTextblock && R0(s, o) && r.node(i).canReplace(a, a + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function dT(t, e, n) {
  let r = new st(e - n, e + n, G.empty, !0);
  t.step(r);
}
function hT(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, n))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function pT(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let s = 0; s < n.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (a > 0 ? 1 : 0), u = r.node(o), c = !1;
      if (s == 1)
        c = u.canReplace(l, l, i);
      else {
        let f = u.contentMatchAt(l).findWrapping(i.firstChild.type);
        c = f && u.canReplaceWith(l, l, f[0]);
      }
      if (c)
        return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function bc(t, e, n = e, r = G.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), s = t.resolve(n);
  return P0(i, s, r) ? new st(e, n, r) : new mT(i, s, r).fit();
}
function P0(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class mT {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = B.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = B.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, a = i.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new G(s, o, a);
    return e > -1 ? new Je(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new st(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = n.firstChild;
      if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = s.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = i1(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: u } = this.frontier[a], c, f = null;
          if (n == 1 && (o ? u.matchType(o.type) || (f = u.fillBefore(B.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: f };
          if (n == 2 && o && (c = u.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: c };
          if (s && u.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = i1(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new G(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = i1(e, n);
    if (i.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + i.size;
      this.unplaced = new G(Ps(e, n - 1, 1), n - 1, s ? n - 1 : r);
    } else
      this.unplaced = new G(Ps(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (s)
      for (let g = 0; g < s.length; g++)
        this.openFrontierNode(s[g]);
    let o = this.unplaced, a = r ? r.content : o.content, l = o.openStart - e, u = 0, c = [], { match: f, type: d } = this.frontier[n];
    if (i) {
      for (let g = 0; g < i.childCount; g++)
        c.push(i.child(g));
      f = f.matchFragment(i);
    }
    let h = a.size + e - (o.content.size - o.openEnd);
    for (; u < a.childCount; ) {
      let g = a.child(u), T = f.matchType(g.type);
      if (!T)
        break;
      u++, (u > 1 || l == 0 || g.content.size) && (f = T, c.push(B0(g.mark(d.allowedMarks(g.marks)), u == 1 ? l : 0, u == a.childCount ? h : -1)));
    }
    let m = u == a.childCount;
    m || (h = -1), this.placed = Bs(this.placed, n, B.from(c)), this.frontier[n].match = f, m && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, T = a; g < h; g++) {
      let E = T.lastChild;
      this.frontier.push({ type: E.type, match: E.contentMatchAt(E.childCount) }), T = E.content;
    }
    this.unplaced = m ? e == 0 ? G.empty : new G(Ps(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new G(Ps(o.content, e, u), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !s1(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: r, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = s1(e, n, i, r, s);
        if (o) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: u } = this.frontier[a], c = s1(e, a, u, l, !0);
            if (!c || c.childCount)
              continue e;
          }
          return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Bs(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Bs(this.placed, this.depth, B.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(B.empty, !0);
    n.childCount && (this.placed = Bs(this.placed, this.frontier.length, n));
  }
}
function Ps(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Ps(t.firstChild.content, e - 1, n)));
}
function Bs(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Bs(t.lastChild.content, e - 1, n)));
}
function i1(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function B0(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, B0(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(B.empty, !0)))), t.copy(r);
}
function s1(t, e, n, r, i) {
  let s = t.node(e), o = i ? t.indexAfter(e) : t.index(e);
  if (o == s.childCount && !n.compatibleContent(s.type))
    return null;
  let a = r.fillBefore(s.content, !0, o);
  return a && !gT(n, s.content, o) ? a : null;
}
function gT(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function TT(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function ET(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), s = t.doc.resolve(n);
  if (P0(i, s, r))
    return t.step(new st(e, n, r));
  let o = H0(i, t.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(i.depth + 1);
  o.unshift(a);
  for (let d = i.depth, h = i.pos - 1; d > 0; d--, h--) {
    let m = i.node(d).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    o.indexOf(d) > -1 ? a = d : i.before(d) == h && o.splice(1, 0, -d);
  }
  let l = o.indexOf(a), u = [], c = r.openStart;
  for (let d = r.content, h = 0; ; h++) {
    let m = d.firstChild;
    if (u.push(m), h == r.openStart)
      break;
    d = m.content;
  }
  for (let d = c - 1; d >= 0; d--) {
    let h = u[d].type, m = TT(h);
    if (m && i.node(l).type != h)
      c = d;
    else if (m || !h.isTextblock)
      break;
  }
  for (let d = r.openStart; d >= 0; d--) {
    let h = (d + c + 1) % (r.openStart + 1), m = u[h];
    if (m)
      for (let g = 0; g < o.length; g++) {
        let T = o[(g + l) % o.length], E = !0;
        T < 0 && (E = !1, T = -T);
        let _ = i.node(T - 1), k = i.index(T - 1);
        if (_.canReplaceWith(k, k, m.type, m.marks))
          return t.replace(i.before(T), E ? s.after(T) : n, new G(F0(r.content, 0, r.openStart, h), h, r.openEnd));
      }
  }
  let f = t.steps.length;
  for (let d = o.length - 1; d >= 0 && (t.replace(e, n, r), !(t.steps.length > f)); d--) {
    let h = o[d];
    h < 0 || (e = i.before(h), n = s.after(h));
  }
}
function F0(t, e, n, r, i) {
  if (e < n) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy(F0(s.content, e + 1, n, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(t).append(t);
    t = o.append(s.matchFragment(o).fillBefore(B.empty, !0));
  }
  return t;
}
function yT(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = hT(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new G(B.from(r), 0, 0));
}
function AT(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), s = H0(r, i);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return t.delete(r.before(a), i.after(a));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o)
      return t.delete(r.before(o), n);
  t.delete(e, n);
}
function H0(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = t.start(i);
    if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i);
  }
  return n;
}
class Qi extends kt {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return $e.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      r[s] = n.attrs[s];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return $e.fromReplace(e, this.pos, this.pos + 1, new G(B.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Gt.empty;
  }
  invert(e) {
    return new Qi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Qi(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Qi(n.pos, n.attr, n.value);
  }
}
kt.jsonID("attr", Qi);
let ns = class extends Error {
};
ns = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
ns.prototype = Object.create(Error.prototype);
ns.prototype.constructor = ns;
ns.prototype.name = "TransformError";
class U0 {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Wi();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new ns(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = G.empty) {
    let i = bc(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new G(B.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, G.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return ET(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return yT(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return AT(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return iT(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return dT(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return aT(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return lT(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return cT(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new Qi(e, n, r)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new Er(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Se)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new ts(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return fT(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return eT(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return tT(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return nT(this, e, n, r), this;
  }
}
const o1 = /* @__PURE__ */ Object.create(null);
class le {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new bT(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = G.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: u } = o[a], c = e.mapping.slice(s);
      e.replaceRange(c.map(l.pos), c.map(u.pos), a ? G.empty : n), a == 0 && Zf(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s], l = e.mapping.slice(r), u = l.map(o.pos), c = l.map(a.pos);
      s ? e.deleteRange(u, c) : (e.replaceRangeWith(u, c, n), Zf(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new ce(e) : Ii(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = n < 0 ? Ii(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : Ii(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new dn(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Ii(e, e, 0, 0, 1) || new dn(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Ii(e, e, e.content.size, e.childCount, -1) || new dn(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = o1[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in o1)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return o1[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ce.between(this.$anchor, this.$head).getBookmark();
  }
}
le.prototype.visible = !0;
class bT {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let Jf = !1;
function Xf(t) {
  !Jf && !t.parent.inlineContent && (Jf = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ce extends le {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    Xf(e), Xf(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return le.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new ce(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = G.empty) {
    if (super.replace(e, n), n == G.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ce && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new gl(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ce(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let s = le.findFrom(n, r, !0) || le.findFrom(n, -r, !0);
      if (s)
        n = s.$head;
      else
        return le.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = (le.findFrom(e, -r, !0) || le.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new ce(e, n);
  }
}
le.jsonID("text", ce);
class gl {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new gl(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ce.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ne extends le {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), s = e.resolve(i);
    return r ? le.near(s) : new ne(s);
  }
  content() {
    return new G(B.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ne && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Cc(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ne(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ne(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ne.prototype.visible = !1;
le.jsonID("node", ne);
class Cc {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new gl(r, r) : new Cc(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && ne.isSelectable(r) ? new ne(n) : le.near(n);
  }
}
class dn extends le {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = G.empty) {
    if (n == G.empty) {
      e.delete(0, e.doc.content.size);
      let r = le.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new dn(e);
  }
  map(e) {
    return new dn(e);
  }
  eq(e) {
    return e instanceof dn;
  }
  getBookmark() {
    return CT;
  }
}
le.jsonID("all", dn);
const CT = {
  map() {
    return this;
  },
  resolve(t) {
    return new dn(t);
  }
};
function Ii(t, e, n, r, i, s = !1) {
  if (e.inlineContent)
    return ce.create(t, n);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && ne.isSelectable(a))
        return ne.create(t, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = Ii(t, a, n + i, i < 0 ? a.childCount : 0, i, s);
      if (l)
        return l;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function Zf(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof st || i instanceof Je))
    return;
  let s = t.mapping.maps[r], o;
  s.forEach((a, l, u, c) => {
    o == null && (o = c);
  }), t.setSelection(le.near(t.doc.resolve(o), n));
}
const ed = 1, Lo = 2, td = 4;
class xT extends U0 {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | ed) & ~Lo, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & ed) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Lo, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Se.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Lo) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~Lo, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Se.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(n);
        s = r == n ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, s)), this.selection.empty || this.setSelection(le.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= td, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & td) > 0;
  }
}
function nd(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Fs {
  constructor(e, n, r) {
    this.name = e, this.init = nd(n.init, r), this.apply = nd(n.apply, r);
  }
}
const ST = [
  new Fs("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Fs("selection", {
    init(t, e) {
      return t.selection || le.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Fs("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Fs("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class a1 {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = ST.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Fs(r.key, r.spec.state, r));
    });
  }
}
class Ui {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0, u = i ? i[o].state : this, c = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, u, r);
          if (c && r.filterTransaction(c, o)) {
            if (c.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let f = 0; f < this.config.plugins.length; f++)
                i.push(f < o ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(c), r = r.applyInner(c), s = !0;
          }
          i && (i[o] = { state: r, n: n.length });
        }
      }
      if (!s)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Ui(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      n[s.name] = s.apply(e, this[s.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new xT(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new a1(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Ui(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new a1(this.schema, e.plugins), r = n.fields, i = new Ui(n);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new a1(e.schema, e.plugins), s = new Ui(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Ar.fromJSON(e.schema, n.doc);
      else if (o.name == "selection")
        s.selection = le.fromJSON(s.doc, n.selection);
      else if (o.name == "storedMarks")
        n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], u = l.spec.state;
            if (l.key == o.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              s[o.name] = u.fromJSON.call(l, e, n[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function q0(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = q0(i, e, {})), n[r] = i;
  }
  return n;
}
class Be {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && q0(e.props, this, this.props), this.key = e.key ? e.key.key : z0("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const l1 = /* @__PURE__ */ Object.create(null);
function z0(t) {
  return t in l1 ? t + "$" + ++l1[t] : (l1[t] = 0, t + "$");
}
class Ge {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = z0(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const It = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, oo = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let rd = null;
const $n = function(t, e, n) {
  let r = rd || (rd = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, ui = function(t, e, n, r) {
  return n && (id(t, e, n, r, -1) || id(t, e, n, r, 1));
}, NT = /^(img|br|input|textarea|hr)$/i;
function id(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : On(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || _T(t) || NT.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = It(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? On(t) : 0;
    } else
      return !1;
  }
}
function On(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function kT(t, e, n) {
  for (let r = e == 0, i = e == On(t); r || i; ) {
    if (t == n)
      return !0;
    let s = It(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && s == 0, i = i && s == On(t);
  }
}
function _T(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Tl = function(t) {
  return t.focusNode && ui(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Wr(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function OT(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
const kr = typeof navigator < "u" ? navigator : null, sd = typeof document < "u" ? document : null, wr = kr && kr.userAgent || "", vu = /Edge\/(\d+)/.exec(wr), $0 = /MSIE \d/.exec(wr), Du = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(wr), Ct = !!($0 || Du || vu), br = $0 ? document.documentMode : Du ? +Du[1] : vu ? +vu[1] : 0, mn = !Ct && /gecko\/(\d+)/i.test(wr);
mn && +(/Firefox\/(\d+)/.exec(wr) || [0, 0])[1];
const Mu = !Ct && /Chrome\/(\d+)/.exec(wr), ft = !!Mu, wT = Mu ? +Mu[1] : 0, ht = !Ct && !!kr && /Apple Computer/.test(kr.vendor), rs = ht && (/Mobile\/\w+/.test(wr) || !!kr && kr.maxTouchPoints > 2), zt = rs || (kr ? /Mac/.test(kr.platform) : !1), un = /Android \d/.test(wr), El = !!sd && "webkitFontSmoothing" in sd.documentElement.style, vT = El ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function DT(t) {
  return {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function tr(t, e) {
  return typeof t == "number" ? t : t[e];
}
function MT(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function od(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, s = t.dom.ownerDocument;
  for (let o = n || t.dom; o; o = oo(o)) {
    if (o.nodeType != 1)
      continue;
    let a = o, l = a == s.body, u = l ? DT(s) : MT(a), c = 0, f = 0;
    if (e.top < u.top + tr(r, "top") ? f = -(u.top - e.top + tr(i, "top")) : e.bottom > u.bottom - tr(r, "bottom") && (f = e.bottom - u.bottom + tr(i, "bottom")), e.left < u.left + tr(r, "left") ? c = -(u.left - e.left + tr(i, "left")) : e.right > u.right - tr(r, "right") && (c = e.right - u.right + tr(i, "right")), c || f)
      if (l)
        s.defaultView.scrollBy(c, f);
      else {
        let d = a.scrollLeft, h = a.scrollTop;
        f && (a.scrollTop += f), c && (a.scrollLeft += c);
        let m = a.scrollLeft - d, g = a.scrollTop - h;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    if (l)
      break;
  }
}
function IT(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t.root.elementFromPoint(s, o);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: V0(t.dom) };
}
function V0(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = oo(r))
    ;
  return e;
}
function RT({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  G0(n, r == 0 ? 0 : r - e);
}
function G0(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: s } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Ni = null;
function LT(t) {
  if (t.setActive)
    return t.setActive();
  if (Ni)
    return t.focus(Ni);
  let e = V0(t);
  t.focus(Ni == null ? {
    get preventScroll() {
      return Ni = { preventScroll: !0 }, !0;
    }
  } : void 0), Ni || (Ni = !1, G0(e, 0));
}
function j0(t, e) {
  let n, r = 2e8, i, s = 0, o = e.top, a = e.top;
  for (let l = t.firstChild, u = 0; l; l = l.nextSibling, u++) {
    let c;
    if (l.nodeType == 1)
      c = l.getClientRects();
    else if (l.nodeType == 3)
      c = $n(l).getClientRects();
    else
      continue;
    for (let f = 0; f < c.length; f++) {
      let d = c[f];
      if (d.top <= o && d.bottom >= a) {
        o = Math.max(d.bottom, o), a = Math.min(d.top, a);
        let h = d.left > e.left ? d.left - e.left : d.right < e.left ? e.left - d.right : 0;
        if (h < r) {
          n = l, r = h, i = h && n.nodeType == 3 ? {
            left: d.right < e.left ? d.right : d.left,
            top: e.top
          } : e, l.nodeType == 1 && h && (s = u + (e.left >= (d.left + d.right) / 2 ? 1 : 0));
          continue;
        }
      }
      !n && (e.left >= d.right && e.top >= d.top || e.left >= d.left && e.top >= d.bottom) && (s = u + 1);
    }
  }
  return n && n.nodeType == 3 ? PT(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: s } : j0(n, i);
}
function PT(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let s = ur(r, 1);
    if (s.top != s.bottom && xc(e, s))
      return { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function xc(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function BT(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function FT(t, e, n) {
  let { node: r, offset: i } = j0(e, n), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, s);
}
function HT(t, e, n, r) {
  let i = -1;
  for (let s = e, o = !1; s != t.dom; ) {
    let a = t.docView.nearestDesc(s, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent && !o || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && !o && (o = !0, l.left > r.left || l.top > r.top ? i = a.posBefore : (l.right < r.left || l.bottom < r.top) && (i = a.posAfter)), !a.contentDOM && i < 0)
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    s = a.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function K0(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ; ) {
      let o = t.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          if (xc(e, u))
            return K0(o, e, u);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return t;
}
function UT(t, e) {
  let n = t.dom.ownerDocument, r, i = 0;
  if (n.caretPositionFromPoint)
    try {
      let l = n.caretPositionFromPoint(e.left, e.top);
      l && ({ offsetNode: r, offset: i } = l);
    } catch {
    }
  if (!r && n.caretRangeFromPoint) {
    let l = n.caretRangeFromPoint(e.left, e.top);
    l && ({ startContainer: r, startOffset: i } = l);
  }
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), o;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let l = t.dom.getBoundingClientRect();
    if (!xc(e, l) || (s = K0(t.dom, e, l), !s))
      return null;
  }
  if (ht)
    for (let l = s; r && l; l = oo(l))
      l.draggable && (r = void 0);
  if (s = BT(s, e), r) {
    if (mn && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let l = r.childNodes[i], u;
      l.nodeName == "IMG" && (u = l.getBoundingClientRect()).right <= e.left && u.bottom > e.top && i++;
    }
    r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? o = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (o = HT(t, r, i, e));
  }
  o == null && (o = FT(t, s, e));
  let a = t.docView.nearestDesc(s, !0);
  return { pos: o, inside: a ? a.posAtStart - a.border : -1 };
}
function ur(t, e) {
  let n = t.getClientRects();
  return n.length ? n[e < 0 ? 0 : n.length - 1] : t.getBoundingClientRect();
}
const qT = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function W0(t, e, n) {
  let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1), o = El || mn;
  if (r.nodeType == 3)
    if (o && (qT.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = ur($n(r, i, i), n);
      if (mn && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = ur($n(r, i - 1, i - 1), -1);
        if (u.top == l.top) {
          let c = ur($n(r, i, i + 1), -1);
          if (c.top != l.top)
            return xs(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = i, u = i, c = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, c = -1) : n >= 0 && i == r.nodeValue.length ? (l--, c = 1) : n < 0 ? l-- : u++, xs(ur($n(r, l, u), 1), c < 0);
    }
  if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (n < 0 || i == On(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return u1(l.getBoundingClientRect(), !1);
    }
    if (s == null && i < On(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return u1(l.getBoundingClientRect(), !0);
    }
    return u1(r.getBoundingClientRect(), n >= 0);
  }
  if (s == null && i && (n < 0 || i == On(r))) {
    let l = r.childNodes[i - 1], u = l.nodeType == 3 ? $n(l, On(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return xs(ur(u, 1), !1);
  }
  if (s == null && i < On(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? $n(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return xs(ur(u, -1), !0);
  }
  return xs(ur(r.nodeType == 3 ? $n(r) : r, -n), n >= 0);
}
function xs(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function u1(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function Y0(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function zT(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return Y0(t, e, () => {
    let { node: s } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = W0(t, i.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = $n(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (c.bottom > c.top + 1 && (n == "up" ? o.top - c.top > (c.bottom - o.top) * 2 : c.bottom - o.bottom > (o.bottom - c.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const $T = /[\u0590-\u08ac]/;
function VT(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, a = t.domSelection();
  return !$T.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : o : Y0(t, e, () => {
    let { focusNode: l, focusOffset: u, anchorNode: c, anchorOffset: f } = t.domSelectionRange(), d = a.caretBidiLevel;
    a.modify("move", n, "character");
    let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: m, focusOffset: g } = t.domSelectionRange(), T = m && !h.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && u == g;
    try {
      a.collapse(c, f), l && (l != c || u != f) && a.extend && a.extend(l, u);
    } catch {
    }
    return d != null && (a.caretBidiLevel = d), T;
  });
}
let ad = null, ld = null, ud = !1;
function GT(t, e, n) {
  return ad == e && ld == n ? ud : (ad = e, ld = n, ud = n == "up" || n == "down" ? zT(t, e, n) : VT(t, e, n));
}
const hn = 0, cd = 1, qi = 2, Mn = 3;
class Co {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = hn, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > It(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!n || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], a = s + o.size;
      if (a > e || o instanceof J0) {
        i = e - s;
        break;
      }
      s = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof Q0 && s.side >= 0; r--)
      ;
    if (n <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && n && o && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? It(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? It(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a], u = o + l.size;
      if (i == -1 && e <= u) {
        let c = o + l.border;
        if (e >= c && n <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, c);
        e = o;
        for (let f = a; f > 0; f--) {
          let d = this.children[f - 1];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) {
            i = It(d.dom) + 1;
            break;
          }
          e -= d.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let c = a + 1; c < this.children.length; c++) {
          let f = this.children[c];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
            s = It(f.dom);
            break;
          }
          n += f.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = u;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let s = Math.min(e, n), o = Math.max(e, n);
    for (let d = 0, h = 0; d < this.children.length; d++) {
      let m = this.children[d], g = h + m.size;
      if (s > h && o < g)
        return m.setSelection(e - h - m.border, n - h - m.border, r, i);
      h = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), u = r.getSelection(), c = !1;
    if ((mn || ht) && e == n) {
      let { node: d, offset: h } = a;
      if (d.nodeType == 3) {
        if (c = !!(h && d.nodeValue[h - 1] == `
`), c && h == d.nodeValue.length)
          for (let m = d, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: It(g) + 1 });
              break;
            }
            let T = m.pmViewDesc;
            if (T && T.node && T.node.isBlock)
              break;
          }
      } else {
        let m = d.childNodes[h - 1];
        c = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (mn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || c && ht) && ui(a.node, a.offset, u.anchorNode, u.anchorOffset) && ui(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((u.extend || e == n) && !c) {
      u.collapse(a.node, a.offset);
      try {
        e != n && u.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let h = a;
        a = l, l = h;
      }
      let d = document.createRange();
      d.setEnd(l.node, l.offset), d.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(d);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && n >= r : e < o && n > r) {
        let a = r + s.border, l = o - s.border;
        if (e >= a && n <= l) {
          this.dirty = e == r || n == o ? qi : cd, e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Mn : s.markDirty(e - a, n - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? qi : Mn;
      }
      r = o;
    }
    this.dirty = qi;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? qi : cd;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class Q0 extends Co {
  constructor(e, n, r, i) {
    let s, o = n.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !n.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = n, this.widget = n, s = this;
  }
  matchesWidget(e) {
    return this.dirty == hn && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class jT extends Co {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class ci extends Co {
  constructor(e, n, r, i) {
    super(e, [], r, i), this.mark = n;
  }
  static create(e, n, r, i) {
    let s = i.nodeViews[n.type.name], o = s && s(n, i, r);
    return (!o || !o.dom) && (o = fn.renderSpec(document, n.type.spec.toDOM(n, r))), new ci(e, n, o.dom, o.contentDOM || o.dom);
  }
  parseRule() {
    return this.dirty & Mn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(e) {
    return this.dirty != Mn && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != hn) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = hn;
    }
  }
  slice(e, n, r) {
    let i = ci.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    n < o && (s = Lu(s, n, o, r)), e > 0 && (s = Lu(s, 0, e, r));
    for (let a = 0; a < s.length; a++)
      s[a].parent = i;
    return i.children = s, i;
  }
}
class fi extends Co {
  constructor(e, n, r, i, s, o, a, l, u) {
    super(e, [], s, o), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a, o && this.updateChildren(l, u);
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, s, o) {
    let a = s.nodeViews[n.type.name], l, u = a && a(n, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), c = u && u.dom, f = u && u.contentDOM;
    if (n.isText) {
      if (!c)
        c = document.createTextNode(n.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      c || ({ dom: c, contentDOM: f } = fn.renderSpec(document, n.type.spec.toDOM(n)));
    !f && !n.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), n.type.spec.draggable && (c.draggable = !0));
    let d = c;
    return c = eg(c, r, n), u ? l = new KT(e, n, r, i, c, f || null, d, u, s, o + 1) : n.isText ? new yl(e, n, r, i, c, d, s) : new fi(e, n, r, i, c, f || null, d, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => B.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == hn && e.eq(this.node) && Ru(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, s = e.composing ? this.localCompositionInfo(e, n) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new YT(this, o && o.node, e);
    XT(this.node, this.innerDeco, (u, c, f) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, r, e) : u.type.side >= 0 && !f && l.syncToMarks(c == this.node.childCount ? Se.none : this.node.child(c).marks, r, e), l.placeWidget(u, e, i);
    }, (u, c, f, d) => {
      l.syncToMarks(u.marks, r, e);
      let h;
      l.findNodeMatch(u, c, f, d) || a && e.state.selection.from > i && e.state.selection.to < i + u.nodeSize && (h = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(u, c, f, h, e) || l.updateNextNode(u, c, f, e, d) || l.addNode(u, c, f, e, i), i += u.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == qi) && (o && this.protectLocalComposition(e, o), X0(this.contentDOM, this.children, e), rs && ZT(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof ce) || r < n || i > n + this.node.content.size)
      return null;
    let s = e.domSelectionRange(), o = eE(s.focusNode, s.focusOffset);
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let a = o.nodeValue, l = tE(this.node.content, a, r - n, i - n);
      return l < 0 ? null : { node: o, pos: l, text: a };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let s = n;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new jT(this, s, n, i);
    e.input.compositionNodes.push(o), this.children = Lu(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == Mn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = hn;
  }
  updateOuterDeco(e) {
    if (Ru(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = Z0(this.dom, this.nodeDOM, Iu(this.outerDeco, this.node, n), Iu(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function fd(t, e, n, r, i) {
  return eg(r, e, t), new fi(void 0, t, e, n, r, r, r, i, 0);
}
class yl extends fi {
  constructor(e, n, r, i, s, o, a) {
    super(e, n, r, i, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == Mn || this.dirty != hn && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != hn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = hn, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), s = document.createTextNode(i.text);
    return new yl(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Mn);
  }
  get domAtom() {
    return !1;
  }
}
class J0 extends Co {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == hn && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class KT extends fi {
  constructor(e, n, r, i, s, o, a, l, u, c) {
    super(e, n, r, i, s, o, a, u, c), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == Mn)
      return !1;
    if (this.spec.update) {
      let s = this.spec.update(e, n, r);
      return s && this.updateInner(e, n, r, i), s;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function X0(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = dd(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(a, r);
    if (o instanceof ci) {
      let l = r ? r.previousSibling : t.lastChild;
      X0(o.contentDOM, o.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = dd(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const zs = function(t) {
  t && (this.nodeName = t);
};
zs.prototype = /* @__PURE__ */ Object.create(null);
const Xr = [new zs()];
function Iu(t, e, n) {
  if (t.length == 0)
    return Xr;
  let r = n ? Xr[0] : new zs(), i = [r];
  for (let s = 0; s < t.length; s++) {
    let o = t[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new zs(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (n && i.length == 1 && i.push(r = new zs(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function Z0(t, e, n, r) {
  if (n == Xr && r == Xr)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], a = n[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = Xr[0]), i = l;
    }
    WT(i, a || Xr[0], o);
  }
  return i;
}
function WT(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && t.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && t.classList.add(i[s]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function eg(t, e, n) {
  return Z0(t, t, Xr, Iu(e, n, t.nodeType != 1));
}
function Ru(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function dd(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class YT {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = QT(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = hn, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(e[s]) && !this.isLocked(u.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = ci.create(this.top, e[s], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == Mn && o.dom == o.contentDOM && (o.dirty = qi), o.update(e, n, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, s) {
    for (let o = this.index; o < this.top.children.length; o++) {
      let a = this.top.children[o];
      if (a instanceof fi) {
        let l = this.preMatch.matched.get(a);
        if (l != null && l != s)
          return !1;
        let u = a.dom;
        if (!(this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != Mn && Ru(n, a.outerDeco))) && a.update(e, n, r, i))
          return this.destroyBetween(this.index, o), a.dom != u && (this.changed = !0), this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, s) {
    this.top.children.splice(this.index++, 0, fi.create(this.top, e, n, r, i, s)), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new Q0(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof ci; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof yl) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((ht || ft) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new J0(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function QT(t, e) {
  let n = e, r = n.children.length, i = t.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e:
    for (; i > 0; ) {
      let a;
      for (; ; )
        if (r) {
          let u = n.children[r - 1];
          if (u instanceof ci)
            n = u, r = u.children.length;
          else {
            a = u, r--;
            break;
          }
        } else {
          if (n == e)
            break e;
          r = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(i - 1))
          break;
        --i, s.set(a, i), o.push(a);
      }
    }
  return { index: i, matched: s, matches: o.reverse() };
}
function JT(t, e) {
  return t.type.side - e.type.side;
}
function XT(t, e, n, r) {
  let i = e.locals(t), s = 0;
  if (i.length == 0) {
    for (let u = 0; u < t.childCount; u++) {
      let c = t.child(u);
      r(c, i, e.forChild(s, c), u), s += c.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let u = 0; ; ) {
    if (o < i.length && i[o].to == s) {
      let m = i[o++], g;
      for (; o < i.length && i[o].to == s; )
        (g || (g = [m])).push(i[o++]);
      if (g) {
        g.sort(JT);
        for (let T = 0; T < g.length; T++)
          n(g[T], u, !!l);
      } else
        n(m, u, !!l);
    }
    let c, f;
    if (l)
      f = -1, c = l, l = null;
    else if (u < t.childCount)
      f = u, c = t.child(u++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= s && a.splice(m--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      a.push(i[o++]);
    let d = s + c.nodeSize;
    if (c.isText) {
      let m = d;
      o < i.length && i[o].from < m && (m = i[o].from);
      for (let g = 0; g < a.length; g++)
        a[g].to < m && (m = a[g].to);
      m < d && (l = c.cut(m - s), c = c.cut(0, m - s), d = m, f = -1);
    }
    let h = c.isInline && !c.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    r(c, h, e.forChild(s, c), f), s = d;
  }
}
function ZT(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function eE(t, e) {
  for (; ; ) {
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.childNodes.length > e && t.childNodes[e].nodeType == 3)
        return t.childNodes[e];
      t = t.childNodes[e - 1], e = On(t);
    } else if (t.nodeType == 1 && e < t.childNodes.length)
      t = t.childNodes[e], e = 0;
    else
      return null;
  }
}
function tE(t, e, n, r) {
  for (let i = 0, s = 0; i < t.childCount && s <= r; ) {
    let o = t.child(i++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; i < t.childCount; ) {
      let u = t.child(i++);
      if (s += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (s >= n) {
      let u = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (u >= 0 && u + e.length + a >= n)
        return a + u;
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Lu(t, e, n, r, i) {
  let s = [];
  for (let o = 0, a = 0; o < t.length; o++) {
    let l = t[o], u = a, c = a += l.size;
    u >= n || c <= e ? s.push(l) : (u < e && s.push(l.slice(0, e - u, r)), i && (s.push(i), i = void 0), c > n && s.push(l.slice(n - u, l.size, r)));
  }
  return s;
}
function Sc(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), s = i && i.size == 0, o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = r.resolve(o), l, u;
  if (Tl(n)) {
    for (l = a; i && !i.node; )
      i = i.parent;
    let c = i.node;
    if (i && c.isAtom && ne.isSelectable(c) && i.parent && !(c.isInline && kT(n.focusNode, n.focusOffset, i.dom))) {
      let f = i.posBefore;
      u = new ne(o == f ? a : r.resolve(f));
    }
  } else {
    let c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
    l = r.resolve(c);
  }
  if (!u) {
    let c = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    u = Nc(t, l, a, c);
  }
  return u;
}
function tg(t) {
  return t.editable ? t.hasFocus() : rg(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Yn(t, e = !1) {
  let n = t.state.selection;
  if (ng(t, n), !!tg(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && ft) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && ui(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      rE(t);
    else {
      let { anchor: r, head: i } = n, s, o;
      hd && !(n instanceof ce) && (n.$from.parent.inlineContent || (s = pd(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = pd(t, n.to))), t.docView.setSelection(r, i, t.root, e), hd && (s && md(s), o && md(o)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && nE(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const hd = ht || ft && wT < 63;
function pd(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, s = r ? n.childNodes[r - 1] : null;
  if (ht && i && i.contentEditable == "false")
    return c1(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return c1(i);
    if (s)
      return c1(s);
  }
}
function c1(t) {
  return t.contentEditable = "true", ht && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function md(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function nE(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!tg(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function rE(t) {
  let e = t.domSelection(), n = document.createRange(), r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setEnd(r.parentNode, It(r) + 1) : n.setEnd(r, 0), n.collapse(!1), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && Ct && br <= 11 && (r.disabled = !0, r.disabled = !1);
}
function ng(t, e) {
  if (e instanceof ne) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (gd(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    gd(t);
}
function gd(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function Nc(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || ce.between(e, n, r);
}
function Td(t) {
  return t.editable && !t.hasFocus() ? !1 : rg(t);
}
function rg(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function iE(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return ui(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Pu(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && le.findFrom(s, e);
}
function Yr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Ed(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ce) {
    if (!r.empty || n.indexOf("s") > -1)
      return !1;
    if (t.endOfTextblock(e > 0 ? "right" : "left")) {
      let i = Pu(t.state, e);
      return i && i instanceof ne ? Yr(t, i) : !1;
    } else if (!(zt && n.indexOf("m") > -1)) {
      let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
      if (!s || s.isText)
        return !1;
      let a = e < 0 ? i.pos - s.nodeSize : i.pos;
      return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? ne.isSelectable(s) ? Yr(t, new ne(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : El ? Yr(t, new ce(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
    }
  } else {
    if (r instanceof ne && r.node.isInline)
      return Yr(t, new ce(e > 0 ? r.$to : r.$from));
    {
      let i = Pu(t.state, e);
      return i ? Yr(t, i) : !1;
    }
  }
}
function Ia(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function $s(t) {
  let e = t.pmViewDesc;
  return e && e.size == 0 && (t.nextSibling || t.nodeName != "BR");
}
function f1(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, s, o = !1;
  for (mn && n.nodeType == 1 && r < Ia(n) && $s(n.childNodes[r]) && (o = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if ($s(a))
          i = n, s = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (ig(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && $s(a); )
          i = n.parentNode, s = It(a), a = a.previousSibling;
        if (a)
          n = a, r = Ia(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  o ? Bu(t, n, r) : i && Bu(t, i, s);
}
function d1(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = Ia(n), s, o;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if ($s(a))
        s = n, o = ++r;
      else
        break;
    } else {
      if (ig(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && $s(a); )
          s = a.parentNode, o = It(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Ia(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && Bu(t, s, o);
}
function ig(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Bu(t, e, n) {
  let r = t.domSelection();
  if (Tl(r)) {
    let s = document.createRange();
    s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s);
  } else
    r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && Yn(t);
  }, 50);
}
function yd(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ce && !r.empty || n.indexOf("s") > -1 || zt && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Pu(t.state, e);
    if (o && o instanceof ne)
      return Yr(t, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, a = r instanceof dn ? le.near(o, e) : le.findFrom(o, e);
    return a ? Yr(t, a) : !1;
  }
  return !1;
}
function Ad(t, e) {
  if (!(t.state.selection instanceof ce))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (s && !s.isText) {
    let o = t.state.tr;
    return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize), t.dispatch(o), !0;
  }
  return !1;
}
function bd(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function sE(t) {
  if (!ht || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    bd(t, r, "true"), setTimeout(() => bd(t, r, "false"), 20);
  }
  return !1;
}
function oE(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function aE(t, e) {
  let n = e.keyCode, r = oE(e);
  return n == 8 || zt && n == 72 && r == "c" ? Ad(t, -1) || f1(t) : n == 46 || zt && n == 68 && r == "c" ? Ad(t, 1) || d1(t) : n == 13 || n == 27 ? !0 : n == 37 || zt && n == 66 && r == "c" ? Ed(t, -1, r) || f1(t) : n == 39 || zt && n == 70 && r == "c" ? Ed(t, 1, r) || d1(t) : n == 38 || zt && n == 80 && r == "c" ? yd(t, -1, r) || f1(t) : n == 40 || zt && n == 78 && r == "c" ? sE(t) || yd(t, 1, r) || d1(t) : r == (zt ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90);
}
function sg(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let h = r.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content;
  }
  let o = t.someProp("clipboardSerializer") || fn.fromSchema(t.state.schema), a = fg(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: a }));
  let u = l.firstChild, c, f = 0;
  for (; u && u.nodeType == 1 && (c = cg[u.nodeName.toLowerCase()]); ) {
    for (let h = c.length - 1; h >= 0; h--) {
      let m = a.createElement(c[h]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), f++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${s}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`);
  let d = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: d };
}
function og(t, e, n, r, i) {
  let s = i.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (r || s || !n);
  if (l) {
    if (t.someProp("transformPastedText", (d) => {
      e = d(e, s || r, t);
    }), s)
      return e ? new G(B.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : G.empty;
    let f = t.someProp("clipboardTextParser", (d) => d(e, i, r, t));
    if (f)
      a = f;
    else {
      let d = i.marks(), { schema: h } = t.state, m = fn.fromSchema(h);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let T = o.appendChild(document.createElement("p"));
        g && T.appendChild(m.serializeNode(h.text(g, d)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (f) => {
      n = f(n, t);
    }), o = cE(n), El && fE(o);
  let u = o && o.querySelector("[data-pm-slice]"), c = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let f = +c[3]; f > 0; f--) {
      let d = o.firstChild;
      for (; d && d.nodeType != 1; )
        d = d.nextSibling;
      if (!d)
        break;
      o = d;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || li.fromSchema(t.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || c),
    context: i,
    ruleFromNode(d) {
      return d.nodeName == "BR" && !d.nextSibling && d.parentNode && !lE.test(d.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    a = dE(Cd(a, +c[1], +c[2]), c[4]);
  else if (a = G.maxOpen(uE(a.content, i), !0), a.openStart || a.openEnd) {
    let f = 0, d = 0;
    for (let h = a.content.firstChild; f < a.openStart && !h.type.spec.isolating; f++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; d < a.openEnd && !h.type.spec.isolating; d++, h = h.lastChild)
      ;
    a = Cd(a, f, d);
  }
  return t.someProp("transformPasted", (f) => {
    a = f(a, t);
  }), a;
}
const lE = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function uE(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), s, o = [];
    if (t.forEach((a) => {
      if (!o)
        return;
      let l = i.findWrapping(a.type), u;
      if (!l)
        return o = null;
      if (u = o.length && s.length && lg(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = u;
      else {
        o.length && (o[o.length - 1] = ug(o[o.length - 1], s.length));
        let c = ag(a, l);
        o.push(c), i = i.matchType(c.type), s = l;
      }
    }), o)
      return B.from(o);
  }
  return t;
}
function ag(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, B.from(t));
  return t;
}
function lg(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let s = lg(t, e, n, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(B.from(ag(n, t, i + 1))));
  }
}
function ug(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, ug(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(B.empty, !0);
  return t.copy(n.append(r));
}
function Fu(t, e, n, r, i, s) {
  let o = e < 0 ? t.firstChild : t.lastChild, a = o.content;
  return i < r - 1 && (a = Fu(a, e, n, r, i + 1, s)), i >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, t.childCount > 1 || s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(B.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a));
}
function Cd(t, e, n) {
  return e < t.openStart && (t = new G(Fu(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new G(Fu(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const cg = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let xd = null;
function fg() {
  return xd || (xd = document.implementation.createHTMLDocument("title"));
}
function cE(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = fg().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && cg[r[1].toLowerCase()]) && (t = i.map((s) => "<" + s + ">").join("") + t + i.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = t, i)
    for (let s = 0; s < i.length; s++)
      n = n.querySelector(i[s]) || n;
  return n;
}
function fE(t) {
  let e = t.querySelectorAll(ft ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function dE(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: s, openEnd: o } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = B.from(l.create(r[a + 1], i)), s++, o++;
  }
  return new G(i, s, o);
}
const pt = {}, mt = {}, hE = { touchstart: !0, touchmove: !0 };
class pE {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function mE(t) {
  for (let e in pt) {
    let n = pt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      TE(t, r) && !kc(t, r) && (t.editable || !(r.type in mt)) && n(t, r);
    }, hE[e] ? { passive: !0 } : void 0);
  }
  ht && t.dom.addEventListener("input", () => null), Hu(t);
}
function yr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function gE(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Hu(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => kc(t, r));
  });
}
function kc(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function TE(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function EE(t, e) {
  !kc(t, e) && pt[e.type] && (t.editable || !(e.type in mt)) && pt[e.type](t, e);
}
mt.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !hg(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(un && ft && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), rs && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, Wr(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (r) => r(t, n)) || aE(t, n) ? n.preventDefault() : yr(t, "key");
};
mt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
mt.keypress = (t, e) => {
  let n = e;
  if (hg(t, n) || !n.charCode || n.ctrlKey && !n.altKey || zt && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof ce) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function Al(t) {
  return { left: t.clientX, top: t.clientY };
}
function yE(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function _c(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let s = t.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (t.someProp(e, (a) => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), i, !0) : a(t, n, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function Ji(t, e, n) {
  t.focused || t.focus();
  let r = t.state.tr.setSelection(e);
  n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function AE(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ne.isSelectable(r) ? (Ji(t, new ne(n), "pointer"), !0) : !1;
}
function bE(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof ne && (r = n.node);
  let s = t.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ne.isSelectable(a)) {
      r && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (Ji(t, ne.create(t.state.doc, i), "pointer"), !0) : !1;
}
function CE(t, e, n, r, i) {
  return _c(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (s) => s(t, e, r)) || (i ? bE(t, n) : AE(t, n));
}
function xE(t, e, n, r) {
  return _c(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function SE(t, e, n, r) {
  return _c(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || NE(t, n, r);
}
function NE(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Ji(t, ce.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
    if (o.inlineContent)
      Ji(t, ce.create(r, a + 1, a + 1 + o.content.size), "pointer");
    else if (ne.isSelectable(o))
      Ji(t, ne.create(r, a), "pointer");
    else
      continue;
    return !0;
  }
}
function Oc(t) {
  return Ra(t);
}
const dg = zt ? "metaKey" : "ctrlKey";
pt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = Oc(t), i = Date.now(), s = "singleClick";
  i - t.input.lastClick.time < 500 && yE(n, t.input.lastClick) && !n[dg] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s };
  let o = t.posAtCoords(Al(n));
  o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new kE(t, o, n, !!r)) : (s == "doubleClick" ? xE : SE)(t, o.pos, o.inside, n) ? n.preventDefault() : yr(t, "pointer"));
};
class kE {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[dg], this.allowDefault = r.shiftKey;
    let s, o;
    if (n.inside > -1)
      s = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let c = e.state.doc.resolve(n.pos);
      s = c.parent, o = c.depth ? c.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l ? l.dom : null;
    let { selection: u } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || u instanceof ne && u.from <= o && u.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && mn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), yr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Yn(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Al(e))), this.updateAllowDefault(e), this.allowDefault || !n ? yr(this.view, "pointer") : CE(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    ht && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    ft && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Ji(this.view, le.near(this.view.state.doc.resolve(n.pos)), "pointer"), e.preventDefault()) : yr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), yr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
pt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), Oc(t), yr(t, "pointer");
};
pt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), yr(t, "pointer");
};
pt.contextmenu = (t) => Oc(t);
function hg(t, e) {
  return t.composing ? !0 : ht && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const _E = un ? 5e3 : -1;
mt.compositionstart = mt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Ra(t, !0), t.markCursor = null;
    else if (Ra(t), mn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          t.domSelection().collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    t.input.composing = !0;
  }
  pg(t, _E);
};
mt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, pg(t, 20));
};
function pg(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Ra(t), e));
}
function mg(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = OE()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function OE() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Ra(t, e = !1) {
  if (!(un && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), mg(t), e || t.docView && t.docView.dirty) {
      let n = Sc(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function wE(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const is = Ct && br < 15 || rs && vT < 604;
pt.copy = mt.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let s = is ? null : n.clipboardData, o = r.content(), { dom: a, text: l } = sg(t, o);
  s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : wE(t, a), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function vE(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function DE(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? ao(t, r.value, null, t.input.shiftKey, e) : ao(t, r.textContent, r.innerHTML, t.input.shiftKey, e);
  }, 50);
}
function ao(t, e, n, r, i) {
  let s = og(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, s || G.empty)))
    return !0;
  if (!s)
    return !1;
  let o = vE(s), a = o ? t.state.tr.replaceSelectionWith(o, t.input.shiftKey) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
mt.paste = (t, e) => {
  let n = e;
  if (t.composing && !un)
    return;
  let r = is ? null : n.clipboardData;
  r && ao(t, r.getData("text/plain"), r.getData("text/html"), t.input.shiftKey, n) ? n.preventDefault() : DE(t, n);
};
class ME {
  constructor(e, n) {
    this.slice = e, this.move = n;
  }
}
const gg = zt ? "altKey" : "ctrlKey";
pt.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, s = i.empty ? null : t.posAtCoords(Al(n));
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ne ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      t.dispatch(t.state.tr.setSelection(ne.create(t.state.doc, r.mightDrag.pos)));
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && t.dispatch(t.state.tr.setSelection(ne.create(t.state.doc, u.posBefore)));
    }
  }
  let o = t.state.selection.content(), { dom: a, text: l } = sg(t, o);
  n.dataTransfer.clearData(), n.dataTransfer.setData(is ? "Text" : "text/html", a.innerHTML), n.dataTransfer.effectAllowed = "copyMove", is || n.dataTransfer.setData("text/plain", l), t.dragging = new ME(o, !n[gg]);
};
pt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
mt.dragover = mt.dragenter = (t, e) => e.preventDefault();
mt.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(Al(n));
  if (!i)
    return;
  let s = t.state.doc.resolve(i.pos), o = r && r.slice;
  o ? t.someProp("transformPasted", (m) => {
    o = m(o, t);
  }) : o = og(t, n.dataTransfer.getData(is ? "Text" : "text/plain"), is ? null : n.dataTransfer.getData("text/html"), !1, s);
  let a = !!(r && !n[gg]);
  if (t.someProp("handleDrop", (m) => m(t, n, o || G.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? pT(t.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let u = t.state.tr;
  a && u.deleteSelection();
  let c = u.mapping.map(l), f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, d = u.doc;
  if (f ? u.replaceRangeWith(c, c, o.content.firstChild) : u.replaceRange(c, c, o), u.doc.eq(d))
    return;
  let h = u.doc.resolve(c);
  if (f && ne.isSelectable(o.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(o.content.firstChild))
    u.setSelection(new ne(h));
  else {
    let m = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((g, T, E, _) => m = _), u.setSelection(Nc(t, h, u.doc.resolve(m)));
  }
  t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
pt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Yn(t);
  }, 20));
};
pt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
pt.beforeinput = (t, e) => {
  if (ft && un && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, Wr(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in mt)
  pt[t] = mt[t];
function lo(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class wc {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || ii, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: s, deleted: o } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new bt(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof wc && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && lo(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Cr {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ii;
  }
  map(e, n, r, i) {
    let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new bt(s, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Cr && lo(this.attrs, e.attrs) && lo(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Cr;
  }
  destroy() {
  }
}
class vc {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ii;
  }
  map(e, n, r, i) {
    let s = e.mapResult(n.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(n.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new bt(s.pos - r, o.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), s;
    return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof vc && lo(this.attrs, e.attrs) && lo(this.spec, e.spec);
  }
  destroy() {
  }
}
class bt {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new bt(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new bt(e, e, new wc(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new bt(e, n, new Cr(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new bt(e, n, new vc(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Cr;
  }
}
const Ri = [], ii = {};
class Le {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Ri, this.children = n.length ? n : Ri;
  }
  /**
  Create a set of decorations, using the structure of the given
  document.
  */
  static create(e, n) {
    return n.length ? La(n, e, 0, ii) : it;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, r, i + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == it || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || ii);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? IE(this.children, o || [], e, n, r, i, s) : o ? new Le(o.sort(si), Ri) : it;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Needs access to the current document to
  create the appropriate tree structure.
  */
  add(e, n) {
    return n.length ? this == it ? Le.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, s = 0;
    e.forEach((a, l) => {
      let u = l + r, c;
      if (c = Eg(n, a, u)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
          s += 3;
        i[s] == l ? i[s + 2] = i[s + 2].addInner(a, c, u + 1) : i.splice(s, 0, l, l + a.nodeSize, La(c, a, u + 1, ii)), s += 3;
      }
    });
    let o = Tg(s ? yg(n) : n, -r);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new Le(o.length ? this.local.concat(o).sort(si) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == it ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, a = r[s] + n, l = r[s + 1] + n;
      for (let c = 0, f; c < e.length; c++)
        (f = e[c]) && f.from > a && f.to < l && (e[c] = null, (o || (o = [])).push(f));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[s + 2].removeInner(o, a + 1);
      u != it ? r[s + 2] = u : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Le(i, r) : it;
  }
  /**
  @internal
  */
  forChild(e, n) {
    if (this == it)
      return this;
    if (n.isLeaf)
      return Le.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof Cr) {
        let u = Math.max(s, l.from) - s, c = Math.min(o, l.to) - s;
        u < c && (i || (i = [])).push(l.copy(u, c));
      }
    }
    if (i) {
      let a = new Le(i.sort(si), Ri);
      return r ? new mr([a, r]) : a;
    }
    return r || it;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Le) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Dc(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == it)
      return Ri;
    if (e.inlineContent || !this.local.some(Cr.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Cr || n.push(this.local[r]);
    return n;
  }
}
Le.empty = new Le([], []);
Le.removeOverlap = Dc;
const it = Le.empty;
class mr {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, ii));
    return mr.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Le.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, n);
      s != it && (s instanceof mr ? r = r.concat(s.members) : r.push(s));
    }
    return mr.from(r);
  }
  eq(e) {
    if (!(e instanceof mr) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!n)
          n = s;
        else {
          r && (n = n.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            n.push(s[o]);
        }
    }
    return n ? Dc(r ? n : n.sort(si)) : Ri;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return it;
      case 1:
        return e[0];
      default:
        return new mr(e.every((n) => n instanceof Le) ? e : e.reduce((n, r) => n.concat(r instanceof Le ? r : r.members), []));
    }
  }
}
function IE(t, e, n, r, i, s, o) {
  let a = t.slice();
  for (let u = 0, c = s; u < n.maps.length; u++) {
    let f = 0;
    n.maps[u].forEach((d, h, m, g) => {
      let T = g - m - (h - d);
      for (let E = 0; E < a.length; E += 3) {
        let _ = a[E + 1];
        if (_ < 0 || d > _ + c - f)
          continue;
        let k = a[E] + c - f;
        h >= k ? a[E + 1] = d <= k ? -2 : -1 : m >= i && T && (a[E] += T, a[E + 1] += T);
      }
      f += T;
    }), c = n.maps[u].map(c, -1);
  }
  let l = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        l = !0, a[u + 1] = -1;
        continue;
      }
      let c = n.map(t[u] + s), f = c - i;
      if (f < 0 || f >= r.content.size) {
        l = !0;
        continue;
      }
      let d = n.map(t[u + 1] + s, -1), h = d - i, { index: m, offset: g } = r.content.findIndex(f), T = r.maybeChild(m);
      if (T && g == f && g + T.nodeSize == h) {
        let E = a[u + 2].mapInner(n, T, c + 1, t[u] + s + 1, o);
        E != it ? (a[u] = f, a[u + 1] = h, a[u + 2] = E) : (a[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = RE(a, t, e, n, i, s, o), c = La(u, r, 0, o);
    e = c.local;
    for (let f = 0; f < a.length; f += 3)
      a[f + 1] < 0 && (a.splice(f, 3), f -= 3);
    for (let f = 0, d = 0; f < c.children.length; f += 3) {
      let h = c.children[f];
      for (; d < a.length && a[d] < h; )
        d += 3;
      a.splice(d, 0, c.children[f], c.children[f + 1], c.children[f + 2]);
    }
  }
  return new Le(e.sort(si), a);
}
function Tg(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new bt(i.from + e, i.to + e, i.type));
  }
  return n;
}
function RE(t, e, n, r, i, s, o) {
  function a(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let f = l.local[c].map(r, i, u);
      f ? n.push(f) : o.onRemove && o.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return n;
}
function Eg(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < r && ((i || (i = [])).push(o), t[s] = null);
  return i;
}
function yg(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function La(t, e, n, r) {
  let i = [], s = !1;
  e.forEach((a, l) => {
    let u = Eg(t, a, l + n);
    if (u) {
      s = !0;
      let c = La(u, a, n + l + 1, r);
      c != it && i.push(l, l + a.nodeSize, c);
    }
  });
  let o = Tg(s ? yg(t) : t, -n).sort(si);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || i.length ? new Le(o, i) : it;
}
function si(t, e) {
  return t.from - e.from || t.to - e.to;
}
function Dc(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == t && (e = t.slice()), e[i] = s.copy(s.from, r.to), Sd(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, s.from), Sd(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Sd(t, e, n) {
  for (; e < t.length && si(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function h1(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != it && e.push(r);
  }), t.cursorWrapper && e.push(Le.create(t.state.doc, [t.cursorWrapper.deco])), mr.from(e);
}
const LE = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, PE = Ct && br <= 11;
class BE {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class FE {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new BE(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Ct && br <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), PE && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, LE)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Td(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Yn(this.view);
      if (Ct && br <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && ui(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = oo(s))
      n.add(s);
    for (let s = e.anchorNode; s; s = oo(s))
      if (n.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.observer ? this.observer.takeRecords() : [];
    this.queue.length && (n = this.queue.concat(n), this.queue.length = 0);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Td(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let c = 0; c < n.length; c++) {
        let f = this.registerMutation(n[c], l);
        f && (s = s < 0 ? f.from : Math.min(f.from, s), o = o < 0 ? f.to : Math.max(f.to, o), f.typeOver && (a = !0));
      }
    if (mn && l.length > 1) {
      let c = l.filter((f) => f.nodeName == "BR");
      if (c.length == 2) {
        let f = c[0], d = c[1];
        f.parentNode && f.parentNode.parentNode == d.parentNode ? d.remove() : f.remove();
      }
    }
    let u = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Tl(r) && (u = Sc(e)) && u.eq(le.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Yn(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), HE(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Yn(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let c = 0; c < e.addedNodes.length; c++)
        n.push(e.addedNodes[c]);
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (Ct && br <= 11 && e.addedNodes.length)
        for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: f, nextSibling: d } = e.addedNodes[c];
          (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f), (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d);
        }
      let o = i && i.parentNode == e.target ? It(i) + 1 : 0, a = r.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? It(s) : e.target.childNodes.length, u = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: u };
    } else
      return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : {
        from: r.posAtStart,
        to: r.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      };
  }
}
let Nd = /* @__PURE__ */ new WeakMap(), kd = !1;
function HE(t) {
  if (!Nd.has(t) && (Nd.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = mn, kd)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), kd = !0;
  }
}
function UE(t) {
  let e;
  function n(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  t.dom.addEventListener("beforeinput", n, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", n, !0);
  let r = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.domAtPos(t.state.selection.anchor);
  return ui(a.node, a.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };
}
function qE(t, e, n) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), u, c = l.anchorNode;
  if (c && t.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (u = [{ node: c, offset: l.anchorOffset }], Tl(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), ft && t.input.lastKeyCode === 8)
    for (let T = s; T > i; T--) {
      let E = r.childNodes[T - 1], _ = E.pmViewDesc;
      if (E.nodeName == "BR" && !_) {
        s = T;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let f = t.state.doc, d = t.someProp("domParser") || li.fromSchema(t.state.schema), h = f.resolve(o), m = null, g = d.parse(r, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: zE,
    context: h
  });
  if (u && u[0].pos != null) {
    let T = u[0].pos, E = u[1] && u[1].pos;
    E == null && (E = T), m = { anchor: T + o, head: E + o };
  }
  return { doc: g, sel: m, from: o, to: a };
}
function zE(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (ht && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || ht && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const $E = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function VE(t, e, n, r, i) {
  if (e < 0) {
    let O = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, P = Sc(t, O);
    if (P && !t.state.selection.eq(P)) {
      if (ft && un && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (M) => M(t, Wr(13, "Enter"))))
        return;
      let $ = t.state.tr.setSelection(P);
      O == "pointer" ? $.setMeta("pointer", !0) : O == "key" && $.scrollIntoView(), t.dispatch($);
    }
    return;
  }
  let s = t.state.doc.resolve(e), o = s.sharedDepth(n);
  e = s.before(o + 1), n = t.state.doc.resolve(n).after(o + 1);
  let a = t.state.selection, l = qE(t, e, n), u = t.state.doc, c = u.slice(l.from, l.to), f, d;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, d = "end") : (f = t.state.selection.from, d = "start"), t.input.lastKeyCode = null;
  let h = KE(c.content, l.doc.content, l.from, f, d);
  if ((rs && t.input.lastIOSEnter > Date.now() - 225 || un) && i.some((O) => O.nodeType == 1 && !$E.test(O.nodeName)) && (!h || h.endA >= h.endB) && t.someProp("handleKeyDown", (O) => O(t, Wr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!h)
    if (r && a instanceof ce && !a.empty && a.$head.sameParent(a.$anchor) && !t.composing && !(l.sel && l.sel.anchor != l.sel.head))
      h = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (l.sel) {
        let O = _d(t, t.state.doc, l.sel);
        O && !O.eq(t.state.selection) && t.dispatch(t.state.tr.setSelection(O));
      }
      return;
    }
  if (ft && t.cursorWrapper && l.sel && l.sel.anchor == t.cursorWrapper.deco.from && l.sel.head == l.sel.anchor) {
    let O = h.endB - h.start;
    l.sel = { anchor: l.sel.anchor + O, head: l.sel.anchor + O };
  }
  t.input.domChangeCount++, t.state.selection.from < t.state.selection.to && h.start == h.endB && t.state.selection instanceof ce && (h.start > t.state.selection.from && h.start <= t.state.selection.from + 2 && t.state.selection.from >= l.from ? h.start = t.state.selection.from : h.endA < t.state.selection.to && h.endA >= t.state.selection.to - 2 && t.state.selection.to <= l.to && (h.endB += t.state.selection.to - h.endA, h.endA = t.state.selection.to)), Ct && br <= 11 && h.endB == h.start + 1 && h.endA == h.start && h.start > l.from && l.doc.textBetween(h.start - l.from - 1, h.start - l.from + 1) == "  " && (h.start--, h.endA--, h.endB--);
  let m = l.doc.resolveNoCache(h.start - l.from), g = l.doc.resolveNoCache(h.endB - l.from), T = u.resolve(h.start), E = m.sameParent(g) && m.parent.inlineContent && T.end() >= h.endA, _;
  if ((rs && t.input.lastIOSEnter > Date.now() - 225 && (!E || i.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !E && m.pos < l.doc.content.size && (_ = le.findFrom(l.doc.resolve(m.pos + 1), 1, !0)) && _.head == g.pos) && t.someProp("handleKeyDown", (O) => O(t, Wr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > h.start && jE(u, h.start, h.endA, m, g) && t.someProp("handleKeyDown", (O) => O(t, Wr(8, "Backspace")))) {
    un && ft && t.domObserver.suppressSelectionUpdates();
    return;
  }
  ft && un && h.endB == h.start && (t.input.lastAndroidDelete = Date.now()), un && !E && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == h.endA && (h.endB -= 2, g = l.doc.resolveNoCache(h.endB - l.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(O) {
      return O(t, Wr(13, "Enter"));
    });
  }, 20));
  let k = h.start, A = h.endA, v, y, b;
  if (E) {
    if (m.pos == g.pos)
      Ct && br <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Yn(t), 20)), v = t.state.tr.delete(k, A), y = u.resolve(h.start).marksAcross(u.resolve(h.endA));
    else if (
      // Adding or removing a mark
      h.endA == h.endB && (b = GE(m.parent.content.cut(m.parentOffset, g.parentOffset), T.parent.content.cut(T.parentOffset, h.endA - T.start())))
    )
      v = t.state.tr, b.type == "add" ? v.addMark(k, A, b.mark) : v.removeMark(k, A, b.mark);
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let O = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (t.someProp("handleTextInput", (P) => P(t, k, A, O)))
        return;
      v = t.state.tr.insertText(O, k, A);
    }
  }
  if (v || (v = t.state.tr.replace(k, A, l.doc.slice(h.start - l.from, h.endB - l.from))), l.sel) {
    let O = _d(t, v.doc, l.sel);
    O && !(ft && un && t.composing && O.empty && (h.start != h.endB || t.input.lastAndroidDelete < Date.now() - 100) && (O.head == k || O.head == v.mapping.map(A) - 1) || Ct && O.empty && O.head == k) && v.setSelection(O);
  }
  y && v.ensureMarks(y), t.dispatch(v.scrollIntoView());
}
function _d(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : Nc(t, e.resolve(n.anchor), e.resolve(n.head));
}
function GE(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, s = r, o, a, l;
  for (let c = 0; c < r.length; c++)
    i = r[c].removeFromSet(i);
  for (let c = 0; c < n.length; c++)
    s = n[c].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    a = i[0], o = "add", l = (c) => c.mark(a.addToSet(c.marks));
  else if (i.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (c) => c.mark(a.removeFromSet(c.marks));
  else
    return null;
  let u = [];
  for (let c = 0; c < e.childCount; c++)
    u.push(l(e.child(c)));
  if (B.from(u).eq(t))
    return { mark: a, type: o };
}
function jE(t, e, n, r, i) {
  if (!r.parent.isTextblock || // The content must have shrunk
  n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
  p1(r, !0, !1) < i.pos)
    return !1;
  let s = t.resolve(e);
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = t.resolve(p1(s, !0, !0));
  return !o.parent.isTextblock || o.pos > n || p1(o, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function p1(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let s = t.node(r).maybeChild(t.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function KE(t, e, n, r, i) {
  let s = t.findDiffStart(e, n);
  if (s == null)
    return null;
  let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && t.size < e.size) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
class WE {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new pE(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Md), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = vd(this), wd(this), this.nodeViews = Dd(this), this.docView = fd(this.state.doc, Od(this), h1(this), this.dom, this), this.domObserver = new FE(this, (r, i, s, o) => VE(this, r, i, s, o)), this.domObserver.start(), mE(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Hu(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Md), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    let r = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (mg(this), s = !0), this.state = e;
    let o = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (o || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let d = Dd(this);
      QE(d, this.nodeViews) && (this.nodeViews = d, i = !0);
    }
    (o || n.handleDOMEvents != this._props.handleDOMEvents) && Hu(this), this.editable = vd(this), wd(this);
    let a = h1(this), l = Od(this), u = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", c = i || !this.docView.matchesNode(e.doc, l, a);
    (c || !e.selection.eq(r.selection)) && (s = !0);
    let f = u == "preserve" && s && this.dom.style.overflowAnchor == null && IT(this);
    if (s) {
      this.domObserver.stop();
      let d = c && (Ct || ft) && !this.composing && !r.selection.empty && !e.selection.empty && YE(r.selection, e.selection);
      if (c) {
        let h = ft ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (i || !this.docView.update(e.doc, l, a, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = fd(e.doc, l, a, this.dom, this)), h && !this.trackWrites && (d = !0);
      }
      d || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && iE(this)) ? Yn(this, d) : (ng(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && RT(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this)))
      if (this.state.selection instanceof ne) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && od(this, n.getBoundingClientRect(), e);
      } else
        od(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ct) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && LT(this.dom), Yn(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return UT(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return W0(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return GT(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return ao(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return ao(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (gE(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], h1(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return EE(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return ht && this.root.nodeType === 11 && OT(this.dom.ownerDocument) == this.dom ? UE(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function Od(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), e.translate = "no", t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" && (e.class += " " + n[r]), r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), [bt.node(0, t.state.doc.content.size, e)];
}
function wd(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: bt.widget(t.state.selection.head, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function vd(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function YE(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function Dd(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function QE(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function Md(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var _r = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Pa = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Id = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), JE = typeof navigator < "u" && /Mac/.test(navigator.platform), XE = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), ZE = JE || Id && +Id[1] < 57;
for (var tt = 0; tt < 10; tt++)
  _r[48 + tt] = _r[96 + tt] = String(tt);
for (var tt = 1; tt <= 24; tt++)
  _r[tt + 111] = "F" + tt;
for (var tt = 65; tt <= 90; tt++)
  _r[tt] = String.fromCharCode(tt + 32), Pa[tt] = String.fromCharCode(tt);
for (var m1 in _r)
  Pa.hasOwnProperty(m1) || (Pa[m1] = _r[m1]);
function e8(t) {
  var e = ZE && (t.ctrlKey || t.altKey || t.metaKey) || XE && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Pa : _r)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const t8 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function n8(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      t8 ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), o && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function r8(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[n8(n)] = t[n];
  return e;
}
function g1(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function i8(t) {
  return new Be({ props: { handleKeyDown: Ag(t) } });
}
function Ag(t) {
  let e = r8(t);
  return function(n, r) {
    let i = e8(r), s, o = e[g1(i, r)];
    if (o && o(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = e[g1(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (s = _r[r.keyCode]) && s != i) {
        let a = e[g1(s, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const s8 = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function o8(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const a8 = (t, e, n) => {
  let r = o8(t, n);
  if (!r)
    return !1;
  let i = bg(r);
  if (!i) {
    let o = r.blockRange(), a = o && hs(o);
    return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (!s.type.spec.isolating && Sg(t, i, e))
    return !0;
  if (r.parent.content.size == 0 && (ss(s, "end") || ne.isSelectable(s))) {
    let o = bc(t.doc, r.before(), r.after(), G.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(ss(s, "end") ? le.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : ne.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
};
function ss(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const l8 = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    s = bg(r);
  }
  let o = s && s.nodeBefore;
  return !o || !ne.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function bg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function u8(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const c8 = (t, e, n) => {
  let r = u8(t, n);
  if (!r)
    return !1;
  let i = Cg(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (Sg(t, i, e))
    return !0;
  if (r.parent.content.size == 0 && (ss(s, "start") || ne.isSelectable(s))) {
    let o = bc(t.doc, r.before(), r.after(), G.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(ss(s, "start") ? le.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ne.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, f8 = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    s = Cg(r);
  }
  let o = s && s.nodeAfter;
  return !o || !ne.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ne.create(t.doc, s.pos)).scrollIntoView()), !0);
};
function Cg(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const d8 = (t, e) => {
  let n = t.selection, r = n instanceof ne, i;
  if (r) {
    if (n.node.isTextblock || !Or(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = L0(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let s = t.tr.join(i);
    r && s.setSelection(ne.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, h8 = (t, e) => {
  let n = t.selection, r;
  if (n instanceof ne) {
    if (n.node.isTextblock || !Or(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = L0(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, p8 = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), s = i && hs(i);
  return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()), !0);
}, m8 = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function xg(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const g8 = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), s = n.indexAfter(-1), o = xg(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(le.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, T8 = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof dn || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = xg(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = t.tr.insert(o, s.createAndFill());
    a.setSelection(ce.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, E8 = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let s = n.before();
    if (Yi(t.doc, s))
      return e && e(t.tr.split(s).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && hs(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, y8 = (t, e) => {
  let { $from: n, to: r } = t.selection, i, s = n.sharedDepth(r);
  return s == 0 ? !1 : (i = n.before(s), e && e(t.tr.setSelection(ne.create(t.doc, i))), !0);
};
function A8(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Or(t.doc, e.pos)) ? !1 : (n && n(t.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()), !0);
}
function Sg(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, s, o;
  if (r.type.spec.isolating || i.type.spec.isolating)
    return !1;
  if (A8(t, e, n))
    return !0;
  let a = e.parent.canReplace(e.index(), e.index() + 1);
  if (a && (s = (o = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && o.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let f = e.pos + i.nodeSize, d = B.empty;
      for (let g = s.length - 1; g >= 0; g--)
        d = B.from(s[g].create(null, d));
      d = B.from(r.copy(d));
      let h = t.tr.step(new Je(e.pos - 1, f, e.pos, f, new G(d, 1, 0), s.length, !0)), m = f + 2 * s.length;
      Or(h.doc, m) && h.join(m), n(h.scrollIntoView());
    }
    return !0;
  }
  let l = le.findFrom(e, 1), u = l && l.$from.blockRange(l.$to), c = u && hs(u);
  if (c != null && c >= e.depth)
    return n && n(t.tr.lift(u, c).scrollIntoView()), !0;
  if (a && ss(i, "start", !0) && ss(r, "end")) {
    let f = r, d = [];
    for (; d.push(f), !f.isTextblock; )
      f = f.lastChild;
    let h = i, m = 1;
    for (; !h.isTextblock; h = h.firstChild)
      m++;
    if (f.canReplace(f.childCount, f.childCount, h.content)) {
      if (n) {
        let g = B.empty;
        for (let E = d.length - 1; E >= 0; E--)
          g = B.from(d[E].copy(g));
        let T = t.tr.step(new Je(e.pos - d.length, e.pos + i.nodeSize, e.pos + m, e.pos + i.nodeSize - m, new G(g, d.length, 0), 0, !0));
        n(T.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Ng(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (n && n(e.tr.setSelection(ce.create(e.doc, t < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const b8 = Ng(-1), C8 = Ng(1);
function x8(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = o && Ac(o, t, e);
    return a ? (r && r(n.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function Rd(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let s = 0; s < n.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[s];
      n.doc.nodesBetween(o, a, (l, u) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let c = n.doc.resolve(u), f = c.index();
            i = c.parent.canReplaceWith(f, f + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = n.tr;
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
        s.setBlockType(a, l, t, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function S8(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: s } = n.selection, o = i.blockRange(s), a = !1, l = o;
    if (!o)
      return !1;
    if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
      if (i.index(o.depth - 1) == 0)
        return !1;
      let c = n.doc.resolve(o.start - 2);
      l = new wa(c, c, o.depth), o.endIndex < o.parent.childCount && (o = new wa(i, n.doc.resolve(s.end(o.depth)), o.depth)), a = !0;
    }
    let u = Ac(l, t, e, o);
    return u ? (r && r(N8(n.tr, o, u, a, t).scrollIntoView()), !0) : !1;
  };
}
function N8(t, e, n, r, i) {
  let s = B.empty;
  for (let c = n.length - 1; c >= 0; c--)
    s = B.from(n[c].type.create(n[c].attrs, s));
  t.step(new Je(e.start - (r ? 2 : 0), e.end, e.start, e.end, new G(s, 0, 0), n.length, !0));
  let o = 0;
  for (let c = 0; c < n.length; c++)
    n[c].type == i && (o = c + 1);
  let a = n.length - o, l = e.start + n.length - (r ? 2 : 0), u = e.parent;
  for (let c = e.startIndex, f = e.endIndex, d = !0; c < f; c++, d = !1)
    !d && Yi(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += u.child(c).nodeSize;
  return t;
}
function k8(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == t);
    return s ? n ? r.node(s.depth - 1).type == t ? _8(e, n, t, s) : O8(e, n, s) : !0 : !1;
  };
}
function _8(t, e, n, r) {
  let i = t.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Je(s - 1, o, s, o, new G(B.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new wa(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const a = hs(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.mapping.map(s, -1) - 1;
  return Or(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function O8(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let h = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
    h -= i.child(m).nodeSize, r.delete(h - 1, h + 1);
  let s = r.doc.resolve(n.start), o = s.nodeAfter;
  if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == i.childCount, u = s.node(-1), c = s.index(-1);
  if (!u.canReplace(c + (a ? 0 : 1), c + 1, o.content.append(l ? B.empty : B.from(i))))
    return !1;
  let f = s.pos, d = f + o.nodeSize;
  return r.step(new Je(f - (a ? 1 : 0), d + (l ? 1 : 0), f + 1, d - 1, new G((a ? B.empty : B.from(i.copy(B.empty))).append(l ? B.empty : B.from(i.copy(B.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function w8(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == t);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == a.type, c = B.from(u ? t.create() : null), f = new G(B.from(t.create(null, B.from(a.type.create(null, c)))), u ? 3 : 1, 0), d = s.start, h = s.end;
      n(e.tr.step(new Je(d - (u ? 3 : 1), h, d, h, f, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function bl(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: i } = n, { storedMarks: s } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    filterTransaction: e.filterTransaction,
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, s = n.storedMarks, n;
    }
  };
}
class Cl {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: s } = r, o = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...c) => {
      const f = l(...c)(o);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), f;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, a = [], l = !!e, u = e || s.tr, c = () => (!l && n && !u.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(u), a.every((d) => d === !0)), f = {
      ...Object.fromEntries(Object.entries(r).map(([d, h]) => [d, (...g) => {
        const T = this.buildProps(u, n), E = h(...g)(T);
        return a.push(E), f;
      }])),
      run: c
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, i = !1, s = e || r.tr, o = this.buildProps(s, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, u]) => [l, (...c) => u(...c)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(s, i)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: s } = this, { view: o } = i;
    s.storedMarks && e.setStoredMarks(s.storedMarks);
    const a = {
      tr: e,
      editor: i,
      view: o,
      state: bl({
        state: s,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, u]) => [l, (...c) => u(...c)(a)]));
      }
    };
    return a;
  }
}
class v8 {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function W(t, e, n) {
  return t.config[e] === void 0 && t.parent ? W(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? W(t.parent, e, n) : null
  }) : t.config[e];
}
function xl(t) {
  const e = t.filter((i) => i.type === "extension"), n = t.filter((i) => i.type === "node"), r = t.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function kg(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = xl(t), i = [...n, ...r], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = W(o, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((c) => {
      c.types.forEach((f) => {
        Object.entries(c.attributes).forEach(([d, h]) => {
          e.push({
            type: f,
            name: d,
            attribute: {
              ...s,
              ...h
            }
          });
        });
      });
    });
  }), i.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = W(o, "addAttributes", a);
    if (!l)
      return;
    const u = l();
    Object.entries(u).forEach(([c, f]) => {
      const d = {
        ...s,
        ...f
      };
      f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete d.default, e.push({
        type: o.name,
        name: c,
        attribute: d
      });
    });
  }), e;
}
function Xe(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Pe(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([i, s]) => {
      if (!r[i]) {
        r[i] = s;
        return;
      }
      i === "class" ? r[i] = [r[i], s].join(" ") : i === "style" ? r[i] = [r[i], s].join("; ") : r[i] = s;
    }), r;
  }, {});
}
function Uu(t, e) {
  return e.filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => Pe(n, r), {});
}
function _g(t) {
  return typeof t == "function";
}
function ae(t, e = void 0, ...n) {
  return _g(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function D8(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function M8(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function Ld(t, e) {
  return t.style ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((s, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : M8(n.getAttribute(o.name));
        return a == null ? s : {
          ...s,
          [o.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function Pd(t) {
  return Object.fromEntries(Object.entries(t).filter(([e, n]) => e === "attrs" && D8(n) ? !1 : n != null));
}
function Og(t) {
  var e;
  const n = kg(t), { nodeExtensions: r, markExtensions: i } = xl(t), s = (e = r.find((l) => W(l, "topNode"))) === null || e === void 0 ? void 0 : e.name, o = Object.fromEntries(r.map((l) => {
    const u = n.filter((T) => T.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage
    }, f = t.reduce((T, E) => {
      const _ = W(E, "extendNodeSchema", c);
      return {
        ...T,
        ..._ ? _(l) : {}
      };
    }, {}), d = Pd({
      ...f,
      content: ae(W(l, "content", c)),
      marks: ae(W(l, "marks", c)),
      group: ae(W(l, "group", c)),
      inline: ae(W(l, "inline", c)),
      atom: ae(W(l, "atom", c)),
      selectable: ae(W(l, "selectable", c)),
      draggable: ae(W(l, "draggable", c)),
      code: ae(W(l, "code", c)),
      defining: ae(W(l, "defining", c)),
      isolating: ae(W(l, "isolating", c)),
      attrs: Object.fromEntries(u.map((T) => {
        var E;
        return [T.name, { default: (E = T == null ? void 0 : T.attribute) === null || E === void 0 ? void 0 : E.default }];
      }))
    }), h = ae(W(l, "parseHTML", c));
    h && (d.parseDOM = h.map((T) => Ld(T, u)));
    const m = W(l, "renderHTML", c);
    m && (d.toDOM = (T) => m({
      node: T,
      HTMLAttributes: Uu(T, u)
    }));
    const g = W(l, "renderText", c);
    return g && (d.toText = g), [l.name, d];
  })), a = Object.fromEntries(i.map((l) => {
    const u = n.filter((g) => g.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage
    }, f = t.reduce((g, T) => {
      const E = W(T, "extendMarkSchema", c);
      return {
        ...g,
        ...E ? E(l) : {}
      };
    }, {}), d = Pd({
      ...f,
      inclusive: ae(W(l, "inclusive", c)),
      excludes: ae(W(l, "excludes", c)),
      group: ae(W(l, "group", c)),
      spanning: ae(W(l, "spanning", c)),
      code: ae(W(l, "code", c)),
      attrs: Object.fromEntries(u.map((g) => {
        var T;
        return [g.name, { default: (T = g == null ? void 0 : g.attribute) === null || T === void 0 ? void 0 : T.default }];
      }))
    }), h = ae(W(l, "parseHTML", c));
    h && (d.parseDOM = h.map((g) => Ld(g, u)));
    const m = W(l, "renderHTML", c);
    return m && (d.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: Uu(g, u)
    })), [l.name, d];
  }));
  return new G4({
    topNode: s,
    nodes: o,
    marks: a
  });
}
function T1(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function Bd(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
const I8 = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, a) => {
    var l, u;
    const c = ((u = (l = i.type.spec).toText) === null || u === void 0 ? void 0 : u.call(l, {
      node: i,
      pos: s,
      parent: o,
      index: a
    })) || i.textContent || "%leaf%";
    n += c.slice(0, Math.max(0, r - s));
  }), n;
};
function Mc(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Sl {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const R8 = (t, e) => {
  if (Mc(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function E1(t) {
  var e;
  const { editor: n, from: r, to: i, text: s, rules: o, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const u = l.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || !((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) && e.marks.find((d) => d.type.spec.code)
  )
    return !1;
  let c = !1;
  const f = I8(u) + s;
  return o.forEach((d) => {
    if (c)
      return;
    const h = R8(f, d.find);
    if (!h)
      return;
    const m = l.state.tr, g = bl({
      state: l.state,
      transaction: m
    }), T = {
      from: r - (h[0].length - s.length),
      to: i
    }, { commands: E, chain: _, can: k } = new Cl({
      editor: n,
      state: g
    });
    d.handler({
      state: g,
      range: T,
      match: h,
      commands: E,
      chain: _,
      can: k
    }) === null || !m.steps.length || (m.setMeta(a, {
      transform: m,
      from: r,
      to: i,
      text: s
    }), l.dispatch(m), c = !0);
  }), c;
}
function L8(t) {
  const { editor: e, rules: n } = t, r = new Be({
    state: {
      init() {
        return null;
      },
      apply(i, s) {
        const o = i.getMeta(r);
        return o || (i.selectionSet || i.docChanged ? null : s);
      }
    },
    props: {
      handleTextInput(i, s, o, a) {
        return E1({
          editor: e,
          from: s,
          to: o,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: s } = i.state.selection;
          s && E1({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = i.state.selection;
        return o ? E1({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function P8(t) {
  return typeof t == "number";
}
class B8 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const F8 = (t, e) => {
  if (Mc(e))
    return [...t.matchAll(e)];
  const n = e(t);
  return n ? n.map((r) => {
    const i = [r.text];
    return i.index = r.index, i.input = t, i.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(r.replaceWith)), i;
  }) : [];
};
function H8(t) {
  const { editor: e, state: n, from: r, to: i, rule: s } = t, { commands: o, chain: a, can: l } = new Cl({
    editor: e,
    state: n
  }), u = [];
  return n.doc.nodesBetween(r, i, (f, d) => {
    if (!f.isTextblock || f.type.spec.code)
      return;
    const h = Math.max(r, d), m = Math.min(i, d + f.content.size), g = f.textBetween(h - d, m - d, void 0, "￼");
    F8(g, s.find).forEach((E) => {
      if (E.index === void 0)
        return;
      const _ = h + E.index + 1, k = _ + E[0].length, A = {
        from: n.tr.mapping.map(_),
        to: n.tr.mapping.map(k)
      }, v = s.handler({
        state: n,
        range: A,
        match: E,
        commands: o,
        chain: a,
        can: l
      });
      u.push(v);
    });
  }), u.every((f) => f !== null);
}
function U8(t) {
  const { editor: e, rules: n } = t;
  let r = null, i = !1, s = !1;
  return n.map((a) => new Be({
    // we register a global drag handler to track the current drag source element
    view(l) {
      const u = (c) => {
        var f;
        r = !((f = l.dom.parentElement) === null || f === void 0) && f.contains(c.target) ? l.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", u), {
        destroy() {
          window.removeEventListener("dragstart", u);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (l) => (s = r === l.dom.parentElement, !1),
        paste: (l, u) => {
          var c;
          const f = (c = u.clipboardData) === null || c === void 0 ? void 0 : c.getData("text/html");
          return i = !!(f != null && f.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (l, u, c) => {
      const f = l[0], d = f.getMeta("uiEvent") === "paste" && !i, h = f.getMeta("uiEvent") === "drop" && !s;
      if (!d && !h)
        return;
      const m = u.doc.content.findDiffStart(c.doc.content), g = u.doc.content.findDiffEnd(c.doc.content);
      if (!P8(m) || !g || m === g.b)
        return;
      const T = c.tr, E = bl({
        state: c,
        transaction: T
      });
      if (!(!H8({
        editor: e,
        state: E,
        from: Math.max(m - 1, 0),
        to: g.b - 1,
        rule: a
      }) || !T.steps.length))
        return T;
    }
  }));
}
function q8(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return [...new Set(e)];
}
class Zr {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Zr.resolve(e), this.schema = Og(this.extensions), this.extensions.forEach((r) => {
      var i;
      this.editor.extensionStorage[r.name] = r.storage;
      const s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: this.editor,
        type: T1(r.name, this.schema)
      };
      r.type === "mark" && (!((i = ae(W(r, "keepOnSplit", s))) !== null && i !== void 0) || i) && this.splittableMarks.push(r.name);
      const o = W(r, "onBeforeCreate", s);
      o && this.editor.on("beforeCreate", o);
      const a = W(r, "onCreate", s);
      a && this.editor.on("create", a);
      const l = W(r, "onUpdate", s);
      l && this.editor.on("update", l);
      const u = W(r, "onSelectionUpdate", s);
      u && this.editor.on("selectionUpdate", u);
      const c = W(r, "onTransaction", s);
      c && this.editor.on("transaction", c);
      const f = W(r, "onFocus", s);
      f && this.editor.on("focus", f);
      const d = W(r, "onBlur", s);
      d && this.editor.on("blur", d);
      const h = W(r, "onDestroy", s);
      h && this.editor.on("destroy", h);
    });
  }
  static resolve(e) {
    const n = Zr.sort(Zr.flatten(e)), r = q8(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = W(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  static sort(e) {
    return e.sort((r, i) => {
      const s = W(r, "priority") || 100, o = W(i, "priority") || 100;
      return s > o ? -1 : s < o ? 1 : 0;
    });
  }
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: T1(n.name, this.schema)
      }, i = W(n, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  get plugins() {
    const { editor: e } = this, n = Zr.sort([...this.extensions].reverse()), r = [], i = [], s = n.map((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: T1(o.name, this.schema)
      }, l = [], u = W(o, "addKeyboardShortcuts", a);
      let c = {};
      if (o.type === "mark" && o.config.exitable && (c.ArrowRight = () => Wt.handleExit({ editor: e, mark: o })), u) {
        const g = Object.fromEntries(Object.entries(u()).map(([T, E]) => [T, () => E({ editor: e })]));
        c = { ...c, ...g };
      }
      const f = i8(c);
      l.push(f);
      const d = W(o, "addInputRules", a);
      Bd(o, e.options.enableInputRules) && d && r.push(...d());
      const h = W(o, "addPasteRules", a);
      Bd(o, e.options.enablePasteRules) && h && i.push(...h());
      const m = W(o, "addProseMirrorPlugins", a);
      if (m) {
        const g = m();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      L8({
        editor: e,
        rules: r
      }),
      ...U8({
        editor: e,
        rules: i
      }),
      ...s
    ];
  }
  get attributes() {
    return kg(this.extensions);
  }
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = xl(this.extensions);
    return Object.fromEntries(n.filter((r) => !!W(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Xe(r.name, this.schema)
      }, o = W(r, "addNodeView", s);
      if (!o)
        return [];
      const a = (l, u, c, f) => {
        const d = Uu(l, i);
        return o()({
          editor: e,
          node: l,
          getPos: c,
          decorations: f,
          HTMLAttributes: d,
          extension: r
        });
      };
      return [r.name, a];
    }));
  }
}
function z8(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function y1(t) {
  return z8(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Nl(t, e) {
  const n = { ...t };
  return y1(t) && y1(e) && Object.keys(e).forEach((r) => {
    y1(e[r]) ? r in t ? n[r] = Nl(t[r], e[r]) : Object.assign(n, { [r]: e[r] }) : Object.assign(n, { [r]: e[r] });
  }), n;
}
class Nt {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ae(W(this, "addOptions", {
      name: this.name
    }))), this.storage = ae(W(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Nt(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = Nl(this.options, e), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new Nt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ae(W(n, "addOptions", {
      name: n.name
    })), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function wg(t, e, n) {
  const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = n || {};
  let a = "", l = !0;
  return t.nodesBetween(r, i, (u, c, f, d) => {
    var h;
    const m = o == null ? void 0 : o[u.type.name];
    m ? (u.isBlock && !l && (a += s, l = !0), f && (a += m({
      node: u,
      pos: c,
      parent: f,
      index: d,
      range: e
    }))) : u.isText ? (a += (h = u == null ? void 0 : u.text) === null || h === void 0 ? void 0 : h.slice(Math.max(r, c) - c, i - c), l = !1) : u.isBlock && !l && (a += s, l = !0);
  }), a;
}
function vg(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const $8 = Nt.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map((c) => c.$from.pos)), a = Math.max(...s.map((c) => c.$to.pos)), l = vg(n);
            return wg(r, { from: o, to: a }, {
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), V8 = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), G8 = (t = !1) => ({ commands: e }) => e.setContent("", t), j8 = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: i } = r;
  return n && i.forEach(({ $from: s, $to: o }) => {
    t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: c } = e, f = u.resolve(c.map(l)), d = u.resolve(c.map(l + a.nodeSize)), h = f.blockRange(d);
      if (!h)
        return;
      const m = hs(h);
      if (a.type.isTextblock) {
        const { defaultType: g } = f.parent.contentMatchAt(f.index());
        e.setNodeMarkup(h.start, g);
      }
      (m || m === 0) && e.lift(h, m);
    });
  }), !0;
}, K8 = (t) => (e) => t(e), W8 = () => ({ state: t, dispatch: e }) => T8(t, e), Y8 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = t.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r.type) {
      if (e) {
        const a = i.before(s), l = i.after(s);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, Q8 = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const i = Xe(t, n.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === i) {
      if (r) {
        const l = s.before(o), u = s.after(o);
        e.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, J8 = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: i } = t;
  return n && e.delete(r, i), !0;
}, X8 = () => ({ state: t, dispatch: e }) => s8(t, e), Z8 = () => ({ commands: t }) => t.keyboardShortcut("Enter"), ey = () => ({ state: t, dispatch: e }) => g8(t, e);
function Ba(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => n.strict ? e[i] === t[i] : Mc(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0;
}
function qu(t, e, n = {}) {
  return t.find((r) => r.type === e && Ba(r.attrs, n));
}
function ty(t, e, n = {}) {
  return !!qu(t, e, n);
}
function Ic(t, e, n = {}) {
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)), !r.node)
    return;
  const i = qu([...r.node.marks], e, n);
  if (!i)
    return;
  let s = r.index, o = t.start() + r.offset, a = s + 1, l = o + r.node.nodeSize;
  for (qu([...r.node.marks], e, n); s > 0 && i.isInSet(t.parent.child(s - 1).marks); )
    s -= 1, o -= t.parent.child(s).nodeSize;
  for (; a < t.parent.childCount && ty([...t.parent.child(a).marks], e, n); )
    l += t.parent.child(a).nodeSize, a += 1;
  return {
    from: o,
    to: l
  };
}
function vr(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const ny = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const s = vr(t, r.schema), { doc: o, selection: a } = n, { $from: l, from: u, to: c } = a;
  if (i) {
    const f = Ic(l, s, e);
    if (f && f.from <= u && f.to >= c) {
      const d = ce.create(o, f.from, f.to);
      n.setSelection(d);
    }
  }
  return !0;
}, ry = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function Rc(t) {
  return t instanceof ce;
}
function Kn(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function Dg(t, e = null) {
  if (!e)
    return null;
  const n = le.atStart(t), r = le.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const i = n.from, s = r.to;
  return e === "all" ? ce.create(t, Kn(0, i, s), Kn(t.content.size, i, s)) : ce.create(t, Kn(e, i, s), Kn(e, i, s));
}
function Lc() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const iy = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    Lc() && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (s && t === null && !Rc(n.state.selection))
    return o(), !0;
  const a = Dg(i.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0;
}, sy = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })), oy = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e);
function Fd(t) {
  const e = `<body>${t}</body>`;
  return new window.DOMParser().parseFromString(e, "text/html").body;
}
function Fa(t, e, n) {
  if (n = {
    slice: !0,
    parseOptions: {},
    ...n
  }, typeof t == "object" && t !== null)
    try {
      return Array.isArray(t) && t.length > 0 ? B.fromArray(t.map((r) => e.nodeFromJSON(r))) : e.nodeFromJSON(t);
    } catch (r) {
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", r), Fa("", e, n);
    }
  if (typeof t == "string") {
    const r = li.fromSchema(e);
    return n.slice ? r.parseSlice(Fd(t), n.parseOptions).content : r.parse(Fd(t), n.parseOptions);
  }
  return Fa("", e, n);
}
function ay(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const i = t.steps[r];
  if (!(i instanceof st || i instanceof Je))
    return;
  const s = t.mapping.maps[r];
  let o = 0;
  s.forEach((a, l, u, c) => {
    o === 0 && (o = c);
  }), t.setSelection(le.near(t.doc.resolve(o), n));
}
const ly = (t) => t.toString().startsWith("<"), uy = (t, e, n) => ({ tr: r, dispatch: i, editor: s }) => {
  if (i) {
    n = {
      parseOptions: {},
      updateSelection: !0,
      ...n
    };
    const o = Fa(e, s.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...n.parseOptions
      }
    });
    if (o.toString() === "<>")
      return !0;
    let { from: a, to: l } = typeof t == "number" ? { from: t, to: t } : t, u = !0, c = !0;
    if ((ly(o) ? o : [o]).forEach((d) => {
      d.check(), u = u ? d.isText && d.marks.length === 0 : !1, c = c ? d.isBlock : !1;
    }), a === l && c) {
      const { parent: d } = r.doc.resolve(a);
      d.isTextblock && !d.type.spec.code && !d.childCount && (a -= 1, l += 1);
    }
    u ? Array.isArray(e) ? r.insertText(e.map((d) => d.text || "").join(""), a, l) : typeof e == "object" && e && e.text ? r.insertText(e.text, a, l) : r.insertText(e, a, l) : r.replaceWith(a, l, o), n.updateSelection && ay(r, r.steps.length - 1, -1);
  }
  return !0;
}, cy = () => ({ state: t, dispatch: e }) => d8(t, e), fy = () => ({ state: t, dispatch: e }) => h8(t, e), dy = () => ({ state: t, dispatch: e }) => a8(t, e), hy = () => ({ state: t, dispatch: e }) => c8(t, e);
function Mg() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function py(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      Lc() || Mg() ? o = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), o && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n;
}
const my = (t) => ({ editor: e, view: n, tr: r, dispatch: i }) => {
  const s = py(t).split(/-(?!$)/), o = s.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return l == null || l.steps.forEach((u) => {
    const c = u.map(r.mapping);
    c && i && r.maybeStep(c);
  }), !0;
};
function uo(t, e, n = {}) {
  const { from: r, to: i, empty: s } = t.selection, o = e ? Xe(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, i, (f, d) => {
    if (f.isText)
      return;
    const h = Math.max(r, d), m = Math.min(i, d + f.nodeSize);
    a.push({
      node: f,
      from: h,
      to: m
    });
  });
  const l = i - r, u = a.filter((f) => o ? o.name === f.node.type.name : !0).filter((f) => Ba(f.node.attrs, n, { strict: !1 }));
  return s ? !!u.length : u.reduce((f, d) => f + d.to - d.from, 0) >= l;
}
const gy = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xe(t, n.schema);
  return uo(n, i, e) ? p8(n, r) : !1;
}, Ty = () => ({ state: t, dispatch: e }) => E8(t, e), Ey = (t) => ({ state: e, dispatch: n }) => {
  const r = Xe(t, e.schema);
  return k8(r)(e, n);
}, yy = () => ({ state: t, dispatch: e }) => m8(t, e);
function kl(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Hd(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
const Ay = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = kl(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = Xe(t, r.schema)), a === "mark" && (o = vr(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
      s && s === u.type && n.setNodeMarkup(c, void 0, Hd(u.attrs, e)), o && u.marks.length && u.marks.forEach((f) => {
        o === f.type && n.addMark(c, c + u.nodeSize, o.create(Hd(f.attrs, e)));
      });
    });
  }), !0) : !1;
}, by = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), Cy = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), xy = () => ({ state: t, dispatch: e }) => l8(t, e), Sy = () => ({ state: t, dispatch: e }) => f8(t, e), Ny = () => ({ state: t, dispatch: e }) => y8(t, e), ky = () => ({ state: t, dispatch: e }) => C8(t, e), _y = () => ({ state: t, dispatch: e }) => b8(t, e);
function Ig(t, e, n = {}) {
  return Fa(t, e, { slice: !1, parseOptions: n });
}
const Oy = (t, e = !1, n = {}) => ({ tr: r, editor: i, dispatch: s }) => {
  const { doc: o } = r, a = Ig(t, i.schema, n);
  return s && r.replaceWith(0, o.content.size, a).setMeta("preventUpdate", !e), !0;
};
function wy(t, e) {
  const n = new U0(t);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function vy(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Dy(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (i, s) => {
    n(i) && r.push({
      node: i,
      pos: s
    });
  }), r;
}
function My(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Pc(t) {
  return (e) => My(e.$from, t);
}
function Iy(t, e) {
  const n = fn.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function Ry(t) {
  const e = Zr.resolve(t);
  return Og(e);
}
function Ly(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return wg(t, n, e);
}
function _l(t, e) {
  const n = vr(e, t.schema), { from: r, to: i, empty: s } = t.selection, o = [];
  s ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function Py(t, e) {
  const n = Xe(e, t.schema), { from: r, to: i } = t.selection, s = [];
  t.doc.nodesBetween(r, i, (a) => {
    s.push(a);
  });
  const o = s.reverse().find((a) => a.type.name === n.name);
  return o ? { ...o.attrs } : {};
}
function Rg(t, e) {
  const n = kl(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? Py(t, e) : n === "mark" ? _l(t, e) : {};
}
function By(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function Fy(t) {
  const e = By(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((s, o) => o !== r).some((s) => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to));
}
function Hy(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((i, s) => {
    const o = [];
    if (i.ranges.length)
      i.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[s];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const u = e.slice(s).map(a, -1), c = e.slice(s).map(l), f = e.invert().map(u, -1), d = e.invert().map(c);
      r.push({
        oldRange: {
          from: f,
          to: d
        },
        newRange: {
          from: u,
          to: c
        }
      });
    });
  }), Fy(r);
}
function Ha(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((i) => {
    const s = n.resolve(t - 1), o = Ic(s, i.type);
    o && r.push({
      mark: i,
      ...o
    });
  }) : n.nodesBetween(t, e, (i, s) => {
    r.push(...i.marks.map((o) => ({
      from: s,
      to: s + i.nodeSize,
      mark: o
    })));
  }), r;
}
function ca(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = t.find((s) => s.type === e && s.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function zu(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection, s = e ? vr(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((f) => s ? s.name === f.type.name : !0).find((f) => Ba(f.attrs, n, { strict: !1 }));
  let o = 0;
  const a = [];
  if (i.forEach(({ $from: f, $to: d }) => {
    const h = f.pos, m = d.pos;
    t.doc.nodesBetween(h, m, (g, T) => {
      if (!g.isText && !g.marks.length)
        return;
      const E = Math.max(h, T), _ = Math.min(m, T + g.nodeSize), k = _ - E;
      o += k, a.push(...g.marks.map((A) => ({
        mark: A,
        from: E,
        to: _
      })));
    });
  }), o === 0)
    return !1;
  const l = a.filter((f) => s ? s.name === f.mark.type.name : !0).filter((f) => Ba(f.mark.attrs, n, { strict: !1 })).reduce((f, d) => f + d.to - d.from, 0), u = a.filter((f) => s ? f.mark.type !== s && f.mark.type.excludes(s) : !0).reduce((f, d) => f + d.to - d.from, 0);
  return (l > 0 ? l + u : l) >= o;
}
function Uy(t, e, n = {}) {
  if (!e)
    return uo(t, null, n) || zu(t, null, n);
  const r = kl(e, t.schema);
  return r === "node" ? uo(t, e, n) : r === "mark" ? zu(t, e, n) : !1;
}
function Ud(t, e) {
  const { nodeExtensions: n } = xl(e), r = n.find((o) => o.name === t);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, s = ae(W(r, "group", i));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function qy(t) {
  var e;
  const n = (e = t.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON(), r = t.toJSON();
  return JSON.stringify(n) === JSON.stringify(r);
}
function zy(t) {
  return t instanceof ne;
}
function Lg(t, e, n) {
  const i = t.state.doc.content.size, s = Kn(e, 0, i), o = Kn(n, 0, i), a = t.coordsAtPos(s), l = t.coordsAtPos(o, -1), u = Math.min(a.top, l.top), c = Math.max(a.bottom, l.bottom), f = Math.min(a.left, l.left), d = Math.max(a.right, l.right), h = d - f, m = c - u, E = {
    top: u,
    bottom: c,
    left: f,
    right: d,
    width: h,
    height: m,
    x: f,
    y: u
  };
  return {
    ...E,
    toJSON: () => E
  };
}
function $y(t, e, n) {
  var r;
  const { selection: i } = e;
  let s = null;
  if (Rc(i) && (s = i.$cursor), s) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: o } = i;
  return o.some(({ $from: a, $to: l }) => {
    let u = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (c, f, d) => {
      if (u)
        return !1;
      if (c.isInline) {
        const h = !d || d.type.allowsMarkType(n), m = !!n.isInSet(c.marks) || !c.marks.some((g) => g.type.excludes(n));
        u = h && m;
      }
      return !u;
    }), u;
  });
}
const Vy = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: s } = n, { empty: o, ranges: a } = s, l = vr(t, r.schema);
  if (i)
    if (o) {
      const u = _l(r, l);
      n.addStoredMark(l.create({
        ...u,
        ...e
      }));
    } else
      a.forEach((u) => {
        const c = u.$from.pos, f = u.$to.pos;
        r.doc.nodesBetween(c, f, (d, h) => {
          const m = Math.max(h, c), g = Math.min(h + d.nodeSize, f);
          d.marks.find((E) => E.type === l) ? d.marks.forEach((E) => {
            l === E.type && n.addMark(m, g, l.create({
              ...E.attrs,
              ...e
            }));
          }) : n.addMark(m, g, l.create(e));
        });
      });
  return $y(r, n, l);
}, Gy = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), jy = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const s = Xe(t, n.schema);
  return s.isTextblock ? i().command(({ commands: o }) => Rd(s, e)(n) ? !0 : o.clearNodes()).command(({ state: o }) => Rd(s, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, Ky = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, i = Kn(t, 0, r.content.size), s = ne.create(r, i);
    e.setSelection(s);
  }
  return !0;
}, Wy = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: i, to: s } = typeof t == "number" ? { from: t, to: t } : t, o = ce.atStart(r).from, a = ce.atEnd(r).to, l = Kn(i, o, a), u = Kn(s, o, a), c = ce.create(r, l, u);
    e.setSelection(c);
  }
  return !0;
}, Yy = (t) => ({ state: e, dispatch: n }) => {
  const r = Xe(t, e.schema);
  return w8(r)(e, n);
};
function qd(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    t.tr.ensureMarks(r);
  }
}
const Qy = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  const { selection: s, doc: o } = e, { $from: a, $to: l } = s, u = i.extensionManager.attributes, c = ca(u, a.node().type.name, a.node().attrs);
  if (s instanceof ne && s.node.isBlock)
    return !a.parentOffset || !Yi(o, a.pos) ? !1 : (r && (t && qd(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  if (r) {
    const f = l.parentOffset === l.parent.content.size;
    s instanceof ce && e.deleteSelection();
    const d = a.depth === 0 ? void 0 : vy(a.node(-1).contentMatchAt(a.indexAfter(-1)));
    let h = f && d ? [
      {
        type: d,
        attrs: c
      }
    ] : void 0, m = Yi(e.doc, e.mapping.map(a.pos), 1, h);
    if (!h && !m && Yi(e.doc, e.mapping.map(a.pos), 1, d ? [{ type: d }] : void 0) && (m = !0, h = d ? [
      {
        type: d,
        attrs: c
      }
    ] : void 0), m && (e.split(e.mapping.map(a.pos), 1, h), d && !f && !a.parentOffset && a.parent.type !== d)) {
      const g = e.mapping.map(a.before()), T = e.doc.resolve(g);
      a.node(-1).canReplaceWith(T.index(), T.index() + 1, d) && e.setNodeMarkup(e.mapping.map(a.before()), d);
    }
    t && qd(n, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return !0;
}, Jy = (t) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  var s;
  const o = Xe(t, n.schema), { $from: a, $to: l } = n.selection, u = n.selection.node;
  if (u && u.isBlock || a.depth < 2 || !a.sameParent(l))
    return !1;
  const c = a.node(-1);
  if (c.type !== o)
    return !1;
  const f = i.extensionManager.attributes;
  if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
    if (a.depth === 2 || a.node(-3).type !== o || a.index(-2) !== a.node(-2).childCount - 1)
      return !1;
    if (r) {
      let T = B.empty;
      const E = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
      for (let b = a.depth - E; b >= a.depth - 3; b -= 1)
        T = B.from(a.node(b).copy(T));
      const _ = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, k = ca(f, a.node().type.name, a.node().attrs), A = ((s = o.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(k)) || void 0;
      T = T.append(B.from(o.createAndFill(null, A) || void 0));
      const v = a.before(a.depth - (E - 1));
      e.replace(v, a.after(-_), new G(T, 4 - E, 0));
      let y = -1;
      e.doc.nodesBetween(v, e.doc.content.size, (b, O) => {
        if (y > -1)
          return !1;
        b.isTextblock && b.content.size === 0 && (y = O + 1);
      }), y > -1 && e.setSelection(ce.near(e.doc.resolve(y))), e.scrollIntoView();
    }
    return !0;
  }
  const d = l.pos === a.end() ? c.contentMatchAt(0).defaultType : null, h = ca(f, c.type.name, c.attrs), m = ca(f, a.node().type.name, a.node().attrs);
  e.delete(a.pos, l.pos);
  const g = d ? [
    { type: o, attrs: h },
    { type: d, attrs: m }
  ] : [{ type: o, attrs: h }];
  if (!Yi(e.doc, a.pos, 2))
    return !1;
  if (r) {
    const { selection: T, storedMarks: E } = n, { splittableMarks: _ } = i.extensionManager, k = E || T.$to.parentOffset && T.$from.marks();
    if (e.split(a.pos, 2, g).scrollIntoView(), !k || !r)
      return !0;
    const A = k.filter((v) => _.includes(v.type.name));
    e.ensureMarks(A);
  }
  return !0;
}, A1 = (t, e) => {
  const n = Pc((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Or(t.doc, n.pos) && t.join(n.pos), !0;
}, b1 = (t, e) => {
  const n = Pc((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Or(t.doc, r) && t.join(r), !0;
}, Xy = (t, e, n) => ({ editor: r, tr: i, state: s, dispatch: o, chain: a, commands: l, can: u }) => {
  const { extensions: c, splittableMarks: f } = r.extensionManager, d = Xe(t, s.schema), h = Xe(e, s.schema), { selection: m, storedMarks: g } = s, { $from: T, $to: E } = m, _ = T.blockRange(E), k = g || m.$to.parentOffset && m.$from.marks();
  if (!_)
    return !1;
  const A = Pc((v) => Ud(v.type.name, c))(m);
  if (_.depth >= 1 && A && _.depth - A.depth <= 1) {
    if (A.node.type === d)
      return l.liftListItem(h);
    if (Ud(A.node.type.name, c) && d.validContent(A.node.content) && o)
      return a().command(() => (i.setNodeMarkup(A.pos, d), !0)).command(() => A1(i, d)).command(() => b1(i, d)).run();
  }
  return !n || !k || !o ? a().command(() => u().wrapInList(d) ? !0 : l.clearNodes()).wrapInList(d).command(() => A1(i, d)).command(() => b1(i, d)).run() : a().command(() => {
    const v = u().wrapInList(d), y = k.filter((b) => f.includes(b.type.name));
    return i.ensureMarks(y), v ? !0 : l.clearNodes();
  }).wrapInList(d).command(() => A1(i, d)).command(() => b1(i, d)).run();
}, Zy = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: s = !1 } = n, o = vr(t, r.schema);
  return zu(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e);
}, eA = (t, e, n = {}) => ({ state: r, commands: i }) => {
  const s = Xe(t, r.schema), o = Xe(e, r.schema);
  return uo(r, s, n) ? i.setNode(o) : i.setNode(s, n);
}, tA = (t, e = {}) => ({ state: n, commands: r }) => {
  const i = Xe(t, n.schema);
  return uo(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, nA = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let s;
    if (i.spec.isInputRules && (s = i.getState(t))) {
      if (e) {
        const o = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, rA = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: i } = n;
  return r || e && i.forEach((s) => {
    t.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, iA = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: a } = n, l = vr(t, r.schema), { $from: u, empty: c, ranges: f } = a;
  if (!i)
    return !0;
  if (c && o) {
    let { from: d, to: h } = a;
    const m = (s = u.marks().find((T) => T.type === l)) === null || s === void 0 ? void 0 : s.attrs, g = Ic(u, l, m);
    g && (d = g.from, h = g.to), n.removeMark(d, h, l);
  } else
    f.forEach((d) => {
      n.removeMark(d.$from.pos, d.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, sA = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let s = null, o = null;
  const a = kl(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (s = Xe(t, r.schema)), a === "mark" && (o = vr(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    const u = l.$from.pos, c = l.$to.pos;
    r.doc.nodesBetween(u, c, (f, d) => {
      s && s === f.type && n.setNodeMarkup(d, void 0, {
        ...f.attrs,
        ...e
      }), o && f.marks.length && f.marks.forEach((h) => {
        if (o === h.type) {
          const m = Math.max(d, u), g = Math.min(d + f.nodeSize, c);
          n.addMark(m, g, o.create({
            ...h.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, oA = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xe(t, n.schema);
  return x8(i, e)(n, r);
}, aA = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xe(t, n.schema);
  return S8(i, e)(n, r);
};
var lA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: V8,
  clearContent: G8,
  clearNodes: j8,
  command: K8,
  createParagraphNear: W8,
  deleteCurrentNode: Y8,
  deleteNode: Q8,
  deleteRange: J8,
  deleteSelection: X8,
  enter: Z8,
  exitCode: ey,
  extendMarkRange: ny,
  first: ry,
  focus: iy,
  forEach: sy,
  insertContent: oy,
  insertContentAt: uy,
  joinUp: cy,
  joinDown: fy,
  joinBackward: dy,
  joinForward: hy,
  keyboardShortcut: my,
  lift: gy,
  liftEmptyBlock: Ty,
  liftListItem: Ey,
  newlineInCode: yy,
  resetAttributes: Ay,
  scrollIntoView: by,
  selectAll: Cy,
  selectNodeBackward: xy,
  selectNodeForward: Sy,
  selectParentNode: Ny,
  selectTextblockEnd: ky,
  selectTextblockStart: _y,
  setContent: Oy,
  setMark: Vy,
  setMeta: Gy,
  setNode: jy,
  setNodeSelection: Ky,
  setTextSelection: Wy,
  sinkListItem: Yy,
  splitBlock: Qy,
  splitListItem: Jy,
  toggleList: Xy,
  toggleMark: Zy,
  toggleNode: eA,
  toggleWrap: tA,
  undoInputRule: nA,
  unsetAllMarks: rA,
  unsetMark: iA,
  updateAttributes: sA,
  wrapIn: oA,
  wrapInList: aA
});
const uA = Nt.create({
  name: "commands",
  addCommands() {
    return {
      ...lA
    };
  }
}), cA = Nt.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), fA = Nt.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Be({
        key: new Ge("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), dA = Nt.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: u } = a, { empty: c, $anchor: f } = l, { pos: d, parent: h } = f, m = le.atStart(u).from === d;
        return !c || !m || !h.type.isTextblock || h.textContent.length ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, s = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Lc() || Mg() ? s : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Be({
        key: new Ge("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (!(t.some((m) => m.docChanged) && !e.doc.eq(n.doc)))
            return;
          const { empty: i, from: s, to: o } = e.selection, a = le.atStart(e.doc).from, l = le.atEnd(e.doc).to, u = s === a && o === l, c = n.doc.textBetween(0, n.doc.content.size, " ", " ").length === 0;
          if (i || !u || !c)
            return;
          const f = n.tr, d = bl({
            state: n,
            transaction: f
          }), { commands: h } = new Cl({
            editor: this.editor,
            state: d
          });
          if (h.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), hA = Nt.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var pA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: $8,
  Commands: uA,
  Editable: cA,
  FocusEvents: fA,
  Keymap: dA,
  Tabindex: hA
});
const mA = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function gA(t, e) {
  const n = document.querySelector("style[data-tiptap-style]");
  if (n !== null)
    return n;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute("data-tiptap-style", ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let TA = class extends v8 {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }));
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = gA(mA, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(e, n) {
    const r = _g(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    this.view.updateState(i);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = typeof e == "string" ? `${e}$` : e.key, r = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((i) => !i.key.startsWith(n))
    });
    this.view.updateState(r);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    const n = [...this.options.enableCoreExtensions ? Object.values(pA) : [], ...this.options.extensions].filter((r) => ["extension", "node", "mark"].includes(r == null ? void 0 : r.type));
    this.extensionManager = new Zr(n, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Cl({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const e = Ig(this.options.content, this.schema, this.options.parseOptions), n = Dg(e, this.options.autofocus);
    this.view = new WE(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Ui.create({
        doc: e,
        selection: n || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), s = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Rg(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
    return Uy(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Iy(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return Ly(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...vg(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return qy(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
};
function as(t) {
  return new Sl({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = ae(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], a = r[0];
      let l = n.to;
      if (o) {
        const u = a.search(/\S/), c = n.from + a.indexOf(o), f = c + o.length;
        if (Ha(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((g) => g === t.type && g !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        f < n.to && s.delete(f, n.to), c > n.from && s.delete(n.from + u, c), l = n.from + u + o.length, s.addMark(n.from + u, l, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function EA(t) {
  return new Sl({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = ae(t.getAttributes, void 0, r) || {}, { tr: s } = e, o = n.from;
      let a = n.to;
      if (r[1]) {
        const l = r[0].lastIndexOf(r[1]);
        let u = o + l;
        u > a ? u = a : a = u + r[1].length;
        const c = r[0][r[0].length - 1];
        s.insertText(c, o + r[0].length - 1), s.replaceWith(u, a, t.type.create(i));
      } else
        r[0] && s.replaceWith(o, a, t.type.create(i));
    }
  });
}
function $u(t) {
  return new Sl({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from), s = ae(t.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s);
    }
  });
}
function co(t) {
  return new Sl({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const s = ae(t.getAttributes, void 0, r) || {}, o = e.tr.delete(n.from, n.to), l = o.doc.resolve(n.from).blockRange(), u = l && Ac(l, t.type, s);
      if (!u)
        return null;
      if (o.wrap(l, u), t.keepMarks && t.editor) {
        const { selection: f, storedMarks: d } = e, { splittableMarks: h } = t.editor.extensionManager, m = d || f.$to.parentOffset && f.$from.marks();
        if (m) {
          const g = m.filter((T) => h.includes(T.type.name));
          o.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const f = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(f, s).run();
      }
      const c = o.doc.resolve(n.from - 1).nodeBefore;
      c && c.type === t.type && Or(o.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, c)) && o.join(n.from - 1);
    }
  });
}
class Wt {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ae(W(this, "addOptions", {
      name: this.name
    }))), this.storage = ae(W(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Wt(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = Nl(this.options, e), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new Wt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ae(W(n, "addOptions", {
      name: n.name
    })), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const o = i.marks();
      if (!!!o.find((u) => (u == null ? void 0 : u.type.name) === n.name))
        return !1;
      const l = o.find((u) => (u == null ? void 0 : u.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
class He {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ae(W(this, "addOptions", {
      name: this.name
    }))), this.storage = ae(W(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new He(e);
  }
  configure(e = {}) {
    const n = this.extend();
    return n.options = Nl(this.options, e), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  extend(e = {}) {
    const n = new He(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ae(W(n, "addOptions", {
      name: n.name
    })), n.storage = ae(W(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function di(t) {
  return new B8({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = ae(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, o = r[r.length - 1], a = r[0];
      let l = n.to;
      if (o) {
        const u = a.search(/\S/), c = n.from + a.indexOf(o), f = c + o.length;
        if (Ha(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((g) => g === t.type && g !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        f < n.to && s.delete(f, n.to), c > n.from && s.delete(n.from + u, c), l = n.from + u + o.length, s.addMark(n.from + u, l, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function yA(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var xt = "top", Yt = "bottom", Qt = "right", St = "left", Ol = "auto", xo = [xt, Yt, Qt, St], ls = "start", fo = "end", AA = "clippingParents", Pg = "viewport", Ss = "popper", bA = "reference", zd = /* @__PURE__ */ xo.reduce(function(t, e) {
  return t.concat([e + "-" + ls, e + "-" + fo]);
}, []), Bg = /* @__PURE__ */ [].concat(xo, [Ol]).reduce(function(t, e) {
  return t.concat([e, e + "-" + ls, e + "-" + fo]);
}, []), CA = "beforeRead", xA = "read", SA = "afterRead", NA = "beforeMain", kA = "main", _A = "afterMain", OA = "beforeWrite", wA = "write", vA = "afterWrite", Vu = [CA, xA, SA, NA, kA, _A, OA, wA, vA];
function In(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Xt(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function hi(t) {
  var e = Xt(t).Element;
  return t instanceof e || t instanceof Element;
}
function Lt(t) {
  var e = Xt(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Bc(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Xt(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function DA(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !Lt(s) || !In(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function MA(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Lt(i) || !In(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const Fg = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: DA,
  effect: MA,
  requires: ["computeStyles"]
};
function pn(t) {
  return t.split("-")[0];
}
var oi = Math.max, Ua = Math.min, us = Math.round;
function Gu() {
  var t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function Hg() {
  return !/^((?!chrome|android).)*safari/i.test(Gu());
}
function cs(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(), i = 1, s = 1;
  e && Lt(t) && (i = t.offsetWidth > 0 && us(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && us(r.height) / t.offsetHeight || 1);
  var o = hi(t) ? Xt(t) : window, a = o.visualViewport, l = !Hg() && n, u = (r.left + (l && a ? a.offsetLeft : 0)) / i, c = (r.top + (l && a ? a.offsetTop : 0)) / s, f = r.width / i, d = r.height / s;
  return {
    width: f,
    height: d,
    top: c,
    right: u + f,
    bottom: c + d,
    left: u,
    x: u,
    y: c
  };
}
function Fc(t) {
  var e = cs(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function Ug(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Bc(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function gn(t) {
  return Xt(t).getComputedStyle(t);
}
function IA(t) {
  return ["table", "td", "th"].indexOf(In(t)) >= 0;
}
function Dr(t) {
  return ((hi(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function wl(t) {
  return In(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (Bc(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Dr(t)
  );
}
function $d(t) {
  return !Lt(t) || // https://github.com/popperjs/popper-core/issues/837
  gn(t).position === "fixed" ? null : t.offsetParent;
}
function RA(t) {
  var e = /firefox/i.test(Gu()), n = /Trident/i.test(Gu());
  if (n && Lt(t)) {
    var r = gn(t);
    if (r.position === "fixed")
      return null;
  }
  var i = wl(t);
  for (Bc(i) && (i = i.host); Lt(i) && ["html", "body"].indexOf(In(i)) < 0; ) {
    var s = gn(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function So(t) {
  for (var e = Xt(t), n = $d(t); n && IA(n) && gn(n).position === "static"; )
    n = $d(n);
  return n && (In(n) === "html" || In(n) === "body" && gn(n).position === "static") ? e : n || RA(t) || e;
}
function Hc(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function Vs(t, e, n) {
  return oi(t, Ua(e, n));
}
function LA(t, e, n) {
  var r = Vs(t, e, n);
  return r > n ? n : r;
}
function qg() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function zg(t) {
  return Object.assign({}, qg(), t);
}
function $g(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var PA = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, zg(typeof e != "number" ? e : $g(e, xo));
};
function BA(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = pn(n.placement), l = Hc(a), u = [St, Qt].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!s || !o)) {
    var f = PA(i.padding, n), d = Fc(s), h = l === "y" ? xt : St, m = l === "y" ? Yt : Qt, g = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c], T = o[l] - n.rects.reference[l], E = So(s), _ = E ? l === "y" ? E.clientHeight || 0 : E.clientWidth || 0 : 0, k = g / 2 - T / 2, A = f[h], v = _ - d[c] - f[m], y = _ / 2 - d[c] / 2 + k, b = Vs(A, y, v), O = l;
    n.modifiersData[r] = (e = {}, e[O] = b, e.centerOffset = b - y, e);
  }
}
function FA(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  if (i != null && !(typeof i == "string" && (i = e.elements.popper.querySelector(i), !i))) {
    if (process.env.NODE_ENV !== "production" && (Lt(i) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Ug(e.elements.popper, i)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    e.elements.arrow = i;
  }
}
const HA = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: BA,
  effect: FA,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function fs(t) {
  return t.split("-")[1];
}
var UA = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function qA(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return {
    x: us(e * i) / i || 0,
    y: us(n * i) / i || 0
  };
}
function Vd(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, u = t.adaptive, c = t.roundOffsets, f = t.isFixed, d = o.x, h = d === void 0 ? 0 : d, m = o.y, g = m === void 0 ? 0 : m, T = typeof c == "function" ? c({
    x: h,
    y: g
  }) : {
    x: h,
    y: g
  };
  h = T.x, g = T.y;
  var E = o.hasOwnProperty("x"), _ = o.hasOwnProperty("y"), k = St, A = xt, v = window;
  if (u) {
    var y = So(n), b = "clientHeight", O = "clientWidth";
    if (y === Xt(n) && (y = Dr(n), gn(y).position !== "static" && a === "absolute" && (b = "scrollHeight", O = "scrollWidth")), y = y, i === xt || (i === St || i === Qt) && s === fo) {
      A = Yt;
      var P = f && y === v && v.visualViewport ? v.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        y[b]
      );
      g -= P - r.height, g *= l ? 1 : -1;
    }
    if (i === St || (i === xt || i === Yt) && s === fo) {
      k = Qt;
      var $ = f && y === v && v.visualViewport ? v.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        y[O]
      );
      h -= $ - r.width, h *= l ? 1 : -1;
    }
  }
  var M = Object.assign({
    position: a
  }, u && UA), R = c === !0 ? qA({
    x: h,
    y: g
  }) : {
    x: h,
    y: g
  };
  if (h = R.x, g = R.y, l) {
    var V;
    return Object.assign({}, M, (V = {}, V[A] = _ ? "0" : "", V[k] = E ? "0" : "", V.transform = (v.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", V));
  }
  return Object.assign({}, M, (e = {}, e[A] = _ ? g + "px" : "", e[k] = E ? h + "px" : "", e.transform = "", e));
}
function zA(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a;
  if (process.env.NODE_ENV !== "production") {
    var u = gn(e.elements.popper).transitionProperty || "";
    o && ["transform", "top", "right", "bottom", "left"].some(function(f) {
      return u.indexOf(f) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var c = {
    placement: pn(e.placement),
    variation: fs(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Vd(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Vd(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const $A = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: zA,
  data: {}
};
var Po = {
  passive: !0
};
function VA(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, l = Xt(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, Po);
  }), a && l.addEventListener("resize", n.update, Po), function() {
    s && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, Po);
    }), a && l.removeEventListener("resize", n.update, Po);
  };
}
const GA = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: VA,
  data: {}
};
var jA = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function fa(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return jA[e];
  });
}
var KA = {
  start: "end",
  end: "start"
};
function Gd(t) {
  return t.replace(/start|end/g, function(e) {
    return KA[e];
  });
}
function Uc(t) {
  var e = Xt(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function qc(t) {
  return cs(Dr(t)).left + Uc(t).scrollLeft;
}
function WA(t, e) {
  var n = Xt(t), r = Dr(t), i = n.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    var u = Hg();
    (u || !u && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + qc(t),
    y: l
  };
}
function YA(t) {
  var e, n = Dr(t), r = Uc(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = oi(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = oi(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + qc(t), l = -r.scrollTop;
  return gn(i || n).direction === "rtl" && (a += oi(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function zc(t) {
  var e = gn(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function Vg(t) {
  return ["html", "body", "#document"].indexOf(In(t)) >= 0 ? t.ownerDocument.body : Lt(t) && zc(t) ? t : Vg(wl(t));
}
function Gs(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = Vg(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Xt(r), o = i ? [s].concat(s.visualViewport || [], zc(r) ? r : []) : r, a = e.concat(o);
  return i ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Gs(wl(o)))
  );
}
function ju(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function QA(t, e) {
  var n = cs(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function jd(t, e, n) {
  return e === Pg ? ju(WA(t, n)) : hi(e) ? QA(e, n) : ju(YA(Dr(t)));
}
function JA(t) {
  var e = Gs(wl(t)), n = ["absolute", "fixed"].indexOf(gn(t).position) >= 0, r = n && Lt(t) ? So(t) : t;
  return hi(r) ? e.filter(function(i) {
    return hi(i) && Ug(i, r) && In(i) !== "body";
  }) : [];
}
function XA(t, e, n, r) {
  var i = e === "clippingParents" ? JA(t) : [].concat(e), s = [].concat(i, [n]), o = s[0], a = s.reduce(function(l, u) {
    var c = jd(t, u, r);
    return l.top = oi(c.top, l.top), l.right = Ua(c.right, l.right), l.bottom = Ua(c.bottom, l.bottom), l.left = oi(c.left, l.left), l;
  }, jd(t, o, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Gg(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? pn(r) : null, s = r ? fs(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (i) {
    case xt:
      l = {
        x: o,
        y: e.y - n.height
      };
      break;
    case Yt:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case Qt:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case St:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var u = i ? Hc(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (s) {
      case ls:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case fo:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function ho(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.strategy, o = s === void 0 ? t.strategy : s, a = n.boundary, l = a === void 0 ? AA : a, u = n.rootBoundary, c = u === void 0 ? Pg : u, f = n.elementContext, d = f === void 0 ? Ss : f, h = n.altBoundary, m = h === void 0 ? !1 : h, g = n.padding, T = g === void 0 ? 0 : g, E = zg(typeof T != "number" ? T : $g(T, xo)), _ = d === Ss ? bA : Ss, k = t.rects.popper, A = t.elements[m ? _ : d], v = XA(hi(A) ? A : A.contextElement || Dr(t.elements.popper), l, c, o), y = cs(t.elements.reference), b = Gg({
    reference: y,
    element: k,
    strategy: "absolute",
    placement: i
  }), O = ju(Object.assign({}, k, b)), P = d === Ss ? O : y, $ = {
    top: v.top - P.top + E.top,
    bottom: P.bottom - v.bottom + E.bottom,
    left: v.left - P.left + E.left,
    right: P.right - v.right + E.right
  }, M = t.modifiersData.offset;
  if (d === Ss && M) {
    var R = M[i];
    Object.keys($).forEach(function(V) {
      var Y = [Qt, Yt].indexOf(V) >= 0 ? 1 : -1, w = [xt, Yt].indexOf(V) >= 0 ? "y" : "x";
      $[V] += R[w] * Y;
    });
  }
  return $;
}
function ZA(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? Bg : l, c = fs(r), f = c ? a ? zd : zd.filter(function(m) {
    return fs(m) === c;
  }) : xo, d = f.filter(function(m) {
    return u.indexOf(m) >= 0;
  });
  d.length === 0 && (d = f, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var h = d.reduce(function(m, g) {
    return m[g] = ho(t, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[pn(g)], m;
  }, {});
  return Object.keys(h).sort(function(m, g) {
    return h[m] - h[g];
  });
}
function eb(t) {
  if (pn(t) === Ol)
    return [];
  var e = fa(t);
  return [Gd(t), e, Gd(e)];
}
function tb(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, u = n.padding, c = n.boundary, f = n.rootBoundary, d = n.altBoundary, h = n.flipVariations, m = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, T = e.options.placement, E = pn(T), _ = E === T, k = l || (_ || !m ? [fa(T)] : eb(T)), A = [T].concat(k).reduce(function(ut, je) {
      return ut.concat(pn(je) === Ol ? ZA(e, {
        placement: je,
        boundary: c,
        rootBoundary: f,
        padding: u,
        flipVariations: m,
        allowedAutoPlacements: g
      }) : je);
    }, []), v = e.rects.reference, y = e.rects.popper, b = /* @__PURE__ */ new Map(), O = !0, P = A[0], $ = 0; $ < A.length; $++) {
      var M = A[$], R = pn(M), V = fs(M) === ls, Y = [xt, Yt].indexOf(R) >= 0, w = Y ? "width" : "height", ue = ho(e, {
        placement: M,
        boundary: c,
        rootBoundary: f,
        altBoundary: d,
        padding: u
      }), se = Y ? V ? Qt : St : V ? Yt : xt;
      v[w] > y[w] && (se = fa(se));
      var ie = fa(se), de = [];
      if (s && de.push(ue[R] <= 0), a && de.push(ue[se] <= 0, ue[ie] <= 0), de.every(function(ut) {
        return ut;
      })) {
        P = M, O = !1;
        break;
      }
      b.set(M, de);
    }
    if (O)
      for (var he = m ? 3 : 1, N = function(je) {
        var Ae = A.find(function(Ke) {
          var We = b.get(Ke);
          if (We)
            return We.slice(0, je).every(function(Ot) {
              return Ot;
            });
        });
        if (Ae)
          return P = Ae, "break";
      }, S = he; S > 0; S--) {
        var gt = N(S);
        if (gt === "break")
          break;
      }
    e.placement !== P && (e.modifiersData[r]._skip = !0, e.placement = P, e.reset = !0);
  }
}
const nb = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: tb,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Kd(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function Wd(t) {
  return [xt, Qt, Yt, St].some(function(e) {
    return t[e] >= 0;
  });
}
function rb(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, o = ho(e, {
    elementContext: "reference"
  }), a = ho(e, {
    altBoundary: !0
  }), l = Kd(o, r), u = Kd(a, i, s), c = Wd(l), f = Wd(u);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: f
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": f
  });
}
const ib = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: rb
};
function sb(t, e, n) {
  var r = pn(t), i = [St, xt].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * i, [St, Qt].indexOf(r) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function ob(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = Bg.reduce(function(c, f) {
    return c[f] = sb(f, e.rects, s), c;
  }, {}), a = o[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
const ab = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: ob
};
function lb(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = Gg({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const ub = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: lb,
  data: {}
};
function cb(t) {
  return t === "x" ? "y" : "x";
}
function fb(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, f = n.padding, d = n.tether, h = d === void 0 ? !0 : d, m = n.tetherOffset, g = m === void 0 ? 0 : m, T = ho(e, {
    boundary: l,
    rootBoundary: u,
    padding: f,
    altBoundary: c
  }), E = pn(e.placement), _ = fs(e.placement), k = !_, A = Hc(E), v = cb(A), y = e.modifiersData.popperOffsets, b = e.rects.reference, O = e.rects.popper, P = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, $ = typeof P == "number" ? {
    mainAxis: P,
    altAxis: P
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, P), M = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, R = {
    x: 0,
    y: 0
  };
  if (y) {
    if (s) {
      var V, Y = A === "y" ? xt : St, w = A === "y" ? Yt : Qt, ue = A === "y" ? "height" : "width", se = y[A], ie = se + T[Y], de = se - T[w], he = h ? -O[ue] / 2 : 0, N = _ === ls ? b[ue] : O[ue], S = _ === ls ? -O[ue] : -b[ue], gt = e.elements.arrow, ut = h && gt ? Fc(gt) : {
        width: 0,
        height: 0
      }, je = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : qg(), Ae = je[Y], Ke = je[w], We = Vs(0, b[ue], ut[ue]), Ot = k ? b[ue] / 2 - he - We - Ae - $.mainAxis : N - We - Ae - $.mainAxis, ct = k ? -b[ue] / 2 + he + We + Ke + $.mainAxis : S + We + Ke + $.mainAxis, yn = e.elements.arrow && So(e.elements.arrow), Rr = yn ? A === "y" ? yn.clientTop || 0 : yn.clientLeft || 0 : 0, Lr = (V = M == null ? void 0 : M[A]) != null ? V : 0, Ei = se + Ot - Lr - Rr, yi = se + ct - Lr, Zn = Vs(h ? Ua(ie, Ei) : ie, se, h ? oi(de, yi) : de);
      y[A] = Zn, R[A] = Zn - se;
    }
    if (a) {
      var er, Pr = A === "x" ? xt : St, Ai = A === "x" ? Yt : Qt, Bt = y[v], nn = v === "y" ? "height" : "width", Br = Bt + T[Pr], Ln = Bt - T[Ai], Fr = [xt, St].indexOf(E) !== -1, bi = (er = M == null ? void 0 : M[v]) != null ? er : 0, Ci = Fr ? Br : Bt - b[nn] - O[nn] - bi + $.altAxis, I = Fr ? Bt + b[nn] + O[nn] - bi - $.altAxis : Ln, q = h && Fr ? LA(Ci, Bt, I) : Vs(h ? Ci : Br, Bt, h ? I : Ln);
      y[v] = q, R[v] = q - Bt;
    }
    e.modifiersData[r] = R;
  }
}
const db = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: fb,
  requiresIfExists: ["offset"]
};
function hb(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function pb(t) {
  return t === Xt(t) || !Lt(t) ? Uc(t) : hb(t);
}
function mb(t) {
  var e = t.getBoundingClientRect(), n = us(e.width) / t.offsetWidth || 1, r = us(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function gb(t, e, n) {
  n === void 0 && (n = !1);
  var r = Lt(e), i = Lt(e) && mb(e), s = Dr(e), o = cs(t, i, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((In(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  zc(s)) && (a = pb(e)), Lt(e) ? (l = cs(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = qc(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function Tb(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function Eb(t) {
  var e = Tb(t);
  return Vu.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function yb(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function nr(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  return [].concat(n).reduce(function(i, s) {
    return i.replace(/%s/, s);
  }, t);
}
var Ur = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', Ab = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', Yd = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function bb(t) {
  t.forEach(function(e) {
    [].concat(Object.keys(e), Yd).filter(function(n, r, i) {
      return i.indexOf(n) === r;
    }).forEach(function(n) {
      switch (n) {
        case "name":
          typeof e.name != "string" && console.error(nr(Ur, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
          break;
        case "enabled":
          typeof e.enabled != "boolean" && console.error(nr(Ur, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
          break;
        case "phase":
          Vu.indexOf(e.phase) < 0 && console.error(nr(Ur, e.name, '"phase"', "either " + Vu.join(", "), '"' + String(e.phase) + '"'));
          break;
        case "fn":
          typeof e.fn != "function" && console.error(nr(Ur, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "effect":
          e.effect != null && typeof e.effect != "function" && console.error(nr(Ur, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "requires":
          e.requires != null && !Array.isArray(e.requires) && console.error(nr(Ur, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(e.requiresIfExists) || console.error(nr(Ur, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + Yd.map(function(r) {
            return '"' + r + '"';
          }).join(", ") + '; but "' + n + '" was provided.');
      }
      e.requires && e.requires.forEach(function(r) {
        t.find(function(i) {
          return i.name === r;
        }) == null && console.error(nr(Ab, String(e.name), r, r));
      });
    });
  });
}
function Cb(t, e) {
  var n = /* @__PURE__ */ new Set();
  return t.filter(function(r) {
    var i = e(r);
    if (!n.has(i))
      return n.add(i), !0;
  });
}
function xb(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Qd = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Sb = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Jd = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Xd() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function Nb(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? Jd : i;
  return function(a, l, u) {
    u === void 0 && (u = s);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Jd, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], d = !1, h = {
      state: c,
      setOptions: function(E) {
        var _ = typeof E == "function" ? E(c.options) : E;
        g(), c.options = Object.assign({}, s, c.options, _), c.scrollParents = {
          reference: hi(a) ? Gs(a) : a.contextElement ? Gs(a.contextElement) : [],
          popper: Gs(l)
        };
        var k = Eb(xb([].concat(r, c.options.modifiers)));
        if (c.orderedModifiers = k.filter(function(M) {
          return M.enabled;
        }), process.env.NODE_ENV !== "production") {
          var A = Cb([].concat(k, c.options.modifiers), function(M) {
            var R = M.name;
            return R;
          });
          if (bb(A), pn(c.options.placement) === Ol) {
            var v = c.orderedModifiers.find(function(M) {
              var R = M.name;
              return R === "flip";
            });
            v || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var y = gn(l), b = y.marginTop, O = y.marginRight, P = y.marginBottom, $ = y.marginLeft;
          [b, O, P, $].some(function(M) {
            return parseFloat(M);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return m(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!d) {
          var E = c.elements, _ = E.reference, k = E.popper;
          if (!Xd(_, k)) {
            process.env.NODE_ENV !== "production" && console.error(Qd);
            return;
          }
          c.rects = {
            reference: gb(_, So(k), c.options.strategy === "fixed"),
            popper: Fc(k)
          }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(M) {
            return c.modifiersData[M.name] = Object.assign({}, M.data);
          });
          for (var A = 0, v = 0; v < c.orderedModifiers.length; v++) {
            if (process.env.NODE_ENV !== "production" && (A += 1, A > 100)) {
              console.error(Sb);
              break;
            }
            if (c.reset === !0) {
              c.reset = !1, v = -1;
              continue;
            }
            var y = c.orderedModifiers[v], b = y.fn, O = y.options, P = O === void 0 ? {} : O, $ = y.name;
            typeof b == "function" && (c = b({
              state: c,
              options: P,
              name: $,
              instance: h
            }) || c);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: yb(function() {
        return new Promise(function(T) {
          h.forceUpdate(), T(c);
        });
      }),
      destroy: function() {
        g(), d = !0;
      }
    };
    if (!Xd(a, l))
      return process.env.NODE_ENV !== "production" && console.error(Qd), h;
    h.setOptions(u).then(function(T) {
      !d && u.onFirstUpdate && u.onFirstUpdate(T);
    });
    function m() {
      c.orderedModifiers.forEach(function(T) {
        var E = T.name, _ = T.options, k = _ === void 0 ? {} : _, A = T.effect;
        if (typeof A == "function") {
          var v = A({
            state: c,
            name: E,
            instance: h,
            options: k
          }), y = function() {
          };
          f.push(v || y);
        }
      });
    }
    function g() {
      f.forEach(function(T) {
        return T();
      }), f = [];
    }
    return h;
  };
}
var kb = [GA, ub, $A, Fg, ab, nb, db, HA, ib], _b = /* @__PURE__ */ Nb({
  defaultModifiers: kb
}), Ob = "tippy-box", jg = "tippy-content", wb = "tippy-backdrop", Kg = "tippy-arrow", Wg = "tippy-svg-arrow", jr = {
  passive: !0,
  capture: !0
}, Yg = function() {
  return document.body;
};
function vb(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function C1(t, e, n) {
  if (Array.isArray(t)) {
    var r = t[e];
    return r ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function $c(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function Qg(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Zd(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(r) {
    clearTimeout(n), n = setTimeout(function() {
      t(r);
    }, e);
  };
}
function Db(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(r) {
    delete n[r];
  }), n;
}
function Mb(t) {
  return t.split(/\s+/).filter(Boolean);
}
function Li(t) {
  return [].concat(t);
}
function eh(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Ib(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function Rb(t) {
  return t.split("-")[0];
}
function qa(t) {
  return [].slice.call(t);
}
function th(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function js() {
  return document.createElement("div");
}
function po(t) {
  return ["Element", "Fragment"].some(function(e) {
    return $c(t, e);
  });
}
function Lb(t) {
  return $c(t, "NodeList");
}
function Pb(t) {
  return $c(t, "MouseEvent");
}
function Bb(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function Fb(t) {
  return po(t) ? [t] : Lb(t) ? qa(t) : Array.isArray(t) ? t : qa(document.querySelectorAll(t));
}
function x1(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function nh(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function Hb(t) {
  var e, n = Li(t), r = n[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function Ub(t, e) {
  var n = e.clientX, r = e.clientY;
  return t.every(function(i) {
    var s = i.popperRect, o = i.popperState, a = i.props, l = a.interactiveBorder, u = Rb(o.placement), c = o.modifiersData.offset;
    if (!c)
      return !0;
    var f = u === "bottom" ? c.top.y : 0, d = u === "top" ? c.bottom.y : 0, h = u === "right" ? c.left.x : 0, m = u === "left" ? c.right.x : 0, g = s.top - r + f > l, T = r - s.bottom - d > l, E = s.left - n + h > l, _ = n - s.right - m > l;
    return g || T || E || _;
  });
}
function S1(t, e, n) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    t[r](i, n);
  });
}
function rh(t, e) {
  for (var n = e; n; ) {
    var r;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var kn = {
  isTouch: !1
}, ih = 0;
function qb() {
  kn.isTouch || (kn.isTouch = !0, window.performance && document.addEventListener("mousemove", Jg));
}
function Jg() {
  var t = performance.now();
  t - ih < 20 && (kn.isTouch = !1, document.removeEventListener("mousemove", Jg)), ih = t;
}
function zb() {
  var t = document.activeElement;
  if (Bb(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function $b() {
  document.addEventListener("touchstart", qb, jr), window.addEventListener("blur", zb);
}
var Vb = typeof window < "u" && typeof document < "u", Gb = Vb ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function ki(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function sh(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function jb(t) {
  return sh(`
  %ctippy.js

  %c` + sh(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function Xg(t) {
  return [
    jb(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var mo;
process.env.NODE_ENV !== "production" && Kb();
function Kb() {
  mo = /* @__PURE__ */ new Set();
}
function Vn(t, e) {
  if (t && !mo.has(e)) {
    var n;
    mo.add(e), (n = console).warn.apply(n, Xg(e));
  }
}
function Ku(t, e) {
  if (t && !mo.has(e)) {
    var n;
    mo.add(e), (n = console).error.apply(n, Xg(e));
  }
}
function Wb(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  Ku(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Ku(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var Zg = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, Yb = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, Rt = Object.assign({
  appendTo: Yg,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, Zg, Yb), Qb = Object.keys(Rt), Jb = function(e) {
  process.env.NODE_ENV !== "production" && t9(e, []);
  var n = Object.keys(e);
  n.forEach(function(r) {
    Rt[r] = e[r];
  });
};
function e9(t) {
  var e = t.plugins || [], n = e.reduce(function(r, i) {
    var s = i.name, o = i.defaultValue;
    if (s) {
      var a;
      r[s] = t[s] !== void 0 ? t[s] : (a = Rt[s]) != null ? a : o;
    }
    return r;
  }, {});
  return Object.assign({}, t, n);
}
function Xb(t, e) {
  var n = e ? Object.keys(e9(Object.assign({}, Rt, {
    plugins: e
  }))) : Qb, r = n.reduce(function(i, s) {
    var o = (t.getAttribute("data-tippy-" + s) || "").trim();
    if (!o)
      return i;
    if (s === "content")
      i[s] = o;
    else
      try {
        i[s] = JSON.parse(o);
      } catch {
        i[s] = o;
      }
    return i;
  }, {});
  return r;
}
function oh(t, e) {
  var n = Object.assign({}, e, {
    content: Qg(e.content, [t])
  }, e.ignoreAttributes ? {} : Xb(t, e.plugins));
  return n.aria = Object.assign({}, Rt.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function t9(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(r) {
    var i = Db(Rt, Object.keys(Zg)), s = !vb(i, r);
    s && (s = e.filter(function(o) {
      return o.name === r;
    }).length === 0), Vn(s, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var Zb = function() {
  return "innerHTML";
};
function Wu(t, e) {
  t[Zb()] = e;
}
function ah(t) {
  var e = js();
  return t === !0 ? e.className = Kg : (e.className = Wg, po(t) ? e.appendChild(t) : Wu(e, t)), e;
}
function lh(t, e) {
  po(e.content) ? (Wu(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Wu(t, e.content) : t.textContent = e.content);
}
function Yu(t) {
  var e = t.firstElementChild, n = qa(e.children);
  return {
    box: e,
    content: n.find(function(r) {
      return r.classList.contains(jg);
    }),
    arrow: n.find(function(r) {
      return r.classList.contains(Kg) || r.classList.contains(Wg);
    }),
    backdrop: n.find(function(r) {
      return r.classList.contains(wb);
    })
  };
}
function n9(t) {
  var e = js(), n = js();
  n.className = Ob, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var r = js();
  r.className = jg, r.setAttribute("data-state", "hidden"), lh(r, t.props), e.appendChild(n), n.appendChild(r), i(t.props, t.props);
  function i(s, o) {
    var a = Yu(e), l = a.box, u = a.content, c = a.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && lh(u, t.props), o.arrow ? c ? s.arrow !== o.arrow && (l.removeChild(c), l.appendChild(ah(o.arrow))) : l.appendChild(ah(o.arrow)) : c && l.removeChild(c);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
n9.$$tippy = !0;
var e3 = 1, Bo = [], N1 = [];
function t3(t, e) {
  var n = oh(t, Object.assign({}, Rt, e9(th(e)))), r, i, s, o = !1, a = !1, l = !1, u = !1, c, f, d, h = [], m = Zd(Ei, n.interactiveDebounce), g, T = e3++, E = null, _ = Ib(n.plugins), k = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, A = {
    // properties
    id: T,
    reference: t,
    popper: js(),
    popperInstance: E,
    props: n,
    state: k,
    plugins: _,
    // methods
    clearDelayTimeouts: Ci,
    setProps: I,
    setContent: q,
    show: re,
    hide: ye,
    hideWithInteractivity: be,
    enable: Fr,
    disable: bi,
    unmount: wt,
    destroy: An
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && Ku(!0, "render() function has not been supplied."), A;
  var v = n.render(A), y = v.popper, b = v.onUpdate;
  y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + A.id, A.popper = y, t._tippy = A, y._tippy = A;
  var O = _.map(function(D) {
    return D.fn(A);
  }), P = t.hasAttribute("aria-expanded");
  return yn(), he(), se(), ie("onCreate", [A]), n.showOnCreate && Br(), y.addEventListener("mouseenter", function() {
    A.props.interactive && A.state.isVisible && A.clearDelayTimeouts();
  }), y.addEventListener("mouseleave", function() {
    A.props.interactive && A.props.trigger.indexOf("mouseenter") >= 0 && Y().addEventListener("mousemove", m);
  }), A;
  function $() {
    var D = A.props.touch;
    return Array.isArray(D) ? D : [D, 0];
  }
  function M() {
    return $()[0] === "hold";
  }
  function R() {
    var D;
    return !!((D = A.props.render) != null && D.$$tippy);
  }
  function V() {
    return g || t;
  }
  function Y() {
    var D = V().parentNode;
    return D ? Hb(D) : document;
  }
  function w() {
    return Yu(y);
  }
  function ue(D) {
    return A.state.isMounted && !A.state.isVisible || kn.isTouch || c && c.type === "focus" ? 0 : C1(A.props.delay, D ? 0 : 1, Rt.delay);
  }
  function se(D) {
    D === void 0 && (D = !1), y.style.pointerEvents = A.props.interactive && !D ? "" : "none", y.style.zIndex = "" + A.props.zIndex;
  }
  function ie(D, j, X) {
    if (X === void 0 && (X = !0), O.forEach(function(pe) {
      pe[D] && pe[D].apply(pe, j);
    }), X) {
      var te;
      (te = A.props)[D].apply(te, j);
    }
  }
  function de() {
    var D = A.props.aria;
    if (D.content) {
      var j = "aria-" + D.content, X = y.id, te = Li(A.props.triggerTarget || t);
      te.forEach(function(pe) {
        var ke = pe.getAttribute(j);
        if (A.state.isVisible)
          pe.setAttribute(j, ke ? ke + " " + X : X);
        else {
          var Ft = ke && ke.replace(X, "").trim();
          Ft ? pe.setAttribute(j, Ft) : pe.removeAttribute(j);
        }
      });
    }
  }
  function he() {
    if (!(P || !A.props.aria.expanded)) {
      var D = Li(A.props.triggerTarget || t);
      D.forEach(function(j) {
        A.props.interactive ? j.setAttribute("aria-expanded", A.state.isVisible && j === V() ? "true" : "false") : j.removeAttribute("aria-expanded");
      });
    }
  }
  function N() {
    Y().removeEventListener("mousemove", m), Bo = Bo.filter(function(D) {
      return D !== m;
    });
  }
  function S(D) {
    if (!(kn.isTouch && (l || D.type === "mousedown"))) {
      var j = D.composedPath && D.composedPath()[0] || D.target;
      if (!(A.props.interactive && rh(y, j))) {
        if (Li(A.props.triggerTarget || t).some(function(X) {
          return rh(X, j);
        })) {
          if (kn.isTouch || A.state.isVisible && A.props.trigger.indexOf("click") >= 0)
            return;
        } else
          ie("onClickOutside", [A, D]);
        A.props.hideOnClick === !0 && (A.clearDelayTimeouts(), A.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), A.state.isMounted || Ae());
      }
    }
  }
  function gt() {
    l = !0;
  }
  function ut() {
    l = !1;
  }
  function je() {
    var D = Y();
    D.addEventListener("mousedown", S, !0), D.addEventListener("touchend", S, jr), D.addEventListener("touchstart", ut, jr), D.addEventListener("touchmove", gt, jr);
  }
  function Ae() {
    var D = Y();
    D.removeEventListener("mousedown", S, !0), D.removeEventListener("touchend", S, jr), D.removeEventListener("touchstart", ut, jr), D.removeEventListener("touchmove", gt, jr);
  }
  function Ke(D, j) {
    Ot(D, function() {
      !A.state.isVisible && y.parentNode && y.parentNode.contains(y) && j();
    });
  }
  function We(D, j) {
    Ot(D, j);
  }
  function Ot(D, j) {
    var X = w().box;
    function te(pe) {
      pe.target === X && (S1(X, "remove", te), j());
    }
    if (D === 0)
      return j();
    S1(X, "remove", f), S1(X, "add", te), f = te;
  }
  function ct(D, j, X) {
    X === void 0 && (X = !1);
    var te = Li(A.props.triggerTarget || t);
    te.forEach(function(pe) {
      pe.addEventListener(D, j, X), h.push({
        node: pe,
        eventType: D,
        handler: j,
        options: X
      });
    });
  }
  function yn() {
    M() && (ct("touchstart", Lr, {
      passive: !0
    }), ct("touchend", yi, {
      passive: !0
    })), Mb(A.props.trigger).forEach(function(D) {
      if (D !== "manual")
        switch (ct(D, Lr), D) {
          case "mouseenter":
            ct("mouseleave", yi);
            break;
          case "focus":
            ct(Gb ? "focusout" : "blur", Zn);
            break;
          case "focusin":
            ct("focusout", Zn);
            break;
        }
    });
  }
  function Rr() {
    h.forEach(function(D) {
      var j = D.node, X = D.eventType, te = D.handler, pe = D.options;
      j.removeEventListener(X, te, pe);
    }), h = [];
  }
  function Lr(D) {
    var j, X = !1;
    if (!(!A.state.isEnabled || er(D) || a)) {
      var te = ((j = c) == null ? void 0 : j.type) === "focus";
      c = D, g = D.currentTarget, he(), !A.state.isVisible && Pb(D) && Bo.forEach(function(pe) {
        return pe(D);
      }), D.type === "click" && (A.props.trigger.indexOf("mouseenter") < 0 || o) && A.props.hideOnClick !== !1 && A.state.isVisible ? X = !0 : Br(D), D.type === "click" && (o = !X), X && !te && Ln(D);
    }
  }
  function Ei(D) {
    var j = D.target, X = V().contains(j) || y.contains(j);
    if (!(D.type === "mousemove" && X)) {
      var te = nn().concat(y).map(function(pe) {
        var ke, Ft = pe._tippy, xi = (ke = Ft.popperInstance) == null ? void 0 : ke.state;
        return xi ? {
          popperRect: pe.getBoundingClientRect(),
          popperState: xi,
          props: n
        } : null;
      }).filter(Boolean);
      Ub(te, D) && (N(), Ln(D));
    }
  }
  function yi(D) {
    var j = er(D) || A.props.trigger.indexOf("click") >= 0 && o;
    if (!j) {
      if (A.props.interactive) {
        A.hideWithInteractivity(D);
        return;
      }
      Ln(D);
    }
  }
  function Zn(D) {
    A.props.trigger.indexOf("focusin") < 0 && D.target !== V() || A.props.interactive && D.relatedTarget && y.contains(D.relatedTarget) || Ln(D);
  }
  function er(D) {
    return kn.isTouch ? M() !== D.type.indexOf("touch") >= 0 : !1;
  }
  function Pr() {
    Ai();
    var D = A.props, j = D.popperOptions, X = D.placement, te = D.offset, pe = D.getReferenceClientRect, ke = D.moveTransition, Ft = R() ? Yu(y).arrow : null, xi = pe ? {
      getBoundingClientRect: pe,
      contextElement: pe.contextElement || V()
    } : t, Uf = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Do) {
        var Si = Do.state;
        if (R()) {
          var k4 = w(), Xl = k4.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Mo) {
            Mo === "placement" ? Xl.setAttribute("data-placement", Si.placement) : Si.attributes.popper["data-popper-" + Mo] ? Xl.setAttribute("data-" + Mo, "") : Xl.removeAttribute("data-" + Mo);
          }), Si.attributes.popper = {};
        }
      }
    }, Hr = [{
      name: "offset",
      options: {
        offset: te
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !ke
      }
    }, Uf];
    R() && Ft && Hr.push({
      name: "arrow",
      options: {
        element: Ft,
        padding: 3
      }
    }), Hr.push.apply(Hr, (j == null ? void 0 : j.modifiers) || []), A.popperInstance = _b(xi, y, Object.assign({}, j, {
      placement: X,
      onFirstUpdate: d,
      modifiers: Hr
    }));
  }
  function Ai() {
    A.popperInstance && (A.popperInstance.destroy(), A.popperInstance = null);
  }
  function Bt() {
    var D = A.props.appendTo, j, X = V();
    A.props.interactive && D === Yg || D === "parent" ? j = X.parentNode : j = Qg(D, [X]), j.contains(y) || j.appendChild(y), A.state.isMounted = !0, Pr(), process.env.NODE_ENV !== "production" && Vn(A.props.interactive && D === Rt.appendTo && X.nextElementSibling !== y, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function nn() {
    return qa(y.querySelectorAll("[data-tippy-root]"));
  }
  function Br(D) {
    A.clearDelayTimeouts(), D && ie("onTrigger", [A, D]), je();
    var j = ue(!0), X = $(), te = X[0], pe = X[1];
    kn.isTouch && te === "hold" && pe && (j = pe), j ? r = setTimeout(function() {
      A.show();
    }, j) : A.show();
  }
  function Ln(D) {
    if (A.clearDelayTimeouts(), ie("onUntrigger", [A, D]), !A.state.isVisible) {
      Ae();
      return;
    }
    if (!(A.props.trigger.indexOf("mouseenter") >= 0 && A.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(D.type) >= 0 && o)) {
      var j = ue(!1);
      j ? i = setTimeout(function() {
        A.state.isVisible && A.hide();
      }, j) : s = requestAnimationFrame(function() {
        A.hide();
      });
    }
  }
  function Fr() {
    A.state.isEnabled = !0;
  }
  function bi() {
    A.hide(), A.state.isEnabled = !1;
  }
  function Ci() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(s);
  }
  function I(D) {
    if (process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("setProps")), !A.state.isDestroyed) {
      ie("onBeforeUpdate", [A, D]), Rr();
      var j = A.props, X = oh(t, Object.assign({}, j, th(D), {
        ignoreAttributes: !0
      }));
      A.props = X, yn(), j.interactiveDebounce !== X.interactiveDebounce && (N(), m = Zd(Ei, X.interactiveDebounce)), j.triggerTarget && !X.triggerTarget ? Li(j.triggerTarget).forEach(function(te) {
        te.removeAttribute("aria-expanded");
      }) : X.triggerTarget && t.removeAttribute("aria-expanded"), he(), se(), b && b(j, X), A.popperInstance && (Pr(), nn().forEach(function(te) {
        requestAnimationFrame(te._tippy.popperInstance.forceUpdate);
      })), ie("onAfterUpdate", [A, D]);
    }
  }
  function q(D) {
    A.setProps({
      content: D
    });
  }
  function re() {
    process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("show"));
    var D = A.state.isVisible, j = A.state.isDestroyed, X = !A.state.isEnabled, te = kn.isTouch && !A.props.touch, pe = C1(A.props.duration, 0, Rt.duration);
    if (!(D || j || X || te) && !V().hasAttribute("disabled") && (ie("onShow", [A], !1), A.props.onShow(A) !== !1)) {
      if (A.state.isVisible = !0, R() && (y.style.visibility = "visible"), se(), je(), A.state.isMounted || (y.style.transition = "none"), R()) {
        var ke = w(), Ft = ke.box, xi = ke.content;
        x1([Ft, xi], 0);
      }
      d = function() {
        var Hr;
        if (!(!A.state.isVisible || u)) {
          if (u = !0, y.offsetHeight, y.style.transition = A.props.moveTransition, R() && A.props.animation) {
            var Jl = w(), Do = Jl.box, Si = Jl.content;
            x1([Do, Si], pe), nh([Do, Si], "visible");
          }
          de(), he(), eh(N1, A), (Hr = A.popperInstance) == null || Hr.forceUpdate(), ie("onMount", [A]), A.props.animation && R() && We(pe, function() {
            A.state.isShown = !0, ie("onShown", [A]);
          });
        }
      }, Bt();
    }
  }
  function ye() {
    process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("hide"));
    var D = !A.state.isVisible, j = A.state.isDestroyed, X = !A.state.isEnabled, te = C1(A.props.duration, 1, Rt.duration);
    if (!(D || j || X) && (ie("onHide", [A], !1), A.props.onHide(A) !== !1)) {
      if (A.state.isVisible = !1, A.state.isShown = !1, u = !1, o = !1, R() && (y.style.visibility = "hidden"), N(), Ae(), se(!0), R()) {
        var pe = w(), ke = pe.box, Ft = pe.content;
        A.props.animation && (x1([ke, Ft], te), nh([ke, Ft], "hidden"));
      }
      de(), he(), A.props.animation ? R() && Ke(te, A.unmount) : A.unmount();
    }
  }
  function be(D) {
    process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("hideWithInteractivity")), Y().addEventListener("mousemove", m), eh(Bo, m), m(D);
  }
  function wt() {
    process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("unmount")), A.state.isVisible && A.hide(), A.state.isMounted && (Ai(), nn().forEach(function(D) {
      D._tippy.unmount();
    }), y.parentNode && y.parentNode.removeChild(y), N1 = N1.filter(function(D) {
      return D !== A;
    }), A.state.isMounted = !1, ie("onHidden", [A]));
  }
  function An() {
    process.env.NODE_ENV !== "production" && Vn(A.state.isDestroyed, ki("destroy")), !A.state.isDestroyed && (A.clearDelayTimeouts(), A.unmount(), Rr(), delete t._tippy, A.state.isDestroyed = !0, ie("onDestroy", [A]));
  }
}
function ps(t, e) {
  e === void 0 && (e = {});
  var n = Rt.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (Wb(t), t9(e, n)), $b();
  var r = Object.assign({}, e, {
    plugins: n
  }), i = Fb(t);
  if (process.env.NODE_ENV !== "production") {
    var s = po(r.content), o = i.length > 1;
    Vn(s && o, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = i.reduce(function(l, u) {
    var c = u && t3(u, r);
    return c && l.push(c), l;
  }, []);
  return po(t) ? a[0] : a;
}
ps.defaultProps = Rt;
ps.setDefaultProps = Jb;
ps.currentInput = kn;
Object.assign({}, Fg, {
  effect: function(e) {
    var n = e.state, r = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
  }
});
ps.setDefaultProps({
  render: n9
});
var Fo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function n3(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var r9 = n3, r3 = typeof Fo == "object" && Fo && Fo.Object === Object && Fo, i3 = r3, s3 = i3, o3 = typeof self == "object" && self && self.Object === Object && self, a3 = s3 || o3 || Function("return this")(), i9 = a3, l3 = i9, u3 = function() {
  return l3.Date.now();
}, c3 = u3, f3 = /\s/;
function d3(t) {
  for (var e = t.length; e-- && f3.test(t.charAt(e)); )
    ;
  return e;
}
var h3 = d3, p3 = h3, m3 = /^\s+/;
function g3(t) {
  return t && t.slice(0, p3(t) + 1).replace(m3, "");
}
var T3 = g3, E3 = i9, y3 = E3.Symbol, s9 = y3, uh = s9, o9 = Object.prototype, A3 = o9.hasOwnProperty, b3 = o9.toString, Ns = uh ? uh.toStringTag : void 0;
function C3(t) {
  var e = A3.call(t, Ns), n = t[Ns];
  try {
    t[Ns] = void 0;
    var r = !0;
  } catch {
  }
  var i = b3.call(t);
  return r && (e ? t[Ns] = n : delete t[Ns]), i;
}
var x3 = C3, S3 = Object.prototype, N3 = S3.toString;
function k3(t) {
  return N3.call(t);
}
var _3 = k3, ch = s9, O3 = x3, w3 = _3, v3 = "[object Null]", D3 = "[object Undefined]", fh = ch ? ch.toStringTag : void 0;
function M3(t) {
  return t == null ? t === void 0 ? D3 : v3 : fh && fh in Object(t) ? O3(t) : w3(t);
}
var I3 = M3;
function R3(t) {
  return t != null && typeof t == "object";
}
var L3 = R3, P3 = I3, B3 = L3, F3 = "[object Symbol]";
function H3(t) {
  return typeof t == "symbol" || B3(t) && P3(t) == F3;
}
var U3 = H3, q3 = T3, dh = r9, z3 = U3, hh = 0 / 0, $3 = /^[-+]0x[0-9a-f]+$/i, V3 = /^0b[01]+$/i, G3 = /^0o[0-7]+$/i, j3 = parseInt;
function K3(t) {
  if (typeof t == "number")
    return t;
  if (z3(t))
    return hh;
  if (dh(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = dh(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = q3(t);
  var n = V3.test(t);
  return n || G3.test(t) ? j3(t.slice(2), n ? 2 : 8) : $3.test(t) ? hh : +t;
}
var W3 = K3, Y3 = r9, k1 = c3, ph = W3, Q3 = "Expected a function", J3 = Math.max, X3 = Math.min;
function Z3(t, e, n) {
  var r, i, s, o, a, l, u = 0, c = !1, f = !1, d = !0;
  if (typeof t != "function")
    throw new TypeError(Q3);
  e = ph(e) || 0, Y3(n) && (c = !!n.leading, f = "maxWait" in n, s = f ? J3(ph(n.maxWait) || 0, e) : s, d = "trailing" in n ? !!n.trailing : d);
  function h(y) {
    var b = r, O = i;
    return r = i = void 0, u = y, o = t.apply(O, b), o;
  }
  function m(y) {
    return u = y, a = setTimeout(E, e), c ? h(y) : o;
  }
  function g(y) {
    var b = y - l, O = y - u, P = e - b;
    return f ? X3(P, s - O) : P;
  }
  function T(y) {
    var b = y - l, O = y - u;
    return l === void 0 || b >= e || b < 0 || f && O >= s;
  }
  function E() {
    var y = k1();
    if (T(y))
      return _(y);
    a = setTimeout(E, g(y));
  }
  function _(y) {
    return a = void 0, d && r ? h(y) : (r = i = void 0, o);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = i = a = void 0;
  }
  function A() {
    return a === void 0 ? o : _(k1());
  }
  function v() {
    var y = k1(), b = T(y);
    if (r = arguments, i = this, l = y, b) {
      if (a === void 0)
        return m(l);
      if (f)
        return clearTimeout(a), a = setTimeout(E, e), h(l);
    }
    return a === void 0 && (a = setTimeout(E, e)), o;
  }
  return v.cancel = k, v.flush = A, v;
}
var e6 = Z3;
class t6 {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: s = 250, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: u, to: c }) => {
      const { doc: f, selection: d } = l, { empty: h } = d, m = !f.textBetween(u, c).length && Rc(l.selection), g = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || g) || h || m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.updateHandler = (a, l) => {
      var u, c, f;
      const { state: d, composing: h } = a, { doc: m, selection: g } = d, T = l && l.doc.eq(m) && l.selection.eq(g);
      if (h || T)
        return;
      this.createTooltip();
      const { ranges: E } = g, _ = Math.min(...E.map((v) => v.$from.pos)), k = Math.max(...E.map((v) => v.$to.pos));
      if (!((u = this.shouldShow) === null || u === void 0 ? void 0 : u.call(this, {
        editor: this.editor,
        view: a,
        state: d,
        oldState: l,
        from: _,
        to: k
      }))) {
        this.hide();
        return;
      }
      (c = this.tippy) === null || c === void 0 || c.setProps({
        getReferenceClientRect: ((f = this.tippyOptions) === null || f === void 0 ? void 0 : f.getReferenceClientRect) || (() => {
          if (zy(d.selection)) {
            const v = a.nodeDOM(_);
            if (v)
              return v.getBoundingClientRect();
          }
          return Lg(a, _, k);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = r, this.updateDelay = s, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = ps(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: r } = e, i = r.selection.$from.pos !== r.selection.$to.pos;
    this.updateDelay > 0 && i ? e6(this.updateHandler, this.updateDelay)(e, n) : this.updateHandler(e, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const a9 = (t) => new Be({
  key: typeof t.pluginKey == "string" ? new Ge(t.pluginKey) : t.pluginKey,
  view: (e) => new t6({ view: e, ...t })
});
Nt.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      a9({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class n6 {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: o, state: a }) => {
      const { selection: l } = a, { $anchor: u, empty: c } = l, f = u.depth === 1, d = u.parent.isTextblock && !u.parent.type.spec.code && !u.parent.textContent;
      return !(!o.hasFocus() || !c || !f || !d || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      o != null && o.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(o.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = n, this.view = r, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = ps(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var r, i, s;
    const { state: o } = e, { doc: a, selection: l } = o, { from: u, to: c } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => Lg(e, u, c))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const l9 = (t) => new Be({
  key: typeof t.pluginKey == "string" ? new Ge(t.pluginKey) : t.pluginKey,
  view: (e) => new n6({ view: e, ...t })
});
Nt.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      l9({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const pR = (t) => {
  const [e, n] = pl(null);
  return Ec(() => {
    if (!e || t.editor.isDestroyed)
      return;
    const { pluginKey: r = "bubbleMenu", editor: i, tippyOptions: s = {}, updateDelay: o, shouldShow: a = null } = t, l = a9({
      updateDelay: o,
      editor: i,
      element: e,
      pluginKey: r,
      shouldShow: a,
      tippyOptions: s
    });
    return i.registerPlugin(l), () => i.unregisterPlugin(r);
  }, [t.editor, e]), Mt.createElement("div", { ref: n, className: t.className, style: { visibility: "hidden" } }, t.children);
};
class r6 extends TA {
  constructor() {
    super(...arguments), this.contentComponent = null;
  }
}
const i6 = ({ renderers: t }) => Mt.createElement(Mt.Fragment, null, Object.entries(t).map(([e, n]) => w4.createPortal(n.reactElement, n.element, e)));
class s6 extends Mt.Component {
  constructor(e) {
    super(e), this.editorContentRef = Mt.createRef(), this.initialized = !1, this.state = {
      renderers: {}
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const { editor: e } = this.props;
    if (e && e.options.element) {
      if (e.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...e.options.element.childNodes), e.setOptions({
        element: n
      }), e.contentComponent = this, e.createNodeViews(), this.initialized = !0;
    }
  }
  maybeFlushSync(e) {
    this.initialized ? queueMicrotask(() => {
      v4(e);
    }) : e();
  }
  setRenderer(e, n) {
    this.maybeFlushSync(() => {
      this.setState(({ renderers: r }) => ({
        renderers: {
          ...r,
          [e]: n
        }
      }));
    });
  }
  removeRenderer(e) {
    this.maybeFlushSync(() => {
      this.setState(({ renderers: n }) => {
        const r = { ...n };
        return delete r[e], { renderers: r };
      });
    });
  }
  componentWillUnmount() {
    const { editor: e } = this.props;
    if (!e || (this.initialized = !1, e.isDestroyed || e.view.setProps({
      nodeViews: {}
    }), e.contentComponent = null, !e.options.element.firstChild))
      return;
    const n = document.createElement("div");
    n.append(...e.options.element.childNodes), e.setOptions({
      element: n
    });
  }
  render() {
    const { editor: e, ...n } = this.props;
    return Mt.createElement(
      Mt.Fragment,
      null,
      Mt.createElement("div", { ref: this.editorContentRef, ...n }),
      Mt.createElement(i6, { renderers: this.state.renderers })
    );
  }
}
const mR = Mt.memo(s6), gR = (t) => {
  const [e, n] = pl(null);
  return Ec(() => {
    if (!e || t.editor.isDestroyed)
      return;
    const { pluginKey: r = "floatingMenu", editor: i, tippyOptions: s = {}, shouldShow: o = null } = t, a = l9({
      pluginKey: r,
      editor: i,
      element: e,
      tippyOptions: s,
      shouldShow: o
    });
    return i.registerPlugin(a), () => i.unregisterPlugin(r);
  }, [
    t.editor,
    e
  ]), Mt.createElement("div", { ref: n, className: t.className, style: { visibility: "hidden" } }, t.children);
}, o6 = _4({
  onDragStart: void 0
}), a6 = () => O4(o6);
Mt.forwardRef((t, e) => {
  const { onDragStart: n } = a6(), r = t.as || "div";
  return Mt.createElement(r, { ...t, ref: e, "data-node-view-wrapper": "", onDragStart: n, style: {
    whiteSpace: "normal",
    ...t.style
  } });
});
function l6() {
  const [, t] = pl(0);
  return () => t((e) => e + 1);
}
const u9 = (t = {}, e = []) => {
  const [n, r] = pl(null), i = l6();
  return Ec(() => {
    let s = !0;
    const o = new r6(t);
    return r(o), o.on("transaction", () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          s && i();
        });
      });
    }), () => {
      o.destroy(), s = !1;
    };
  }, e), n;
}, u6 = /^\s*>\s$/, c9 = He.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      co({
        find: u6,
        type: this.type
      })
    ];
  }
}), c6 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/, f6 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g, d6 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/, h6 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g, f9 = Wt.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      as({
        find: c6,
        type: this.type
      }),
      as({
        find: d6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      di({
        find: f6,
        type: this.type
      }),
      di({
        find: h6,
        type: this.type
      })
    ];
  }
}), p6 = He.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Pe(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), mh = Wt.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = _l(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), gh = /^\s*([-+*])\s$/, d9 = He.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(p6.name, this.editor.getAttributes(mh.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = co({
      find: gh,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = co({
      find: gh,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(mh.name),
      editor: this.editor
    })), [
      t
    ];
  }
}), m6 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/, g6 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g, h9 = Wt.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      as({
        find: m6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      di({
        find: g6,
        type: this.type
      })
    ];
  }
}), T6 = /^```([a-z]+)?[\s\n]$/, E6 = /^~~~([a-z]+)?[\s\n]$/, p9 = He.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(n)).map((o) => o.replace(n, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Pe(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
        return !s || !o ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: i, empty: s } = n;
        if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 || r.nodeAt(a) ? !1 : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      $u({
        find: T6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      $u({
        find: E6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Be({
        key: new Ge("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i == null ? void 0 : i.mode;
            if (!n || !s)
              return !1;
            const { tr: o } = t.state;
            return o.replaceSelectionWith(this.type.create({ language: s })), o.setSelection(ce.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.insertText(n.replace(/\r\n?/g, `
`)), o.setMeta("paste", !0), t.dispatch(o), !0;
          }
        }
      })
    ];
  }
}), m9 = He.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
class Re extends le {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Re.valid(r) ? new Re(r) : le.near(r);
  }
  content() {
    return G.empty;
  }
  eq(e) {
    return e instanceof Re && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Re(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Vc(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !y6(e) || !A6(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e:
      for (; ; ) {
        if (!r && Re.valid(e))
          return e;
        let i = e.pos, s = null;
        for (let o = e.depth; ; o--) {
          let a = e.node(o);
          if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
            s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
            break;
          } else if (o == 0)
            return null;
          i += n;
          let l = e.doc.resolve(i);
          if (Re.valid(l))
            return l;
        }
        for (; ; ) {
          let o = n > 0 ? s.firstChild : s.lastChild;
          if (!o) {
            if (s.isAtom && !s.isText && !ne.isSelectable(s)) {
              e = e.doc.resolve(i + s.nodeSize * n), r = !1;
              continue e;
            }
            break;
          }
          s = o, i += n;
          let a = e.doc.resolve(i);
          if (Re.valid(a))
            return a;
        }
        return null;
      }
  }
}
Re.prototype.visible = !1;
Re.findFrom = Re.findGapCursorFrom;
le.jsonID("gapcursor", Re);
class Vc {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Vc(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Re.valid(n) ? new Re(n) : le.near(n);
  }
}
function y6(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function A6(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function b6() {
  return new Be({
    props: {
      decorations: N6,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Re.valid(n) ? new Re(n) : null;
      },
      handleClick: x6,
      handleKeyDown: C6,
      handleDOMEvents: { beforeinput: S6 }
    }
  });
}
const C6 = Ag({
  ArrowLeft: Ho("horiz", -1),
  ArrowRight: Ho("horiz", 1),
  ArrowUp: Ho("vert", -1),
  ArrowDown: Ho("vert", 1)
});
function Ho(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof ce) {
      if (!s.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let u = Re.findGapCursorFrom(a, e, l);
    return u ? (i && i(r.tr.setSelection(new Re(u))), !0) : !1;
  };
}
function x6(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Re.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ne.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Re(r))), !0);
}
function S6(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Re))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = B.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = B.from(r[o].createAndFill(null, i));
  let s = t.state.tr.replace(n.pos, n.pos, new G(i, 0, 0));
  return s.setSelection(ce.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1;
}
function N6(t) {
  if (!(t.selection instanceof Re))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Le.create(t.doc, [bt.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const k6 = Nt.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      b6()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = ae(W(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), g9 = He.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Pe(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: i, storedMarks: s } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: a } = r.extensionManager, l = s || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: u, dispatch: c }) => {
            if (c && l && o) {
              const f = l.filter((d) => a.includes(d.type.name));
              u.ensureMarks(f);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), _6 = He.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Pe(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => $u({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
var za = 200, nt = function() {
};
nt.prototype.append = function(e) {
  return e.length ? (e = nt.from(e), !this.length && e || e.length < za && this.leafAppend(e) || this.length < za && e.leafPrepend(this) || this.appendInner(e)) : this;
};
nt.prototype.prepend = function(e) {
  return e.length ? nt.from(e).append(this) : this;
};
nt.prototype.appendInner = function(e) {
  return new O6(this, e);
};
nt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? nt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
nt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
nt.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
nt.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, n, r), i;
};
nt.from = function(e) {
  return e instanceof nt ? e : e && e.length ? new T9(e) : nt.empty;
};
var T9 = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, a) {
    for (var l = s; l < o; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= za)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= za)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(nt);
nt.empty = new T9([]);
var O6 = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(nt), E9 = nt;
const w6 = 500;
class cn {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    n && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, a, l, u = [], c = [];
    return this.items.forEach((f, d) => {
      if (!f.step) {
        i || (i = this.remapping(r, d + 1), s = i.maps.length), s--, c.push(f);
        return;
      }
      if (i) {
        c.push(new Cn(f.map));
        let h = f.step.map(i.slice(s)), m;
        h && o.maybeStep(h).doc && (m = o.mapping.maps[o.mapping.maps.length - 1], u.push(new Cn(m, void 0, void 0, u.length + c.length))), s--, m && i.appendMap(m, s);
      } else
        o.maybeStep(f.step);
      if (f.selection)
        return a = i ? f.selection.map(i.slice(s)) : f.selection, l = new cn(this.items.slice(0, r).append(c.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let s = [], o = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let f = e.steps[c].invert(e.docs[c]), d = new Cn(e.mapping.maps[c], f, n), h;
      (h = l && l.merge(d)) && (d = h, c ? s.pop() : a = a.slice(0, a.length - 1)), s.push(d), n && (o++, n = void 0), i || (l = d);
    }
    let u = o - r.depth;
    return u > D6 && (a = v6(a, u), o -= u), new cn(a.append(s), o);
  }
  remapping(e, n) {
    let r = new Wi();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new cn(this.items.append(e.map((n) => new Cn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((d) => {
      d.selection && a--;
    }, i);
    let l = n;
    this.items.forEach((d) => {
      let h = s.getMirror(--l);
      if (h == null)
        return;
      o = Math.min(o, h);
      let m = s.maps[h];
      if (d.step) {
        let g = e.steps[h].invert(e.docs[h]), T = d.selection && d.selection.map(s.slice(l + 1, h));
        T && a++, r.push(new Cn(m, g, T));
      } else
        r.push(new Cn(m));
    }, i);
    let u = [];
    for (let d = n; d < o; d++)
      u.push(new Cn(s.maps[d]));
    let c = this.items.slice(0, i).append(u).append(r), f = new cn(c, a);
    return f.emptyItemCount() > w6 && (f = f.compress(this.items.length - r.length)), f;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(n.slice(r)), u = l && l.getMap();
        if (r--, u && n.appendMap(u, r), l) {
          let c = o.selection && o.selection.map(n.slice(r));
          c && s++;
          let f = new Cn(u.invert(), l, c), d, h = i.length - 1;
          (d = i.length && i[h].merge(f)) ? i[h] = d : i.push(f);
        }
      } else
        o.map && r--;
    }, this.items.length, 0), new cn(E9.from(i.reverse()), s);
  }
}
cn.empty = new cn(E9.empty, 0);
function v6(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
class Cn {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Cn(n.getMap().invert(), n, this.selection);
    }
  }
}
class dr {
  constructor(e, n, r, i) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i;
  }
}
const D6 = 20;
function M6(t, e, n, r) {
  let i = n.getMeta(xr), s;
  if (i)
    return i.historyState;
  n.getMeta(R6) && (t = new dr(t.done, t.undone, null, 0));
  let o = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (o && o.getMeta(xr))
    return o.getMeta(xr).redo ? new dr(t.done.addTransform(n, void 0, r, da(e)), t.undone, Th(n.mapping.maps[n.steps.length - 1]), t.prevTime) : new dr(t.done, t.undone.addTransform(n, void 0, r, da(e)), null, t.prevTime);
  if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = t.prevTime == 0 || !o && (t.prevTime < (n.time || 0) - r.newGroupDelay || !I6(n, t.prevRanges)), l = o ? _1(t.prevRanges, n.mapping) : Th(n.mapping.maps[n.steps.length - 1]);
    return new dr(t.done.addTransform(n, a ? e.selection.getBookmark() : void 0, r, da(e)), cn.empty, l, n.time);
  } else
    return (s = n.getMeta("rebased")) ? new dr(t.done.rebased(n, s), t.undone.rebased(n, s), _1(t.prevRanges, n.mapping), t.prevTime) : new dr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), _1(t.prevRanges, n.mapping), t.prevTime);
}
function I6(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (n = !0);
  }), n;
}
function Th(t) {
  let e = [];
  return t.forEach((n, r, i, s) => e.push(i, s)), e;
}
function _1(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), s = e.map(t[r + 1], -1);
    i <= s && n.push(i, s);
  }
  return n;
}
function y9(t, e, n, r) {
  let i = da(e), s = xr.get(e).spec.config, o = (r ? t.undone : t.done).popEvent(e, i);
  if (!o)
    return;
  let a = o.selection.resolve(o.transform.doc), l = (r ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), s, i), u = new dr(r ? l : o.remaining, r ? o.remaining : l, null, 0);
  n(o.transform.setSelection(a).setMeta(xr, { redo: r, historyState: u }).scrollIntoView());
}
let O1 = !1, Eh = null;
function da(t) {
  let e = t.plugins;
  if (Eh != e) {
    O1 = !1, Eh = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        O1 = !0;
        break;
      }
  }
  return O1;
}
const xr = new Ge("history"), R6 = new Ge("closeHistory");
function L6(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Be({
    key: xr,
    state: {
      init() {
        return new dr(cn.empty, cn.empty, null, 0);
      },
      apply(e, n, r) {
        return M6(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? A9 : r == "historyRedo" ? b9 : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const A9 = (t, e) => {
  let n = xr.getState(t);
  return !n || n.done.eventCount == 0 ? !1 : (e && y9(n, t, e, !1), !0);
}, b9 = (t, e) => {
  let n = xr.getState(t);
  return !n || n.undone.eventCount == 0 ? !1 : (e && y9(n, t, e, !0), !0);
}, C9 = Nt.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => A9(t, e),
      redo: () => ({ state: t, dispatch: e }) => b9(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      L6(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), P6 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/, B6 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g, F6 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/, H6 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g, x9 = Wt.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      as({
        find: P6,
        type: this.type
      }),
      as({
        find: F6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      di({
        find: B6,
        type: this.type
      }),
      di({
        find: H6,
        type: this.type
      })
    ];
  }
}), S9 = Wt.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), N9 = He.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Pe(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t }) => t().insertContent({ type: this.name }).command(({ tr: e, dispatch: n }) => {
        var r;
        if (n) {
          const { $to: i } = e.selection, s = i.end();
          if (i.nodeAfter)
            e.setSelection(ce.create(e.doc, i.pos));
          else {
            const o = (r = i.parent.type.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.create();
            o && (e.insert(s, o), e.setSelection(ce.create(e.doc, s)));
          }
          e.scrollIntoView();
        }
        return !0;
      }).run()
    };
  },
  addInputRules() {
    return [
      EA({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), k9 = He.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Pe(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), U6 = He.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Pe(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), yh = Wt.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = _l(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), Ah = /^(\d+)\.\s$/, _9 = He.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Pe(this.options.HTMLAttributes, n), 0] : ["ol", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(U6.name, this.editor.getAttributes(yh.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = co({
      find: Ah,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = co({
      find: Ah,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(yh.name),
      editor: this.editor
    })), [
      t
    ];
  }
}), O9 = He.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), w9 = Nt.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = [];
            if (!n)
              return null;
            const s = t.type.createAndFill(), o = (s == null ? void 0 : s.sameMarkup(t)) && s.content.findDiffStart(t.content) === null;
            return t.descendants((a, l) => {
              const u = r >= l && r <= l + a.nodeSize, c = !a.isLeaf && !a.childCount;
              if ((u || !this.options.showOnlyCurrent) && c) {
                const f = [this.options.emptyNodeClass];
                o && f.push(this.options.emptyEditorClass);
                const d = bt.node(l, l + a.nodeSize, {
                  class: f.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: l,
                    hasAnchor: u
                  }) : this.options.placeholder
                });
                i.push(d);
              }
              return this.options.includeChildren;
            }), Le.create(t, i);
          }
        }
      })
    ];
  }
}), q6 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/, z6 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g, v9 = Wt.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Pe(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      as({
        find: q6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      di({
        find: z6,
        type: this.type
      })
    ];
  }
}), D9 = He.create({
  name: "text",
  group: "inline"
}), $6 = He.create({
  name: "figureAudio",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("source")) == null ? void 0 : e.getAttribute("src");
        }
      },
      title: {
        default: "",
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector(".title")) == null ? void 0 : e.textContent;
        }
      },
      duration: {
        default: "00:00",
        parseHTML: (t) => {
          var n;
          const e = t.querySelector(".duration");
          return (n = e == null ? void 0 : e.dataset) == null ? void 0 : n.time;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'figure[class="audio"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "figure",
      { class: "audio" },
      [
        "audio",
        { controls: !0 },
        [
          "source",
          {
            src: t.src,
            type: "audio/mp3",
            draggable: !1,
            contenteditable: !1
          }
        ]
      ],
      [
        "div",
        { class: "player" },
        [
          "header",
          [
            "div",
            { class: "meta" },
            ["h4", { class: "title" }, t.title],
            [
              "div",
              { class: "time" },
              ["span", { class: "current", "data-time": "00:00" }],
              [
                "span",
                {
                  class: "duration",
                  "data-time": t.duration
                }
              ]
            ]
          ],
          ["span", { class: "play" }]
        ],
        ["footer", ["div", { class: "progress-bar" }, ["span", {}]]]
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureAudio: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("removePastedFigureAudio"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.audio.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), V6 = (t) => {
  const e = {
    url: "",
    allowfullscreen: !1,
    sandbox: []
  };
  let n;
  try {
    n = new URL(t);
  } catch {
    return e;
  }
  const { hostname: r, pathname: i, searchParams: s } = n;
  if ([
    "youtube.com",
    "youtu.be",
    "www.youtu.be",
    "www.youtube.com"
  ].includes(r)) {
    const d = s.get("v"), h = s.get("t"), m = new URLSearchParams({
      rel: "0",
      ...h ? { start: h } : {}
    }).toString();
    let g = "";
    return d ? g = d : i.match("/embed/") ? g = i.split("/embed/")[1] : r.includes("youtu.be") && (g = i.split("/")[1]), {
      url: `https://www.youtube.com/embed/${g}` + (m ? `?=${m}` : ""),
      provider: "youtube",
      allowfullscreen: !0,
      sandbox: []
    };
  }
  if (["vimeo.com", "www.vimeo.com", "player.vimeo.com"].includes(
    r
  ))
    return {
      url: `https://player.vimeo.com/video/${i.replace(/\/$/, "").split("/").slice(-1)[0]}`,
      provider: "vimeo",
      allowfullscreen: !0,
      sandbox: []
    };
  if ([
    "bilibili.com",
    "player.bilibili.com",
    "www.bilibili.com"
  ].includes(r)) {
    const d = s.get("bvid");
    let h = "";
    return d ? h = d : h = i.replace(/\/$/, "").split("/").slice(-1)[0], {
      url: `https://player.bilibili.com/player.html?bvid=${h}`,
      provider: "bilibili",
      allowfullscreen: !0,
      sandbox: []
    };
  }
  if (["instagram.com", "www.instagram.com"].includes(r))
    return {
      url: `https://www.instagram.com/p/${i.replace("/embed", "").replace(/\/$/, "").split("/").slice(-1)[0]}/embed`,
      provider: "instagram",
      allowfullscreen: !1,
      sandbox: []
    };
  if (["jsfiddle.net", "www.jsfiddle.net"].includes(r)) {
    const d = i.replace("/embedded", "").replace(/\/$/, "").split("/").filter(Boolean);
    return {
      url: `https://jsfiddle.net/${d.length === 1 ? d[0] : d[1]}/embedded/`,
      provider: "jsfiddle",
      allowfullscreen: !1,
      sandbox: []
    };
  }
  if (["codepen.io", "www.codepen.io"].includes(r)) {
    const d = i.split("/")[1], h = i.replace(/\/$/, "").split("/").slice(-1)[0];
    return {
      url: `https://codepen.io/${d}/embed/preview/${h}`,
      provider: "codepen",
      allowfullscreen: !1,
      sandbox: []
    };
  }
  return e;
}, G6 = He.create({
  name: "figureEmbed",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      class: {
        default: null,
        parseHTML: (t) => t.getAttribute("class")
      },
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("iframe")) == null ? void 0 : e.getAttribute("src");
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        // match "embed", "embed-video", "embed-code" for backward compatibility
        tag: 'figure[class^="embed"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { url: e, provider: n, allowfullscreen: r, sandbox: i } = V6(
      t.src
    );
    return [
      "figure",
      { class: "embed", ...n ? { "data-provider": n } : {} },
      [
        "div",
        { class: "iframe-container" },
        [
          "iframe",
          {
            src: e,
            loading: "lazy",
            ...i && i.length > 0 ? { sandbox: i.join(" ") } : {},
            ...r ? { allowfullscreen: !0 } : {},
            frameborder: "0",
            draggable: !1,
            contenteditable: !1
          }
        ]
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureEmbed: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("removePastedFigureEmbed"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.embed.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), j6 = He.create({
  name: "figureImage",
  group: "block",
  content: "inline*",
  draggable: !0,
  isolating: !0,
  addAttributes() {
    return {
      class: {
        default: null,
        parseHTML: (t) => t.getAttribute("class")
      },
      src: {
        default: null,
        parseHTML: (t) => {
          var e;
          return (e = t.querySelector("img")) == null ? void 0 : e.getAttribute("src");
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'figure[class="image"]',
        contentElement: "figcaption"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "figure",
      { class: "image" },
      [
        "img",
        {
          src: t.src,
          draggable: !1,
          contenteditable: !1
        }
      ],
      ["figcaption", 0]
    ];
  },
  addCommands() {
    return {
      setFigureImage: ({ caption: t, ...e }) => ({ chain: n }) => n().insertContent({
        type: this.name,
        attrs: e,
        content: t ? [{ type: "text", text: t }] : []
      }).command(({ tr: r, commands: i }) => {
        const { doc: s, selection: o } = r, a = s.resolve(o.to - 2).end();
        return i.setTextSelection(a);
      }).run()
    };
  },
  addProseMirrorPlugins() {
    return [
      new Be({
        key: new Ge("removePastedFigureImage"),
        props: {
          transformPastedHTML(t) {
            return t = t.replace(
              /<figure.*class=.image.*[\n]*.*?<\/figure>/g,
              ""
            ), t;
          }
        }
      })
    ];
  }
}), K6 = "aaa1rp3barth4b_ott3vie4c1le2ogado5udhabi7c_ademy5centure6ountant_s9o1tor4d_s1ult4e_g1ro2tna4f_l1rica5g_akhan5ency5i_g1rbus3force5tel5kdn3l_faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m_azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o_l2partments8p_le4q_uarelle8r_ab1mco4chi3my2pa2t_e3s_da2ia2sociates9t_hleta5torney7u_ction5di_ble3o3spost5thor3o_s4vianca6w_s2x_a2z_ure5ba_by2idu3namex3narepublic11d1k2r_celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b_c1t1va3cg1n2d1e_ats2uty4er2ntley5rlin4st_buy5t2f1g1h_arti5i_ble3d1ke2ng_o3o1z2j1lack_friday9ockbuster8g1omberg7ue3m_s1w2n_pparibas9o_ats3ehringer8fa2m1nd2o_k_ing5sch2tik2on4t1utique6x2r_adesco6idgestone9oadway5ker3ther5ussels7s1t1uild_ers6siness6y1zz3v1w1y1z_h3ca_b1fe2l_l1vinklein9m_era3p2non3petown5ital_one8r_avan4ds2e_er_s4s2sa1e1h1ino4t_ering5holic7ba1n1re2s2c1d1enter4o1rn3f_a1d2g1h_anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i_priani6rcle4sco3tadel4i_c2y_eats7k1l_aims4eaning6ick2nic1que6othing5ud3ub_med6m1n1o_ach3des3ffee4llege4ogne5m_cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking_channel11l1p2rsica5untry4pon_s4rses6pa2r_edit_card4union9icket5own3s1uise_s6u_isinella9v1w1x1y_mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e_al_er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si_gn4v2hl2iamonds6et2gital5rect_ory7scount3ver5h2y2j1k1m1np2o_cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c_o2deka3u_cation8e1g1mail3erck5nergy4gineer_ing9terprises10pson4quipment8r_icsson6ni3s_q1tate5t_isalat7u_rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n_s2rm_ers5shion4t3edex3edback6rrari3ero6i_at2delity5o2lm2nal1nce1ial7re_stone6mdale6sh_ing5t_ness6j1k1lickr3ghts4r2orist4wers5y2m1o_o_d_network8tball6rd1ex2sale4um3undation8x2r_ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n_d2rniture7tbol5yi3ga_l_lery3o1up4me_s3p1rden4y2b_iz3d_n2e_a1nt_ing5orge5f1g_ee3h1i_ft_s3ves2ing5l_ass3e1obal2o4m_ail3bh2o1x2n1odaddy5ld_point6f2o_dyear5g_le4p1t1v2p1q1r_ainger5phics5tis4een3ipe3ocery4up4s1t1u_ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc_bank7ealth_care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k_t2m1n1ockey4ldings5iday5medepot5goods5s_ense7nda3rse3spital5t_ing5t_eles2s3mail5use3w2r1sbc3t1u_ghes5yatt3undai7ibm2cbc2e1u2d1e_ee3fm2kano4l1m_amat4db2mo_bilien9n_c1dustries8finiti5o2g1k1stitute6urance4e4t_ernational10uit4vestments10o1piranga7q1r_ish4s_maili5t_anbul7t_au2v3jaguar4va3cb2e_ep2tzt3welry6io2ll2m_p2nj2o_bs1urg4t1y2p_morgan6rs3uegos4niper7kaufen5ddi3e_rryhotels6logistics9properties14fh2g1h1i_a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p_mg2n2r_d1ed3uokgroup8w1y_oto4z2la_caixa5mborghini8er3ncaster5ia3d_rover6xess5salle5t_ino3robe5w_yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i_dl2fe_insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan_s3cker3us3l1ndon4tte1o3ve3pl_financial11r1s1t_d_a3u_ndbeck6xe1ury5v1y2ma_cys3drid4if1son4keup4n_agement7go3p1rket_ing3s4riott5shalls7serati6ttel5ba2c_kinsey7d1e_d_ia3et2lbourne7me1orial6n_u2rckmsd7g1h1iami3crosoft7l1ni1t2t_subishi9k1l_b1s2m_a2n1o_bi_le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to_rcycles9v_ie4p1q1r1s_d2t_n1r2u_seum3ic3tual5v1w1x1y1z2na_b1goya4me2tura4vy3ba2c1e_c1t_bank4flix4work5ustar5w_s2xt_direct7us4f_l2g_o2hk2i_co2ke1on3nja3ssan1y5l1o_kia3rthwesternmutual14on4w_ruz3tv4p1r_a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan_group9dnavy5lo3m_ega4ne1g1l_ine5oo2pen3racle3nge4g_anic5igins6saka4tsuka4t2vh3pa_ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e_t2f_izer5g1h_armacy6d1ilips5one2to_graphy6s4ysio5ics1tet2ures6d1n_g1k2oneer5zza4k1l_ace2y_station9umbing5s3m1n_c2ohl2ker3litie5rn2st3r_america6xi3ess3ime3o_d_uctions8f1gressive8mo2perties3y5tection8u_dential9s1t1ub2w_c2y2qa1pon3uebec3st5racing4dio4e_ad1lestate6tor2y4cipes5d_stone5umbrella9hab3ise_n3t2liance6n_t_als5pair3ort3ublican8st_aurant8view_s5xroth6ich_ardli6oh3l1o1p2o_cher3ks3deo3gers4om3s_vp3u_gby3hr2n2w_e2yukyu6sa_arland6fe_ty4kura4le1on3msclub4ung5ndvik_coromant12ofi4p1rl2s1ve2xo3b_i1s2c_a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e_arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x_y3fr2g1h_angrila6rp2w2ell3ia1ksha5oes2p_ping5uji3w_time7i_lk2na1gles5te3j1k_i_n2y_pe4l_ing4m_art3ile4n_cf3o_ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa_ce3ort2t3r_l2s1t_ada2ples4r1tebank4farm7c_group6ockholm6rage3e3ream4udio2y3yle4u_cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y_dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x_i3c_i2d_k2eam2ch_nology8l1masek5nnis4va3f1g1h_d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j_maxx4x2k_maxx5l1m_all4n1o_day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r_ade1ing4ining5vel_channel7ers_insurance16ust3v2t1ube2i1nes3shu4v_s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va_cations7na1guard7c1e_gas3ntures6risign5mögensberater2ung14sicherung10t2g1i_ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u_elos6wales2mart4ter4ng_gou5tch_es6eather_channel12bcam3er2site5d_ding5ibo2r3f1hoswho6ien2ki2lliamhill9n_dows4e1ners6me2olterskluwer11odside6rk_s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u_tube6t1un3za_ppos4ra3ero3ip2m1one3uerich6w2", W6 = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत_म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里_大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", ds = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, Qu = "numeric", Ju = "ascii", Xu = "alpha", ha = "asciinumeric", Uo = "alphanumeric", Zu = "domain", M9 = "emoji", Y6 = "scheme", Q6 = "slashscheme", bh = "whitespace";
function J6(t, e) {
  return t in e || (e[t] = []), e[t];
}
function ei(t, e, n) {
  e[Qu] && (e[ha] = !0, e[Uo] = !0), e[Ju] && (e[ha] = !0, e[Xu] = !0), e[ha] && (e[Uo] = !0), e[Xu] && (e[Uo] = !0), e[Uo] && (e[Zu] = !0), e[M9] && (e[Zu] = !0);
  for (const r in e) {
    const i = J6(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function X6(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function At(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
At.groups = {};
At.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], s = e.jr[r][1];
      if (s && i.test(t))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || At.groups;
    let i;
    return e && e.j ? i = e : (i = new At(e), n && r && ei(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const s = t.length;
    if (!s)
      return i;
    for (let o = 0; o < s - 1; o++)
      i = i.tt(t[o]);
    return i.tt(t[s - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || At.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const s = e;
    let o, a = i.go(t);
    if (a ? (o = new At(), ds(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new At(), s) {
      if (r)
        if (o.t && typeof o.t == "string") {
          const l = ds(X6(o.t, r), n);
          ei(s, l, r);
        } else
          n && ei(s, n, r);
      o.t = s;
    }
    return i.j[t] = o, o;
  }
};
const Q = (t, e, n, r, i) => t.ta(e, n, r, i), Ht = (t, e, n, r, i) => t.tr(e, n, r, i), Ch = (t, e, n, r, i) => t.ts(e, n, r, i), U = (t, e, n, r, i) => t.tt(e, n, r, i), qn = "WORD", ec = "UWORD", go = "LOCALHOST", tc = "TLD", nc = "UTLD", pa = "SCHEME", Pi = "SLASH_SCHEME", $a = "NUM", I9 = "WS", Gc = "NL", zi = "OPENBRACE", Ks = "OPENBRACKET", Ws = "OPENANGLEBRACKET", Ys = "OPENPAREN", Qr = "CLOSEBRACE", $i = "CLOSEBRACKET", Vi = "CLOSEANGLEBRACKET", Jr = "CLOSEPAREN", Va = "AMPERSAND", Ga = "APOSTROPHE", ja = "ASTERISK", hr = "AT", Ka = "BACKSLASH", Wa = "BACKTICK", Ya = "CARET", gr = "COLON", jc = "COMMA", Qa = "DOLLAR", xn = "DOT", Ja = "EQUALS", Kc = "EXCLAMATION", Sn = "HYPHEN", Xa = "PERCENT", Za = "PIPE", el = "PLUS", tl = "POUND", nl = "QUERY", Wc = "QUOTE", Yc = "SEMI", Gn = "SLASH", Qs = "TILDE", rl = "UNDERSCORE", R9 = "EMOJI", il = "SYM";
var L9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: qn,
  UWORD: ec,
  LOCALHOST: go,
  TLD: tc,
  UTLD: nc,
  SCHEME: pa,
  SLASH_SCHEME: Pi,
  NUM: $a,
  WS: I9,
  NL: Gc,
  OPENBRACE: zi,
  OPENBRACKET: Ks,
  OPENANGLEBRACKET: Ws,
  OPENPAREN: Ys,
  CLOSEBRACE: Qr,
  CLOSEBRACKET: $i,
  CLOSEANGLEBRACKET: Vi,
  CLOSEPAREN: Jr,
  AMPERSAND: Va,
  APOSTROPHE: Ga,
  ASTERISK: ja,
  AT: hr,
  BACKSLASH: Ka,
  BACKTICK: Wa,
  CARET: Ya,
  COLON: gr,
  COMMA: jc,
  DOLLAR: Qa,
  DOT: xn,
  EQUALS: Ja,
  EXCLAMATION: Kc,
  HYPHEN: Sn,
  PERCENT: Xa,
  PIPE: Za,
  PLUS: el,
  POUND: tl,
  QUERY: nl,
  QUOTE: Wc,
  SEMI: Yc,
  SLASH: Gn,
  TILDE: Qs,
  UNDERSCORE: rl,
  EMOJI: R9,
  SYM: il
});
const _i = /[a-z]/, w1 = /\p{L}/u, v1 = /\p{Emoji}/u, D1 = /\d/, xh = /\s/, Sh = `
`, Z6 = "️", eC = "‍";
let qo = null, zo = null;
function tC(t) {
  t === void 0 && (t = []);
  const e = {};
  At.groups = e;
  const n = new At();
  qo == null && (qo = Nh(K6)), zo == null && (zo = Nh(W6)), U(n, "'", Ga), U(n, "{", zi), U(n, "[", Ks), U(n, "<", Ws), U(n, "(", Ys), U(n, "}", Qr), U(n, "]", $i), U(n, ">", Vi), U(n, ")", Jr), U(n, "&", Va), U(n, "*", ja), U(n, "@", hr), U(n, "`", Wa), U(n, "^", Ya), U(n, ":", gr), U(n, ",", jc), U(n, "$", Qa), U(n, ".", xn), U(n, "=", Ja), U(n, "!", Kc), U(n, "-", Sn), U(n, "%", Xa), U(n, "|", Za), U(n, "+", el), U(n, "#", tl), U(n, "?", nl), U(n, '"', Wc), U(n, "/", Gn), U(n, ";", Yc), U(n, "~", Qs), U(n, "_", rl), U(n, "\\", Ka);
  const r = Ht(n, D1, $a, {
    [Qu]: !0
  });
  Ht(r, D1, r);
  const i = Ht(n, _i, qn, {
    [Ju]: !0
  });
  Ht(i, _i, i);
  const s = Ht(n, w1, ec, {
    [Xu]: !0
  });
  Ht(s, _i), Ht(s, w1, s);
  const o = Ht(n, xh, I9, {
    [bh]: !0
  });
  U(n, Sh, Gc, {
    [bh]: !0
  }), U(o, Sh), Ht(o, xh, o);
  const a = Ht(n, v1, R9, {
    [M9]: !0
  });
  Ht(a, v1, a), U(a, Z6, a);
  const l = U(a, eC);
  Ht(l, v1, a);
  const u = [[_i, i]], c = [[_i, null], [w1, s]];
  for (let f = 0; f < qo.length; f++)
    rr(n, qo[f], tc, qn, u);
  for (let f = 0; f < zo.length; f++)
    rr(n, zo[f], nc, ec, c);
  ei(tc, {
    tld: !0,
    ascii: !0
  }, e), ei(nc, {
    utld: !0,
    alpha: !0
  }, e), rr(n, "file", pa, qn, u), rr(n, "mailto", pa, qn, u), rr(n, "http", Pi, qn, u), rr(n, "https", Pi, qn, u), rr(n, "ftp", Pi, qn, u), rr(n, "ftps", Pi, qn, u), ei(pa, {
    scheme: !0,
    ascii: !0
  }, e), ei(Pi, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((f, d) => f[0] > d[0] ? 1 : -1);
  for (let f = 0; f < t.length; f++) {
    const d = t[f][0], m = t[f][1] ? {
      [Y6]: !0
    } : {
      [Q6]: !0
    };
    d.indexOf("-") >= 0 ? m[Zu] = !0 : _i.test(d) ? D1.test(d) ? m[ha] = !0 : m[Ju] = !0 : m[Qu] = !0, Ch(n, d, d, m);
  }
  return Ch(n, "localhost", go, {
    ascii: !0
  }), n.jd = new At(il), {
    start: n,
    tokens: ds({
      groups: e
    }, L9)
  };
}
function nC(t, e) {
  const n = rC(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let s = 0, o = 0;
  for (; o < r; ) {
    let a = t, l = null, u = 0, c = null, f = -1, d = -1;
    for (; o < r && (l = a.go(n[o])); )
      a = l, a.accepts() ? (f = 0, d = 0, c = a) : f >= 0 && (f += n[o].length, d++), u += n[o].length, s += n[o].length, o++;
    s -= f, o -= d, u -= f, i.push({
      t: c.t,
      // token type/name
      v: e.slice(s - u, s),
      // string value
      s: s - u,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return i;
}
function rC(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), s, o = i < 55296 || i > 56319 || r + 1 === n || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(o), r += o.length;
  }
  return e;
}
function rr(t, e, n, r, i) {
  let s;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    t.j[l] ? s = t.j[l] : (s = new At(r), s.jr = i.slice(), t.j[l] = s), t = s;
  }
  return s = new At(n), s.jr = i.slice(), t.j[e[o - 1]] = s, s;
}
function Nh(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let s = 0;
    for (; i.indexOf(t[r + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(n.join(""));
      let o = parseInt(t.substring(r, r + s), 10);
      for (; o > 0; o--)
        n.pop();
      r += s;
    } else
      t[r] === "_" ? (e.push(n.join("")), r++) : (n.push(t[r]), r++);
  }
  return e;
}
const To = {
  defaultProtocol: "http",
  events: null,
  format: kh,
  formatHref: kh,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Qc(t, e) {
  e === void 0 && (e = null);
  let n = ds({}, To);
  t && (n = ds(n, t instanceof Qc ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let s = 0; s < r.length; s++)
    i.push(r[s].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
Qc.prototype = {
  o: To,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : To[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function kh(t) {
  return t;
}
function P9(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
P9.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = To.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toFormattedHref(t), r = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, o = t.get("className", n, e), a = t.get("target", n, e), l = t.get("rel", n, e), u = t.getObj("attributes", n, e), c = t.getObj("events", n, e);
    return s.href = n, o && (s.class = o), a && (s.target = a), l && (s.rel = l), u && ds(s, u), {
      tagName: r,
      attributes: s,
      content: i,
      eventListeners: c
    };
  }
};
function vl(t, e) {
  class n extends P9 {
    constructor(i, s) {
      super(i, s), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const _h = vl("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), Oh = vl("text"), iC = vl("nl"), qr = vl("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = To.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== go && t[1].t === gr;
  }
}), Ye = (t) => new At(t);
function sC(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([Va, ja, hr, Ka, Wa, Ya, Qa, Ja, Sn, $a, Xa, Za, el, tl, Gn, il, Qs, rl]), r = [Ga, Vi, Qr, $i, Jr, gr, jc, xn, Kc, Ws, zi, Ks, Ys, nl, Wc, Yc], i = [Va, Ga, ja, Ka, Wa, Ya, Qr, Qa, Ja, Sn, $a, zi, Xa, Za, el, tl, nl, Gn, il, Qs, rl], s = Ye(), o = U(s, Qs);
  Q(o, i, o), Q(o, e.domain, o);
  const a = Ye(), l = Ye(), u = Ye();
  Q(s, e.domain, a), Q(s, e.scheme, l), Q(s, e.slashscheme, u), Q(a, i, o), Q(a, e.domain, a);
  const c = U(a, hr);
  U(o, hr, c), U(l, hr, c), U(u, hr, c);
  const f = U(o, xn);
  Q(f, i, o), Q(f, e.domain, o);
  const d = Ye();
  Q(c, e.domain, d), Q(d, e.domain, d);
  const h = U(d, xn);
  Q(h, e.domain, d);
  const m = Ye(_h);
  Q(h, e.tld, m), Q(h, e.utld, m), U(c, go, m);
  const g = U(d, Sn);
  Q(g, e.domain, d), Q(m, e.domain, d), U(m, xn, h), U(m, Sn, g);
  const T = U(m, gr);
  Q(T, e.numeric, _h);
  const E = U(a, Sn), _ = U(a, xn);
  Q(E, e.domain, a), Q(_, i, o), Q(_, e.domain, a);
  const k = Ye(qr);
  Q(_, e.tld, k), Q(_, e.utld, k), Q(k, e.domain, a), Q(k, i, o), U(k, xn, _), U(k, Sn, E), U(k, hr, c);
  const A = U(k, gr), v = Ye(qr);
  Q(A, e.numeric, v);
  const y = Ye(qr), b = Ye();
  Q(y, n, y), Q(y, r, b), Q(b, n, y), Q(b, r, b), U(k, Gn, y), U(v, Gn, y);
  const O = U(l, gr), P = U(u, gr), $ = U(P, Gn);
  U($, Gn, O), Q(l, e.domain, a), U(l, xn, _), U(l, Sn, E), Q(u, e.domain, a), U(u, xn, _), U(u, Sn, E), Q(O, e.domain, y), U(O, Gn, y);
  const M = U(y, zi), R = U(y, Ks), V = U(y, Ws), Y = U(y, Ys);
  U(b, zi, M), U(b, Ks, R), U(b, Ws, V), U(b, Ys, Y), U(M, Qr, y), U(R, $i, y), U(V, Vi, y), U(Y, Jr, y), U(M, Qr, y);
  const w = Ye(qr), ue = Ye(qr), se = Ye(qr), ie = Ye(qr);
  Q(M, n, w), Q(R, n, ue), Q(V, n, se), Q(Y, n, ie);
  const de = Ye(), he = Ye(), N = Ye(), S = Ye();
  return Q(M, r), Q(R, r), Q(V, r), Q(Y, r), Q(w, n, w), Q(ue, n, ue), Q(se, n, se), Q(ie, n, ie), Q(w, r, w), Q(ue, r, ue), Q(se, r, se), Q(ie, r, ie), Q(de, n, de), Q(he, n, ue), Q(N, n, se), Q(S, n, ie), Q(de, r, de), Q(he, r, he), Q(N, r, N), Q(S, r, S), U(ue, $i, y), U(se, Vi, y), U(ie, Jr, y), U(w, Qr, y), U(he, $i, y), U(N, Vi, y), U(S, Jr, y), U(de, Jr, y), U(s, go, k), U(s, Gc, iC), {
    start: s,
    tokens: L9
  };
}
function oC(t, e, n) {
  let r = n.length, i = 0, s = [], o = [];
  for (; i < r; ) {
    let a = t, l = null, u = null, c = 0, f = null, d = -1;
    for (; i < r && !(l = a.go(n[i].t)); )
      o.push(n[i++]);
    for (; i < r && (u = l || a.go(n[i].t)); )
      l = null, a = u, a.accepts() ? (d = 0, f = a) : d >= 0 && d++, i++, c++;
    if (d < 0)
      i -= c, i < r && (o.push(n[i]), i++);
    else {
      o.length > 0 && (s.push(M1(Oh, e, o)), o = []), i -= d, c -= d;
      const h = f.t, m = n.slice(i - c, i);
      s.push(M1(h, e, m));
    }
  }
  return o.length > 0 && s.push(M1(Oh, e, o)), s;
}
function M1(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, s = e.slice(r, i);
  return new t(s, n);
}
const aC = typeof console < "u" && console && console.warn || (() => {
}), lC = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", ve = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function uC() {
  At.groups = {}, ve.scanner = null, ve.parser = null, ve.tokenQueue = [], ve.pluginQueue = [], ve.customSchemes = [], ve.initialized = !1;
}
function wh(t, e) {
  if (e === void 0 && (e = !1), ve.initialized && aC(`linkifyjs: already initialized - will not register custom scheme "${t}" ${lC}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
 1. Must only contain digits, lowercase ASCII letters or "-"
 2. Cannot start or end with "-"
 3. "-" cannot repeat`);
  ve.customSchemes.push([t, e]);
}
function cC() {
  ve.scanner = tC(ve.customSchemes);
  for (let t = 0; t < ve.tokenQueue.length; t++)
    ve.tokenQueue[t][1]({
      scanner: ve.scanner
    });
  ve.parser = sC(ve.scanner.tokens);
  for (let t = 0; t < ve.pluginQueue.length; t++)
    ve.pluginQueue[t][1]({
      scanner: ve.scanner,
      parser: ve.parser
    });
  ve.initialized = !0;
}
function B9(t) {
  return ve.initialized || cC(), oC(ve.parser.start, t, nC(ve.scanner.start, t));
}
function Jc(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new Qc(n), i = B9(t), s = [];
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    a.isLink && (!e || a.t === e) && s.push(a.toFormattedObject(r));
  }
  return s;
}
function vh(t, e) {
  e === void 0 && (e = null);
  const n = B9(t);
  return n.length === 1 && n[0].isLink && (!e || n[0].t === e);
}
function fC(t) {
  return new Be({
    key: new Ge("autolink"),
    appendTransaction: (e, n, r) => {
      const i = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), s = e.some(
        (c) => c.getMeta("preventAutolink")
      );
      if (!i || s)
        return;
      const { tr: o } = r, a = wy(n.doc, [...e]), { mapping: l } = a;
      if (Hy(a).forEach(({ oldRange: c, newRange: f }) => {
        Ha(c.from, c.to, n.doc).filter((g) => g.mark.type === t.type).forEach((g) => {
          const T = l.map(g.from), E = l.map(g.to), _ = Ha(
            T,
            E,
            r.doc
          ).filter((O) => O.mark.type === t.type);
          if (!_.length)
            return;
          const k = _[0], A = n.doc.textBetween(
            g.from,
            g.to,
            void 0,
            " "
          ), v = r.doc.textBetween(
            k.from,
            k.to,
            void 0,
            " "
          ), y = vh(A), b = vh(v);
          y && !b && o.removeMark(k.from, k.to, t.type);
        });
        const d = Dy(
          r.doc,
          f,
          (g) => g.isTextblock
        );
        let h, m;
        if (d.length > 1 ? (h = d[0], m = r.doc.textBetween(
          h.pos,
          h.pos + h.node.nodeSize,
          void 0,
          " "
        )) : d.length && // We want to make sure to include the block seperator argument to treat hard breaks like spaces
        r.doc.textBetween(f.from, f.to, " ", " ").endsWith(" ") && (h = d[0], m = r.doc.textBetween(
          h.pos,
          f.to,
          void 0,
          " "
        )), h && m) {
          const g = m.split(" ").filter((_) => _ !== "");
          if (g.length <= 0)
            return !1;
          const T = g[g.length - 1], E = h.pos + m.lastIndexOf(T);
          if (!T)
            return !1;
          Jc(T).filter((_) => _.isLink).filter((_) => t.validate ? t.validate(_.value) : !0).map((_) => ({
            ..._,
            from: E + _.start + 1,
            to: E + _.end + 1
          })).forEach((_) => {
            o.addMark(
              _.from,
              _.to,
              t.type.create({
                href: _.href
              })
            );
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function dC(t) {
  return new Be({
    key: new Ge("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var l;
        if (r.button !== 1)
          return !1;
        const i = Rg(e.state, t.type.name), s = (l = r.target) == null ? void 0 : l.closest("a"), o = (s == null ? void 0 : s.href) ?? i.href, a = (s == null ? void 0 : s.target) ?? i.target;
        return s && o ? (window.open(o, a), !0) : !1;
      }
    }
  });
}
function hC(t) {
  return new Be({
    key: new Ge("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e, { selection: s } = i, { empty: o } = s;
        if (o)
          return !1;
        let a = "";
        r.content.forEach((u) => {
          a += u.textContent;
        });
        const l = Jc(a).find(
          (u) => u.isLink && u.value === a
        );
        return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const F9 = Wt.create({
  name: "link",
  keepOnSplit: !1,
  onCreate() {
    this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        wh(t);
        return;
      }
      wh(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    uC();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([href *= "javascript:" i]):not([class="mention"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      Pe(this.options.HTMLAttributes, t),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      di({
        find: (t) => Jc(t).filter((e) => this.options.validate ? this.options.validate(e.value) : !0).filter((e) => e.isLink).map((e) => ({
          text: e.value,
          index: e.start,
          data: e
        })),
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [];
    return this.options.autolink && t.push(
      fC({
        type: this.type,
        validate: this.options.validate
      })
    ), this.options.openOnClick && t.push(
      dC({
        type: this.type
      })
    ), this.options.linkOnPaste && t.push(
      hC({
        editor: this.editor,
        type: this.type
      })
    ), t;
  }
});
function pC(t) {
  var e;
  const { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: s, $position: o } = t, a = yA(n), l = new RegExp(`\\s${a}$`), u = s ? "^" : "", c = r ? new RegExp(`${u}${a}.*?(?=\\s${a}|$)`, "gm") : new RegExp(`${u}(?:^)?${a}[^\\s${a}]*`, "gm"), f = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text;
  if (!f)
    return null;
  const d = o.pos - f.length, h = Array.from(f.matchAll(c)).pop();
  if (!h || h.input === void 0 || h.index === void 0)
    return null;
  const m = h.input.slice(Math.max(0, h.index - 1), h.index), g = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(m);
  if (i !== null && !g)
    return null;
  const T = d + h.index;
  let E = T + h[0].length;
  return r && l.test(f.slice(E - 1, E + 1)) && (h[0] += " ", E += 1), T < o.pos && E >= o.pos ? {
    range: {
      from: T,
      to: E
    },
    query: h[0].slice(n.length),
    text: h[0]
  } : null;
}
const mC = new Ge("suggestion");
function gC({ pluginKey: t = mC, editor: e, char: n = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: o = "span", decorationClass: a = "suggestion", command: l = () => null, items: u = () => [], render: c = () => ({}), allow: f = () => !0 }) {
  let d;
  const h = c == null ? void 0 : c(), m = new Be({
    key: t,
    view() {
      return {
        update: async (g, T) => {
          var E, _, k, A, v, y, b;
          const O = (E = this.key) === null || E === void 0 ? void 0 : E.getState(T), P = (_ = this.key) === null || _ === void 0 ? void 0 : _.getState(g.state), $ = O.active && P.active && O.range.from !== P.range.from, M = !O.active && P.active, R = O.active && !P.active, V = !M && !R && O.query !== P.query, Y = M || $, w = V && !$, ue = R || $;
          if (!Y && !w && !ue)
            return;
          const se = ue && !Y ? O : P, ie = g.dom.querySelector(`[data-decoration-id="${se.decorationId}"]`);
          d = {
            editor: e,
            range: se.range,
            query: se.query,
            text: se.text,
            items: [],
            command: (de) => {
              l({
                editor: e,
                range: se.range,
                props: de
              });
            },
            decorationNode: ie,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: ie ? () => {
              var de;
              const { decorationId: he } = (de = this.key) === null || de === void 0 ? void 0 : de.getState(e.state), N = g.dom.querySelector(`[data-decoration-id="${he}"]`);
              return (N == null ? void 0 : N.getBoundingClientRect()) || null;
            } : null
          }, Y && ((k = h == null ? void 0 : h.onBeforeStart) === null || k === void 0 || k.call(h, d)), w && ((A = h == null ? void 0 : h.onBeforeUpdate) === null || A === void 0 || A.call(h, d)), (w || Y) && (d.items = await u({
            editor: e,
            query: se.query
          })), ue && ((v = h == null ? void 0 : h.onExit) === null || v === void 0 || v.call(h, d)), w && ((y = h == null ? void 0 : h.onUpdate) === null || y === void 0 || y.call(h, d)), Y && ((b = h == null ? void 0 : h.onStart) === null || b === void 0 || b.call(h, d));
        },
        destroy: () => {
          var g;
          d && ((g = h == null ? void 0 : h.onExit) === null || g === void 0 || g.call(h, d));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(g, T, E, _) {
        const { isEditable: k } = e, { composing: A } = e.view, { selection: v } = g, { empty: y, from: b } = v, O = { ...T };
        if (O.composing = A, k && (y || e.view.composing)) {
          (b < T.range.from || b > T.range.to) && !A && !T.composing && (O.active = !1);
          const P = pC({
            char: n,
            allowSpaces: r,
            allowedPrefixes: i,
            startOfLine: s,
            $position: v.$from
          }), $ = `id_${Math.floor(Math.random() * 4294967295)}`;
          P && f({ editor: e, state: _, range: P.range }) ? (O.active = !0, O.decorationId = T.decorationId ? T.decorationId : $, O.range = P.range, O.query = P.query, O.text = P.text) : O.active = !1;
        } else
          O.active = !1;
        return O.active || (O.decorationId = null, O.range = { from: 0, to: 0 }, O.query = null, O.text = null), O;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(g, T) {
        var E;
        const { active: _, range: k } = m.getState(g.state);
        return _ && ((E = h == null ? void 0 : h.onKeyDown) === null || E === void 0 ? void 0 : E.call(h, { view: g, event: T, range: k })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(g) {
        const { active: T, range: E, decorationId: _ } = m.getState(g);
        return T ? Le.create(g.doc, [
          bt.inline(E.from, E.to, {
            nodeName: o,
            class: a,
            "data-decoration-id": _
          })
        ]) : null;
      }
    }
  });
  return m;
}
const TC = new Ge("mention"), H9 = He.create({
  name: "mention",
  group: "inline",
  inline: !0,
  selectable: !1,
  atom: !0,
  addOptions() {
    return {
      suggestion: {
        char: "@",
        allowedPrefixes: null,
        pluginKey: TC,
        command: ({ editor: t, range: e, props: n }) => {
          var f, d, h;
          const { $from: r, $to: i } = t.view.state.selection, s = r.parentOffset === 1, o = i.nodeBefore, a = i.nodeAfter, l = (f = o == null ? void 0 : o.text) == null ? void 0 : f.startsWith(" "), u = (d = a == null ? void 0 : a.text) == null ? void 0 : d.startsWith(" "), c = [];
          !s && !l && c.push({
            type: "text",
            text: " "
          }), c.push({
            type: this.name,
            attrs: n
          }), u || c.push({
            type: "text",
            text: " "
          }), t.chain().focus().insertContentAt(e, c).run(), (h = window.getSelection()) == null || h.collapseToEnd();
        },
        allow: ({ state: t, range: e }) => {
          const n = t.doc.resolve(e.from), r = t.schema.nodes[this.name];
          return !!n.parent.type.contentMatch.matchType(r);
        }
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-id")
      },
      userName: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-user-name")
      },
      displayName: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-display-name")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'a[class="mention"]'
      }
    ];
  },
  renderHTML({ node: t }) {
    return [
      "a",
      {
        class: "mention",
        href: "/" + this.options.suggestion.char + t.attrs.userName,
        "data-id": t.attrs.id,
        "data-user-name": t.attrs.userName,
        "data-display-name": t.attrs.displayName,
        ref: "noopener noreferrer nofollow"
      },
      ["span", `@${t.attrs.displayName ?? t.attrs.userName}`]
    ];
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: t, state: e }) => {
        let n = !1;
        const { selection: r } = e, { empty: i, anchor: s } = r;
        return i ? (e.doc.nodesBetween(s - 1, s, (o, a) => {
          if (o.type.name === this.name)
            return n = !0, t.insertText(
              this.options.suggestion.char || "",
              a,
              a + o.nodeSize
            ), !1;
        }), n) : !1;
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      gC({
        editor: this.editor,
        ...this.options.suggestion
      })
    ];
  }
}), U9 = ({
  placeholder: t,
  mentionSuggestion: e
}) => [
  m9,
  C9,
  k6,
  w9.configure({
    placeholder: t
  }),
  // Basic Formats
  D9,
  O9,
  _6.configure({
    levels: [2, 3]
  }),
  f9,
  v9,
  S9,
  x9,
  h9,
  p9,
  c9,
  g9,
  N9,
  _9,
  k9,
  d9,
  // Custom Formats
  F9,
  j6,
  $6,
  G6,
  H9.configure({
    suggestion: e
  })
], TR = ({
  content: t,
  placeholder: e,
  mentionSuggestion: n,
  ...r
}) => u9({
  extensions: U9({ placeholder: e, mentionSuggestion: n }),
  content: t,
  ...r
}), q9 = ({
  placeholder: t,
  mentionSuggestion: e
}) => [
  m9,
  C9,
  w9.configure({
    placeholder: t
  }),
  // Basic Formats
  D9,
  O9,
  f9,
  v9,
  S9,
  x9,
  h9,
  p9,
  c9,
  g9,
  N9,
  k9,
  _9,
  d9,
  // Custom Formats
  F9,
  H9.configure({
    suggestion: e
  })
], ER = ({
  content: t,
  placeholder: e,
  mentionSuggestion: n,
  ...r
}) => u9({
  extensions: q9({ placeholder: e, mentionSuggestion: n }),
  content: t,
  ...r
});
function Dh(t) {
  if (t)
    throw t;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var z9 = function(e) {
  return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}, ma = Object.prototype.hasOwnProperty, $9 = Object.prototype.toString, Mh = Object.defineProperty, Ih = Object.getOwnPropertyDescriptor, Rh = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : $9.call(e) === "[object Array]";
}, Lh = function(e) {
  if (!e || $9.call(e) !== "[object Object]")
    return !1;
  var n = ma.call(e, "constructor"), r = e.constructor && e.constructor.prototype && ma.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !r)
    return !1;
  var i;
  for (i in e)
    ;
  return typeof i > "u" || ma.call(e, i);
}, Ph = function(e, n) {
  Mh && n.name === "__proto__" ? Mh(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, Bh = function(e, n) {
  if (n === "__proto__")
    if (ma.call(e, n)) {
      if (Ih)
        return Ih(e, n).value;
    } else
      return;
  return e[n];
}, sl = function t() {
  var e, n, r, i, s, o, a = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof a == "boolean" && (c = a, a = arguments[1] || {}, l = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < u; ++l)
    if (e = arguments[l], e != null)
      for (n in e)
        r = Bh(a, n), i = Bh(e, n), a !== i && (c && i && (Lh(i) || (s = Rh(i))) ? (s ? (s = !1, o = r && Rh(r) ? r : []) : o = r && Lh(r) ? r : {}, Ph(a, { name: n, newValue: t(c, o, i) })) : typeof i < "u" && Ph(a, { name: n, newValue: i }));
  return a;
};
function rc(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function EC() {
  const t = [], e = { run: n, use: r };
  return e;
  function n(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(l, ...u) {
      const c = t[++s];
      let f = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++f < i.length; )
        (u[f] === null || u[f] === void 0) && (u[f] = i[f]);
      i = u, c ? yC(c, a)(...u) : o(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return t.push(i), e;
  }
}
function yC(t, e) {
  let n;
  return r;
  function r(...o) {
    const a = t.length > o.length;
    let l;
    a && o.push(i);
    try {
      l = t.apply(this, o);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (a && n)
        throw c;
      return i(c);
    }
    a || (l instanceof Promise ? l.then(s, i) : l instanceof Error ? i(l) : s(l));
  }
  function i(o, ...a) {
    n || (n = !0, e(o, ...a));
  }
  function s(o) {
    i(null, o);
  }
}
function Js(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? Fh(t.position) : "start" in t || "end" in t ? Fh(t) : "line" in t || "column" in t ? ic(t) : "";
}
function ic(t) {
  return Hh(t && t.line) + ":" + Hh(t && t.column);
}
function Fh(t) {
  return ic(t && t.start) + "-" + ic(t && t.end);
}
function Hh(t) {
  return t && typeof t == "number" ? t : 1;
}
class Zt extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(e, n, r) {
    const i = [null, null];
    let s = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof n == "string" && (r = n, n = void 0), typeof r == "string") {
      const o = r.indexOf(":");
      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));
    }
    n && ("type" in n || "position" in n ? n.position && (s = n.position) : "start" in n || "end" in n ? s = n : ("line" in n || "column" in n) && (s.start = n)), this.name = Js(n) || "1:1", this.message = typeof e == "object" ? e.message : e, this.stack = "", typeof e == "object" && e.stack && (this.stack = e.stack), this.reason = this.message, this.fatal, this.line = s.start.line, this.column = s.start.column, this.position = s, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
Zt.prototype.file = "";
Zt.prototype.name = "";
Zt.prototype.reason = "";
Zt.prototype.message = "";
Zt.prototype.stack = "";
Zt.prototype.fatal = null;
Zt.prototype.column = null;
Zt.prototype.line = null;
Zt.prototype.source = null;
Zt.prototype.ruleId = null;
Zt.prototype.position = null;
const Nn = { basename: AC, dirname: bC, extname: CC, join: xC, sep: "/" };
function AC(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  No(t);
  let n = 0, r = -1, i = t.length, s;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; i--; )
      if (t.charCodeAt(i) === 47) {
        if (s) {
          n = i + 1;
          break;
        }
      } else
        r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let o = -1, a = e.length - 1;
  for (; i--; )
    if (t.charCodeAt(i) === 47) {
      if (s) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), a > -1 && (t.charCodeAt(i) === e.charCodeAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return n === r ? r = o : r < 0 && (r = t.length), t.slice(n, r);
}
function bC(t) {
  if (No(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.charCodeAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else
      r || (r = !0);
  return e < 0 ? t.charCodeAt(0) === 47 ? "/" : "." : e === 1 && t.charCodeAt(0) === 47 ? "//" : t.slice(0, e);
}
function CC(t) {
  No(t);
  let e = t.length, n = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const a = t.charCodeAt(e);
    if (a === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = e + 1), a === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === n - 1 && i === r + 1 ? "" : t.slice(i, n);
}
function xC(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    No(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : SC(n);
}
function SC(t) {
  No(t);
  const e = t.charCodeAt(0) === 47;
  let n = NC(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.charCodeAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function NC(t, e) {
  let n = "", r = 0, i = -1, s = 0, o = -1, a, l;
  for (; ++o <= t.length; ) {
    if (o < t.length)
      a = t.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || s === 1))
        if (i !== o - 1 && s === 2) {
          if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (l = n.lastIndexOf("/"), l !== n.length - 1) {
                l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = o, s = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, i = o, s = 0;
              continue;
            }
          }
          e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + t.slice(i + 1, o) : n = t.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else
      a === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function No(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const kC = { cwd: _C };
function _C() {
  return "/";
}
function sc(t) {
  return t !== null && typeof t == "object" && // @ts-expect-error: indexable.
  t.href && // @ts-expect-error: indexable.
  t.origin;
}
function OC(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!sc(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return wC(t);
}
function wC(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.charCodeAt(n) === 37 && e.charCodeAt(n + 1) === 50) {
      const r = e.charCodeAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const I1 = ["history", "path", "basename", "stem", "extname", "dirname"];
class vC {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? typeof e == "string" || DC(e) ? n = { value: e } : sc(e) ? n = { path: e } : n = e : n = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = kC.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < I1.length; ) {
      const s = I1[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let i;
    for (i in n)
      I1.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(e) {
    sc(e) && (e = OC(e)), L1(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Nn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(e) {
    Uh(this.basename, "dirname"), this.path = Nn.join(e || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Nn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(e) {
    L1(e, "basename"), R1(e, "basename"), this.path = Nn.join(this.dirname || "", e);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Nn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(e) {
    if (R1(e, "extname"), Uh(this.dirname, "extname"), e) {
      if (e.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Nn.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Nn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(e) {
    L1(e, "stem"), R1(e, "stem"), this.path = Nn.join(this.dirname || "", e + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return (this.value || "").toString(e || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const i = new Zt(e, n, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const i = this.message(e, n, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const i = this.message(e, n, r);
    throw i.fatal = !0, i;
  }
}
function R1(t, e) {
  if (t && t.includes(Nn.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + Nn.sep + "`"
    );
}
function L1(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function Uh(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function DC(t) {
  return z9(t);
}
const Xc = G9().freeze(), V9 = {}.hasOwnProperty;
function G9() {
  const t = EC(), e = [];
  let n = {}, r, i = -1;
  return s.data = o, s.Parser = void 0, s.Compiler = void 0, s.freeze = a, s.attachers = e, s.use = l, s.parse = u, s.stringify = c, s.run = f, s.runSync = d, s.process = h, s.processSync = m, s;
  function s() {
    const g = G9();
    let T = -1;
    for (; ++T < e.length; )
      g.use(...e[T]);
    return g.data(sl(!0, {}, n)), g;
  }
  function o(g, T) {
    return typeof g == "string" ? arguments.length === 2 ? (F1("data", r), n[g] = T, s) : V9.call(n, g) && n[g] || null : g ? (F1("data", r), n = g, s) : n;
  }
  function a() {
    if (r)
      return s;
    for (; ++i < e.length; ) {
      const [g, ...T] = e[i];
      if (T[0] === !1)
        continue;
      T[0] === !0 && (T[0] = void 0);
      const E = g.call(s, ...T);
      typeof E == "function" && t.use(E);
    }
    return r = !0, i = Number.POSITIVE_INFINITY, s;
  }
  function l(g, ...T) {
    let E;
    if (F1("use", r), g != null)
      if (typeof g == "function")
        v(g, ...T);
      else if (typeof g == "object")
        Array.isArray(g) ? A(g) : k(g);
      else
        throw new TypeError("Expected usable value, not `" + g + "`");
    return E && (n.settings = Object.assign(n.settings || {}, E)), s;
    function _(y) {
      if (typeof y == "function")
        v(y);
      else if (typeof y == "object")
        if (Array.isArray(y)) {
          const [b, ...O] = y;
          v(b, ...O);
        } else
          k(y);
      else
        throw new TypeError("Expected usable value, not `" + y + "`");
    }
    function k(y) {
      A(y.plugins), y.settings && (E = Object.assign(E || {}, y.settings));
    }
    function A(y) {
      let b = -1;
      if (y != null)
        if (Array.isArray(y))
          for (; ++b < y.length; ) {
            const O = y[b];
            _(O);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + y + "`");
    }
    function v(y, b) {
      let O = -1, P;
      for (; ++O < e.length; )
        if (e[O][0] === y) {
          P = e[O];
          break;
        }
      P ? (rc(P[1]) && rc(b) && (b = sl(!0, P[1], b)), P[1] = b) : e.push([...arguments]);
    }
  }
  function u(g) {
    s.freeze();
    const T = ks(g), E = s.Parser;
    return P1("parse", E), qh(E, "parse") ? new E(String(T), T).parse() : E(String(T), T);
  }
  function c(g, T) {
    s.freeze();
    const E = ks(T), _ = s.Compiler;
    return B1("stringify", _), zh(g), qh(_, "compile") ? new _(g, E).compile() : _(g, E);
  }
  function f(g, T, E) {
    if (zh(g), s.freeze(), !E && typeof T == "function" && (E = T, T = void 0), !E)
      return new Promise(_);
    _(null, E);
    function _(k, A) {
      t.run(g, ks(T), v);
      function v(y, b, O) {
        b = b || g, y ? A(y) : k ? k(b) : E(null, b, O);
      }
    }
  }
  function d(g, T) {
    let E, _;
    return s.run(g, T, k), $h("runSync", "run", _), E;
    function k(A, v) {
      Dh(A), E = v, _ = !0;
    }
  }
  function h(g, T) {
    if (s.freeze(), P1("process", s.Parser), B1("process", s.Compiler), !T)
      return new Promise(E);
    E(null, T);
    function E(_, k) {
      const A = ks(g);
      s.run(s.parse(A), A, (y, b, O) => {
        if (y || !b || !O)
          v(y);
        else {
          const P = s.stringify(b, O);
          P == null || (RC(P) ? O.value = P : O.result = P), v(y, O);
        }
      });
      function v(y, b) {
        y || !b ? k(y) : _ ? _(b) : T(null, b);
      }
    }
  }
  function m(g) {
    let T;
    s.freeze(), P1("processSync", s.Parser), B1("processSync", s.Compiler);
    const E = ks(g);
    return s.process(E, _), $h("processSync", "process", T), E;
    function _(k) {
      T = !0, Dh(k);
    }
  }
}
function qh(t, e) {
  return typeof t == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  t.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (MC(t.prototype) || e in t.prototype);
}
function MC(t) {
  let e;
  for (e in t)
    if (V9.call(t, e))
      return !0;
  return !1;
}
function P1(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `Parser`");
}
function B1(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `Compiler`");
}
function F1(t, e) {
  if (e)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function zh(t) {
  if (!rc(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function $h(t, e, n) {
  if (!n)
    throw new Error(
      "`" + t + "` finished async. Use `" + e + "` instead"
    );
}
function ks(t) {
  return IC(t) ? t : new vC(t);
}
function IC(t) {
  return Boolean(
    t && typeof t == "object" && "message" in t && "messages" in t
  );
}
function RC(t) {
  return typeof t == "string" || z9(t);
}
var Tn = {};
const LC = [
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
];
Tn.REPLACEMENT_CHARACTER = "�";
Tn.CODE_POINTS = {
  EOF: -1,
  NULL: 0,
  TABULATION: 9,
  CARRIAGE_RETURN: 13,
  LINE_FEED: 10,
  FORM_FEED: 12,
  SPACE: 32,
  EXCLAMATION_MARK: 33,
  QUOTATION_MARK: 34,
  NUMBER_SIGN: 35,
  AMPERSAND: 38,
  APOSTROPHE: 39,
  HYPHEN_MINUS: 45,
  SOLIDUS: 47,
  DIGIT_0: 48,
  DIGIT_9: 57,
  SEMICOLON: 59,
  LESS_THAN_SIGN: 60,
  EQUALS_SIGN: 61,
  GREATER_THAN_SIGN: 62,
  QUESTION_MARK: 63,
  LATIN_CAPITAL_A: 65,
  LATIN_CAPITAL_F: 70,
  LATIN_CAPITAL_X: 88,
  LATIN_CAPITAL_Z: 90,
  RIGHT_SQUARE_BRACKET: 93,
  GRAVE_ACCENT: 96,
  LATIN_SMALL_A: 97,
  LATIN_SMALL_F: 102,
  LATIN_SMALL_X: 120,
  LATIN_SMALL_Z: 122,
  REPLACEMENT_CHARACTER: 65533
};
Tn.CODE_POINT_SEQUENCES = {
  DASH_DASH_STRING: [45, 45],
  //--
  DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
  //DOCTYPE
  CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
  //[CDATA[
  SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
  //script
  PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
  //PUBLIC
  SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
  //SYSTEM
};
Tn.isSurrogate = function(t) {
  return t >= 55296 && t <= 57343;
};
Tn.isSurrogatePair = function(t) {
  return t >= 56320 && t <= 57343;
};
Tn.getSurrogatePairCodePoint = function(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
};
Tn.isControlCodePoint = function(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
};
Tn.isUndefinedCodePoint = function(t) {
  return t >= 64976 && t <= 65007 || LC.indexOf(t) > -1;
};
var Zc = {
  controlCharacterInInputStream: "control-character-in-input-stream",
  noncharacterInInputStream: "noncharacter-in-input-stream",
  surrogateInInputStream: "surrogate-in-input-stream",
  nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
  endTagWithAttributes: "end-tag-with-attributes",
  endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
  unexpectedSolidusInTag: "unexpected-solidus-in-tag",
  unexpectedNullCharacter: "unexpected-null-character",
  unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
  invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
  unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
  missingEndTagName: "missing-end-tag-name",
  unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
  unknownNamedCharacterReference: "unknown-named-character-reference",
  missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
  unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
  unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
  eofBeforeTagName: "eof-before-tag-name",
  eofInTag: "eof-in-tag",
  missingAttributeValue: "missing-attribute-value",
  missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
  missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
  missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
  missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
  missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
  missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
  missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
  abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
  abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
  cdataInHtmlContent: "cdata-in-html-content",
  incorrectlyOpenedComment: "incorrectly-opened-comment",
  eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
  eofInDoctype: "eof-in-doctype",
  nestedComment: "nested-comment",
  abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
  eofInComment: "eof-in-comment",
  incorrectlyClosedComment: "incorrectly-closed-comment",
  eofInCdata: "eof-in-cdata",
  absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
  nullCharacterReference: "null-character-reference",
  surrogateCharacterReference: "surrogate-character-reference",
  characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
  controlCharacterReference: "control-character-reference",
  noncharacterCharacterReference: "noncharacter-character-reference",
  missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
  missingDoctypeName: "missing-doctype-name",
  invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
  duplicateAttribute: "duplicate-attribute",
  nonConformingDoctype: "non-conforming-doctype",
  missingDoctype: "missing-doctype",
  misplacedDoctype: "misplaced-doctype",
  endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
  closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
  disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
  openElementsLeftAfterEof: "open-elements-left-after-eof",
  abandonedHeadElementChild: "abandoned-head-element-child",
  misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
  nestedNoscriptInHead: "nested-noscript-in-head",
  eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
};
const Bi = Tn, H1 = Zc, zr = Bi.CODE_POINTS, PC = 1 << 16;
let BC = class {
  constructor() {
    this.html = null, this.pos = -1, this.lastGapPos = -1, this.lastCharPos = -1, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = PC;
  }
  _err() {
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.lastCharPos) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (Bi.isSurrogatePair(n))
        return this.pos++, this._addGap(), Bi.getSurrogatePairCodePoint(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, zr.EOF;
    return this._err(H1.surrogateInInputStream), e;
  }
  dropParsedChunk() {
    this.pos > this.bufferWaterline && (this.lastCharPos -= this.pos, this.html = this.html.substring(this.pos), this.pos = 0, this.lastGapPos = -1, this.gapStack = []);
  }
  write(e, n) {
    this.html ? this.html += e : this.html = e, this.lastCharPos = this.html.length - 1, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1, this.html.length), this.lastCharPos = this.html.length - 1, this.endOfChunkHit = !1;
  }
  advance() {
    if (this.pos++, this.pos > this.lastCharPos)
      return this.endOfChunkHit = !this.lastChunkWritten, zr.EOF;
    let e = this.html.charCodeAt(this.pos);
    return this.skipNextNewLine && e === zr.LINE_FEED ? (this.skipNextNewLine = !1, this._addGap(), this.advance()) : e === zr.CARRIAGE_RETURN ? (this.skipNextNewLine = !0, zr.LINE_FEED) : (this.skipNextNewLine = !1, Bi.isSurrogate(e) && (e = this._processSurrogate(e)), e > 31 && e < 127 || e === zr.LINE_FEED || e === zr.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    Bi.isControlCodePoint(e) ? this._err(H1.controlCharacterInInputStream) : Bi.isUndefinedCodePoint(e) && this._err(H1.noncharacterInInputStream);
  }
  retreat() {
    this.pos === this.lastGapPos && (this.lastGapPos = this.gapStack.pop(), this.pos--), this.pos--;
  }
};
var FC = BC, HC = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
const UC = FC, Ce = Tn, ti = HC, L = Zc, C = Ce.CODE_POINTS, $r = Ce.CODE_POINT_SEQUENCES, qC = {
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, j9 = 1 << 0, K9 = 1 << 1, W9 = 1 << 2, zC = j9 | K9 | W9, me = "DATA_STATE", Fi = "RCDATA_STATE", Hs = "RAWTEXT_STATE", zn = "SCRIPT_DATA_STATE", Y9 = "PLAINTEXT_STATE", Vh = "TAG_OPEN_STATE", Gh = "END_TAG_OPEN_STATE", U1 = "TAG_NAME_STATE", jh = "RCDATA_LESS_THAN_SIGN_STATE", Kh = "RCDATA_END_TAG_OPEN_STATE", Wh = "RCDATA_END_TAG_NAME_STATE", Yh = "RAWTEXT_LESS_THAN_SIGN_STATE", Qh = "RAWTEXT_END_TAG_OPEN_STATE", Jh = "RAWTEXT_END_TAG_NAME_STATE", Xh = "SCRIPT_DATA_LESS_THAN_SIGN_STATE", Zh = "SCRIPT_DATA_END_TAG_OPEN_STATE", ep = "SCRIPT_DATA_END_TAG_NAME_STATE", tp = "SCRIPT_DATA_ESCAPE_START_STATE", np = "SCRIPT_DATA_ESCAPE_START_DASH_STATE", rn = "SCRIPT_DATA_ESCAPED_STATE", rp = "SCRIPT_DATA_ESCAPED_DASH_STATE", q1 = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE", $o = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE", ip = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE", sp = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE", op = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE", Pn = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE", ap = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE", lp = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE", Vo = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE", up = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE", bn = "BEFORE_ATTRIBUTE_NAME_STATE", Go = "ATTRIBUTE_NAME_STATE", z1 = "AFTER_ATTRIBUTE_NAME_STATE", $1 = "BEFORE_ATTRIBUTE_VALUE_STATE", jo = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE", Ko = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE", Wo = "ATTRIBUTE_VALUE_UNQUOTED_STATE", V1 = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE", ir = "SELF_CLOSING_START_TAG_STATE", _s = "BOGUS_COMMENT_STATE", cp = "MARKUP_DECLARATION_OPEN_STATE", fp = "COMMENT_START_STATE", dp = "COMMENT_START_DASH_STATE", sr = "COMMENT_STATE", hp = "COMMENT_LESS_THAN_SIGN_STATE", pp = "COMMENT_LESS_THAN_SIGN_BANG_STATE", mp = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE", gp = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE", Yo = "COMMENT_END_DASH_STATE", Qo = "COMMENT_END_STATE", Tp = "COMMENT_END_BANG_STATE", Ep = "DOCTYPE_STATE", Jo = "BEFORE_DOCTYPE_NAME_STATE", Xo = "DOCTYPE_NAME_STATE", yp = "AFTER_DOCTYPE_NAME_STATE", Ap = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE", bp = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE", G1 = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE", j1 = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE", K1 = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE", Cp = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE", xp = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE", Sp = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE", Os = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE", ws = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE", W1 = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE", Bn = "BOGUS_DOCTYPE_STATE", Zo = "CDATA_SECTION_STATE", Np = "CDATA_SECTION_BRACKET_STATE", kp = "CDATA_SECTION_END_STATE", Oi = "CHARACTER_REFERENCE_STATE", _p = "NAMED_CHARACTER_REFERENCE_STATE", Op = "AMBIGUOS_AMPERSAND_STATE", wp = "NUMERIC_CHARACTER_REFERENCE_STATE", vp = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE", Dp = "DECIMAL_CHARACTER_REFERENCE_START_STATE", Mp = "HEXADEMICAL_CHARACTER_REFERENCE_STATE", Ip = "DECIMAL_CHARACTER_REFERENCE_STATE", vs = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
function _e(t) {
  return t === C.SPACE || t === C.LINE_FEED || t === C.TABULATION || t === C.FORM_FEED;
}
function Xs(t) {
  return t >= C.DIGIT_0 && t <= C.DIGIT_9;
}
function on(t) {
  return t >= C.LATIN_CAPITAL_A && t <= C.LATIN_CAPITAL_Z;
}
function Kr(t) {
  return t >= C.LATIN_SMALL_A && t <= C.LATIN_SMALL_Z;
}
function cr(t) {
  return Kr(t) || on(t);
}
function Y1(t) {
  return cr(t) || Xs(t);
}
function Q9(t) {
  return t >= C.LATIN_CAPITAL_A && t <= C.LATIN_CAPITAL_F;
}
function J9(t) {
  return t >= C.LATIN_SMALL_A && t <= C.LATIN_SMALL_F;
}
function $C(t) {
  return Xs(t) || Q9(t) || J9(t);
}
function ga(t) {
  return t + 32;
}
function Me(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(t >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | t & 1023));
}
function or(t) {
  return String.fromCharCode(ga(t));
}
function Rp(t, e) {
  const n = ti[++t];
  let r = ++t, i = r + n - 1;
  for (; r <= i; ) {
    const s = r + i >>> 1, o = ti[s];
    if (o < e)
      r = s + 1;
    else if (o > e)
      i = s - 1;
    else
      return ti[s + n];
  }
  return -1;
}
let en = class Tt {
  constructor() {
    this.preprocessor = new UC(), this.tokenQueue = [], this.allowCDATA = !1, this.state = me, this.returnState = "", this.charRefCode = -1, this.tempBuff = [], this.lastStartTagName = "", this.consumedAfterSnapshot = -1, this.active = !1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = null;
  }
  //Errors
  _err() {
  }
  _errOnNextCodePoint(e) {
    this._consume(), this._err(e), this._unconsume();
  }
  //API
  getNextToken() {
    for (; !this.tokenQueue.length && this.active; ) {
      this.consumedAfterSnapshot = 0;
      const e = this._consume();
      this._ensureHibernation() || this[this.state](e);
    }
    return this.tokenQueue.shift();
  }
  write(e, n) {
    this.active = !0, this.preprocessor.write(e, n);
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e);
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--)
        this.preprocessor.retreat();
      return this.active = !1, this.tokenQueue.push({ type: Tt.HIBERNATION_TOKEN }), !0;
    }
    return !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume() {
    this.consumedAfterSnapshot--, this.preprocessor.retreat();
  }
  _reconsumeInState(e) {
    this.state = e, this._unconsume();
  }
  _consumeSequenceIfMatch(e, n, r) {
    let i = 0, s = !0;
    const o = e.length;
    let a = 0, l = n, u;
    for (; a < o; a++) {
      if (a > 0 && (l = this._consume(), i++), l === C.EOF) {
        s = !1;
        break;
      }
      if (u = e[a], l !== u && (r || l !== ga(u))) {
        s = !1;
        break;
      }
    }
    if (!s)
      for (; i--; )
        this._unconsume();
    return s;
  }
  //Temp buffer
  _isTempBufferEqualToScriptString() {
    if (this.tempBuff.length !== $r.SCRIPT_STRING.length)
      return !1;
    for (let e = 0; e < this.tempBuff.length; e++)
      if (this.tempBuff[e] !== $r.SCRIPT_STRING[e])
        return !1;
    return !0;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Tt.START_TAG_TOKEN,
      tagName: "",
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: []
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Tt.END_TAG_TOKEN,
      tagName: "",
      selfClosing: !1,
      attrs: []
    };
  }
  _createCommentToken() {
    this.currentToken = {
      type: Tt.COMMENT_TOKEN,
      data: ""
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: Tt.DOCTYPE_TOKEN,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n
    };
  }
  _createEOFToken() {
    this.currentToken = { type: Tt.EOF_TOKEN };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    };
  }
  _leaveAttrName(e) {
    Tt.getTokenAttr(this.currentToken, this.currentAttr.name) === null ? this.currentToken.attrs.push(this.currentAttr) : this._err(L.duplicateAttribute), this.state = e;
  }
  _leaveAttrValue(e) {
    this.state = e;
  }
  //Token emission
  _emitCurrentToken() {
    this._emitCurrentCharacterToken();
    const e = this.currentToken;
    this.currentToken = null, e.type === Tt.START_TAG_TOKEN ? this.lastStartTagName = e.tagName : e.type === Tt.END_TAG_TOKEN && (e.attrs.length > 0 && this._err(L.endTagWithAttributes), e.selfClosing && this._err(L.endTagWithTrailingSolidus)), this.tokenQueue.push(e);
  }
  _emitCurrentCharacterToken() {
    this.currentCharacterToken && (this.tokenQueue.push(this.currentCharacterToken), this.currentCharacterToken = null);
  }
  _emitEOFToken() {
    this._createEOFToken(), this._emitCurrentToken();
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    this.currentCharacterToken && this.currentCharacterToken.type !== e && this._emitCurrentCharacterToken(), this.currentCharacterToken ? this.currentCharacterToken.chars += n : this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    let n = Tt.CHARACTER_TOKEN;
    _e(e) ? n = Tt.WHITESPACE_CHARACTER_TOKEN : e === C.NULL && (n = Tt.NULL_CHARACTER_TOKEN), this._appendCharToCurrentCharacterToken(n, Me(e));
  }
  _emitSeveralCodePoints(e) {
    for (let n = 0; n < e.length; n++)
      this._emitCodePoint(e[n]);
  }
  //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
  //So we can avoid additional checks here.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(Tt.CHARACTER_TOKEN, e);
  }
  // Character reference helpers
  _matchNamedCharacterReference(e) {
    let n = null, r = 1, i = Rp(0, e);
    for (this.tempBuff.push(e); i > -1; ) {
      const s = ti[i], o = s < zC;
      o && s & j9 && (n = s & K9 ? [ti[++i], ti[++i]] : [ti[++i]], r = 0);
      const l = this._consume();
      if (this.tempBuff.push(l), r++, l === C.EOF)
        break;
      o ? i = s & W9 ? Rp(i, l) : -1 : i = l === s ? ++i : -1;
    }
    for (; r--; )
      this.tempBuff.pop(), this._unconsume();
    return n;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === jo || this.returnState === Ko || this.returnState === Wo;
  }
  _isCharacterReferenceAttributeQuirk(e) {
    if (!e && this._isCharacterReferenceInAttribute()) {
      const n = this._consume();
      return this._unconsume(), n === C.EQUALS_SIGN || Y1(n);
    }
    return !1;
  }
  _flushCodePointsConsumedAsCharacterReference() {
    if (this._isCharacterReferenceInAttribute())
      for (let e = 0; e < this.tempBuff.length; e++)
        this.currentAttr.value += Me(this.tempBuff[e]);
    else
      this._emitSeveralCodePoints(this.tempBuff);
    this.tempBuff = [];
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  [me](e) {
    this.preprocessor.dropParsedChunk(), e === C.LESS_THAN_SIGN ? this.state = Vh : e === C.AMPERSAND ? (this.returnState = me, this.state = Oi) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitCodePoint(e)) : e === C.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  //  RCDATA state
  //------------------------------------------------------------------
  [Fi](e) {
    this.preprocessor.dropParsedChunk(), e === C.AMPERSAND ? (this.returnState = Fi, this.state = Oi) : e === C.LESS_THAN_SIGN ? this.state = jh : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  [Hs](e) {
    this.preprocessor.dropParsedChunk(), e === C.LESS_THAN_SIGN ? this.state = Yh : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // Script data state
  //------------------------------------------------------------------
  [zn](e) {
    this.preprocessor.dropParsedChunk(), e === C.LESS_THAN_SIGN ? this.state = Xh : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  [Y9](e) {
    this.preprocessor.dropParsedChunk(), e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
  }
  // Tag open state
  //------------------------------------------------------------------
  [Vh](e) {
    e === C.EXCLAMATION_MARK ? this.state = cp : e === C.SOLIDUS ? this.state = Gh : cr(e) ? (this._createStartTagToken(), this._reconsumeInState(U1)) : e === C.QUESTION_MARK ? (this._err(L.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(), this._reconsumeInState(_s)) : e === C.EOF ? (this._err(L.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken()) : (this._err(L.invalidFirstCharacterOfTagName), this._emitChars("<"), this._reconsumeInState(me));
  }
  // End tag open state
  //------------------------------------------------------------------
  [Gh](e) {
    cr(e) ? (this._createEndTagToken(), this._reconsumeInState(U1)) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingEndTagName), this.state = me) : e === C.EOF ? (this._err(L.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken()) : (this._err(L.invalidFirstCharacterOfTagName), this._createCommentToken(), this._reconsumeInState(_s));
  }
  // Tag name state
  //------------------------------------------------------------------
  [U1](e) {
    _e(e) ? this.state = bn : e === C.SOLIDUS ? this.state = ir : e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : on(e) ? this.currentToken.tagName += or(e) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.tagName += Ce.REPLACEMENT_CHARACTER) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : this.currentToken.tagName += Me(e);
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  [jh](e) {
    e === C.SOLIDUS ? (this.tempBuff = [], this.state = Kh) : (this._emitChars("<"), this._reconsumeInState(Fi));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  [Kh](e) {
    cr(e) ? (this._createEndTagToken(), this._reconsumeInState(Wh)) : (this._emitChars("</"), this._reconsumeInState(Fi));
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  [Wh](e) {
    if (on(e))
      this.currentToken.tagName += or(e), this.tempBuff.push(e);
    else if (Kr(e))
      this.currentToken.tagName += Me(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (_e(e)) {
          this.state = bn;
          return;
        }
        if (e === C.SOLIDUS) {
          this.state = ir;
          return;
        }
        if (e === C.GREATER_THAN_SIGN) {
          this.state = me, this._emitCurrentToken();
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Fi);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  [Yh](e) {
    e === C.SOLIDUS ? (this.tempBuff = [], this.state = Qh) : (this._emitChars("<"), this._reconsumeInState(Hs));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  [Qh](e) {
    cr(e) ? (this._createEndTagToken(), this._reconsumeInState(Jh)) : (this._emitChars("</"), this._reconsumeInState(Hs));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  [Jh](e) {
    if (on(e))
      this.currentToken.tagName += or(e), this.tempBuff.push(e);
    else if (Kr(e))
      this.currentToken.tagName += Me(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (_e(e)) {
          this.state = bn;
          return;
        }
        if (e === C.SOLIDUS) {
          this.state = ir;
          return;
        }
        if (e === C.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = me;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Hs);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  [Xh](e) {
    e === C.SOLIDUS ? (this.tempBuff = [], this.state = Zh) : e === C.EXCLAMATION_MARK ? (this.state = tp, this._emitChars("<!")) : (this._emitChars("<"), this._reconsumeInState(zn));
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  [Zh](e) {
    cr(e) ? (this._createEndTagToken(), this._reconsumeInState(ep)) : (this._emitChars("</"), this._reconsumeInState(zn));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  [ep](e) {
    if (on(e))
      this.currentToken.tagName += or(e), this.tempBuff.push(e);
    else if (Kr(e))
      this.currentToken.tagName += Me(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (_e(e)) {
          this.state = bn;
          return;
        } else if (e === C.SOLIDUS) {
          this.state = ir;
          return;
        } else if (e === C.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = me;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(zn);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  [tp](e) {
    e === C.HYPHEN_MINUS ? (this.state = np, this._emitChars("-")) : this._reconsumeInState(zn);
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  [np](e) {
    e === C.HYPHEN_MINUS ? (this.state = q1, this._emitChars("-")) : this._reconsumeInState(zn);
  }
  // Script data escaped state
  //------------------------------------------------------------------
  [rn](e) {
    e === C.HYPHEN_MINUS ? (this.state = rp, this._emitChars("-")) : e === C.LESS_THAN_SIGN ? this.state = $o : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  [rp](e) {
    e === C.HYPHEN_MINUS ? (this.state = q1, this._emitChars("-")) : e === C.LESS_THAN_SIGN ? this.state = $o : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.state = rn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = rn, this._emitCodePoint(e));
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  [q1](e) {
    e === C.HYPHEN_MINUS ? this._emitChars("-") : e === C.LESS_THAN_SIGN ? this.state = $o : e === C.GREATER_THAN_SIGN ? (this.state = zn, this._emitChars(">")) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.state = rn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = rn, this._emitCodePoint(e));
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  [$o](e) {
    e === C.SOLIDUS ? (this.tempBuff = [], this.state = ip) : cr(e) ? (this.tempBuff = [], this._emitChars("<"), this._reconsumeInState(op)) : (this._emitChars("<"), this._reconsumeInState(rn));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  [ip](e) {
    cr(e) ? (this._createEndTagToken(), this._reconsumeInState(sp)) : (this._emitChars("</"), this._reconsumeInState(rn));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  [sp](e) {
    if (on(e))
      this.currentToken.tagName += or(e), this.tempBuff.push(e);
    else if (Kr(e))
      this.currentToken.tagName += Me(e), this.tempBuff.push(e);
    else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (_e(e)) {
          this.state = bn;
          return;
        }
        if (e === C.SOLIDUS) {
          this.state = ir;
          return;
        }
        if (e === C.GREATER_THAN_SIGN) {
          this._emitCurrentToken(), this.state = me;
          return;
        }
      }
      this._emitChars("</"), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(rn);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  [op](e) {
    _e(e) || e === C.SOLIDUS || e === C.GREATER_THAN_SIGN ? (this.state = this._isTempBufferEqualToScriptString() ? Pn : rn, this._emitCodePoint(e)) : on(e) ? (this.tempBuff.push(ga(e)), this._emitCodePoint(e)) : Kr(e) ? (this.tempBuff.push(e), this._emitCodePoint(e)) : this._reconsumeInState(rn);
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  [Pn](e) {
    e === C.HYPHEN_MINUS ? (this.state = ap, this._emitChars("-")) : e === C.LESS_THAN_SIGN ? (this.state = Vo, this._emitChars("<")) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  [ap](e) {
    e === C.HYPHEN_MINUS ? (this.state = lp, this._emitChars("-")) : e === C.LESS_THAN_SIGN ? (this.state = Vo, this._emitChars("<")) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.state = Pn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Pn, this._emitCodePoint(e));
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  [lp](e) {
    e === C.HYPHEN_MINUS ? this._emitChars("-") : e === C.LESS_THAN_SIGN ? (this.state = Vo, this._emitChars("<")) : e === C.GREATER_THAN_SIGN ? (this.state = zn, this._emitChars(">")) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.state = Pn, this._emitChars(Ce.REPLACEMENT_CHARACTER)) : e === C.EOF ? (this._err(L.eofInScriptHtmlCommentLikeText), this._emitEOFToken()) : (this.state = Pn, this._emitCodePoint(e));
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  [Vo](e) {
    e === C.SOLIDUS ? (this.tempBuff = [], this.state = up, this._emitChars("/")) : this._reconsumeInState(Pn);
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  [up](e) {
    _e(e) || e === C.SOLIDUS || e === C.GREATER_THAN_SIGN ? (this.state = this._isTempBufferEqualToScriptString() ? rn : Pn, this._emitCodePoint(e)) : on(e) ? (this.tempBuff.push(ga(e)), this._emitCodePoint(e)) : Kr(e) ? (this.tempBuff.push(e), this._emitCodePoint(e)) : this._reconsumeInState(Pn);
  }
  // Before attribute name state
  //------------------------------------------------------------------
  [bn](e) {
    _e(e) || (e === C.SOLIDUS || e === C.GREATER_THAN_SIGN || e === C.EOF ? this._reconsumeInState(z1) : e === C.EQUALS_SIGN ? (this._err(L.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = Go) : (this._createAttr(""), this._reconsumeInState(Go)));
  }
  // Attribute name state
  //------------------------------------------------------------------
  [Go](e) {
    _e(e) || e === C.SOLIDUS || e === C.GREATER_THAN_SIGN || e === C.EOF ? (this._leaveAttrName(z1), this._unconsume()) : e === C.EQUALS_SIGN ? this._leaveAttrName($1) : on(e) ? this.currentAttr.name += or(e) : e === C.QUOTATION_MARK || e === C.APOSTROPHE || e === C.LESS_THAN_SIGN ? (this._err(L.unexpectedCharacterInAttributeName), this.currentAttr.name += Me(e)) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentAttr.name += Ce.REPLACEMENT_CHARACTER) : this.currentAttr.name += Me(e);
  }
  // After attribute name state
  //------------------------------------------------------------------
  [z1](e) {
    _e(e) || (e === C.SOLIDUS ? this.state = ir : e === C.EQUALS_SIGN ? this.state = $1 : e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : (this._createAttr(""), this._reconsumeInState(Go)));
  }
  // Before attribute value state
  //------------------------------------------------------------------
  [$1](e) {
    _e(e) || (e === C.QUOTATION_MARK ? this.state = jo : e === C.APOSTROPHE ? this.state = Ko : e === C.GREATER_THAN_SIGN ? (this._err(L.missingAttributeValue), this.state = me, this._emitCurrentToken()) : this._reconsumeInState(Wo));
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  [jo](e) {
    e === C.QUOTATION_MARK ? this.state = V1 : e === C.AMPERSAND ? (this.returnState = jo, this.state = Oi) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Me(e);
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  [Ko](e) {
    e === C.APOSTROPHE ? this.state = V1 : e === C.AMPERSAND ? (this.returnState = Ko, this.state = Oi) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Me(e);
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  [Wo](e) {
    _e(e) ? this._leaveAttrValue(bn) : e === C.AMPERSAND ? (this.returnState = Wo, this.state = Oi) : e === C.GREATER_THAN_SIGN ? (this._leaveAttrValue(me), this._emitCurrentToken()) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentAttr.value += Ce.REPLACEMENT_CHARACTER) : e === C.QUOTATION_MARK || e === C.APOSTROPHE || e === C.LESS_THAN_SIGN || e === C.EQUALS_SIGN || e === C.GRAVE_ACCENT ? (this._err(L.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += Me(e)) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : this.currentAttr.value += Me(e);
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  [V1](e) {
    _e(e) ? this._leaveAttrValue(bn) : e === C.SOLIDUS ? this._leaveAttrValue(ir) : e === C.GREATER_THAN_SIGN ? (this._leaveAttrValue(me), this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : (this._err(L.missingWhitespaceBetweenAttributes), this._reconsumeInState(bn));
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  [ir](e) {
    e === C.GREATER_THAN_SIGN ? (this.currentToken.selfClosing = !0, this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInTag), this._emitEOFToken()) : (this._err(L.unexpectedSolidusInTag), this._reconsumeInState(bn));
  }
  // Bogus comment state
  //------------------------------------------------------------------
  [_s](e) {
    e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._emitCurrentToken(), this._emitEOFToken()) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.data += Ce.REPLACEMENT_CHARACTER) : this.currentToken.data += Me(e);
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  [cp](e) {
    this._consumeSequenceIfMatch($r.DASH_DASH_STRING, e, !0) ? (this._createCommentToken(), this.state = fp) : this._consumeSequenceIfMatch($r.DOCTYPE_STRING, e, !1) ? this.state = Ep : this._consumeSequenceIfMatch($r.CDATA_START_STRING, e, !0) ? this.allowCDATA ? this.state = Zo : (this._err(L.cdataInHtmlContent), this._createCommentToken(), this.currentToken.data = "[CDATA[", this.state = _s) : this._ensureHibernation() || (this._err(L.incorrectlyOpenedComment), this._createCommentToken(), this._reconsumeInState(_s));
  }
  // Comment start state
  //------------------------------------------------------------------
  [fp](e) {
    e === C.HYPHEN_MINUS ? this.state = dp : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptClosingOfEmptyComment), this.state = me, this._emitCurrentToken()) : this._reconsumeInState(sr);
  }
  // Comment start dash state
  //------------------------------------------------------------------
  [dp](e) {
    e === C.HYPHEN_MINUS ? this.state = Qo : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptClosingOfEmptyComment), this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "-", this._reconsumeInState(sr));
  }
  // Comment state
  //------------------------------------------------------------------
  [sr](e) {
    e === C.HYPHEN_MINUS ? this.state = Yo : e === C.LESS_THAN_SIGN ? (this.currentToken.data += "<", this.state = hp) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.data += Ce.REPLACEMENT_CHARACTER) : e === C.EOF ? (this._err(L.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.data += Me(e);
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  [hp](e) {
    e === C.EXCLAMATION_MARK ? (this.currentToken.data += "!", this.state = pp) : e === C.LESS_THAN_SIGN ? this.currentToken.data += "!" : this._reconsumeInState(sr);
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  [pp](e) {
    e === C.HYPHEN_MINUS ? this.state = mp : this._reconsumeInState(sr);
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  [mp](e) {
    e === C.HYPHEN_MINUS ? this.state = gp : this._reconsumeInState(Yo);
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  [gp](e) {
    e !== C.GREATER_THAN_SIGN && e !== C.EOF && this._err(L.nestedComment), this._reconsumeInState(Qo);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  [Yo](e) {
    e === C.HYPHEN_MINUS ? this.state = Qo : e === C.EOF ? (this._err(L.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "-", this._reconsumeInState(sr));
  }
  // Comment end state
  //------------------------------------------------------------------
  [Qo](e) {
    e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : e === C.EXCLAMATION_MARK ? this.state = Tp : e === C.HYPHEN_MINUS ? this.currentToken.data += "-" : e === C.EOF ? (this._err(L.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "--", this._reconsumeInState(sr));
  }
  // Comment end bang state
  //------------------------------------------------------------------
  [Tp](e) {
    e === C.HYPHEN_MINUS ? (this.currentToken.data += "--!", this.state = Yo) : e === C.GREATER_THAN_SIGN ? (this._err(L.incorrectlyClosedComment), this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInComment), this._emitCurrentToken(), this._emitEOFToken()) : (this.currentToken.data += "--!", this._reconsumeInState(sr));
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  [Ep](e) {
    _e(e) ? this.state = Jo : e === C.GREATER_THAN_SIGN ? this._reconsumeInState(Jo) : e === C.EOF ? (this._err(L.eofInDoctype), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingWhitespaceBeforeDoctypeName), this._reconsumeInState(Jo));
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  [Jo](e) {
    _e(e) || (on(e) ? (this._createDoctypeToken(or(e)), this.state = Xo) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this._createDoctypeToken(Ce.REPLACEMENT_CHARACTER), this.state = Xo) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingDoctypeName), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this._createDoctypeToken(null), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._createDoctypeToken(Me(e)), this.state = Xo));
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  [Xo](e) {
    _e(e) ? this.state = yp : e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : on(e) ? this.currentToken.name += or(e) : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.name += Ce.REPLACEMENT_CHARACTER) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.name += Me(e);
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  [yp](e) {
    _e(e) || (e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this._consumeSequenceIfMatch($r.PUBLIC_STRING, e, !1) ? this.state = Ap : this._consumeSequenceIfMatch($r.SYSTEM_STRING, e, !1) ? this.state = xp : this._ensureHibernation() || (this._err(L.invalidCharacterSequenceAfterDoctypeName), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn)));
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  [Ap](e) {
    _e(e) ? this.state = bp : e === C.QUOTATION_MARK ? (this._err(L.missingWhitespaceAfterDoctypePublicKeyword), this.currentToken.publicId = "", this.state = G1) : e === C.APOSTROPHE ? (this._err(L.missingWhitespaceAfterDoctypePublicKeyword), this.currentToken.publicId = "", this.state = j1) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn));
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  [bp](e) {
    _e(e) || (e === C.QUOTATION_MARK ? (this.currentToken.publicId = "", this.state = G1) : e === C.APOSTROPHE ? (this.currentToken.publicId = "", this.state = j1) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn)));
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  [G1](e) {
    e === C.QUOTATION_MARK ? this.state = K1 : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.publicId += Ce.REPLACEMENT_CHARACTER) : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.publicId += Me(e);
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  [j1](e) {
    e === C.APOSTROPHE ? this.state = K1 : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.publicId += Ce.REPLACEMENT_CHARACTER) : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptDoctypePublicIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.publicId += Me(e);
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  [K1](e) {
    _e(e) ? this.state = Cp : e === C.GREATER_THAN_SIGN ? (this.state = me, this._emitCurrentToken()) : e === C.QUOTATION_MARK ? (this._err(L.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), this.currentToken.systemId = "", this.state = Os) : e === C.APOSTROPHE ? (this._err(L.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), this.currentToken.systemId = "", this.state = ws) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn));
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  [Cp](e) {
    _e(e) || (e === C.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = me) : e === C.QUOTATION_MARK ? (this.currentToken.systemId = "", this.state = Os) : e === C.APOSTROPHE ? (this.currentToken.systemId = "", this.state = ws) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn)));
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  [xp](e) {
    _e(e) ? this.state = Sp : e === C.QUOTATION_MARK ? (this._err(L.missingWhitespaceAfterDoctypeSystemKeyword), this.currentToken.systemId = "", this.state = Os) : e === C.APOSTROPHE ? (this._err(L.missingWhitespaceAfterDoctypeSystemKeyword), this.currentToken.systemId = "", this.state = ws) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn));
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  [Sp](e) {
    _e(e) || (e === C.QUOTATION_MARK ? (this.currentToken.systemId = "", this.state = Os) : e === C.APOSTROPHE ? (this.currentToken.systemId = "", this.state = ws) : e === C.GREATER_THAN_SIGN ? (this._err(L.missingDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this.state = me, this._emitCurrentToken()) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.missingQuoteBeforeDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._reconsumeInState(Bn)));
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  [Os](e) {
    e === C.QUOTATION_MARK ? this.state = W1 : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.systemId += Ce.REPLACEMENT_CHARACTER) : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.systemId += Me(e);
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  [ws](e) {
    e === C.APOSTROPHE ? this.state = W1 : e === C.NULL ? (this._err(L.unexpectedNullCharacter), this.currentToken.systemId += Ce.REPLACEMENT_CHARACTER) : e === C.GREATER_THAN_SIGN ? (this._err(L.abruptDoctypeSystemIdentifier), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : this.currentToken.systemId += Me(e);
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  [W1](e) {
    _e(e) || (e === C.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = me) : e === C.EOF ? (this._err(L.eofInDoctype), this.currentToken.forceQuirks = !0, this._emitCurrentToken(), this._emitEOFToken()) : (this._err(L.unexpectedCharacterAfterDoctypeSystemIdentifier), this._reconsumeInState(Bn)));
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  [Bn](e) {
    e === C.GREATER_THAN_SIGN ? (this._emitCurrentToken(), this.state = me) : e === C.NULL ? this._err(L.unexpectedNullCharacter) : e === C.EOF && (this._emitCurrentToken(), this._emitEOFToken());
  }
  // CDATA section state
  //------------------------------------------------------------------
  [Zo](e) {
    e === C.RIGHT_SQUARE_BRACKET ? this.state = Np : e === C.EOF ? (this._err(L.eofInCdata), this._emitEOFToken()) : this._emitCodePoint(e);
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  [Np](e) {
    e === C.RIGHT_SQUARE_BRACKET ? this.state = kp : (this._emitChars("]"), this._reconsumeInState(Zo));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  [kp](e) {
    e === C.GREATER_THAN_SIGN ? this.state = me : e === C.RIGHT_SQUARE_BRACKET ? this._emitChars("]") : (this._emitChars("]]"), this._reconsumeInState(Zo));
  }
  // Character reference state
  //------------------------------------------------------------------
  [Oi](e) {
    this.tempBuff = [C.AMPERSAND], e === C.NUMBER_SIGN ? (this.tempBuff.push(e), this.state = wp) : Y1(e) ? this._reconsumeInState(_p) : (this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Named character reference state
  //------------------------------------------------------------------
  [_p](e) {
    const n = this._matchNamedCharacterReference(e);
    if (this._ensureHibernation())
      this.tempBuff = [C.AMPERSAND];
    else if (n) {
      const r = this.tempBuff[this.tempBuff.length - 1] === C.SEMICOLON;
      this._isCharacterReferenceAttributeQuirk(r) || (r || this._errOnNextCodePoint(L.missingSemicolonAfterCharacterReference), this.tempBuff = n), this._flushCodePointsConsumedAsCharacterReference(), this.state = this.returnState;
    } else
      this._flushCodePointsConsumedAsCharacterReference(), this.state = Op;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  [Op](e) {
    Y1(e) ? this._isCharacterReferenceInAttribute() ? this.currentAttr.value += Me(e) : this._emitCodePoint(e) : (e === C.SEMICOLON && this._err(L.unknownNamedCharacterReference), this._reconsumeInState(this.returnState));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  [wp](e) {
    this.charRefCode = 0, e === C.LATIN_SMALL_X || e === C.LATIN_CAPITAL_X ? (this.tempBuff.push(e), this.state = vp) : this._reconsumeInState(Dp);
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  [vp](e) {
    $C(e) ? this._reconsumeInState(Mp) : (this._err(L.absenceOfDigitsInNumericCharacterReference), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Decimal character reference start state
  //------------------------------------------------------------------
  [Dp](e) {
    Xs(e) ? this._reconsumeInState(Ip) : (this._err(L.absenceOfDigitsInNumericCharacterReference), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  [Mp](e) {
    Q9(e) ? this.charRefCode = this.charRefCode * 16 + e - 55 : J9(e) ? this.charRefCode = this.charRefCode * 16 + e - 87 : Xs(e) ? this.charRefCode = this.charRefCode * 16 + e - 48 : e === C.SEMICOLON ? this.state = vs : (this._err(L.missingSemicolonAfterCharacterReference), this._reconsumeInState(vs));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  [Ip](e) {
    Xs(e) ? this.charRefCode = this.charRefCode * 10 + e - 48 : e === C.SEMICOLON ? this.state = vs : (this._err(L.missingSemicolonAfterCharacterReference), this._reconsumeInState(vs));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  [vs]() {
    if (this.charRefCode === C.NULL)
      this._err(L.nullCharacterReference), this.charRefCode = C.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(L.characterReferenceOutsideUnicodeRange), this.charRefCode = C.REPLACEMENT_CHARACTER;
    else if (Ce.isSurrogate(this.charRefCode))
      this._err(L.surrogateCharacterReference), this.charRefCode = C.REPLACEMENT_CHARACTER;
    else if (Ce.isUndefinedCodePoint(this.charRefCode))
      this._err(L.noncharacterCharacterReference);
    else if (Ce.isControlCodePoint(this.charRefCode) || this.charRefCode === C.CARRIAGE_RETURN) {
      this._err(L.controlCharacterReference);
      const e = qC[this.charRefCode];
      e && (this.charRefCode = e);
    }
    this.tempBuff = [this.charRefCode], this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState);
  }
};
en.CHARACTER_TOKEN = "CHARACTER_TOKEN";
en.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
en.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
en.START_TAG_TOKEN = "START_TAG_TOKEN";
en.END_TAG_TOKEN = "END_TAG_TOKEN";
en.COMMENT_TOKEN = "COMMENT_TOKEN";
en.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
en.EOF_TOKEN = "EOF_TOKEN";
en.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
en.MODE = {
  DATA: me,
  RCDATA: Fi,
  RAWTEXT: Hs,
  SCRIPT_DATA: zn,
  PLAINTEXT: Y9
};
en.getTokenAttr = function(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
};
var Dl = en, En = {};
const Q1 = En.NAMESPACES = {
  HTML: "http://www.w3.org/1999/xhtml",
  MATHML: "http://www.w3.org/1998/Math/MathML",
  SVG: "http://www.w3.org/2000/svg",
  XLINK: "http://www.w3.org/1999/xlink",
  XML: "http://www.w3.org/XML/1998/namespace",
  XMLNS: "http://www.w3.org/2000/xmlns/"
};
En.ATTRS = {
  TYPE: "type",
  ACTION: "action",
  ENCODING: "encoding",
  PROMPT: "prompt",
  NAME: "name",
  COLOR: "color",
  FACE: "face",
  SIZE: "size"
};
En.DOCUMENT_MODE = {
  NO_QUIRKS: "no-quirks",
  QUIRKS: "quirks",
  LIMITED_QUIRKS: "limited-quirks"
};
const H = En.TAG_NAMES = {
  A: "a",
  ADDRESS: "address",
  ANNOTATION_XML: "annotation-xml",
  APPLET: "applet",
  AREA: "area",
  ARTICLE: "article",
  ASIDE: "aside",
  B: "b",
  BASE: "base",
  BASEFONT: "basefont",
  BGSOUND: "bgsound",
  BIG: "big",
  BLOCKQUOTE: "blockquote",
  BODY: "body",
  BR: "br",
  BUTTON: "button",
  CAPTION: "caption",
  CENTER: "center",
  CODE: "code",
  COL: "col",
  COLGROUP: "colgroup",
  DD: "dd",
  DESC: "desc",
  DETAILS: "details",
  DIALOG: "dialog",
  DIR: "dir",
  DIV: "div",
  DL: "dl",
  DT: "dt",
  EM: "em",
  EMBED: "embed",
  FIELDSET: "fieldset",
  FIGCAPTION: "figcaption",
  FIGURE: "figure",
  FONT: "font",
  FOOTER: "footer",
  FOREIGN_OBJECT: "foreignObject",
  FORM: "form",
  FRAME: "frame",
  FRAMESET: "frameset",
  H1: "h1",
  H2: "h2",
  H3: "h3",
  H4: "h4",
  H5: "h5",
  H6: "h6",
  HEAD: "head",
  HEADER: "header",
  HGROUP: "hgroup",
  HR: "hr",
  HTML: "html",
  I: "i",
  IMG: "img",
  IMAGE: "image",
  INPUT: "input",
  IFRAME: "iframe",
  KEYGEN: "keygen",
  LABEL: "label",
  LI: "li",
  LINK: "link",
  LISTING: "listing",
  MAIN: "main",
  MALIGNMARK: "malignmark",
  MARQUEE: "marquee",
  MATH: "math",
  MENU: "menu",
  META: "meta",
  MGLYPH: "mglyph",
  MI: "mi",
  MO: "mo",
  MN: "mn",
  MS: "ms",
  MTEXT: "mtext",
  NAV: "nav",
  NOBR: "nobr",
  NOFRAMES: "noframes",
  NOEMBED: "noembed",
  NOSCRIPT: "noscript",
  OBJECT: "object",
  OL: "ol",
  OPTGROUP: "optgroup",
  OPTION: "option",
  P: "p",
  PARAM: "param",
  PLAINTEXT: "plaintext",
  PRE: "pre",
  RB: "rb",
  RP: "rp",
  RT: "rt",
  RTC: "rtc",
  RUBY: "ruby",
  S: "s",
  SCRIPT: "script",
  SECTION: "section",
  SELECT: "select",
  SOURCE: "source",
  SMALL: "small",
  SPAN: "span",
  STRIKE: "strike",
  STRONG: "strong",
  STYLE: "style",
  SUB: "sub",
  SUMMARY: "summary",
  SUP: "sup",
  TABLE: "table",
  TBODY: "tbody",
  TEMPLATE: "template",
  TEXTAREA: "textarea",
  TFOOT: "tfoot",
  TD: "td",
  TH: "th",
  THEAD: "thead",
  TITLE: "title",
  TR: "tr",
  TRACK: "track",
  TT: "tt",
  U: "u",
  UL: "ul",
  SVG: "svg",
  VAR: "var",
  WBR: "wbr",
  XMP: "xmp"
};
En.SPECIAL_ELEMENTS = {
  [Q1.HTML]: {
    [H.ADDRESS]: !0,
    [H.APPLET]: !0,
    [H.AREA]: !0,
    [H.ARTICLE]: !0,
    [H.ASIDE]: !0,
    [H.BASE]: !0,
    [H.BASEFONT]: !0,
    [H.BGSOUND]: !0,
    [H.BLOCKQUOTE]: !0,
    [H.BODY]: !0,
    [H.BR]: !0,
    [H.BUTTON]: !0,
    [H.CAPTION]: !0,
    [H.CENTER]: !0,
    [H.COL]: !0,
    [H.COLGROUP]: !0,
    [H.DD]: !0,
    [H.DETAILS]: !0,
    [H.DIR]: !0,
    [H.DIV]: !0,
    [H.DL]: !0,
    [H.DT]: !0,
    [H.EMBED]: !0,
    [H.FIELDSET]: !0,
    [H.FIGCAPTION]: !0,
    [H.FIGURE]: !0,
    [H.FOOTER]: !0,
    [H.FORM]: !0,
    [H.FRAME]: !0,
    [H.FRAMESET]: !0,
    [H.H1]: !0,
    [H.H2]: !0,
    [H.H3]: !0,
    [H.H4]: !0,
    [H.H5]: !0,
    [H.H6]: !0,
    [H.HEAD]: !0,
    [H.HEADER]: !0,
    [H.HGROUP]: !0,
    [H.HR]: !0,
    [H.HTML]: !0,
    [H.IFRAME]: !0,
    [H.IMG]: !0,
    [H.INPUT]: !0,
    [H.LI]: !0,
    [H.LINK]: !0,
    [H.LISTING]: !0,
    [H.MAIN]: !0,
    [H.MARQUEE]: !0,
    [H.MENU]: !0,
    [H.META]: !0,
    [H.NAV]: !0,
    [H.NOEMBED]: !0,
    [H.NOFRAMES]: !0,
    [H.NOSCRIPT]: !0,
    [H.OBJECT]: !0,
    [H.OL]: !0,
    [H.P]: !0,
    [H.PARAM]: !0,
    [H.PLAINTEXT]: !0,
    [H.PRE]: !0,
    [H.SCRIPT]: !0,
    [H.SECTION]: !0,
    [H.SELECT]: !0,
    [H.SOURCE]: !0,
    [H.STYLE]: !0,
    [H.SUMMARY]: !0,
    [H.TABLE]: !0,
    [H.TBODY]: !0,
    [H.TD]: !0,
    [H.TEMPLATE]: !0,
    [H.TEXTAREA]: !0,
    [H.TFOOT]: !0,
    [H.TH]: !0,
    [H.THEAD]: !0,
    [H.TITLE]: !0,
    [H.TR]: !0,
    [H.TRACK]: !0,
    [H.UL]: !0,
    [H.WBR]: !0,
    [H.XMP]: !0
  },
  [Q1.MATHML]: {
    [H.MI]: !0,
    [H.MO]: !0,
    [H.MN]: !0,
    [H.MS]: !0,
    [H.MTEXT]: !0,
    [H.ANNOTATION_XML]: !0
  },
  [Q1.SVG]: {
    [H.TITLE]: !0,
    [H.FOREIGN_OBJECT]: !0,
    [H.DESC]: !0
  }
};
const X9 = En, z = X9.TAG_NAMES, xe = X9.NAMESPACES;
function Lp(t) {
  switch (t.length) {
    case 1:
      return t === z.P;
    case 2:
      return t === z.RB || t === z.RP || t === z.RT || t === z.DD || t === z.DT || t === z.LI;
    case 3:
      return t === z.RTC;
    case 6:
      return t === z.OPTION;
    case 8:
      return t === z.OPTGROUP;
  }
  return !1;
}
function VC(t) {
  switch (t.length) {
    case 1:
      return t === z.P;
    case 2:
      return t === z.RB || t === z.RP || t === z.RT || t === z.DD || t === z.DT || t === z.LI || t === z.TD || t === z.TH || t === z.TR;
    case 3:
      return t === z.RTC;
    case 5:
      return t === z.TBODY || t === z.TFOOT || t === z.THEAD;
    case 6:
      return t === z.OPTION;
    case 7:
      return t === z.CAPTION;
    case 8:
      return t === z.OPTGROUP || t === z.COLGROUP;
  }
  return !1;
}
function ea(t, e) {
  switch (t.length) {
    case 2:
      if (t === z.TD || t === z.TH)
        return e === xe.HTML;
      if (t === z.MI || t === z.MO || t === z.MN || t === z.MS)
        return e === xe.MATHML;
      break;
    case 4:
      if (t === z.HTML)
        return e === xe.HTML;
      if (t === z.DESC)
        return e === xe.SVG;
      break;
    case 5:
      if (t === z.TABLE)
        return e === xe.HTML;
      if (t === z.MTEXT)
        return e === xe.MATHML;
      if (t === z.TITLE)
        return e === xe.SVG;
      break;
    case 6:
      return (t === z.APPLET || t === z.OBJECT) && e === xe.HTML;
    case 7:
      return (t === z.CAPTION || t === z.MARQUEE) && e === xe.HTML;
    case 8:
      return t === z.TEMPLATE && e === xe.HTML;
    case 13:
      return t === z.FOREIGN_OBJECT && e === xe.SVG;
    case 14:
      return t === z.ANNOTATION_XML && e === xe.MATHML;
  }
  return !1;
}
let GC = class {
  constructor(e, n) {
    this.stackTop = -1, this.items = [], this.current = e, this.currentTagName = null, this.currentTmplContent = null, this.tmplCount = 0, this.treeAdapter = n;
  }
  //Index of element
  _indexOf(e) {
    let n = -1;
    for (let r = this.stackTop; r >= 0; r--)
      if (this.items[r] === e) {
        n = r;
        break;
      }
    return n;
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagName === z.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === xe.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagName = this.current && this.treeAdapter.getTagName(this.current), this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
  }
  //Mutations
  push(e) {
    this.items[++this.stackTop] = e, this._updateCurrentElement(), this._isInTemplate() && this.tmplCount++;
  }
  pop() {
    this.stackTop--, this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this._updateCurrentElement();
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && this._updateCurrentElement();
  }
  insertAfter(e, n) {
    const r = this._indexOf(e) + 1;
    this.items.splice(r, 0, n), r === ++this.stackTop && this._updateCurrentElement();
  }
  popUntilTagNamePopped(e) {
    for (; this.stackTop > -1; ) {
      const n = this.currentTagName, r = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), n === e && r === xe.HTML)
        break;
    }
  }
  popUntilElementPopped(e) {
    for (; this.stackTop > -1; ) {
      const n = this.current;
      if (this.pop(), n === e)
        break;
    }
  }
  popUntilNumberedHeaderPopped() {
    for (; this.stackTop > -1; ) {
      const e = this.currentTagName, n = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), e === z.H1 || e === z.H2 || e === z.H3 || e === z.H4 || e === z.H5 || e === z.H6 && n === xe.HTML)
        break;
    }
  }
  popUntilTableCellPopped() {
    for (; this.stackTop > -1; ) {
      const e = this.currentTagName, n = this.treeAdapter.getNamespaceURI(this.current);
      if (this.pop(), e === z.TD || e === z.TH && n === xe.HTML)
        break;
    }
  }
  popAllUpToHtmlElement() {
    this.stackTop = 0, this._updateCurrentElement();
  }
  clearBackToTableContext() {
    for (; this.currentTagName !== z.TABLE && this.currentTagName !== z.TEMPLATE && this.currentTagName !== z.HTML || this.treeAdapter.getNamespaceURI(this.current) !== xe.HTML; )
      this.pop();
  }
  clearBackToTableBodyContext() {
    for (; this.currentTagName !== z.TBODY && this.currentTagName !== z.TFOOT && this.currentTagName !== z.THEAD && this.currentTagName !== z.TEMPLATE && this.currentTagName !== z.HTML || this.treeAdapter.getNamespaceURI(this.current) !== xe.HTML; )
      this.pop();
  }
  clearBackToTableRowContext() {
    for (; this.currentTagName !== z.TR && this.currentTagName !== z.TEMPLATE && this.currentTagName !== z.HTML || this.treeAdapter.getNamespaceURI(this.current) !== xe.HTML; )
      this.pop();
  }
  remove(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.items[n] === e) {
        this.items.splice(n, 1), this.stackTop--, this._updateCurrentElement();
        break;
      }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    const e = this.items[1];
    return e && this.treeAdapter.getTagName(e) === z.BODY ? e : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    let n = this._indexOf(e);
    return --n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.currentTagName === z.HTML;
  }
  //Element in scope
  hasInScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === xe.HTML)
        return !0;
      if (ea(r, i))
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.treeAdapter.getTagName(this.items[e]), r = this.treeAdapter.getNamespaceURI(this.items[e]);
      if ((n === z.H1 || n === z.H2 || n === z.H3 || n === z.H4 || n === z.H5 || n === z.H6) && r === xe.HTML)
        return !0;
      if (ea(n, r))
        return !1;
    }
    return !0;
  }
  hasInListItemScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === xe.HTML)
        return !0;
      if ((r === z.UL || r === z.OL) && i === xe.HTML || ea(r, i))
        return !1;
    }
    return !0;
  }
  hasInButtonScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]), i = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === e && i === xe.HTML)
        return !0;
      if (r === z.BUTTON && i === xe.HTML || ea(r, i))
        return !1;
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]);
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === xe.HTML) {
        if (r === e)
          return !0;
        if (r === z.TABLE || r === z.TEMPLATE || r === z.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.treeAdapter.getTagName(this.items[e]);
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === xe.HTML) {
        if (n === z.TBODY || n === z.THEAD || n === z.TFOOT)
          return !0;
        if (n === z.TABLE || n === z.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.treeAdapter.getTagName(this.items[n]);
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === xe.HTML) {
        if (r === e)
          return !0;
        if (r !== z.OPTION && r !== z.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; Lp(this.currentTagName); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; VC(this.currentTagName); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; Lp(this.currentTagName) && this.currentTagName !== e; )
      this.pop();
  }
};
var jC = GC;
const ta = 3;
let ef = class fr {
  constructor(e) {
    this.length = 0, this.entries = [], this.treeAdapter = e, this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e) {
    const n = [];
    if (this.length >= ta) {
      const r = this.treeAdapter.getAttrList(e).length, i = this.treeAdapter.getTagName(e), s = this.treeAdapter.getNamespaceURI(e);
      for (let o = this.length - 1; o >= 0; o--) {
        const a = this.entries[o];
        if (a.type === fr.MARKER_ENTRY)
          break;
        const l = a.element, u = this.treeAdapter.getAttrList(l);
        this.treeAdapter.getTagName(l) === i && this.treeAdapter.getNamespaceURI(l) === s && u.length === r && n.push({ idx: o, attrs: u });
      }
    }
    return n.length < ta ? [] : n;
  }
  _ensureNoahArkCondition(e) {
    const n = this._getNoahArkConditionCandidates(e);
    let r = n.length;
    if (r) {
      const i = this.treeAdapter.getAttrList(e), s = i.length, o = /* @__PURE__ */ Object.create(null);
      for (let a = 0; a < s; a++) {
        const l = i[a];
        o[l.name] = l.value;
      }
      for (let a = 0; a < s; a++)
        for (let l = 0; l < r; l++) {
          const u = n[l].attrs[a];
          if (o[u.name] !== u.value && (n.splice(l, 1), r--), n.length < ta)
            return;
        }
      for (let a = r - 1; a >= ta - 1; a--)
        this.entries.splice(n[a].idx, 1), this.length--;
    }
  }
  //Mutations
  insertMarker() {
    this.entries.push({ type: fr.MARKER_ENTRY }), this.length++;
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.push({
      type: fr.ELEMENT_ENTRY,
      element: e,
      token: n
    }), this.length++;
  }
  insertElementAfterBookmark(e, n) {
    let r = this.length - 1;
    for (; r >= 0 && this.entries[r] !== this.bookmark; r--)
      ;
    this.entries.splice(r + 1, 0, {
      type: fr.ELEMENT_ENTRY,
      element: e,
      token: n
    }), this.length++;
  }
  removeEntry(e) {
    for (let n = this.length - 1; n >= 0; n--)
      if (this.entries[n] === e) {
        this.entries.splice(n, 1), this.length--;
        break;
      }
  }
  clearToLastMarker() {
    for (; this.length; ) {
      const e = this.entries.pop();
      if (this.length--, e.type === fr.MARKER_ENTRY)
        break;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    for (let n = this.length - 1; n >= 0; n--) {
      const r = this.entries[n];
      if (r.type === fr.MARKER_ENTRY)
        return null;
      if (this.treeAdapter.getTagName(r.element) === e)
        return r;
    }
    return null;
  }
  getElementEntry(e) {
    for (let n = this.length - 1; n >= 0; n--) {
      const r = this.entries[n];
      if (r.type === fr.ELEMENT_ENTRY && r.element === e)
        return r;
    }
    return null;
  }
};
ef.MARKER_ENTRY = "MARKER_ENTRY";
ef.ELEMENT_ENTRY = "ELEMENT_ENTRY";
var KC = ef;
let Z9 = class {
  constructor(e) {
    const n = {}, r = this._getOverriddenMethods(this, n);
    for (const i of Object.keys(r))
      typeof r[i] == "function" && (n[i] = e[i], e[i] = r[i]);
  }
  _getOverriddenMethods() {
    throw new Error("Not implemented");
  }
};
Z9.install = function(t, e, n) {
  t.__mixins || (t.__mixins = []);
  for (let i = 0; i < t.__mixins.length; i++)
    if (t.__mixins[i].constructor === e)
      return t.__mixins[i];
  const r = new e(t, n);
  return t.__mixins.push(r), r;
};
var Jn = Z9;
const WC = Jn;
let YC = class extends WC {
  constructor(e) {
    super(e), this.preprocessor = e, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.offset = 0, this.col = 0, this.line = 1;
  }
  _getOverriddenMethods(e, n) {
    return {
      advance() {
        const r = this.pos + 1, i = this.html[r];
        return e.isEol && (e.isEol = !1, e.line++, e.lineStartPos = r), (i === `
` || i === "\r" && this.html[r + 1] !== `
`) && (e.isEol = !0), e.col = r - e.lineStartPos + 1, e.offset = e.droppedBufferSize + r, n.advance.call(this);
      },
      retreat() {
        n.retreat.call(this), e.isEol = !1, e.col = this.pos - e.lineStartPos + 1;
      },
      dropParsedChunk() {
        const r = this.pos;
        n.dropParsedChunk.call(this);
        const i = r - this.pos;
        e.lineStartPos -= i, e.droppedBufferSize += i, e.offset = e.droppedBufferSize + this.pos;
      }
    };
  }
};
var e2 = YC;
const Pp = Jn, J1 = Dl, QC = e2;
let JC = class extends Pp {
  constructor(e) {
    super(e), this.tokenizer = e, this.posTracker = Pp.install(e.preprocessor, QC), this.currentAttrLocation = null, this.ctLoc = null;
  }
  _getCurrentLocation() {
    return {
      startLine: this.posTracker.line,
      startCol: this.posTracker.col,
      startOffset: this.posTracker.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _attachCurrentAttrLocationInfo() {
    this.currentAttrLocation.endLine = this.posTracker.line, this.currentAttrLocation.endCol = this.posTracker.col, this.currentAttrLocation.endOffset = this.posTracker.offset;
    const e = this.tokenizer.currentToken, n = this.tokenizer.currentAttr;
    e.location.attrs || (e.location.attrs = /* @__PURE__ */ Object.create(null)), e.location.attrs[n.name] = this.currentAttrLocation;
  }
  _getOverriddenMethods(e, n) {
    const r = {
      _createStartTagToken() {
        n._createStartTagToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createEndTagToken() {
        n._createEndTagToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createCommentToken() {
        n._createCommentToken.call(this), this.currentToken.location = e.ctLoc;
      },
      _createDoctypeToken(i) {
        n._createDoctypeToken.call(this, i), this.currentToken.location = e.ctLoc;
      },
      _createCharacterToken(i, s) {
        n._createCharacterToken.call(this, i, s), this.currentCharacterToken.location = e.ctLoc;
      },
      _createEOFToken() {
        n._createEOFToken.call(this), this.currentToken.location = e._getCurrentLocation();
      },
      _createAttr(i) {
        n._createAttr.call(this, i), e.currentAttrLocation = e._getCurrentLocation();
      },
      _leaveAttrName(i) {
        n._leaveAttrName.call(this, i), e._attachCurrentAttrLocationInfo();
      },
      _leaveAttrValue(i) {
        n._leaveAttrValue.call(this, i), e._attachCurrentAttrLocationInfo();
      },
      _emitCurrentToken() {
        const i = this.currentToken.location;
        this.currentCharacterToken && (this.currentCharacterToken.location.endLine = i.startLine, this.currentCharacterToken.location.endCol = i.startCol, this.currentCharacterToken.location.endOffset = i.startOffset), this.currentToken.type === J1.EOF_TOKEN ? (i.endLine = i.startLine, i.endCol = i.startCol, i.endOffset = i.startOffset) : (i.endLine = e.posTracker.line, i.endCol = e.posTracker.col + 1, i.endOffset = e.posTracker.offset + 1), n._emitCurrentToken.call(this);
      },
      _emitCurrentCharacterToken() {
        const i = this.currentCharacterToken && this.currentCharacterToken.location;
        i && i.endOffset === -1 && (i.endLine = e.posTracker.line, i.endCol = e.posTracker.col, i.endOffset = e.posTracker.offset), n._emitCurrentCharacterToken.call(this);
      }
    };
    return Object.keys(J1.MODE).forEach((i) => {
      const s = J1.MODE[i];
      r[s] = function(o) {
        e.ctLoc = e._getCurrentLocation(), n[s].call(this, o);
      };
    }), r;
  }
};
var t2 = JC;
const XC = Jn;
let ZC = class extends XC {
  constructor(e, n) {
    super(e), this.onItemPop = n.onItemPop;
  }
  _getOverriddenMethods(e, n) {
    return {
      pop() {
        e.onItemPop(this.current), n.pop.call(this);
      },
      popAllUpToHtmlElement() {
        for (let r = this.stackTop; r > 0; r--)
          e.onItemPop(this.items[r]);
        n.popAllUpToHtmlElement.call(this);
      },
      remove(r) {
        e.onItemPop(this.current), n.remove.call(this, r);
      }
    };
  }
};
var e7 = ZC;
const X1 = Jn, Bp = Dl, t7 = t2, n7 = e7, r7 = En, Z1 = r7.TAG_NAMES;
let i7 = class extends X1 {
  constructor(e) {
    super(e), this.parser = e, this.treeAdapter = this.parser.treeAdapter, this.posTracker = null, this.lastStartTagToken = null, this.lastFosterParentingLocation = null, this.currentToken = null;
  }
  _setStartLocation(e) {
    let n = null;
    this.lastStartTagToken && (n = Object.assign({}, this.lastStartTagToken.location), n.startTag = this.lastStartTagToken.location), this.treeAdapter.setNodeSourceCodeLocation(e, n);
  }
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const i = n.location, s = this.treeAdapter.getTagName(e), o = n.type === Bp.END_TAG_TOKEN && s === n.tagName, a = {};
      o ? (a.endTag = Object.assign({}, i), a.endLine = i.endLine, a.endCol = i.endCol, a.endOffset = i.endOffset) : (a.endLine = i.startLine, a.endCol = i.startCol, a.endOffset = i.startOffset), this.treeAdapter.updateNodeSourceCodeLocation(e, a);
    }
  }
  _getOverriddenMethods(e, n) {
    return {
      _bootstrap(r, i) {
        n._bootstrap.call(this, r, i), e.lastStartTagToken = null, e.lastFosterParentingLocation = null, e.currentToken = null;
        const s = X1.install(this.tokenizer, t7);
        e.posTracker = s.posTracker, X1.install(this.openElements, n7, {
          onItemPop: function(o) {
            e._setEndLocation(o, e.currentToken);
          }
        });
      },
      _runParsingLoop(r) {
        n._runParsingLoop.call(this, r);
        for (let i = this.openElements.stackTop; i >= 0; i--)
          e._setEndLocation(this.openElements.items[i], e.currentToken);
      },
      //Token processing
      _processTokenInForeignContent(r) {
        e.currentToken = r, n._processTokenInForeignContent.call(this, r);
      },
      _processToken(r) {
        if (e.currentToken = r, n._processToken.call(this, r), r.type === Bp.END_TAG_TOKEN && (r.tagName === Z1.HTML || r.tagName === Z1.BODY && this.openElements.hasInScope(Z1.BODY)))
          for (let s = this.openElements.stackTop; s >= 0; s--) {
            const o = this.openElements.items[s];
            if (this.treeAdapter.getTagName(o) === r.tagName) {
              e._setEndLocation(o, r);
              break;
            }
          }
      },
      //Doctype
      _setDocumentType(r) {
        n._setDocumentType.call(this, r);
        const i = this.treeAdapter.getChildNodes(this.document), s = i.length;
        for (let o = 0; o < s; o++) {
          const a = i[o];
          if (this.treeAdapter.isDocumentTypeNode(a)) {
            this.treeAdapter.setNodeSourceCodeLocation(a, r.location);
            break;
          }
        }
      },
      //Elements
      _attachElementToTree(r) {
        e._setStartLocation(r), e.lastStartTagToken = null, n._attachElementToTree.call(this, r);
      },
      _appendElement(r, i) {
        e.lastStartTagToken = r, n._appendElement.call(this, r, i);
      },
      _insertElement(r, i) {
        e.lastStartTagToken = r, n._insertElement.call(this, r, i);
      },
      _insertTemplate(r) {
        e.lastStartTagToken = r, n._insertTemplate.call(this, r);
        const i = this.treeAdapter.getTemplateContent(this.openElements.current);
        this.treeAdapter.setNodeSourceCodeLocation(i, null);
      },
      _insertFakeRootElement() {
        n._insertFakeRootElement.call(this), this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
      },
      //Comments
      _appendCommentNode(r, i) {
        n._appendCommentNode.call(this, r, i);
        const s = this.treeAdapter.getChildNodes(i), o = s[s.length - 1];
        this.treeAdapter.setNodeSourceCodeLocation(o, r.location);
      },
      //Text
      _findFosterParentingLocation() {
        return e.lastFosterParentingLocation = n._findFosterParentingLocation.call(this), e.lastFosterParentingLocation;
      },
      _insertCharacters(r) {
        n._insertCharacters.call(this, r);
        const i = this._shouldFosterParentOnInsertion(), s = i && e.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current, o = this.treeAdapter.getChildNodes(s), a = i && e.lastFosterParentingLocation.beforeElement ? o.indexOf(e.lastFosterParentingLocation.beforeElement) - 1 : o.length - 1, l = o[a];
        if (this.treeAdapter.getNodeSourceCodeLocation(l)) {
          const { endLine: c, endCol: f, endOffset: d } = r.location;
          this.treeAdapter.updateNodeSourceCodeLocation(l, { endLine: c, endCol: f, endOffset: d });
        } else
          this.treeAdapter.setNodeSourceCodeLocation(l, r.location);
      }
    };
  }
};
var s7 = i7;
const o7 = Jn;
let a7 = class extends o7 {
  constructor(e, n) {
    super(e), this.posTracker = null, this.onParseError = n.onParseError;
  }
  _setErrorLocation(e) {
    e.startLine = e.endLine = this.posTracker.line, e.startCol = e.endCol = this.posTracker.col, e.startOffset = e.endOffset = this.posTracker.offset;
  }
  _reportError(e) {
    const n = {
      code: e,
      startLine: -1,
      startCol: -1,
      startOffset: -1,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    this._setErrorLocation(n), this.onParseError(n);
  }
  _getOverriddenMethods(e) {
    return {
      _err(n) {
        e._reportError(n);
      }
    };
  }
};
var tf = a7;
const l7 = tf, u7 = e2, c7 = Jn;
let f7 = class extends l7 {
  constructor(e, n) {
    super(e, n), this.posTracker = c7.install(e, u7), this.lastErrOffset = -1;
  }
  _reportError(e) {
    this.lastErrOffset !== this.posTracker.offset && (this.lastErrOffset = this.posTracker.offset, super._reportError(e));
  }
};
var d7 = f7;
const h7 = tf, p7 = d7, m7 = Jn;
let g7 = class extends h7 {
  constructor(e, n) {
    super(e, n);
    const r = m7.install(e.preprocessor, p7, n);
    this.posTracker = r.posTracker;
  }
};
var T7 = g7;
const E7 = tf, y7 = T7, A7 = t2, Fp = Jn;
let b7 = class extends E7 {
  constructor(e, n) {
    super(e, n), this.opts = n, this.ctLoc = null, this.locBeforeToken = !1;
  }
  _setErrorLocation(e) {
    this.ctLoc && (e.startLine = this.ctLoc.startLine, e.startCol = this.ctLoc.startCol, e.startOffset = this.ctLoc.startOffset, e.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine, e.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol, e.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset);
  }
  _getOverriddenMethods(e, n) {
    return {
      _bootstrap(r, i) {
        n._bootstrap.call(this, r, i), Fp.install(this.tokenizer, y7, e.opts), Fp.install(this.tokenizer, A7);
      },
      _processInputToken(r) {
        e.ctLoc = r.location, n._processInputToken.call(this, r);
      },
      _err(r, i) {
        e.locBeforeToken = i && i.beforeToken, e._reportError(r);
      }
    };
  }
};
var C7 = b7, Ee = {};
const { DOCUMENT_MODE: x7 } = En;
Ee.createDocument = function() {
  return {
    nodeName: "#document",
    mode: x7.NO_QUIRKS,
    childNodes: []
  };
};
Ee.createDocumentFragment = function() {
  return {
    nodeName: "#document-fragment",
    childNodes: []
  };
};
Ee.createElement = function(t, e, n) {
  return {
    nodeName: t,
    tagName: t,
    attrs: n,
    namespaceURI: e,
    childNodes: [],
    parentNode: null
  };
};
Ee.createCommentNode = function(t) {
  return {
    nodeName: "#comment",
    data: t,
    parentNode: null
  };
};
const n2 = function(t) {
  return {
    nodeName: "#text",
    value: t,
    parentNode: null
  };
}, r2 = Ee.appendChild = function(t, e) {
  t.childNodes.push(e), e.parentNode = t;
}, S7 = Ee.insertBefore = function(t, e, n) {
  const r = t.childNodes.indexOf(n);
  t.childNodes.splice(r, 0, e), e.parentNode = t;
};
Ee.setTemplateContent = function(t, e) {
  t.content = e;
};
Ee.getTemplateContent = function(t) {
  return t.content;
};
Ee.setDocumentType = function(t, e, n, r) {
  let i = null;
  for (let s = 0; s < t.childNodes.length; s++)
    if (t.childNodes[s].nodeName === "#documentType") {
      i = t.childNodes[s];
      break;
    }
  i ? (i.name = e, i.publicId = n, i.systemId = r) : r2(t, {
    nodeName: "#documentType",
    name: e,
    publicId: n,
    systemId: r
  });
};
Ee.setDocumentMode = function(t, e) {
  t.mode = e;
};
Ee.getDocumentMode = function(t) {
  return t.mode;
};
Ee.detachNode = function(t) {
  if (t.parentNode) {
    const e = t.parentNode.childNodes.indexOf(t);
    t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
  }
};
Ee.insertText = function(t, e) {
  if (t.childNodes.length) {
    const n = t.childNodes[t.childNodes.length - 1];
    if (n.nodeName === "#text") {
      n.value += e;
      return;
    }
  }
  r2(t, n2(e));
};
Ee.insertTextBefore = function(t, e, n) {
  const r = t.childNodes[t.childNodes.indexOf(n) - 1];
  r && r.nodeName === "#text" ? r.value += e : S7(t, n2(e), n);
};
Ee.adoptAttributes = function(t, e) {
  const n = [];
  for (let r = 0; r < t.attrs.length; r++)
    n.push(t.attrs[r].name);
  for (let r = 0; r < e.length; r++)
    n.indexOf(e[r].name) === -1 && t.attrs.push(e[r]);
};
Ee.getFirstChild = function(t) {
  return t.childNodes[0];
};
Ee.getChildNodes = function(t) {
  return t.childNodes;
};
Ee.getParentNode = function(t) {
  return t.parentNode;
};
Ee.getAttrList = function(t) {
  return t.attrs;
};
Ee.getTagName = function(t) {
  return t.tagName;
};
Ee.getNamespaceURI = function(t) {
  return t.namespaceURI;
};
Ee.getTextNodeContent = function(t) {
  return t.value;
};
Ee.getCommentNodeContent = function(t) {
  return t.data;
};
Ee.getDocumentTypeNodeName = function(t) {
  return t.name;
};
Ee.getDocumentTypeNodePublicId = function(t) {
  return t.publicId;
};
Ee.getDocumentTypeNodeSystemId = function(t) {
  return t.systemId;
};
Ee.isTextNode = function(t) {
  return t.nodeName === "#text";
};
Ee.isCommentNode = function(t) {
  return t.nodeName === "#comment";
};
Ee.isDocumentTypeNode = function(t) {
  return t.nodeName === "#documentType";
};
Ee.isElementNode = function(t) {
  return !!t.tagName;
};
Ee.setNodeSourceCodeLocation = function(t, e) {
  t.sourceCodeLocation = e;
};
Ee.getNodeSourceCodeLocation = function(t) {
  return t.sourceCodeLocation;
};
Ee.updateNodeSourceCodeLocation = function(t, e) {
  t.sourceCodeLocation = Object.assign(t.sourceCodeLocation, e);
};
var N7 = function(e, n) {
  return n = n || /* @__PURE__ */ Object.create(null), [e, n].reduce((r, i) => (Object.keys(i).forEach((s) => {
    r[s] = i[s];
  }), r), /* @__PURE__ */ Object.create(null));
}, Ml = {};
const { DOCUMENT_MODE: wi } = En, i2 = "html", k7 = "about:legacy-compat", _7 = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", s2 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], O7 = s2.concat([
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
]), w7 = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"], o2 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], v7 = o2.concat([
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
]);
function Hp(t) {
  const e = t.indexOf('"') !== -1 ? "'" : '"';
  return e + t + e;
}
function Up(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.indexOf(e[n]) === 0)
      return !0;
  return !1;
}
Ml.isConforming = function(t) {
  return t.name === i2 && t.publicId === null && (t.systemId === null || t.systemId === k7);
};
Ml.getDocumentMode = function(t) {
  if (t.name !== i2)
    return wi.QUIRKS;
  const e = t.systemId;
  if (e && e.toLowerCase() === _7)
    return wi.QUIRKS;
  let n = t.publicId;
  if (n !== null) {
    if (n = n.toLowerCase(), w7.indexOf(n) > -1)
      return wi.QUIRKS;
    let r = e === null ? O7 : s2;
    if (Up(n, r))
      return wi.QUIRKS;
    if (r = e === null ? o2 : v7, Up(n, r))
      return wi.LIMITED_QUIRKS;
  }
  return wi.NO_QUIRKS;
};
Ml.serializeContent = function(t, e, n) {
  let r = "!DOCTYPE ";
  return t && (r += t), e ? r += " PUBLIC " + Hp(e) : n && (r += " SYSTEM"), n !== null && (r += " " + Hp(n)), r;
};
var Mr = {};
const eu = Dl, nf = En, J = nf.TAG_NAMES, et = nf.NAMESPACES, Ta = nf.ATTRS, qp = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, D7 = "definitionurl", M7 = "definitionURL", I7 = {
  attributename: "attributeName",
  attributetype: "attributeType",
  basefrequency: "baseFrequency",
  baseprofile: "baseProfile",
  calcmode: "calcMode",
  clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef",
  gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits",
  kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength",
  keypoints: "keyPoints",
  keysplines: "keySplines",
  keytimes: "keyTimes",
  lengthadjust: "lengthAdjust",
  limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight",
  markerunits: "markerUnits",
  markerwidth: "markerWidth",
  maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits",
  numoctaves: "numOctaves",
  pathlength: "pathLength",
  patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform",
  patternunits: "patternUnits",
  pointsatx: "pointsAtX",
  pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ",
  preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits",
  refx: "refX",
  refy: "refY",
  repeatcount: "repeatCount",
  repeatdur: "repeatDur",
  requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent",
  spreadmethod: "spreadMethod",
  startoffset: "startOffset",
  stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles",
  surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage",
  tablevalues: "tableValues",
  targetx: "targetX",
  targety: "targetY",
  textlength: "textLength",
  viewbox: "viewBox",
  viewtarget: "viewTarget",
  xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector",
  zoomandpan: "zoomAndPan"
}, R7 = {
  "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: et.XLINK },
  "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: et.XLINK },
  "xlink:href": { prefix: "xlink", name: "href", namespace: et.XLINK },
  "xlink:role": { prefix: "xlink", name: "role", namespace: et.XLINK },
  "xlink:show": { prefix: "xlink", name: "show", namespace: et.XLINK },
  "xlink:title": { prefix: "xlink", name: "title", namespace: et.XLINK },
  "xlink:type": { prefix: "xlink", name: "type", namespace: et.XLINK },
  "xml:base": { prefix: "xml", name: "base", namespace: et.XML },
  "xml:lang": { prefix: "xml", name: "lang", namespace: et.XML },
  "xml:space": { prefix: "xml", name: "space", namespace: et.XML },
  xmlns: { prefix: "", name: "xmlns", namespace: et.XMLNS },
  "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: et.XMLNS }
}, L7 = Mr.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
  altglyph: "altGlyph",
  altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem",
  animatecolor: "animateColor",
  animatemotion: "animateMotion",
  animatetransform: "animateTransform",
  clippath: "clipPath",
  feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer",
  fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight",
  feflood: "feFlood",
  fefunca: "feFuncA",
  fefuncb: "feFuncB",
  fefuncg: "feFuncG",
  fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur",
  feimage: "feImage",
  femerge: "feMerge",
  femergenode: "feMergeNode",
  femorphology: "feMorphology",
  feoffset: "feOffset",
  fepointlight: "fePointLight",
  fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight",
  fetile: "feTile",
  feturbulence: "feTurbulence",
  foreignobject: "foreignObject",
  glyphref: "glyphRef",
  lineargradient: "linearGradient",
  radialgradient: "radialGradient",
  textpath: "textPath"
}, P7 = {
  [J.B]: !0,
  [J.BIG]: !0,
  [J.BLOCKQUOTE]: !0,
  [J.BODY]: !0,
  [J.BR]: !0,
  [J.CENTER]: !0,
  [J.CODE]: !0,
  [J.DD]: !0,
  [J.DIV]: !0,
  [J.DL]: !0,
  [J.DT]: !0,
  [J.EM]: !0,
  [J.EMBED]: !0,
  [J.H1]: !0,
  [J.H2]: !0,
  [J.H3]: !0,
  [J.H4]: !0,
  [J.H5]: !0,
  [J.H6]: !0,
  [J.HEAD]: !0,
  [J.HR]: !0,
  [J.I]: !0,
  [J.IMG]: !0,
  [J.LI]: !0,
  [J.LISTING]: !0,
  [J.MENU]: !0,
  [J.META]: !0,
  [J.NOBR]: !0,
  [J.OL]: !0,
  [J.P]: !0,
  [J.PRE]: !0,
  [J.RUBY]: !0,
  [J.S]: !0,
  [J.SMALL]: !0,
  [J.SPAN]: !0,
  [J.STRONG]: !0,
  [J.STRIKE]: !0,
  [J.SUB]: !0,
  [J.SUP]: !0,
  [J.TABLE]: !0,
  [J.TT]: !0,
  [J.U]: !0,
  [J.UL]: !0,
  [J.VAR]: !0
};
Mr.causesExit = function(t) {
  const e = t.tagName;
  return e === J.FONT && (eu.getTokenAttr(t, Ta.COLOR) !== null || eu.getTokenAttr(t, Ta.SIZE) !== null || eu.getTokenAttr(t, Ta.FACE) !== null) ? !0 : P7[e];
};
Mr.adjustTokenMathMLAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === D7) {
      t.attrs[e].name = M7;
      break;
    }
};
Mr.adjustTokenSVGAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = I7[t.attrs[e].name];
    n && (t.attrs[e].name = n);
  }
};
Mr.adjustTokenXMLAttrs = function(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = R7[t.attrs[e].name];
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
};
Mr.adjustTokenSVGTagName = function(t) {
  const e = L7[t.tagName];
  e && (t.tagName = e);
};
function B7(t, e) {
  return e === et.MATHML && (t === J.MI || t === J.MO || t === J.MN || t === J.MS || t === J.MTEXT);
}
function F7(t, e, n) {
  if (e === et.MATHML && t === J.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === Ta.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === qp.TEXT_HTML || i === qp.APPLICATION_XML;
      }
  }
  return e === et.SVG && (t === J.FOREIGN_OBJECT || t === J.DESC || t === J.TITLE);
}
Mr.isIntegrationPoint = function(t, e, n, r) {
  return !!((!r || r === et.HTML) && F7(t, e, n) || (!r || r === et.MATHML) && B7(t, e));
};
const x = Dl, H7 = jC, zp = KC, U7 = s7, q7 = C7, $p = Jn, z7 = Ee, $7 = N7, Vp = Ml, wn = Mr, rt = Zc, V7 = Tn, mi = En, p = mi.TAG_NAMES, K = mi.NAMESPACES, a2 = mi.ATTRS, G7 = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  onParseError: null,
  treeAdapter: z7
}, l2 = "hidden", j7 = 8, K7 = 3, u2 = "INITIAL_MODE", rf = "BEFORE_HTML_MODE", Il = "BEFORE_HEAD_MODE", ms = "IN_HEAD_MODE", c2 = "IN_HEAD_NO_SCRIPT_MODE", Rl = "AFTER_HEAD_MODE", Dn = "IN_BODY_MODE", ol = "TEXT_MODE", at = "IN_TABLE_MODE", f2 = "IN_TABLE_TEXT_MODE", Ll = "IN_CAPTION_MODE", ko = "IN_COLUMN_GROUP_MODE", Kt = "IN_TABLE_BODY_MODE", Qn = "IN_ROW_MODE", Pl = "IN_CELL_MODE", sf = "IN_SELECT_MODE", of = "IN_SELECT_IN_TABLE_MODE", al = "IN_TEMPLATE_MODE", af = "AFTER_BODY_MODE", Bl = "IN_FRAMESET_MODE", d2 = "AFTER_FRAMESET_MODE", h2 = "AFTER_AFTER_BODY_MODE", p2 = "AFTER_AFTER_FRAMESET_MODE", W7 = {
  [p.TR]: Qn,
  [p.TBODY]: Kt,
  [p.THEAD]: Kt,
  [p.TFOOT]: Kt,
  [p.CAPTION]: Ll,
  [p.COLGROUP]: ko,
  [p.TABLE]: at,
  [p.BODY]: Dn,
  [p.FRAMESET]: Bl
}, Y7 = {
  [p.CAPTION]: at,
  [p.COLGROUP]: at,
  [p.TBODY]: at,
  [p.TFOOT]: at,
  [p.THEAD]: at,
  [p.COL]: ko,
  [p.TR]: Kt,
  [p.TD]: Qn,
  [p.TH]: Qn
}, Gp = {
  [u2]: {
    [x.CHARACTER_TOKEN]: Ms,
    [x.NULL_CHARACTER_TOKEN]: Ms,
    [x.WHITESPACE_CHARACTER_TOKEN]: ge,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: sx,
    [x.START_TAG_TOKEN]: Ms,
    [x.END_TAG_TOKEN]: Ms,
    [x.EOF_TOKEN]: Ms
  },
  [rf]: {
    [x.CHARACTER_TOKEN]: Zs,
    [x.NULL_CHARACTER_TOKEN]: Zs,
    [x.WHITESPACE_CHARACTER_TOKEN]: ge,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: ox,
    [x.END_TAG_TOKEN]: ax,
    [x.EOF_TOKEN]: Zs
  },
  [Il]: {
    [x.CHARACTER_TOKEN]: eo,
    [x.NULL_CHARACTER_TOKEN]: eo,
    [x.WHITESPACE_CHARACTER_TOKEN]: ge,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: na,
    [x.START_TAG_TOKEN]: lx,
    [x.END_TAG_TOKEN]: ux,
    [x.EOF_TOKEN]: eo
  },
  [ms]: {
    [x.CHARACTER_TOKEN]: to,
    [x.NULL_CHARACTER_TOKEN]: to,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: na,
    [x.START_TAG_TOKEN]: Qe,
    [x.END_TAG_TOKEN]: gi,
    [x.EOF_TOKEN]: to
  },
  [c2]: {
    [x.CHARACTER_TOKEN]: no,
    [x.NULL_CHARACTER_TOKEN]: no,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: na,
    [x.START_TAG_TOKEN]: cx,
    [x.END_TAG_TOKEN]: fx,
    [x.EOF_TOKEN]: no
  },
  [Rl]: {
    [x.CHARACTER_TOKEN]: ro,
    [x.NULL_CHARACTER_TOKEN]: ro,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: na,
    [x.START_TAG_TOKEN]: dx,
    [x.END_TAG_TOKEN]: hx,
    [x.EOF_TOKEN]: ro
  },
  [Dn]: {
    [x.CHARACTER_TOKEN]: ra,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: _t,
    [x.END_TAG_TOKEN]: lf,
    [x.EOF_TOKEN]: Hn
  },
  [ol]: {
    [x.CHARACTER_TOKEN]: Et,
    [x.NULL_CHARACTER_TOKEN]: Et,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: ge,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: ge,
    [x.END_TAG_TOKEN]: Vx,
    [x.EOF_TOKEN]: Gx
  },
  [at]: {
    [x.CHARACTER_TOKEN]: Un,
    [x.NULL_CHARACTER_TOKEN]: Un,
    [x.WHITESPACE_CHARACTER_TOKEN]: Un,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: uf,
    [x.END_TAG_TOKEN]: cf,
    [x.EOF_TOKEN]: Hn
  },
  [f2]: {
    [x.CHARACTER_TOKEN]: tS,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: eS,
    [x.COMMENT_TOKEN]: Is,
    [x.DOCTYPE_TOKEN]: Is,
    [x.START_TAG_TOKEN]: Is,
    [x.END_TAG_TOKEN]: Is,
    [x.EOF_TOKEN]: Is
  },
  [Ll]: {
    [x.CHARACTER_TOKEN]: ra,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: nS,
    [x.END_TAG_TOKEN]: rS,
    [x.EOF_TOKEN]: Hn
  },
  [ko]: {
    [x.CHARACTER_TOKEN]: ll,
    [x.NULL_CHARACTER_TOKEN]: ll,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: iS,
    [x.END_TAG_TOKEN]: sS,
    [x.EOF_TOKEN]: Hn
  },
  [Kt]: {
    [x.CHARACTER_TOKEN]: Un,
    [x.NULL_CHARACTER_TOKEN]: Un,
    [x.WHITESPACE_CHARACTER_TOKEN]: Un,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: oS,
    [x.END_TAG_TOKEN]: aS,
    [x.EOF_TOKEN]: Hn
  },
  [Qn]: {
    [x.CHARACTER_TOKEN]: Un,
    [x.NULL_CHARACTER_TOKEN]: Un,
    [x.WHITESPACE_CHARACTER_TOKEN]: Un,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: lS,
    [x.END_TAG_TOKEN]: uS,
    [x.EOF_TOKEN]: Hn
  },
  [Pl]: {
    [x.CHARACTER_TOKEN]: ra,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: cS,
    [x.END_TAG_TOKEN]: fS,
    [x.EOF_TOKEN]: Hn
  },
  [sf]: {
    [x.CHARACTER_TOKEN]: Et,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: m2,
    [x.END_TAG_TOKEN]: g2,
    [x.EOF_TOKEN]: Hn
  },
  [of]: {
    [x.CHARACTER_TOKEN]: Et,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: dS,
    [x.END_TAG_TOKEN]: hS,
    [x.EOF_TOKEN]: Hn
  },
  [al]: {
    [x.CHARACTER_TOKEN]: ra,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: pS,
    [x.END_TAG_TOKEN]: mS,
    [x.EOF_TOKEN]: T2
  },
  [af]: {
    [x.CHARACTER_TOKEN]: ul,
    [x.NULL_CHARACTER_TOKEN]: ul,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: ix,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: gS,
    [x.END_TAG_TOKEN]: TS,
    [x.EOF_TOKEN]: Ds
  },
  [Bl]: {
    [x.CHARACTER_TOKEN]: ge,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: ES,
    [x.END_TAG_TOKEN]: yS,
    [x.EOF_TOKEN]: Ds
  },
  [d2]: {
    [x.CHARACTER_TOKEN]: ge,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Et,
    [x.COMMENT_TOKEN]: qe,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: AS,
    [x.END_TAG_TOKEN]: bS,
    [x.EOF_TOKEN]: Ds
  },
  [h2]: {
    [x.CHARACTER_TOKEN]: Ea,
    [x.NULL_CHARACTER_TOKEN]: Ea,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: jp,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: CS,
    [x.END_TAG_TOKEN]: Ea,
    [x.EOF_TOKEN]: Ds
  },
  [p2]: {
    [x.CHARACTER_TOKEN]: ge,
    [x.NULL_CHARACTER_TOKEN]: ge,
    [x.WHITESPACE_CHARACTER_TOKEN]: Vr,
    [x.COMMENT_TOKEN]: jp,
    [x.DOCTYPE_TOKEN]: ge,
    [x.START_TAG_TOKEN]: xS,
    [x.END_TAG_TOKEN]: ge,
    [x.EOF_TOKEN]: Ds
  }
};
class Q7 {
  constructor(e) {
    this.options = $7(G7, e), this.treeAdapter = this.options.treeAdapter, this.pendingScript = null, this.options.sourceCodeLocationInfo && $p.install(this, U7), this.options.onParseError && $p.install(this, q7, { onParseError: this.options.onParseError });
  }
  // API
  parse(e) {
    const n = this.treeAdapter.createDocument();
    return this._bootstrap(n, null), this.tokenizer.write(e, !0), this._runParsingLoop(null), n;
  }
  parseFragment(e, n) {
    n || (n = this.treeAdapter.createElement(p.TEMPLATE, K.HTML, []));
    const r = this.treeAdapter.createElement("documentmock", K.HTML, []);
    this._bootstrap(r, n), this.treeAdapter.getTagName(n) === p.TEMPLATE && this._pushTmplInsertionMode(al), this._initTokenizerForFragmentParsing(), this._insertFakeRootElement(), this._resetInsertionMode(), this._findFormInFragmentContext(), this.tokenizer.write(e, !0), this._runParsingLoop(null);
    const i = this.treeAdapter.getFirstChild(r), s = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(i, s), s;
  }
  //Bootstrap parser
  _bootstrap(e, n) {
    this.tokenizer = new x(this.options), this.stopped = !1, this.insertionMode = u2, this.originalInsertionMode = "", this.document = e, this.fragmentContext = n, this.headElement = null, this.formElement = null, this.openElements = new H7(this.document, this.treeAdapter), this.activeFormattingElements = new zp(this.treeAdapter), this.tmplInsertionModeStack = [], this.tmplInsertionModeStackTop = -1, this.currentTmplInsertionMode = null, this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1;
  }
  //Errors
  _err() {
  }
  //Parsing loop
  _runParsingLoop(e) {
    for (; !this.stopped; ) {
      this._setupTokenizerCDATAMode();
      const n = this.tokenizer.getNextToken();
      if (n.type === x.HIBERNATION_TOKEN)
        break;
      if (this.skipNextNewLine && (this.skipNextNewLine = !1, n.type === x.WHITESPACE_CHARACTER_TOKEN && n.chars[0] === `
`)) {
        if (n.chars.length === 1)
          continue;
        n.chars = n.chars.substr(1);
      }
      if (this._processInputToken(n), e && this.pendingScript)
        break;
    }
  }
  runParsingLoopForCurrentChunk(e, n) {
    if (this._runParsingLoop(n), n && this.pendingScript) {
      const r = this.pendingScript;
      this.pendingScript = null, n(r);
      return;
    }
    e && e();
  }
  //Text parsing
  _setupTokenizerCDATAMode() {
    const e = this._getAdjustedCurrentElement();
    this.tokenizer.allowCDATA = e && e !== this.document && this.treeAdapter.getNamespaceURI(e) !== K.HTML && !this._isIntegrationPoint(e);
  }
  _switchToTextParsing(e, n) {
    this._insertElement(e, K.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = ol;
  }
  switchToPlaintextParsing() {
    this.insertionMode = ol, this.originalInsertionMode = Dn, this.tokenizer.state = x.MODE.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    do {
      if (this.treeAdapter.getTagName(e) === p.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    } while (e);
  }
  _initTokenizerForFragmentParsing() {
    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === K.HTML) {
      const e = this.treeAdapter.getTagName(this.fragmentContext);
      e === p.TITLE || e === p.TEXTAREA ? this.tokenizer.state = x.MODE.RCDATA : e === p.STYLE || e === p.XMP || e === p.IFRAME || e === p.NOEMBED || e === p.NOFRAMES || e === p.NOSCRIPT ? this.tokenizer.state = x.MODE.RAWTEXT : e === p.SCRIPT ? this.tokenizer.state = x.MODE.SCRIPT_DATA : e === p.PLAINTEXT && (this.tokenizer.state = x.MODE.PLAINTEXT);
    }
  }
  //Tree mutation
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", i = e.systemId || "";
    this.treeAdapter.setDocumentType(this.document, n, r, i);
  }
  _attachElementToTree(e) {
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const n = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.appendChild(n, e);
    }
  }
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r);
  }
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r), this.openElements.push(r);
  }
  _insertFakeElement(e) {
    const n = this.treeAdapter.createElement(e, K.HTML, []);
    this._attachElementToTree(n), this.openElements.push(n);
  }
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, K.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n), this.openElements.push(n);
  }
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(p.HTML, K.HTML, []);
    this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e);
  }
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r);
  }
  _insertCharacters(e) {
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentText(e.chars);
    else {
      const n = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.insertText(n, e.chars);
    }
  }
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  //Token processing
  _shouldProcessTokenInForeignContent(e) {
    const n = this._getAdjustedCurrentElement();
    if (!n || n === this.document)
      return !1;
    const r = this.treeAdapter.getNamespaceURI(n);
    if (r === K.HTML || this.treeAdapter.getTagName(n) === p.ANNOTATION_XML && r === K.MATHML && e.type === x.START_TAG_TOKEN && e.tagName === p.SVG)
      return !1;
    const i = e.type === x.CHARACTER_TOKEN || e.type === x.NULL_CHARACTER_TOKEN || e.type === x.WHITESPACE_CHARACTER_TOKEN;
    return (e.type === x.START_TAG_TOKEN && e.tagName !== p.MGLYPH && e.tagName !== p.MALIGNMARK || i) && this._isIntegrationPoint(n, K.MATHML) || (e.type === x.START_TAG_TOKEN || i) && this._isIntegrationPoint(n, K.HTML) ? !1 : e.type !== x.EOF_TOKEN;
  }
  _processToken(e) {
    Gp[this.insertionMode][e.type](this, e);
  }
  _processTokenInBodyMode(e) {
    Gp[Dn][e.type](this, e);
  }
  _processTokenInForeignContent(e) {
    e.type === x.CHARACTER_TOKEN ? NS(this, e) : e.type === x.NULL_CHARACTER_TOKEN ? SS(this, e) : e.type === x.WHITESPACE_CHARACTER_TOKEN ? Et(this, e) : e.type === x.COMMENT_TOKEN ? qe(this, e) : e.type === x.START_TAG_TOKEN ? kS(this, e) : e.type === x.END_TAG_TOKEN && _S(this, e);
  }
  _processInputToken(e) {
    this._shouldProcessTokenInForeignContent(e) ? this._processTokenInForeignContent(e) : this._processToken(e), e.type === x.START_TAG_TOKEN && e.selfClosing && !e.ackSelfClosing && this._err(rt.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  //Integration points
  _isIntegrationPoint(e, n) {
    const r = this.treeAdapter.getTagName(e), i = this.treeAdapter.getNamespaceURI(e), s = this.treeAdapter.getAttrList(e);
    return wn.isIntegrationPoint(r, i, s, n);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.length;
    if (e) {
      let n = e, r = null;
      do
        if (n--, r = this.activeFormattingElements.entries[n], r.type === zp.MARKER_ENTRY || this.openElements.contains(r.element)) {
          n++;
          break;
        }
      while (n > 0);
      for (let i = n; i < e; i++)
        r = this.activeFormattingElements.entries[i], this._insertElement(r.token, this.treeAdapter.getNamespaceURI(r.element)), r.element = this.openElements.current;
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = Qn;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(p.P), this.openElements.popUntilTagNamePopped(p.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop, n = !1; e >= 0; e--) {
      let r = this.openElements.items[e];
      e === 0 && (n = !0, this.fragmentContext && (r = this.fragmentContext));
      const i = this.treeAdapter.getTagName(r), s = W7[i];
      if (s) {
        this.insertionMode = s;
        break;
      } else if (!n && (i === p.TD || i === p.TH)) {
        this.insertionMode = Pl;
        break;
      } else if (!n && i === p.HEAD) {
        this.insertionMode = ms;
        break;
      } else if (i === p.SELECT) {
        this._resetInsertionModeForSelect(e);
        break;
      } else if (i === p.TEMPLATE) {
        this.insertionMode = this.currentTmplInsertionMode;
        break;
      } else if (i === p.HTML) {
        this.insertionMode = this.headElement ? Rl : Il;
        break;
      } else if (n) {
        this.insertionMode = Dn;
        break;
      }
    }
  }
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.items[n], i = this.treeAdapter.getTagName(r);
        if (i === p.TEMPLATE)
          break;
        if (i === p.TABLE) {
          this.insertionMode = of;
          return;
        }
      }
    this.insertionMode = sf;
  }
  _pushTmplInsertionMode(e) {
    this.tmplInsertionModeStack.push(e), this.tmplInsertionModeStackTop++, this.currentTmplInsertionMode = e;
  }
  _popTmplInsertionMode() {
    this.tmplInsertionModeStack.pop(), this.tmplInsertionModeStackTop--, this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
  }
  //Foster parenting
  _isElementCausesFosterParenting(e) {
    const n = this.treeAdapter.getTagName(e);
    return n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR;
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
  }
  _findFosterParentingLocation() {
    const e = {
      parent: null,
      beforeElement: null
    };
    for (let n = this.openElements.stackTop; n >= 0; n--) {
      const r = this.openElements.items[n], i = this.treeAdapter.getTagName(r), s = this.treeAdapter.getNamespaceURI(r);
      if (i === p.TEMPLATE && s === K.HTML) {
        e.parent = this.treeAdapter.getTemplateContent(r);
        break;
      } else if (i === p.TABLE) {
        e.parent = this.treeAdapter.getParentNode(r), e.parent ? e.beforeElement = r : e.parent = this.openElements.items[n - 1];
        break;
      }
    }
    return e.parent || (e.parent = this.openElements.items[0]), e;
  }
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  _fosterParentText(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertTextBefore(n.parent, e, n.beforeElement) : this.treeAdapter.insertText(n.parent, e);
  }
  //Special elements
  _isSpecialElement(e) {
    const n = this.treeAdapter.getTagName(e), r = this.treeAdapter.getNamespaceURI(e);
    return mi.SPECIAL_ELEMENTS[r][n];
  }
}
var J7 = Q7;
function X7(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagName) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : an(t, e), n;
}
function Z7(t, e) {
  let n = null;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.items[r];
    if (i === e.element)
      break;
    t._isSpecialElement(i) && (n = i);
  }
  return n || (t.openElements.popUntilElementPopped(e.element), t.activeFormattingElements.removeEntry(e)), n;
}
function ex(t, e, n) {
  let r = e, i = t.openElements.getCommonAncestor(e);
  for (let s = 0, o = i; o !== n; s++, o = i) {
    i = t.openElements.getCommonAncestor(o);
    const a = t.activeFormattingElements.getElementEntry(o), l = a && s >= K7;
    !a || l ? (l && t.activeFormattingElements.removeEntry(a), t.openElements.remove(o)) : (o = tx(t, a), r === e && (t.activeFormattingElements.bookmark = a), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(o, r), r = o);
  }
  return r;
}
function tx(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function nx(t, e, n) {
  if (t._isElementCausesFosterParenting(e))
    t._fosterParentElement(n);
  else {
    const r = t.treeAdapter.getTagName(e), i = t.treeAdapter.getNamespaceURI(e);
    r === p.TEMPLATE && i === K.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function rx(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), i = n.token, s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
  t._adoptNodes(e, s), t.treeAdapter.appendChild(e, s), t.activeFormattingElements.insertElementAfterBookmark(s, n.token), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, s);
}
function pr(t, e) {
  let n;
  for (let r = 0; r < j7 && (n = X7(t, e), !!n); r++) {
    const i = Z7(t, n);
    if (!i)
      break;
    t.activeFormattingElements.bookmark = n;
    const s = ex(t, i, n.element), o = t.openElements.getCommonAncestor(n.element);
    t.treeAdapter.detachNode(s), nx(t, o, s), rx(t, i, n);
  }
}
function ge() {
}
function na(t) {
  t._err(rt.misplacedDoctype);
}
function qe(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContent || t.openElements.current);
}
function ix(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function jp(t, e) {
  t._appendCommentNode(e, t.document);
}
function Et(t, e) {
  t._insertCharacters(e);
}
function Ds(t) {
  t.stopped = !0;
}
function sx(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? mi.DOCUMENT_MODE.QUIRKS : Vp.getDocumentMode(e);
  Vp.isConforming(e) || t._err(rt.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = rf;
}
function Ms(t, e) {
  t._err(rt.missingDoctype, { beforeToken: !0 }), t.treeAdapter.setDocumentMode(t.document, mi.DOCUMENT_MODE.QUIRKS), t.insertionMode = rf, t._processToken(e);
}
function ox(t, e) {
  e.tagName === p.HTML ? (t._insertElement(e, K.HTML), t.insertionMode = Il) : Zs(t, e);
}
function ax(t, e) {
  const n = e.tagName;
  (n === p.HTML || n === p.HEAD || n === p.BODY || n === p.BR) && Zs(t, e);
}
function Zs(t, e) {
  t._insertFakeRootElement(), t.insertionMode = Il, t._processToken(e);
}
function lx(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.HEAD ? (t._insertElement(e, K.HTML), t.headElement = t.openElements.current, t.insertionMode = ms) : eo(t, e);
}
function ux(t, e) {
  const n = e.tagName;
  n === p.HEAD || n === p.BODY || n === p.HTML || n === p.BR ? eo(t, e) : t._err(rt.endTagWithoutMatchingOpenElement);
}
function eo(t, e) {
  t._insertFakeElement(p.HEAD), t.headElement = t.openElements.current, t.insertionMode = ms, t._processToken(e);
}
function Qe(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META ? (t._appendElement(e, K.HTML), e.ackSelfClosing = !0) : n === p.TITLE ? t._switchToTextParsing(e, x.MODE.RCDATA) : n === p.NOSCRIPT ? t.options.scriptingEnabled ? t._switchToTextParsing(e, x.MODE.RAWTEXT) : (t._insertElement(e, K.HTML), t.insertionMode = c2) : n === p.NOFRAMES || n === p.STYLE ? t._switchToTextParsing(e, x.MODE.RAWTEXT) : n === p.SCRIPT ? t._switchToTextParsing(e, x.MODE.SCRIPT_DATA) : n === p.TEMPLATE ? (t._insertTemplate(e, K.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = al, t._pushTmplInsertionMode(al)) : n === p.HEAD ? t._err(rt.misplacedStartTagForHeadElement) : to(t, e);
}
function gi(t, e) {
  const n = e.tagName;
  n === p.HEAD ? (t.openElements.pop(), t.insertionMode = Rl) : n === p.BODY || n === p.BR || n === p.HTML ? to(t, e) : n === p.TEMPLATE && t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagName !== p.TEMPLATE && t._err(rt.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(p.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t._popTmplInsertionMode(), t._resetInsertionMode()) : t._err(rt.endTagWithoutMatchingOpenElement);
}
function to(t, e) {
  t.openElements.pop(), t.insertionMode = Rl, t._processToken(e);
}
function cx(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.BASEFONT || n === p.BGSOUND || n === p.HEAD || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.STYLE ? Qe(t, e) : n === p.NOSCRIPT ? t._err(rt.nestedNoscriptInHead) : no(t, e);
}
function fx(t, e) {
  const n = e.tagName;
  n === p.NOSCRIPT ? (t.openElements.pop(), t.insertionMode = ms) : n === p.BR ? no(t, e) : t._err(rt.endTagWithoutMatchingOpenElement);
}
function no(t, e) {
  const n = e.type === x.EOF_TOKEN ? rt.openElementsLeftAfterEof : rt.disallowedContentInNoscriptInHead;
  t._err(n), t.openElements.pop(), t.insertionMode = ms, t._processToken(e);
}
function dx(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.BODY ? (t._insertElement(e, K.HTML), t.framesetOk = !1, t.insertionMode = Dn) : n === p.FRAMESET ? (t._insertElement(e, K.HTML), t.insertionMode = Bl) : n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.SCRIPT || n === p.STYLE || n === p.TEMPLATE || n === p.TITLE ? (t._err(rt.abandonedHeadElementChild), t.openElements.push(t.headElement), Qe(t, e), t.openElements.remove(t.headElement)) : n === p.HEAD ? t._err(rt.misplacedStartTagForHeadElement) : ro(t, e);
}
function hx(t, e) {
  const n = e.tagName;
  n === p.BODY || n === p.HTML || n === p.BR ? ro(t, e) : n === p.TEMPLATE ? gi(t, e) : t._err(rt.endTagWithoutMatchingOpenElement);
}
function ro(t, e) {
  t._insertFakeElement(p.BODY), t.insertionMode = Dn, t._processToken(e);
}
function Vr(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function ra(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function px(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function mx(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function gx(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, K.HTML), t.insertionMode = Bl);
}
function Fn(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML);
}
function Tx(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement();
  const n = t.openElements.currentTagName;
  (n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6) && t.openElements.pop(), t._insertElement(e, K.HTML);
}
function Kp(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function Ex(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML), n || (t.formElement = t.openElements.current));
}
function yx(t, e) {
  t.framesetOk = !1;
  const n = e.tagName;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.items[r], s = t.treeAdapter.getTagName(i);
    let o = null;
    if (n === p.LI && s === p.LI ? o = p.LI : (n === p.DD || n === p.DT) && (s === p.DD || s === p.DT) && (o = s), o) {
      t.openElements.generateImpliedEndTagsWithExclusion(o), t.openElements.popUntilTagNamePopped(o);
      break;
    }
    if (s !== p.ADDRESS && s !== p.DIV && s !== p.P && t._isSpecialElement(i))
      break;
  }
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML);
}
function Ax(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML), t.tokenizer.state = x.MODE.PLAINTEXT;
}
function bx(t, e) {
  t.openElements.hasInScope(p.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML), t.framesetOk = !1;
}
function Cx(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(p.A);
  n && (pr(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function vi(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function xx(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(p.NOBR) && (pr(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, K.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function Wp(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function Sx(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== mi.DOCUMENT_MODE.QUIRKS && t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML), t.framesetOk = !1, t.insertionMode = at;
}
function Hi(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, K.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function Nx(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, K.HTML);
  const n = x.getTokenAttr(e, a2.TYPE);
  (!n || n.toLowerCase() !== l2) && (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function Yp(t, e) {
  t._appendElement(e, K.HTML), e.ackSelfClosing = !0;
}
function kx(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._appendElement(e, K.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function _x(t, e) {
  e.tagName = p.IMG, Hi(t, e);
}
function Ox(t, e) {
  t._insertElement(e, K.HTML), t.skipNextNewLine = !0, t.tokenizer.state = x.MODE.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = ol;
}
function wx(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, x.MODE.RAWTEXT);
}
function vx(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, x.MODE.RAWTEXT);
}
function Qp(t, e) {
  t._switchToTextParsing(e, x.MODE.RAWTEXT);
}
function Dx(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML), t.framesetOk = !1, t.insertionMode === at || t.insertionMode === Ll || t.insertionMode === Kt || t.insertionMode === Qn || t.insertionMode === Pl ? t.insertionMode = of : t.insertionMode = sf;
}
function Jp(t, e) {
  t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML);
}
function Xp(t, e) {
  t.openElements.hasInScope(p.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, K.HTML);
}
function Mx(t, e) {
  t.openElements.hasInScope(p.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(p.RTC), t._insertElement(e, K.HTML);
}
function Ix(t, e) {
  t.openElements.hasInButtonScope(p.P) && t._closePElement(), t._insertElement(e, K.HTML);
}
function Rx(t, e) {
  t._reconstructActiveFormattingElements(), wn.adjustTokenMathMLAttrs(e), wn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, K.MATHML) : t._insertElement(e, K.MATHML), e.ackSelfClosing = !0;
}
function Lx(t, e) {
  t._reconstructActiveFormattingElements(), wn.adjustTokenSVGAttrs(e), wn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, K.SVG) : t._insertElement(e, K.SVG), e.ackSelfClosing = !0;
}
function Ut(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, K.HTML);
}
function _t(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 1:
      n === p.I || n === p.S || n === p.B || n === p.U ? vi(t, e) : n === p.P ? Fn(t, e) : n === p.A ? Cx(t, e) : Ut(t, e);
      break;
    case 2:
      n === p.DL || n === p.OL || n === p.UL ? Fn(t, e) : n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6 ? Tx(t, e) : n === p.LI || n === p.DD || n === p.DT ? yx(t, e) : n === p.EM || n === p.TT ? vi(t, e) : n === p.BR ? Hi(t, e) : n === p.HR ? kx(t, e) : n === p.RB ? Xp(t, e) : n === p.RT || n === p.RP ? Mx(t, e) : n !== p.TH && n !== p.TD && n !== p.TR && Ut(t, e);
      break;
    case 3:
      n === p.DIV || n === p.DIR || n === p.NAV ? Fn(t, e) : n === p.PRE ? Kp(t, e) : n === p.BIG ? vi(t, e) : n === p.IMG || n === p.WBR ? Hi(t, e) : n === p.XMP ? wx(t, e) : n === p.SVG ? Lx(t, e) : n === p.RTC ? Xp(t, e) : n !== p.COL && Ut(t, e);
      break;
    case 4:
      n === p.HTML ? px(t, e) : n === p.BASE || n === p.LINK || n === p.META ? Qe(t, e) : n === p.BODY ? mx(t, e) : n === p.MAIN || n === p.MENU ? Fn(t, e) : n === p.FORM ? Ex(t, e) : n === p.CODE || n === p.FONT ? vi(t, e) : n === p.NOBR ? xx(t, e) : n === p.AREA ? Hi(t, e) : n === p.MATH ? Rx(t, e) : n === p.MENU ? Ix(t, e) : n !== p.HEAD && Ut(t, e);
      break;
    case 5:
      n === p.STYLE || n === p.TITLE ? Qe(t, e) : n === p.ASIDE ? Fn(t, e) : n === p.SMALL ? vi(t, e) : n === p.TABLE ? Sx(t, e) : n === p.EMBED ? Hi(t, e) : n === p.INPUT ? Nx(t, e) : n === p.PARAM || n === p.TRACK ? Yp(t, e) : n === p.IMAGE ? _x(t, e) : n !== p.FRAME && n !== p.TBODY && n !== p.TFOOT && n !== p.THEAD && Ut(t, e);
      break;
    case 6:
      n === p.SCRIPT ? Qe(t, e) : n === p.CENTER || n === p.FIGURE || n === p.FOOTER || n === p.HEADER || n === p.HGROUP || n === p.DIALOG ? Fn(t, e) : n === p.BUTTON ? bx(t, e) : n === p.STRIKE || n === p.STRONG ? vi(t, e) : n === p.APPLET || n === p.OBJECT ? Wp(t, e) : n === p.KEYGEN ? Hi(t, e) : n === p.SOURCE ? Yp(t, e) : n === p.IFRAME ? vx(t, e) : n === p.SELECT ? Dx(t, e) : n === p.OPTION ? Jp(t, e) : Ut(t, e);
      break;
    case 7:
      n === p.BGSOUND ? Qe(t, e) : n === p.DETAILS || n === p.ADDRESS || n === p.ARTICLE || n === p.SECTION || n === p.SUMMARY ? Fn(t, e) : n === p.LISTING ? Kp(t, e) : n === p.MARQUEE ? Wp(t, e) : n === p.NOEMBED ? Qp(t, e) : n !== p.CAPTION && Ut(t, e);
      break;
    case 8:
      n === p.BASEFONT ? Qe(t, e) : n === p.FRAMESET ? gx(t, e) : n === p.FIELDSET ? Fn(t, e) : n === p.TEXTAREA ? Ox(t, e) : n === p.TEMPLATE ? Qe(t, e) : n === p.NOSCRIPT ? t.options.scriptingEnabled ? Qp(t, e) : Ut(t, e) : n === p.OPTGROUP ? Jp(t, e) : n !== p.COLGROUP && Ut(t, e);
      break;
    case 9:
      n === p.PLAINTEXT ? Ax(t, e) : Ut(t, e);
      break;
    case 10:
      n === p.BLOCKQUOTE || n === p.FIGCAPTION ? Fn(t, e) : Ut(t, e);
      break;
    default:
      Ut(t, e);
  }
}
function Px(t) {
  t.openElements.hasInScope(p.BODY) && (t.insertionMode = af);
}
function Bx(t, e) {
  t.openElements.hasInScope(p.BODY) && (t.insertionMode = af, t._processToken(e));
}
function ar(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function Fx(t) {
  const e = t.openElements.tmplCount > 0, n = t.formElement;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(p.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(p.FORM) : t.openElements.remove(n));
}
function Hx(t) {
  t.openElements.hasInButtonScope(p.P) || t._insertFakeElement(p.P), t._closePElement();
}
function Ux(t) {
  t.openElements.hasInListItemScope(p.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(p.LI), t.openElements.popUntilTagNamePopped(p.LI));
}
function qx(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function zx(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function Zp(t, e) {
  const n = e.tagName;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function $x(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(p.BR), t.openElements.pop(), t.framesetOk = !1;
}
function an(t, e) {
  const n = e.tagName;
  for (let r = t.openElements.stackTop; r > 0; r--) {
    const i = t.openElements.items[r];
    if (t.treeAdapter.getTagName(i) === n) {
      t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilElementPopped(i);
      break;
    }
    if (t._isSpecialElement(i))
      break;
  }
}
function lf(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 1:
      n === p.A || n === p.B || n === p.I || n === p.S || n === p.U ? pr(t, e) : n === p.P ? Hx(t) : an(t, e);
      break;
    case 2:
      n === p.DL || n === p.UL || n === p.OL ? ar(t, e) : n === p.LI ? Ux(t) : n === p.DD || n === p.DT ? qx(t, e) : n === p.H1 || n === p.H2 || n === p.H3 || n === p.H4 || n === p.H5 || n === p.H6 ? zx(t) : n === p.BR ? $x(t) : n === p.EM || n === p.TT ? pr(t, e) : an(t, e);
      break;
    case 3:
      n === p.BIG ? pr(t, e) : n === p.DIR || n === p.DIV || n === p.NAV || n === p.PRE ? ar(t, e) : an(t, e);
      break;
    case 4:
      n === p.BODY ? Px(t) : n === p.HTML ? Bx(t, e) : n === p.FORM ? Fx(t) : n === p.CODE || n === p.FONT || n === p.NOBR ? pr(t, e) : n === p.MAIN || n === p.MENU ? ar(t, e) : an(t, e);
      break;
    case 5:
      n === p.ASIDE ? ar(t, e) : n === p.SMALL ? pr(t, e) : an(t, e);
      break;
    case 6:
      n === p.CENTER || n === p.FIGURE || n === p.FOOTER || n === p.HEADER || n === p.HGROUP || n === p.DIALOG ? ar(t, e) : n === p.APPLET || n === p.OBJECT ? Zp(t, e) : n === p.STRIKE || n === p.STRONG ? pr(t, e) : an(t, e);
      break;
    case 7:
      n === p.ADDRESS || n === p.ARTICLE || n === p.DETAILS || n === p.SECTION || n === p.SUMMARY || n === p.LISTING ? ar(t, e) : n === p.MARQUEE ? Zp(t, e) : an(t, e);
      break;
    case 8:
      n === p.FIELDSET ? ar(t, e) : n === p.TEMPLATE ? gi(t, e) : an(t, e);
      break;
    case 10:
      n === p.BLOCKQUOTE || n === p.FIGCAPTION ? ar(t, e) : an(t, e);
      break;
    default:
      an(t, e);
  }
}
function Hn(t, e) {
  t.tmplInsertionModeStackTop > -1 ? T2(t, e) : t.stopped = !0;
}
function Vx(t, e) {
  e.tagName === p.SCRIPT && (t.pendingScript = t.openElements.current), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function Gx(t, e) {
  t._err(rt.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
function Un(t, e) {
  const n = t.openElements.currentTagName;
  n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? (t.pendingCharacterTokens = [], t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = f2, t._processToken(e)) : qt(t, e);
}
function jx(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, K.HTML), t.insertionMode = Ll;
}
function Kx(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, K.HTML), t.insertionMode = ko;
}
function Wx(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(p.COLGROUP), t.insertionMode = ko, t._processToken(e);
}
function Yx(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, K.HTML), t.insertionMode = Kt;
}
function Qx(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(p.TBODY), t.insertionMode = Kt, t._processToken(e);
}
function Jx(t, e) {
  t.openElements.hasInTableScope(p.TABLE) && (t.openElements.popUntilTagNamePopped(p.TABLE), t._resetInsertionMode(), t._processToken(e));
}
function Xx(t, e) {
  const n = x.getTokenAttr(e, a2.TYPE);
  n && n.toLowerCase() === l2 ? t._appendElement(e, K.HTML) : qt(t, e), e.ackSelfClosing = !0;
}
function Zx(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, K.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function uf(t, e) {
  const n = e.tagName;
  switch (n.length) {
    case 2:
      n === p.TD || n === p.TH || n === p.TR ? Qx(t, e) : qt(t, e);
      break;
    case 3:
      n === p.COL ? Wx(t, e) : qt(t, e);
      break;
    case 4:
      n === p.FORM ? Zx(t, e) : qt(t, e);
      break;
    case 5:
      n === p.TABLE ? Jx(t, e) : n === p.STYLE ? Qe(t, e) : n === p.TBODY || n === p.TFOOT || n === p.THEAD ? Yx(t, e) : n === p.INPUT ? Xx(t, e) : qt(t, e);
      break;
    case 6:
      n === p.SCRIPT ? Qe(t, e) : qt(t, e);
      break;
    case 7:
      n === p.CAPTION ? jx(t, e) : qt(t, e);
      break;
    case 8:
      n === p.COLGROUP ? Kx(t, e) : n === p.TEMPLATE ? Qe(t, e) : qt(t, e);
      break;
    default:
      qt(t, e);
  }
}
function cf(t, e) {
  const n = e.tagName;
  n === p.TABLE ? t.openElements.hasInTableScope(p.TABLE) && (t.openElements.popUntilTagNamePopped(p.TABLE), t._resetInsertionMode()) : n === p.TEMPLATE ? gi(t, e) : n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && n !== p.TBODY && n !== p.TD && n !== p.TFOOT && n !== p.TH && n !== p.THEAD && n !== p.TR && qt(t, e);
}
function qt(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, t._processTokenInBodyMode(e), t.fosterParentingEnabled = n;
}
function eS(t, e) {
  t.pendingCharacterTokens.push(e);
}
function tS(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function Is(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      qt(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
function nS(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TD || n === p.TFOOT || n === p.TH || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(p.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = at, t._processToken(e)) : _t(t, e);
}
function rS(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE ? t.openElements.hasInTableScope(p.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(p.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = at, n === p.TABLE && t._processToken(e)) : n !== p.BODY && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && n !== p.TBODY && n !== p.TD && n !== p.TFOOT && n !== p.TH && n !== p.THEAD && n !== p.TR && lf(t, e);
}
function iS(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.COL ? (t._appendElement(e, K.HTML), e.ackSelfClosing = !0) : n === p.TEMPLATE ? Qe(t, e) : ll(t, e);
}
function sS(t, e) {
  const n = e.tagName;
  n === p.COLGROUP ? t.openElements.currentTagName === p.COLGROUP && (t.openElements.pop(), t.insertionMode = at) : n === p.TEMPLATE ? gi(t, e) : n !== p.COL && ll(t, e);
}
function ll(t, e) {
  t.openElements.currentTagName === p.COLGROUP && (t.openElements.pop(), t.insertionMode = at, t._processToken(e));
}
function oS(t, e) {
  const n = e.tagName;
  n === p.TR ? (t.openElements.clearBackToTableBodyContext(), t._insertElement(e, K.HTML), t.insertionMode = Qn) : n === p.TH || n === p.TD ? (t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(p.TR), t.insertionMode = Qn, t._processToken(e)) : n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TFOOT || n === p.THEAD ? t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = at, t._processToken(e)) : uf(t, e);
}
function aS(t, e) {
  const n = e.tagName;
  n === p.TBODY || n === p.TFOOT || n === p.THEAD ? t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = at) : n === p.TABLE ? t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = at, t._processToken(e)) : (n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP || n !== p.HTML && n !== p.TD && n !== p.TH && n !== p.TR) && cf(t, e);
}
function lS(t, e) {
  const n = e.tagName;
  n === p.TH || n === p.TD ? (t.openElements.clearBackToTableRowContext(), t._insertElement(e, K.HTML), t.insertionMode = Pl, t.activeFormattingElements.insertMarker()) : n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Kt, t._processToken(e)) : uf(t, e);
}
function uS(t, e) {
  const n = e.tagName;
  n === p.TR ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Kt) : n === p.TABLE ? t.openElements.hasInTableScope(p.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Kt, t._processToken(e)) : n === p.TBODY || n === p.TFOOT || n === p.THEAD ? (t.openElements.hasInTableScope(n) || t.openElements.hasInTableScope(p.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Kt, t._processToken(e)) : (n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP || n !== p.HTML && n !== p.TD && n !== p.TH) && cf(t, e);
}
function cS(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.COL || n === p.COLGROUP || n === p.TBODY || n === p.TD || n === p.TFOOT || n === p.TH || n === p.THEAD || n === p.TR ? (t.openElements.hasInTableScope(p.TD) || t.openElements.hasInTableScope(p.TH)) && (t._closeTableCell(), t._processToken(e)) : _t(t, e);
}
function fS(t, e) {
  const n = e.tagName;
  n === p.TD || n === p.TH ? t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = Qn) : n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR ? t.openElements.hasInTableScope(n) && (t._closeTableCell(), t._processToken(e)) : n !== p.BODY && n !== p.CAPTION && n !== p.COL && n !== p.COLGROUP && n !== p.HTML && lf(t, e);
}
function m2(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.OPTION ? (t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t._insertElement(e, K.HTML)) : n === p.OPTGROUP ? (t.openElements.currentTagName === p.OPTION && t.openElements.pop(), t.openElements.currentTagName === p.OPTGROUP && t.openElements.pop(), t._insertElement(e, K.HTML)) : n === p.INPUT || n === p.KEYGEN || n === p.TEXTAREA || n === p.SELECT ? t.openElements.hasInSelectScope(p.SELECT) && (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), n !== p.SELECT && t._processToken(e)) : (n === p.SCRIPT || n === p.TEMPLATE) && Qe(t, e);
}
function g2(t, e) {
  const n = e.tagName;
  if (n === p.OPTGROUP) {
    const r = t.openElements.items[t.openElements.stackTop - 1], i = r && t.treeAdapter.getTagName(r);
    t.openElements.currentTagName === p.OPTION && i === p.OPTGROUP && t.openElements.pop(), t.openElements.currentTagName === p.OPTGROUP && t.openElements.pop();
  } else
    n === p.OPTION ? t.openElements.currentTagName === p.OPTION && t.openElements.pop() : n === p.SELECT && t.openElements.hasInSelectScope(p.SELECT) ? (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode()) : n === p.TEMPLATE && gi(t, e);
}
function dS(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR || n === p.TD || n === p.TH ? (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), t._processToken(e)) : m2(t, e);
}
function hS(t, e) {
  const n = e.tagName;
  n === p.CAPTION || n === p.TABLE || n === p.TBODY || n === p.TFOOT || n === p.THEAD || n === p.TR || n === p.TD || n === p.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(p.SELECT), t._resetInsertionMode(), t._processToken(e)) : g2(t, e);
}
function pS(t, e) {
  const n = e.tagName;
  if (n === p.BASE || n === p.BASEFONT || n === p.BGSOUND || n === p.LINK || n === p.META || n === p.NOFRAMES || n === p.SCRIPT || n === p.STYLE || n === p.TEMPLATE || n === p.TITLE)
    Qe(t, e);
  else {
    const r = Y7[n] || Dn;
    t._popTmplInsertionMode(), t._pushTmplInsertionMode(r), t.insertionMode = r, t._processToken(e);
  }
}
function mS(t, e) {
  e.tagName === p.TEMPLATE && gi(t, e);
}
function T2(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(p.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t._popTmplInsertionMode(), t._resetInsertionMode(), t._processToken(e)) : t.stopped = !0;
}
function gS(t, e) {
  e.tagName === p.HTML ? _t(t, e) : ul(t, e);
}
function TS(t, e) {
  e.tagName === p.HTML ? t.fragmentContext || (t.insertionMode = h2) : ul(t, e);
}
function ul(t, e) {
  t.insertionMode = Dn, t._processToken(e);
}
function ES(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.FRAMESET ? t._insertElement(e, K.HTML) : n === p.FRAME ? (t._appendElement(e, K.HTML), e.ackSelfClosing = !0) : n === p.NOFRAMES && Qe(t, e);
}
function yS(t, e) {
  e.tagName === p.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagName !== p.FRAMESET && (t.insertionMode = d2));
}
function AS(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.NOFRAMES && Qe(t, e);
}
function bS(t, e) {
  e.tagName === p.HTML && (t.insertionMode = p2);
}
function CS(t, e) {
  e.tagName === p.HTML ? _t(t, e) : Ea(t, e);
}
function Ea(t, e) {
  t.insertionMode = Dn, t._processToken(e);
}
function xS(t, e) {
  const n = e.tagName;
  n === p.HTML ? _t(t, e) : n === p.NOFRAMES && Qe(t, e);
}
function SS(t, e) {
  e.chars = V7.REPLACEMENT_CHARACTER, t._insertCharacters(e);
}
function NS(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function kS(t, e) {
  if (wn.causesExit(e) && !t.fragmentContext) {
    for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== K.HTML && !t._isIntegrationPoint(t.openElements.current); )
      t.openElements.pop();
    t._processToken(e);
  } else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === K.MATHML ? wn.adjustTokenMathMLAttrs(e) : r === K.SVG && (wn.adjustTokenSVGTagName(e), wn.adjustTokenSVGAttrs(e)), wn.adjustTokenXMLAttrs(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function _S(t, e) {
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === K.HTML) {
      t._processToken(e);
      break;
    }
    if (t.treeAdapter.getTagName(r).toLowerCase() === e.tagName) {
      t.openElements.popUntilElementPopped(r);
      break;
    }
  }
}
const E2 = J7;
class _o {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(e, n, r) {
    this.property = e, this.normal = n, r && (this.space = r);
  }
}
_o.prototype.property = {};
_o.prototype.normal = {};
_o.prototype.space = null;
function y2(t, e) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < t.length; )
    Object.assign(n, t[i].property), Object.assign(r, t[i].normal);
  return new _o(n, r, e);
}
function Eo(t) {
  return t.toLowerCase();
}
class tn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(e, n) {
    this.property = e, this.attribute = n;
  }
}
tn.prototype.space = null;
tn.prototype.boolean = !1;
tn.prototype.booleanish = !1;
tn.prototype.overloadedBoolean = !1;
tn.prototype.number = !1;
tn.prototype.commaSeparated = !1;
tn.prototype.spaceSeparated = !1;
tn.prototype.commaOrSpaceSeparated = !1;
tn.prototype.mustUseProperty = !1;
tn.prototype.defined = !1;
let OS = 0;
const oe = Ti(), Fe = Ti(), A2 = Ti(), F = Ti(), Oe = Ti(), Xi = Ti(), Dt = Ti();
function Ti() {
  return 2 ** ++OS;
}
const oc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: oe,
  booleanish: Fe,
  commaOrSpaceSeparated: Dt,
  commaSeparated: Xi,
  number: F,
  overloadedBoolean: A2,
  spaceSeparated: Oe
}, Symbol.toStringTag, { value: "Module" })), tu = Object.keys(oc);
class ff extends tn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), em(this, "space", i), typeof r == "number")
      for (; ++s < tu.length; ) {
        const o = tu[s];
        em(this, tu[s], (r & oc[o]) === oc[o]);
      }
  }
}
ff.prototype.defined = !0;
function em(t, e, n) {
  n && (t[e] = n);
}
const wS = {}.hasOwnProperty;
function gs(t) {
  const e = {}, n = {};
  let r;
  for (r in t.properties)
    if (wS.call(t.properties, r)) {
      const i = t.properties[r], s = new ff(
        r,
        t.transform(t.attributes || {}, r),
        i,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[Eo(r)] = r, n[Eo(s.attribute)] = r;
    }
  return new _o(e, n, t.space);
}
const b2 = gs({
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), C2 = gs({
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function x2(t, e) {
  return e in t ? t[e] : e;
}
function S2(t, e) {
  return x2(t, e.toLowerCase());
}
const N2 = gs({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: S2,
  properties: { xmlns: null, xmlnsXLink: null }
}), k2 = gs({
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Fe,
    ariaAutoComplete: null,
    ariaBusy: Fe,
    ariaChecked: Fe,
    ariaColCount: F,
    ariaColIndex: F,
    ariaColSpan: F,
    ariaControls: Oe,
    ariaCurrent: null,
    ariaDescribedBy: Oe,
    ariaDetails: null,
    ariaDisabled: Fe,
    ariaDropEffect: Oe,
    ariaErrorMessage: null,
    ariaExpanded: Fe,
    ariaFlowTo: Oe,
    ariaGrabbed: Fe,
    ariaHasPopup: null,
    ariaHidden: Fe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Oe,
    ariaLevel: F,
    ariaLive: null,
    ariaModal: Fe,
    ariaMultiLine: Fe,
    ariaMultiSelectable: Fe,
    ariaOrientation: null,
    ariaOwns: Oe,
    ariaPlaceholder: null,
    ariaPosInSet: F,
    ariaPressed: Fe,
    ariaReadOnly: Fe,
    ariaRelevant: null,
    ariaRequired: Fe,
    ariaRoleDescription: Oe,
    ariaRowCount: F,
    ariaRowIndex: F,
    ariaRowSpan: F,
    ariaSelected: Fe,
    ariaSetSize: F,
    ariaSort: null,
    ariaValueMax: F,
    ariaValueMin: F,
    ariaValueNow: F,
    ariaValueText: null,
    role: null
  }
}), vS = gs({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: S2,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Xi,
    acceptCharset: Oe,
    accessKey: Oe,
    action: null,
    allow: null,
    allowFullScreen: oe,
    allowPaymentRequest: oe,
    allowUserMedia: oe,
    alt: null,
    as: null,
    async: oe,
    autoCapitalize: null,
    autoComplete: Oe,
    autoFocus: oe,
    autoPlay: oe,
    capture: oe,
    charSet: null,
    checked: oe,
    cite: null,
    className: Oe,
    cols: F,
    colSpan: null,
    content: null,
    contentEditable: Fe,
    controls: oe,
    controlsList: Oe,
    coords: F | Xi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: oe,
    defer: oe,
    dir: null,
    dirName: null,
    disabled: oe,
    download: A2,
    draggable: Fe,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: oe,
    formTarget: null,
    headers: Oe,
    height: F,
    hidden: oe,
    high: F,
    href: null,
    hrefLang: null,
    htmlFor: Oe,
    httpEquiv: Oe,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: oe,
    itemId: null,
    itemProp: Oe,
    itemRef: Oe,
    itemScope: oe,
    itemType: Oe,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: oe,
    low: F,
    manifest: null,
    max: null,
    maxLength: F,
    media: null,
    method: null,
    min: null,
    minLength: F,
    multiple: oe,
    muted: oe,
    name: null,
    nonce: null,
    noModule: oe,
    noValidate: oe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: oe,
    optimum: F,
    pattern: null,
    ping: Oe,
    placeholder: null,
    playsInline: oe,
    poster: null,
    preload: null,
    readOnly: oe,
    referrerPolicy: null,
    rel: Oe,
    required: oe,
    reversed: oe,
    rows: F,
    rowSpan: F,
    sandbox: Oe,
    scope: null,
    scoped: oe,
    seamless: oe,
    selected: oe,
    shape: null,
    size: F,
    sizes: null,
    slot: null,
    span: F,
    spellCheck: Fe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: F,
    step: null,
    style: null,
    tabIndex: F,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: oe,
    useMap: null,
    value: Fe,
    width: F,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Oe,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: F,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: F,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: oe,
    // Lists. Use CSS to reduce space between items instead
    declare: oe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: F,
    // `<img>` and `<object>`
    leftMargin: F,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: F,
    // `<body>`
    marginWidth: F,
    // `<body>`
    noResize: oe,
    // `<frame>`
    noHref: oe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: oe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: oe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: F,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Fe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: F,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: F,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: oe,
    disableRemotePlayback: oe,
    prefix: null,
    property: null,
    results: F,
    security: null,
    unselectable: null
  }
}), DS = gs({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: x2,
  properties: {
    about: Dt,
    accentHeight: F,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: F,
    amplitude: F,
    arabicForm: null,
    ascent: F,
    attributeName: null,
    attributeType: null,
    azimuth: F,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: F,
    by: null,
    calcMode: null,
    capHeight: F,
    className: Oe,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: F,
    diffuseConstant: F,
    direction: null,
    display: null,
    dur: null,
    divisor: F,
    dominantBaseline: null,
    download: oe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: F,
    enableBackground: null,
    end: null,
    event: null,
    exponent: F,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: F,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Xi,
    g2: Xi,
    glyphName: Xi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: F,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: F,
    horizOriginX: F,
    horizOriginY: F,
    id: null,
    ideographic: F,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: F,
    k: F,
    k1: F,
    k2: F,
    k3: F,
    k4: F,
    kernelMatrix: Dt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: F,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: F,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: F,
    overlineThickness: F,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: F,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Oe,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: F,
    pointsAtY: F,
    pointsAtZ: F,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Dt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Dt,
    rev: Dt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Dt,
    requiredFeatures: Dt,
    requiredFonts: Dt,
    requiredFormats: Dt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: F,
    specularExponent: F,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: F,
    strikethroughThickness: F,
    string: null,
    stroke: null,
    strokeDashArray: Dt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: F,
    strokeOpacity: F,
    strokeWidth: null,
    style: null,
    surfaceScale: F,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Dt,
    tabIndex: F,
    tableValues: null,
    target: null,
    targetX: F,
    targetY: F,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Dt,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: F,
    underlineThickness: F,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: F,
    values: null,
    vAlphabetic: F,
    vMathematical: F,
    vectorEffect: null,
    vHanging: F,
    vIdeographic: F,
    version: null,
    vertAdvY: F,
    vertOriginX: F,
    vertOriginY: F,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: F,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), MS = /^data[-\w.:]+$/i, tm = /-[a-z]/g, IS = /[A-Z]/g;
function Oo(t, e) {
  const n = Eo(e);
  let r = e, i = tn;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && MS.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(tm, LS);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!tm.test(s)) {
        let o = s.replace(IS, RS);
        o.charAt(0) !== "-" && (o = "-" + o), e = "data" + o;
      }
    }
    i = ff;
  }
  return new i(r, e);
}
function RS(t) {
  return "-" + t.toLowerCase();
}
function LS(t) {
  return t.charAt(1).toUpperCase();
}
const Ts = y2([C2, b2, N2, k2, vS], "html"), Xn = y2([C2, b2, N2, k2, DS], "svg"), nm = /[#.]/g;
function PS(t, e) {
  const n = t || "", r = {};
  let i = 0, s, o;
  for (; i < n.length; ) {
    nm.lastIndex = i;
    const a = nm.exec(n), l = n.slice(i, a ? a.index : n.length);
    l && (s ? s === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : o = l, i += l.length), a && (s = a[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: fine.
    tagName: o || e || "div",
    properties: r,
    children: []
  };
}
function rm(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function df(t) {
  return t.join(" ").trim();
}
function ac(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), i = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = n.length, s = !0);
    const o = n.slice(i, r).trim();
    (o || !s) && e.push(o), i = r + 1, r = n.indexOf(",", i);
  }
  return e;
}
function hf(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const BS = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]), lc = {}.hasOwnProperty;
function _2(t, e, n) {
  const r = n && qS(n);
  return (
    /**
     * @type {{
     *   (): Root
     *   (selector: null | undefined, ...children: Array<HChild>): Root
     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
     *   (selector: string, ...children: Array<HChild>): Element
     * }}
     */
    /**
     * Hyperscript compatible DSL for creating virtual hast trees.
     *
     * @param {string | null} [selector]
     * @param {HProperties | HChild} [properties]
     * @param {Array<HChild>} children
     * @returns {HResult}
     */
    function(s, o, ...a) {
      let l = -1, u;
      if (s == null)
        u = { type: "root", children: [] }, a.unshift(o);
      else if (u = PS(s, e), u.tagName = u.tagName.toLowerCase(), r && lc.call(r, u.tagName) && (u.tagName = r[u.tagName]), FS(o, u.tagName)) {
        let c;
        for (c in o)
          lc.call(o, c) && HS(t, u.properties, c, o[c]);
      } else
        a.unshift(o);
      for (; ++l < a.length; )
        uc(u.children, a[l]);
      return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
    }
  );
}
function FS(t, e) {
  return t == null || typeof t != "object" || Array.isArray(t) ? !1 : e === "input" || !t.type || typeof t.type != "string" ? !0 : "children" in t && Array.isArray(t.children) ? !1 : e === "button" ? BS.has(t.type.toLowerCase()) : !("value" in t);
}
function HS(t, e, n, r) {
  const i = Oo(t, n);
  let s = -1, o;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r))
        return;
      o = r;
    } else
      typeof r == "boolean" ? o = r : typeof r == "string" ? i.spaceSeparated ? o = rm(r) : i.commaSeparated ? o = ac(r) : i.commaOrSpaceSeparated ? o = rm(ac(r).join(" ")) : o = im(i, i.property, r) : Array.isArray(r) ? o = r.concat() : o = i.property === "style" ? US(r) : String(r);
    if (Array.isArray(o)) {
      const a = [];
      for (; ++s < o.length; )
        a[s] = im(i, i.property, o[s]);
      o = a;
    }
    i.property === "className" && Array.isArray(e.className) && (o = e.className.concat(o)), e[i.property] = o;
  }
}
function uc(t, e) {
  let n = -1;
  if (e != null)
    if (typeof e == "string" || typeof e == "number")
      t.push({ type: "text", value: String(e) });
    else if (Array.isArray(e))
      for (; ++n < e.length; )
        uc(t, e[n]);
    else if (typeof e == "object" && "type" in e)
      e.type === "root" ? uc(t, e.children) : t.push(e);
    else
      throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function im(t, e, n) {
  if (typeof n == "string") {
    if (t.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((t.boolean || t.overloadedBoolean) && (n === "" || Eo(n) === Eo(e)))
      return !0;
  }
  return n;
}
function US(t) {
  const e = [];
  let n;
  for (n in t)
    lc.call(t, n) && e.push([n, t[n]].join(": "));
  return e.join("; ");
}
function qS(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    e[t[n].toLowerCase()] = t[n];
  return e;
}
const O2 = _2(Ts, "div"), zS = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], $S = _2(Xn, "g", zS);
function VS(t) {
  const e = String(t), n = [], r = /\r?\n|\r/g;
  for (; r.test(e); )
    n.push(r.lastIndex);
  return n.push(e.length + 1), { toPoint: i, toOffset: s };
  function i(o) {
    let a = -1;
    if (typeof o == "number" && o > -1 && o < n[n.length - 1]) {
      for (; ++a < n.length; )
        if (n[a] > o)
          return {
            line: a + 1,
            column: o - (a > 0 ? n[a - 1] : 0) + 1,
            offset: o
          };
    }
    return { line: void 0, column: void 0, offset: void 0 };
  }
  function s(o) {
    const a = o && o.line, l = o && o.column;
    if (typeof a == "number" && typeof l == "number" && !Number.isNaN(a) && !Number.isNaN(l) && a - 1 in n) {
      const u = (n[a - 2] || 0) + l - 1 || 0;
      if (u > -1 && u < n[n.length - 1])
        return u;
    }
    return -1;
  }
}
const yo = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, w2 = {}.hasOwnProperty, GS = Object.prototype;
function v2(t, e) {
  const n = e || {};
  let r, i;
  return WS(n) ? (i = n, r = {}) : (i = n.file || void 0, r = n), pf(
    {
      schema: r.space === "svg" ? Xn : Ts,
      file: i,
      verbose: r.verbose,
      location: !1
    },
    t
  );
}
function pf(t, e) {
  let n;
  switch (e.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        e
      );
      return n = { type: "comment", value: r.data }, ya(t, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        e
      ), i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: D2(t, e.childNodes),
        data: { quirksMode: i }
      }, t.file && t.location) {
        const s = String(t.file), o = VS(s), a = o.toPoint(0), l = o.toPoint(s.length);
        n.position = { start: a, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        e
      );
      return n = { type: "doctype" }, ya(t, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        e
      );
      return n = { type: "text", value: r.value }, ya(t, r, n), n;
    }
    default:
      return n = jS(
        t,
        /** @type {P5Element} */
        e
      ), n;
  }
}
function D2(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    r[n] = pf(t, e[n]);
  return r;
}
function jS(t, e) {
  const n = t.schema;
  t.schema = e.namespaceURI === yo.svg ? Xn : Ts;
  let r = -1;
  const i = {};
  for (; ++r < e.attrs.length; ) {
    const a = e.attrs[r], l = (a.prefix ? a.prefix + ":" : "") + a.name;
    w2.call(GS, l) || (i[l] = a.value);
  }
  const o = (t.schema.space === "svg" ? $S : O2)(e.tagName, i, D2(t, e.childNodes));
  if (ya(t, e, o), o.tagName === "template") {
    const a = (
      /** @type {P5Template} */
      e
    ), l = a.sourceCodeLocation, u = l && l.startTag && Gi(l.startTag), c = l && l.endTag && Gi(l.endTag), f = pf(t, a.content);
    u && c && t.file && (f.position = { start: u.end, end: c.start }), o.content = f;
  }
  return t.schema = n, o;
}
function ya(t, e, n) {
  if ("sourceCodeLocation" in e && e.sourceCodeLocation && t.file) {
    const r = KS(t, n, e.sourceCodeLocation);
    r && (t.location = !0, n.position = r);
  }
}
function KS(t, e, n) {
  const r = Gi(n);
  if (e.type === "element") {
    const i = e.children[e.children.length - 1];
    if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), t.verbose) {
      const s = {};
      let o;
      if (n.attrs)
        for (o in n.attrs)
          w2.call(n.attrs, o) && (s[Oo(t.schema, o).property] = Gi(
            n.attrs[o]
          ));
      e.data = {
        position: {
          // @ts-expect-error: assume not `undefined`.
          opening: Gi(n.startTag),
          closing: n.endTag ? Gi(n.endTag) : null,
          properties: s
        }
      };
    }
  }
  return r;
}
function Gi(t) {
  const e = sm({
    line: t.startLine,
    column: t.startCol,
    offset: t.startOffset
  }), n = sm({
    line: t.endLine,
    column: t.endCol,
    offset: t.endOffset
  });
  return e || n ? { start: e, end: n } : void 0;
}
function sm(t) {
  return t.line && t.column ? t : void 0;
}
function WS(t) {
  return "messages" in t;
}
const YS = {
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: !1
  },
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: !1
  },
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: !1
  },
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: !1
  },
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: !1
  },
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: !1
  },
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: !1
  },
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: !1
  },
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: !1
  },
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: !1
  },
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: !1
  },
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
}, QS = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-", JS = { 2: !0, 1: !1, 0: null };
function M2(t) {
  const e = (
    /** @type {Options} */
    this.data("settings")
  ), n = Object.assign({}, e, t);
  Object.assign(this, { Parser: r });
  function r(i, s) {
    const o = n.fragment ? "parseFragment" : "parse", a = n.emitParseErrors ? u : null, l = new E2({
      sourceCodeLocationInfo: !0,
      onParseError: a,
      scriptingEnabled: !1
    });
    return v2(l[o](i), {
      space: n.space,
      file: s,
      verbose: n.verbose
    });
    function u(c) {
      const f = c.code, d = XS(f), h = n[d], m = h ?? !0, g = typeof m == "number" ? m : m ? 1 : 0, T = {
        line: c.startLine,
        column: c.startCol,
        offset: c.startOffset
      }, E = {
        line: c.endLine,
        column: c.endCol,
        offset: c.endOffset
      };
      if (g) {
        const k = YS[d] || { reason: "", description: "", url: "" }, A = s.message(_(k.reason), { start: T, end: E });
        A.source = "parse-error", A.ruleId = f, A.fatal = JS[g], A.note = _(k.description), A.url = "url" in k && k.url === !1 ? null : QS + f;
      }
      function _(k) {
        return k.replace(/%c(?:-(\d+))?/g, (A, v) => {
          const y = v ? -Number.parseInt(v, 10) : 0, b = i.charAt(c.startOffset + y);
          return b === "`" ? "` ` `" : b;
        }).replace(
          /%x/g,
          () => "0x" + i.charCodeAt(c.startOffset).toString(16).toUpperCase()
        );
      }
    }
  }
}
function XS(t) {
  return t.replace(/-[a-z]/g, (e) => e.charAt(1).toUpperCase());
}
const Sr = (
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [node]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parent | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(t, e, n, r, i) {
    const s = Ne(e);
    if (n != null && (typeof n != "number" || n < 0 || n === Number.POSITIVE_INFINITY))
      throw new Error("Expected positive finite index for child node");
    if (r != null && (!r.type || !r.children))
      throw new Error("Expected parent node");
    if (!t || !t.type || typeof t.type != "string")
      return !1;
    if (r == null != (n == null))
      throw new Error("Expected both parent and index");
    return s.call(i, t, n, r);
  }
), Ne = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(t) {
    if (t == null)
      return mf;
    if (typeof t == "string")
      return eN(t);
    if (typeof t == "object")
      return ZS(t);
    if (typeof t == "function")
      return I2(t);
    throw new Error("Expected function, string, or array as test");
  }
);
function ZS(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Ne(t[n]);
  return I2(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].call(this, ...i))
        return !0;
    return !1;
  }
}
function eN(t) {
  return e;
  function e(n) {
    return mf(n) && n.tagName === t;
  }
}
function I2(t) {
  return e;
  function e(n, ...r) {
    return mf(n) && Boolean(t.call(this, n, ...r));
  }
}
function mf(t) {
  return Boolean(
    t && typeof t == "object" && // @ts-expect-error Looks like a node.
    t.type === "element" && // @ts-expect-error Looks like an element.
    typeof t.tagName == "string"
  );
}
const gf = Ne([
  "audio",
  "canvas",
  "embed",
  "iframe",
  "img",
  "math",
  "object",
  "picture",
  "svg",
  "video"
]), Es = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(t) {
    if (t == null)
      return iN;
    if (typeof t == "string")
      return rN(t);
    if (typeof t == "object")
      return Array.isArray(t) ? tN(t) : nN(t);
    if (typeof t == "function")
      return Fl(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function tN(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Es(t[n]);
  return Fl(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].call(this, ...i))
        return !0;
    return !1;
  }
}
function nN(t) {
  return Fl(e);
  function e(n) {
    let r;
    for (r in t)
      if (n[r] !== t[r])
        return !1;
    return !0;
  }
}
function rN(t) {
  return Fl(e);
  function e(n) {
    return n && n.type === t;
  }
}
function Fl(t) {
  return e;
  function e(n, ...r) {
    return Boolean(
      n && typeof n == "object" && "type" in n && // @ts-expect-error: fine.
      Boolean(t.call(this, n, ...r))
    );
  }
}
function iN() {
  return !0;
}
function Nr(t) {
  const e = (
    // @ts-expect-error looks like a node.
    t && typeof t == "object" && t.type === "text" ? (
      // @ts-expect-error looks like a text.
      t.value || ""
    ) : t
  );
  return typeof e == "string" && e.replace(/[ \t\n\f\r]/g, "") === "";
}
const sN = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
], oN = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
], aN = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
], Tf = Es(["doctype", "comment"]);
function R2(t = {}) {
  const e = pN(
    t.newlines ? dN : hN
  );
  return (n) => {
    L2(n, { collapse: e, whitespace: "normal" });
  };
}
function L2(t, e) {
  if ("children" in t) {
    const n = Object.assign({}, e);
    return (t.type === "root" || F2(t)) && (n.before = !0, n.after = !0), n.whitespace = mN(t, e), uN(t, n);
  }
  if (t.type === "text") {
    if (e.whitespace === "normal")
      return lN(t, e);
    e.whitespace === "nowrap" && (t.value = e.collapse(t.value));
  }
  return { remove: !1, ignore: Tf(t), stripAtStart: !1 };
}
function lN(t, e) {
  const n = e.collapse(t.value), r = { remove: !1, ignore: !1, stripAtStart: !1 };
  let i = 0, s = n.length;
  return e.before && om(n.charAt(0)) && i++, i !== s && om(n.charAt(s - 1)) && (e.after ? s-- : r.stripAtStart = !0), i === s ? r.remove = !0 : t.value = n.slice(i, s), r;
}
function uN(t, e) {
  let n = e.before;
  const r = e.after, i = t.children;
  let s = i.length, o = -1;
  for (; ++o < s; ) {
    const a = L2(
      i[o],
      Object.assign({}, e, {
        before: n,
        after: P2(i, o, r)
      })
    );
    a.remove ? (i.splice(o, 1), o--, s--) : a.ignore || (n = a.stripAtStart), B2(i[o]) && (n = !1);
  }
  return { remove: !1, ignore: !1, stripAtStart: Boolean(n || r) };
}
function P2(t, e, n) {
  for (; ++e < t.length; ) {
    const r = t[e];
    let i = cN(r);
    if (i === void 0 && "children" in r && !fN(r) && (i = P2(r.children, -1)), typeof i == "boolean")
      return i;
  }
  return n;
}
function cN(t) {
  if (t.type === "element") {
    if (B2(t))
      return !1;
    if (F2(t))
      return !0;
  } else if (t.type === "text") {
    if (!Nr(t))
      return !1;
  } else if (!Tf(t))
    return !1;
}
function B2(t) {
  return gf(t) || Sr(t, oN);
}
function F2(t) {
  return Sr(t, sN);
}
function fN(t) {
  return Boolean(
    "properties" in t && t.properties && t.properties.hidden
  ) || Tf(t) || Sr(t, aN);
}
function om(t) {
  return t === " " || t === `
`;
}
function dN(t) {
  const e = /\r?\n|\r/.exec(t);
  return e ? e[0] : " ";
}
function hN() {
  return " ";
}
function pN(t) {
  return e;
  function e(n) {
    return String(n).replace(/[\t\n\v\f\r ]+/g, t);
  }
}
function mN(t, e) {
  if ("tagName" in t && t.properties)
    switch (t.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return t.properties.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return t.properties.noWrap ? "nowrap" : e.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  return e.whitespace;
}
const gN = !0, Ao = !1, Hl = "skip", Ef = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null);
    const i = Es(e), s = r ? -1 : 1;
    o(t, void 0, [])();
    function o(a, l, u) {
      const c = a && typeof a == "object" ? a : {};
      if (typeof c.type == "string") {
        const d = (
          // `hast`
          typeof c.tagName == "string" ? c.tagName : (
            // `xast`
            typeof c.name == "string" ? c.name : void 0
          )
        );
        Object.defineProperty(f, "name", {
          value: "node (" + (a.type + (d ? "<" + d + ">" : "")) + ")"
        });
      }
      return f;
      function f() {
        let d = [], h, m, g;
        if ((!e || i(a, l, u[u.length - 1] || null)) && (d = TN(n(a, u)), d[0] === Ao))
          return d;
        if (a.children && d[0] !== Hl)
          for (m = (r ? a.children.length : -1) + s, g = u.concat(a); m > -1 && m < a.children.length; ) {
            if (h = o(a.children[m], m, g)(), h[0] === Ao)
              return h;
            m = typeof h[1] == "number" ? h[1] : m + s;
          }
        return d;
      }
    }
  }
);
function TN(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [gN, t] : [t];
}
const Jt = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(t, e, n, r) {
    typeof e == "function" && typeof n != "function" && (r = n, n = e, e = null), Ef(t, e, i, r);
    function i(s, o) {
      const a = o[o.length - 1];
      return n(
        s,
        a ? a.children.indexOf(s) : null,
        a
      );
    }
  }
);
function Z(t, e) {
  const n = e.children || [], r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const a = H2(t, n[i], e);
    Array.isArray(a) ? r.push(...a) : a && r.push(a);
  }
  let s = 0, o = r.length;
  for (; s < o && r[s].type === "break"; )
    s++;
  for (; o > s && r[o - 1].type === "break"; )
    o--;
  return s === 0 && o === r.length ? r : r.slice(s, o);
}
const cl = {}.hasOwnProperty;
function ot(t, e) {
  return t.wrapText ? e : e.replace(/\r?\n|\r/g, " ");
}
function H2(t, e, n) {
  let r;
  if (e.type === "element") {
    if (e.properties && e.properties.dataMdast === "ignore")
      return;
    cl.call(t.handlers, e.tagName) && (r = t.handlers[e.tagName]);
  } else
    cl.call(t.handlers, e.type) && (r = t.handlers[e.type]);
  return typeof r == "function" ? r(t, e, n) : EN(t, e);
}
function EN(t, e) {
  return typeof e.value == "string" ? t(e, "text", ot(t, e.value)) : Z(t, e);
}
const yN = {}.hasOwnProperty;
function Ve(t, e) {
  const n = typeof e == "string" && AN(t) && t.type === "element" && t.properties && yN.call(t.properties, e) && t.properties[e];
  return n != null && n !== !1;
}
function AN(t) {
  return Boolean(t && typeof t == "object" && "type" in t);
}
const bN = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function CN(t) {
  if (!Sr(t, "link"))
    return !1;
  if (Ve(t, "itemProp"))
    return !0;
  const n = (t.properties || {}).rel || [];
  let r = -1;
  if (!Array.isArray(n) || n.length === 0)
    return !1;
  for (; ++r < n.length; )
    if (!bN.has(String(n[r])))
      return !1;
  return !0;
}
const xN = Ne([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]), SN = Ne("meta");
function U2(t) {
  return Boolean(
    NN(t) && (t.type === "text" || xN(t) || gf(t) || CN(t) || SN(t) && Ve(t, "itemProp"))
  );
}
function NN(t) {
  return t && typeof t == "object" && "type" in t;
}
const q2 = (
  /** @type {AssertPredicatePhrasing} */
  Es([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function z2(t) {
  return $2(t, e);
  function e(n) {
    const r = n[0];
    return n.length === 1 && r.type === "text" && (r.value === " " || r.value === `
`) ? [] : { type: "paragraph", children: n };
  }
}
function Ul(t) {
  let e = -1, n;
  for (; ++e < t.length; )
    if (n = t[e], !V2(n) || "children" in n && Ul(n.children))
      return !0;
  return !1;
}
function $2(t, e, n) {
  const r = n || ON, i = kN(t);
  let s = [], o = -1, a, l;
  for (; ++o < i.length; )
    l = i[o], V2(l) ? (a || (a = []), a.push(l)) : (a && (s = s.concat(e(a)), a = void 0), s = s.concat(r(l)));
  return a && (s = s.concat(e(a))), s;
}
function kN(t) {
  let e = [], n = -1, r;
  for (; ++n < t.length; )
    r = t[n], (r.type === "delete" || r.type === "link") && Ul(r.children) ? e = e.concat(_N(r)) : e.push(r);
  return e;
}
function _N(t) {
  return $2(t.children, n, e);
  function e(r) {
    if ("children" in r && "children" in t) {
      const { children: i, ...s } = t;
      return {
        ...r,
        // @ts-expect-error: assume matching parent & child.
        children: [{ ...sl(!0, {}, s), children: r.children }]
      };
    }
    return { ...r };
  }
  function n(r) {
    const { children: i, ...s } = t;
    return { ...sl(!0, {}, s), children: r };
  }
}
function V2(t) {
  return t.data && t.data.hName ? U2({
    type: "element",
    tagName: t.data.hName,
    properties: {},
    children: []
  }) : q2(t);
}
function ON(t) {
  return t;
}
function Ie(t, e) {
  return z2(Z(t, e));
}
function pi(t, e) {
  return e == null ? "" : t.frozenBaseUrl ? String(new URL(e, t.frozenBaseUrl)) : e;
}
function wN(t, e) {
  const n = e.properties;
  return t(
    e,
    "link",
    {
      title: n.title || null,
      url: pi(t, String(n.href || "") || null)
    },
    Z(t, e)
  );
}
function vN(t, e) {
  t.baseFound || (t.frozenBaseUrl = String(e.properties && e.properties.href || "") || null, t.baseFound = !0);
}
function DN(t, e) {
  return t(e, "blockquote", Ie(t, e));
}
function MN(t, e) {
  return t.wrapText ? t(e, "break") : t(e, "text", " ");
}
const am = (
  /**
   * @type {(
   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
   * )}
   */
  /**
   * @param {Parent} parent
   * @param {Node | number} index
   * @param {Test} [test]
   * @returns {Node | null}
   */
  function(t, e, n) {
    const r = Es(n);
    if (!t || !t.type || !t.children)
      throw new Error("Expected parent node");
    if (typeof e == "number") {
      if (e < 0 || e === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (e = t.children.indexOf(e), e < 0)
      throw new Error("Expected child node or index");
    for (; ++e < t.children.length; )
      if (r(t.children[e], e, t))
        return t.children[e];
    return null;
  }
), lm = /\n/g, um = /[\t ]+/g, cc = Ne("br"), IN = Ne("p"), cm = Ne(["th", "td"]), fm = Ne("tr"), RN = Ne([
  // List from: <https://html.spec.whatwg.org/#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  FN,
  // From: <https://html.spec.whatwg.org/#flow-content-3>
  HN
]), G2 = Ne([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function wo(t, e = {}) {
  const n = "children" in t ? t.children : [], r = G2(t), i = W2(t, {
    whitespace: e.whitespace || "normal",
    breakBefore: !1,
    breakAfter: !1
  }), s = [];
  (t.type === "text" || t.type === "comment") && s.push(
    ...K2(t, {
      whitespace: i,
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let o = -1;
  for (; ++o < n.length; )
    s.push(
      ...j2(n[o], t, {
        whitespace: i,
        breakBefore: o ? void 0 : r,
        breakAfter: o < n.length - 1 ? cc(n[o + 1]) : r
      })
    );
  const a = [];
  let l;
  for (o = -1; ++o < s.length; ) {
    const u = s[o];
    typeof u == "number" ? l !== void 0 && u > l && (l = u) : u && (l !== void 0 && l > -1 && a.push(`
`.repeat(l) || " "), l = -1, a.push(u));
  }
  return a.join("");
}
function j2(t, e, n) {
  return t.type === "element" ? LN(t, e, n) : t.type === "text" ? n.whitespace === "normal" ? K2(t, n) : PN(t) : [];
}
function LN(t, e, n) {
  const r = W2(t, n), i = t.children || [];
  let s = -1, o = [];
  if (RN(t))
    return o;
  let a, l;
  for (cc(t) || fm(t) && am(e, t, fm) ? l = `
` : IN(t) ? (a = 2, l = 2) : G2(t) && (a = 1, l = 1); ++s < i.length; )
    o = o.concat(
      j2(i[s], t, {
        whitespace: r,
        breakBefore: s ? void 0 : a,
        breakAfter: s < i.length - 1 ? cc(i[s + 1]) : l
      })
    );
  return cm(t) && am(e, t, cm) && o.push("	"), a && o.unshift(a), l && o.push(l), o;
}
function K2(t, e) {
  const n = String(t.value), r = [], i = [];
  let s = 0;
  for (; s <= n.length; ) {
    lm.lastIndex = s;
    const l = lm.exec(n), u = l && "index" in l ? l.index : n.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      BN(
        // […] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        n.slice(s, u).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        s === 0 ? e.breakBefore : !0,
        u === n.length ? e.breakAfter : !0
      )
    ), s = u + 1;
  }
  let o = -1, a;
  for (; ++o < r.length; )
    r[o].charCodeAt(r[o].length - 1) === 8203 || o < r.length - 1 && r[o + 1].charCodeAt(0) === 8203 ? (i.push(r[o]), a = void 0) : r[o] ? (typeof a == "number" && i.push(a), i.push(r[o]), a = 0) : (o === 0 || o === r.length - 1) && i.push(0);
  return i;
}
function PN(t) {
  return [String(t.value)];
}
function BN(t, e, n) {
  const r = [];
  let i = 0, s;
  for (; i < t.length; ) {
    um.lastIndex = i;
    const o = um.exec(t);
    s = o ? o.index : t.length, !i && !s && o && !e && r.push(""), i !== s && r.push(t.slice(i, s)), i = o ? s + o[0].length : s;
  }
  return i !== s && !n && r.push(""), r.join(" ");
}
function W2(t, e) {
  if (t.type === "element") {
    const n = t.properties || {};
    switch (t.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return n.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return n.noWrap ? "nowrap" : e.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return e.whitespace;
}
function FN(t) {
  return Boolean((t.properties || {}).hidden);
}
function HN(t) {
  return t.tagName === "dialog" && !(t.properties || {}).open;
}
function UN(t) {
  const e = String(t);
  let n = e.length;
  for (; n > 0; ) {
    const r = e.codePointAt(n - 1);
    if (r !== void 0 && (r === 10 || r === 13))
      n--;
    else
      break;
  }
  return e.slice(0, n);
}
const nu = "language-", qN = Ne("pre"), zN = Ne("code");
function ia(t, e) {
  const n = e.children;
  let r = -1, i, s;
  if (qN(e))
    for (; ++r < n.length; ) {
      const o = n[r];
      if (zN(o) && o.properties && o.properties.className && Array.isArray(o.properties.className)) {
        i = o.properties.className;
        break;
      }
    }
  if (i) {
    for (r = -1; ++r < i.length; )
      if (String(i[r]).slice(0, nu.length) === nu) {
        s = String(i[r]).slice(nu.length);
        break;
      }
  }
  return t(
    e,
    "code",
    { lang: s || null, meta: null },
    UN(ot(t, wo(e)))
  );
}
function $N(t, e) {
  return t(e, "html", "<!--" + ot(t, e.value) + "-->");
}
function ru(t, e) {
  return t(e, "delete", Z(t, e));
}
function yf(t) {
  let e = -1;
  if (t.length > 1) {
    for (; ++e < t.length; )
      if (t[e].spread)
        return !0;
  }
  return !1;
}
function Y2(t, e) {
  const n = Z(t, e);
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    i.type !== "listItem" && (n[r] = {
      type: "listItem",
      spread: !1,
      checked: null,
      // @ts-expect-error Assume `children[index]` is block content.
      children: [i]
    });
  }
  return n;
}
const VN = Ne("div"), GN = Ne("dt"), jN = Ne("dd");
function KN(t, e) {
  const n = e.children;
  let r = -1, i = [];
  const s = [];
  let o = { titles: [], definitions: [] }, a, l;
  for (; ++r < n.length; )
    a = n[r], i = i.concat(VN(a) ? a.children : a);
  for (r = -1; ++r < i.length; )
    a = i[r], GN(a) ? (jN(i[r - 1]) && (s.push(o), o = { titles: [], definitions: [] }), o.titles.push(a)) : o.definitions.push(a);
  s.push(o), r = -1;
  const u = [];
  for (; ++r < s.length; )
    l = [
      ...dm(t, s[r].titles),
      ...dm(t, s[r].definitions)
    ], l.length > 0 && u.push({
      type: "listItem",
      spread: l.length > 1,
      checked: null,
      children: l
    });
  if (u.length > 0)
    return t(
      e,
      "list",
      { ordered: !1, start: null, spread: yf(u) },
      u
    );
}
function dm(t, e) {
  const n = Y2(t, { type: "element", tagName: "x", children: e });
  return n.length === 0 ? [] : n.length === 1 ? n[0].children : [
    {
      type: "list",
      ordered: !1,
      start: null,
      spread: yf(n),
      children: n
    }
  ];
}
function sa(t, e) {
  return t(e, "emphasis", Z(t, e));
}
function Di(t, e) {
  const n = Number(e.tagName.charAt(1)) || 1, r = t.wrapText;
  t.wrapText = !1;
  const i = t(e, "heading", { depth: n }, Z(t, e));
  return t.wrapText = r, i;
}
function WN(t, e) {
  return t(e, "thematicBreak");
}
function YN(t, e) {
  const n = e.properties, r = String(n.src || ""), i = String(n.title || "");
  if (r && i)
    return {
      type: "link",
      title: null,
      url: pi(t, r),
      children: [{ type: "text", value: ot(t, i) }]
    };
}
function hm(t, e) {
  const n = e.properties;
  return t(e, "image", {
    url: pi(t, String(n.src || "") || null),
    title: n.title || null,
    alt: n.alt || ""
  });
}
function Rs(t, e) {
  return t(e, "inlineCode", ot(t, wo(e)));
}
const QN = Ne("option");
function Q2(t, e, n) {
  const r = n || e.properties;
  let i = J2(e);
  const s = Math.min(Number.parseInt(String(r.size), 10), 0) || (r.multiple ? 4 : 1);
  let o = -1;
  const a = [], l = [];
  for (; ++o < i.length; )
    Ve(i[o], "selected") && a.push(i[o]);
  for (i = (a.length > 0 ? a : i).slice(0, s), o = -1; ++o < i.length; ) {
    const c = i[o], f = ot(t, wo(c)), d = c.properties, h = f || String(d.label || ""), m = String(d.value || "") || f;
    l.push([m, h === m ? null : h]);
  }
  return l;
}
function J2(t) {
  const e = t.children;
  let n = -1, r = [], i;
  for (; ++n < e.length; )
    i = e[n], Array.isArray(i.children) && (r = r.concat(J2(i))), QN(i) && !Ve(i, "disabled") && r.push(i);
  return r;
}
const JN = Ne("datalist");
function XN(t, e) {
  const n = e.properties;
  let r = String(n.value || n.placeholder || "");
  const i = [], s = [];
  let o = [], a = -1, l;
  if (!(n.disabled || n.type === "hidden" || n.type === "file")) {
    if (n.type === "checkbox" || n.type === "radio")
      return t(
        e,
        "text",
        ot(t, t[n.checked ? "checked" : "unchecked"])
      );
    if (n.type === "image")
      return n.alt || r ? t(e, "image", {
        url: pi(t, String(n.src || "") || null),
        title: ot(t, String(n.title || "")) || null,
        alt: ot(t, String(n.alt || r))
      }) : [];
    if (r ? o = [[r, null]] : (
      // `list` is not supported on these types:
      n.type !== "password" && n.type !== "file" && n.type !== "submit" && n.type !== "reset" && n.type !== "button" && n.list && (l = String(n.list).toUpperCase(), cl.call(t.nodeById, l) && JN(t.nodeById[l]) && (o = Q2(t, t.nodeById[l], n)))
    ), o.length !== 0) {
      if (n.type === "password" && (o[0] = ["•".repeat(o[0][0].length), null]), n.type === "url" || n.type === "email") {
        for (; ++a < o.length; )
          r = pi(t, o[a][0]), i.push(
            t(
              e,
              "link",
              {
                title: null,
                url: ot(t, n.type === "email" ? "mailto:" + r : r)
              },
              [{ type: "text", value: ot(t, o[a][1] || r) }]
            )
          ), a !== o.length - 1 && i.push({ type: "text", value: ", " });
        return i;
      }
      for (; ++a < o.length; )
        s.push(
          o[a][1] ? o[a][1] + " (" + o[a][0] + ")" : o[a][0]
        );
      return t(e, "text", ot(t, s.join(", ")));
    }
  }
}
const ZN = Ne("p"), ek = Ne("input");
function iu(t, e) {
  const n = e.children[0];
  let r = null, i, s;
  ZN(n) && (i = n.children[0], ek(i) && i.properties && (i.properties.type === "checkbox" || i.properties.type === "radio") && (r = Boolean(i.properties.checked), s = {
    ...e,
    children: [
      { ...n, children: n.children.slice(1) },
      ...e.children.slice(1)
    ]
  }));
  const o = Ie(t, s || e);
  return t(e, "listItem", { spread: o.length > 1, checked: r }, o);
}
const tk = Ne("ol");
function su(t, e) {
  const n = tk(e), r = Y2(t, e);
  let i = null;
  return n && (i = Ve(e, "start") ? (
    // @ts-expect-error: `props` exist.
    Number.parseInt(String(e.properties.start), 10)
  ) : 1), t(
    e,
    "list",
    { ordered: n, start: i, spread: yf(r) },
    r
  );
}
function ql(t, e) {
  const n = (e || {}).includeImageAlt;
  return X2(
    t,
    typeof n == "boolean" ? n : !0
  );
}
function X2(t, e) {
  return nk(t) && ("value" in t && t.value || e && "alt" in t && t.alt || "children" in t && pm(t.children, e)) || Array.isArray(t) && pm(t, e) || "";
}
function pm(t, e) {
  const n = [];
  let r = -1;
  for (; ++r < t.length; )
    n[r] = X2(t[r], e);
  return n.join("");
}
function nk(t) {
  return Boolean(t && typeof t == "object");
}
const rk = Ne("source"), ik = Ne("video");
function mm(t, e) {
  let n = Z(t, e);
  const r = e.properties, i = ik(e) && String(r.poster || "");
  let s = String(r.src || ""), o = -1, a = !1, l;
  if (Jt({ type: "root", children: n }, "link", u), a || Ul(n))
    return n;
  for (; !s && ++o < e.children.length; )
    l = e.children[o], rk(l) && (s = String(l.properties.src || ""));
  return i && (n = [
    {
      type: "image",
      title: null,
      url: pi(t, i),
      alt: ql({ children: n })
    }
  ]), {
    type: "link",
    // @ts-expect-error Types are broken.
    title: e.properties.title || null,
    url: pi(t, s),
    // @ts-expect-error Assume phrasing content.
    children: n
  };
  function u() {
    return a = !0, Ao;
  }
}
function gm(t, e) {
  const n = Z(t, e);
  if (n.length > 0)
    return t(e, "paragraph", n);
}
function sk(t, e) {
  const n = t.quotes[t.qNesting % t.quotes.length];
  t.qNesting++;
  const r = Z(t, e);
  return t.qNesting--, r.unshift({ type: "text", value: n.charAt(0) }), r.push({
    type: "text",
    value: n.length > 1 ? n.charAt(1) : n
  }), r;
}
function ok(t, e) {
  let n = Z(t, e);
  return (t.document || Ul(n)) && (n = z2(n)), t(e, "root", n);
}
function ak(t, e) {
  const n = Q2(t, e);
  let r = -1;
  const i = [];
  let s;
  for (; ++r < n.length; )
    s = n[r], i.push(s[1] ? s[1] + " (" + s[0] + ")" : s[0]);
  if (i.length > 0)
    return t(e, "text", ot(t, i.join(", ")));
}
function Tm(t, e) {
  return t(e, "strong", Z(t, e));
}
function Em(t, e) {
  const n = t.wrapText;
  t.wrapText = !1;
  const r = t(e, "tableCell", Z(t, e));
  if (e.properties && (e.properties.rowSpan || e.properties.colSpan)) {
    const i = r.data || (r.data = {});
    e.properties.rowSpan && (i.rowSpan = e.properties.rowSpan), e.properties.colSpan && (i.colSpan = e.properties.colSpan);
  }
  return t.wrapText = n, r;
}
function lk(t, e) {
  return t(e, "tableRow", Z(t, e));
}
const uk = Ne("thead"), ck = Ne("tr"), fk = Ne(["th", "td"]);
function dk(t, e) {
  if (t.inTable)
    return t(e, "text", ot(t, wo(e)));
  t.inTable = !0;
  const { headless: n, align: r } = hk(e), i = pk(Z(t, e), n);
  let s = 1, o = -1;
  for (; ++o < i.length; ) {
    const l = i[o].children;
    let u = -1;
    for (; ++u < l.length; ) {
      const c = l[u];
      if (c.data) {
        const f = Number.parseInt(String(c.data.colSpan), 10) || 1, d = Number.parseInt(String(c.data.rowSpan), 10) || 1;
        if (f > 1 || d > 1) {
          let h = o - 1;
          for (; ++h < o + d; ) {
            let m = u - 1;
            for (; ++m < u + f && i[h]; ) {
              const g = [];
              (h !== o || m !== u) && g.push({ type: "tableCell", children: [] }), i[h].children.splice(m, 0, ...g);
            }
          }
        }
        "colSpan" in c.data && delete c.data.colSpan, "rowSpan" in c.data && delete c.data.rowSpan, Object.keys(c.data).length === 0 && delete c.data;
      }
    }
    l.length > s && (s = l.length);
  }
  for (o = -1; ++o < i.length; ) {
    const l = i[o].children;
    let u = l.length - 1;
    for (; ++u < s; )
      l.push({ type: "tableCell", children: [] });
  }
  let a = r.length - 1;
  for (; ++a < s; )
    r.push(null);
  return t.inTable = !1, t(e, "table", { align: r }, i);
}
function hk(t) {
  let e = !0, n = 0, r = 0;
  const i = [null];
  return Jt(t, "element", (s) => {
    if (s.tagName === "table" && t !== s)
      return Hl;
    fk(s) && s.properties ? (i[r] || (i[r] = String(s.properties.align || "") || null), e && n < 2 && s.tagName === "th" && (e = !1), r++) : uk(s) ? e = !1 : ck(s) && (n++, r = 0);
  }), { align: i, headless: e };
}
function pk(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (e && r.push({ type: "tableRow", children: [] }); ++n < t.length; ) {
    const s = t[n];
    s.type === "tableRow" ? (i && (s.children.unshift(...i), i = void 0), r.push(s)) : (i || (i = []), i.push(s));
  }
  for (i && r[r.length - 1].children.push(...i), n = -1; ++n < r.length; )
    r[n].children = mk(r[n].children);
  return r;
}
function mk(t) {
  const e = [];
  let n = -1, r, i;
  for (; ++n < t.length; )
    r = t[n], r.type === "tableCell" ? (i && (r.children.unshift(...i), i = void 0), e.push(r)) : (i || (i = []), i.push(r));
  return i && (r = e[e.length - 1], r || (r = { type: "tableCell", children: [] }, e.push(r)), r.children.push(...i)), e;
}
function gk(t, e) {
  return t(e, "text", ot(t, e.value));
}
function Tk(t, e) {
  return t(e, "text", ot(t, wo(e)));
}
function Ek(t, e) {
  return t(e, "text", "​");
}
const ym = {
  root: ok,
  text: gk,
  comment: $N,
  doctype: fe,
  applet: fe,
  area: fe,
  basefont: fe,
  bgsound: fe,
  caption: fe,
  col: fe,
  colgroup: fe,
  command: fe,
  content: fe,
  datalist: fe,
  dialog: fe,
  element: fe,
  embed: fe,
  frame: fe,
  frameset: fe,
  isindex: fe,
  keygen: fe,
  link: fe,
  math: fe,
  menu: fe,
  menuitem: fe,
  meta: fe,
  nextid: fe,
  noembed: fe,
  noframes: fe,
  optgroup: fe,
  option: fe,
  param: fe,
  script: fe,
  shadow: fe,
  source: fe,
  spacer: fe,
  style: fe,
  svg: fe,
  template: fe,
  title: fe,
  track: fe,
  abbr: Z,
  acronym: Z,
  bdi: Z,
  bdo: Z,
  big: Z,
  blink: Z,
  button: Z,
  canvas: Z,
  cite: Z,
  data: Z,
  details: Z,
  dfn: Z,
  font: Z,
  ins: Z,
  label: Z,
  map: Z,
  marquee: Z,
  meter: Z,
  nobr: Z,
  noscript: Z,
  object: Z,
  output: Z,
  progress: Z,
  rb: Z,
  rbc: Z,
  rp: Z,
  rt: Z,
  rtc: Z,
  ruby: Z,
  slot: Z,
  small: Z,
  span: Z,
  sup: Z,
  sub: Z,
  tbody: Z,
  tfoot: Z,
  thead: Z,
  time: Z,
  address: Ie,
  article: Ie,
  aside: Ie,
  body: Ie,
  center: Ie,
  div: Ie,
  fieldset: Ie,
  figcaption: Ie,
  figure: Ie,
  form: Ie,
  footer: Ie,
  header: Ie,
  hgroup: Ie,
  html: Ie,
  legend: Ie,
  main: Ie,
  multicol: Ie,
  nav: Ie,
  picture: Ie,
  section: Ie,
  a: wN,
  audio: mm,
  b: Tm,
  base: vN,
  blockquote: DN,
  br: MN,
  code: Rs,
  dir: su,
  dl: KN,
  dt: iu,
  dd: iu,
  del: ru,
  em: sa,
  h1: Di,
  h2: Di,
  h3: Di,
  h4: Di,
  h5: Di,
  h6: Di,
  hr: WN,
  i: sa,
  iframe: YN,
  img: hm,
  image: hm,
  input: XN,
  kbd: Rs,
  li: iu,
  listing: ia,
  mark: sa,
  ol: su,
  p: gm,
  plaintext: ia,
  pre: ia,
  q: sk,
  s: ru,
  samp: Rs,
  select: ak,
  strike: ru,
  strong: Tm,
  summary: gm,
  table: dk,
  td: Em,
  textarea: Tk,
  th: Em,
  tr: lk,
  tt: Rs,
  u: sa,
  ul: su,
  var: Rs,
  video: mm,
  wbr: Ek,
  xmp: ia
};
function fe() {
}
const yk = Es(["heading", "paragraph", "root"]);
function Z2(t, e = {}) {
  const n = {};
  let r;
  const i = Object.assign(
    /**
     * @type {HWithProps & HWithoutProps}
     */
    /**
     * @param {Node} node
     * @param {string} type
     * @param {Properties|string|Array<Node>} [props]
     * @param {string|Array<Node>} [children]
     */
    (a, l, u, c) => {
      let f;
      typeof u == "string" || Array.isArray(u) ? (c = u, f = {}) : f = u;
      const d = { type: l, ...f };
      return typeof c == "string" ? d.value = c : c && (d.children = c), a.position && (d.position = a.position), d;
    },
    {
      nodeById: n,
      baseFound: !1,
      inTable: !1,
      wrapText: !0,
      /** @type {string|null} */
      frozenBaseUrl: null,
      qNesting: 0,
      handlers: e.handlers ? { ...ym, ...e.handlers } : ym,
      document: e.document,
      checked: e.checked || "[x]",
      unchecked: e.unchecked || "[ ]",
      quotes: e.quotes || ['"']
    }
  );
  Jt(t, "element", (a) => {
    const l = a.properties && "id" in a.properties && String(a.properties.id).toUpperCase();
    l && !cl.call(n, l) && (n[l] = a);
  }), R2({ newlines: e.newlines === !0 })(t);
  const s = H2(i, t, void 0);
  return s ? Array.isArray(s) ? r = { type: "root", children: s } : r = s : r = { type: "root", children: [] }, Jt(r, "text", o), r;
  function o(a, l, u) {
    if (l === null || !u)
      return;
    const c = u.children[l - 1];
    if (c && c.type === a.type)
      return c.value += a.value, u.children.splice(l, 1), c.position && a.position && (c.position.end = a.position.end), l - 1;
    if (a.value = a.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1"), u && yk(u) && (l || (a.value = a.value.replace(/^[\t ]+/, "")), l === u.children.length - 1 && (a.value = a.value.replace(/[\t ]+$/, ""))), !a.value)
      return u.children.splice(l, 1), l;
  }
}
const Ak = (
  /**
   * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}
   */
  /**
   * @param {Processor|Options} [destination]
   * @param {Options} [options]
   */
  function(t, e) {
    let n, r;
    return typeof t == "function" ? (r = t, n = e || {}) : n = t || {}, (n.document === void 0 || n.document === null) && (n = Object.assign({}, n, { document: !0 })), r ? Ck(r, n) : xk(n);
  }
), bk = Ak;
function Ck(t, e) {
  return (n, r, i) => {
    t.run(Z2(n, e), r, (s) => {
      i(s);
    });
  };
}
function xk(t = {}) {
  return (e) => (
    /** @type {MdastRoot} */
    Z2(e, t)
  );
}
const Am = {}.hasOwnProperty;
function ys(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const a = r.handlers;
    if (i && Am.call(i, t)) {
      const l = String(i[t]);
      o = Am.call(a, l) ? a[l] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function Aa(t, e) {
  let n = -1, r;
  if (e.extensions)
    for (; ++n < e.extensions.length; )
      Aa(t, e.extensions[n]);
  for (r in e)
    r === "extensions" || (r === "unsafe" || r === "join" ? t[r] = [...t[r] || [], ...e[r] || []] : r === "handlers" ? t[r] = Object.assign(t[r], e[r] || {}) : t.options[r] = e[r]);
  return t;
}
function Sk(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const o = n.indentLines(
    n.containerFlow(t, s.current()),
    Nk
  );
  return i(), o;
}
function Nk(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function e5(t, e) {
  return bm(t, e.inConstruct, !0) && !bm(t, e.notInConstruct, !1);
}
function bm(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function Cm(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && e5(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function kk(t, e) {
  const n = String(t);
  let r = n.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = n.indexOf(e, i);
  return o;
}
function fc(t, e) {
  return Boolean(
    !e.options.fences && t.value && // If there’s no info…
    !t.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(t.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value)
  );
}
function _k(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function Ok(t, e, n, r) {
  const i = _k(n), s = t.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (fc(t, n)) {
    const f = n.enter("codeIndented"), d = n.indentLines(s, wk);
    return f(), d;
  }
  const a = n.createTracker(r), l = i.repeat(Math.max(kk(s, i) + 1, 3)), u = n.enter("codeFenced");
  let c = a.move(l);
  if (t.lang) {
    const f = n.enter(`codeFencedLang${o}`);
    c += a.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  if (t.lang && t.meta) {
    const f = n.enter(`codeFencedMeta${o}`);
    c += a.move(" "), c += a.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), f();
  }
  return c += a.move(`
`), s && (c += a.move(s + `
`)), c += a.move(l), u(), c;
}
function wk(t, e, n) {
  return (n ? "" : "    ") + t;
}
function zl(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function vk(t, e, n, r) {
  const i = zl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("[");
  return u += l.move(
    n.safe(n.associationId(t), {
      before: u,
      after: "]",
      ...l.current()
    })
  ), u += l.move("]: "), a(), // If there’s no url, or…
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(t.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (a = n.enter("destinationRaw"), u += l.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : `
`,
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${s}`), u += l.move(" " + i), u += l.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), a()), o(), u;
}
function Dk(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
t5.peek = Mk;
function t5(t, e, n, r) {
  const i = Dk(n), s = n.enter("emphasis"), o = n.createTracker(r);
  let a = o.move(i);
  return a += o.move(
    n.containerPhrasing(t, {
      before: a,
      after: i,
      ...o.current()
    })
  ), a += o.move(i), s(), a;
}
function Mk(t, e, n) {
  return n.options.emphasis || "*";
}
function n5(t, e) {
  let n = !1;
  return Jt(t, (r) => {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Ao;
  }), Boolean(
    (!t.depth || t.depth < 3) && ql(t) && (e.options.setext || n)
  );
}
function Ik(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (n5(t, n)) {
    const c = n.enter("headingSetext"), f = n.enter("phrasing"), d = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return f(), c(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), a = n.enter("headingAtx"), l = n.enter("phrasing");
  s.move(o + " ");
  let u = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)), u = u ? o + " " + u : o, n.options.closeAtx && (u += " " + o), l(), a(), u;
}
r5.peek = Rk;
function r5(t) {
  return t.value || "";
}
function Rk() {
  return "<";
}
i5.peek = Lk;
function i5(t, e, n, r) {
  const i = zl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("![");
  return u += l.move(
    n.safe(t.alt, { before: u, after: "]", ...l.current() })
  ), u += l.move("]("), a(), // If there’s no url but there is a title…
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (a = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(t.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (a = n.enter("destinationRaw"), u += l.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : ")",
      ...l.current()
    })
  )), a(), t.title && (a = n.enter(`title${s}`), u += l.move(" " + i), u += l.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), a()), u += l.move(")"), o(), u;
}
function Lk() {
  return "!";
}
s5.peek = Pk;
function s5(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const u = n.safe(t.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(u + "]["), o();
  const c = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = c, s(), i === "full" || !u || u !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function Pk() {
  return "!";
}
function o5(t) {
  if (!t._compiled) {
    const e = (t.atBreak ? "[\\r\\n][\\t ]*" : "") + (t.before ? "(?:" + t.before + ")" : "");
    t._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(t.character) ? "\\" : "") + t.character + (t.after ? "(?:" + t.after + ")" : ""),
      "g"
    );
  }
  return t._compiled;
}
a5.peek = Bk;
function a5(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const o = n.unsafe[s], a = o5(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let u = l.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function Bk() {
  return "`";
}
function l5(t, e) {
  const n = ql(t);
  return Boolean(
    !e.options.resourceLink && // If there’s a url…
    t.url && // And there’s a no title…
    !t.title && // And the content of `node` is a single text node…
    t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content…
    (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(t.url)
  );
}
u5.peek = Fk;
function u5(t, e, n, r) {
  const i = zl(n), s = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let a, l;
  if (l5(t, n)) {
    const c = n.stack;
    n.stack = [], a = n.enter("autolink");
    let f = o.move("<");
    return f += o.move(
      n.containerPhrasing(t, {
        before: f,
        after: ">",
        ...o.current()
      })
    ), f += o.move(">"), a(), n.stack = c, f;
  }
  a = n.enter("link"), l = n.enter("label");
  let u = o.move("[");
  return u += o.move(
    n.containerPhrasing(t, {
      before: u,
      after: "](",
      ...o.current()
    })
  ), u += o.move("]("), l(), // If there’s no url but there is a title…
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (l = n.enter("destinationLiteral"), u += o.move("<"), u += o.move(
    n.safe(t.url, { before: u, after: ">", ...o.current() })
  ), u += o.move(">")) : (l = n.enter("destinationRaw"), u += o.move(
    n.safe(t.url, {
      before: u,
      after: t.title ? " " : ")",
      ...o.current()
    })
  )), l(), t.title && (l = n.enter(`title${s}`), u += o.move(" " + i), u += o.move(
    n.safe(t.title, {
      before: u,
      after: i,
      ...o.current()
    })
  ), u += o.move(i), l()), u += o.move(")"), a(), u;
}
function Fk(t, e, n) {
  return l5(t, n) ? "<" : "[";
}
c5.peek = Hk;
function c5(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let o = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const u = n.containerPhrasing(t, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(u + "]["), o();
  const c = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(t), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), n.stack = c, s(), i === "full" || !u || u !== f ? l += a.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function Hk() {
  return "[";
}
function Af(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function Uk(t) {
  const e = Af(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function f5(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function qk(t) {
  const e = f5(t), n = t.options.bulletOrderedOther;
  if (!n)
    return e === "." ? ")" : ".";
  if (n !== "." && n !== ")")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bulletOrdered` (`" + e + "`) and `bulletOrderedOther` (`" + n + "`) to be different"
    );
  return n;
}
function d5(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function zk(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let o = t.ordered ? f5(n) : Af(n);
  const a = t.ordered ? qk(n) : Uk(n), l = n.bulletLastUsed;
  let u = !1;
  if (e && // Explicit `other` set.
  (t.ordered ? n.options.bulletOrderedOther : n.options.bulletOther) && l && o === l && (u = !0), !t.ordered) {
    const f = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), d5(n) === o && f
    ) {
      let d = -1;
      for (; ++d < t.children.length; ) {
        const h = t.children[d];
        if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (o = a), n.bulletCurrent = o;
  const c = n.containerFlow(t, r);
  return n.bulletLastUsed = o, n.bulletCurrent = s, i(), c;
}
function $k(t) {
  const e = t.options.listItemIndent || "tab";
  if (e === 1 || e === "1")
    return "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function Vk(t, e, n, r) {
  const i = $k(n);
  let s = n.bulletCurrent || Af(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = n.createTracker(r);
  a.move(s + " ".repeat(o - s.length)), a.shift(o);
  const l = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(t, a.current()),
    c
  );
  return l(), u;
  function c(f, d, h) {
    return d ? (h ? "" : " ".repeat(o)) + f : (h ? s : s + " ".repeat(o - s.length)) + f;
  }
}
function Gk(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), o = n.containerPhrasing(t, r);
  return s(), i(), o;
}
function jk(t, e, n, r) {
  return (t.children.some((o) => q2(o)) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function Kk(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
h5.peek = Wk;
function h5(t, e, n, r) {
  const i = Kk(n), s = n.enter("strong"), o = n.createTracker(r);
  let a = o.move(i + i);
  return a += o.move(
    n.containerPhrasing(t, {
      before: a,
      after: i,
      ...o.current()
    })
  ), a += o.move(i + i), s(), a;
}
function Wk(t, e, n) {
  return n.options.strong || "*";
}
function Yk(t, e, n, r) {
  return n.safe(t.value, r);
}
function Qk(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function Jk(t, e, n) {
  const r = (d5(n) + (n.options.ruleSpaces ? " " : "")).repeat(Qk(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Xk = {
  blockquote: Sk,
  break: Cm,
  code: Ok,
  definition: vk,
  emphasis: t5,
  hardBreak: Cm,
  heading: Ik,
  html: r5,
  image: i5,
  imageReference: s5,
  inlineCode: a5,
  link: u5,
  linkReference: c5,
  list: zk,
  listItem: Vk,
  paragraph: Gk,
  root: jk,
  strong: h5,
  text: Yk,
  thematicBreak: Jk
}, Zk = [e_];
function e_(t, e, n, r) {
  if (e.type === "code" && fc(e, r) && (t.type === "list" || t.type === e.type && fc(t, r)) || t.type === "list" && t.type === e.type && Boolean(t.ordered) === Boolean(e.ordered) && !(t.ordered ? r.options.bulletOrderedOther : r.options.bulletOther))
    return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return t.type === "paragraph" && // Two paragraphs.
    (t.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && n5(e, r)) ? void 0 : n.spread ? 1 : 0;
}
const Gr = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], t_ = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: Gr
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: Gr
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: Gr },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: Gr
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: Gr },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: Gr },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: Gr },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
], xm = document.createElement("i");
function bo(t) {
  const e = "&" + t + ";";
  xm.innerHTML = e;
  const n = xm.textContent;
  return n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n;
}
function p5(t, e) {
  const n = Number.parseInt(t, e);
  return (
    // C0 except for HT, LF, FF, CR, space
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of the basic block and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || // Out of range
    n > 1114111 ? "�" : String.fromCharCode(n)
  );
}
const n_ = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function m5(t) {
  return t.replace(n_, r_);
}
function r_(t, e, n) {
  if (e)
    return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), s = i === 120 || i === 88;
    return p5(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return bo(n) || t;
}
function i_(t) {
  return t.label || !t.identifier ? t.label || "" : m5(t.identifier);
}
function bf(t, e, n) {
  const r = e.indexStack, i = t.children || [], s = [];
  let o = -1, a = n.before;
  r.push(-1);
  let l = e.createTracker(n);
  for (; ++o < i.length; ) {
    const u = i[o];
    let c;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let f = e.handle.handlers[i[o + 1].type];
      f && f.peek && (f = f.peek), c = f ? f(i[o + 1], t, e, {
        before: "",
        after: "",
        ...l.current()
      }).charAt(0) : "";
    } else
      c = n.after;
    s.length > 0 && (a === "\r" || a === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), a = " ", l = e.createTracker(n), l.move(s.join(""))), s.push(
      l.move(
        e.handle(u, t, e, {
          ...l.current(),
          before: a,
          after: c
        })
      )
    ), a = s[s.length - 1].slice(-1);
  }
  return r.pop(), s.join("");
}
function g5(t, e, n) {
  const r = e.indexStack, i = t.children || [], s = e.createTracker(n), o = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const l = i[a];
    r[r.length - 1] = a, o.push(
      s.move(
        e.handle(l, t, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), l.type !== "list" && (e.bulletLastUsed = void 0), a < i.length - 1 && o.push(
      s.move(s_(l, i[a + 1], t, e))
    );
  }
  return r.pop(), o.join("");
}
function s_(t, e, n, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](t, e, n, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const o_ = /\r?\n|\r/g;
function a_(t, e) {
  const n = [];
  let r = 0, i = 0, s;
  for (; s = o_.exec(t); )
    o(t.slice(r, s.index)), n.push(s[0]), r = s.index + s[0].length, i++;
  return o(t.slice(r)), n.join("");
  function o(a) {
    n.push(e(a, i, !a));
  }
}
function l_(t, e, n) {
  const r = (n.before || "") + (e || "") + (n.after || ""), i = [], s = [], o = {};
  let a = -1;
  for (; ++a < t.unsafe.length; ) {
    const c = t.unsafe[a];
    if (!e5(t.stack, c))
      continue;
    const f = o5(c);
    let d;
    for (; d = f.exec(r); ) {
      const h = "before" in c || Boolean(c.atBreak), m = "after" in c, g = d.index + (h ? d[1].length : 0);
      i.includes(g) ? (o[g].before && !h && (o[g].before = !1), o[g].after && !m && (o[g].after = !1)) : (i.push(g), o[g] = { before: h, after: m });
    }
  }
  i.sort(u_);
  let l = n.before ? n.before.length : 0;
  const u = r.length - (n.after ? n.after.length : 0);
  for (a = -1; ++a < i.length; ) {
    const c = i[a];
    c < l || c >= u || c + 1 < u && i[a + 1] === c + 1 && o[c].after && !o[c + 1].before && !o[c + 1].after || i[a - 1] === c - 1 && o[c].before && !o[c - 1].before && !o[c - 1].after || (l !== c && s.push(Sm(r.slice(l, c), "\\")), l = c, /[!-/:-@[-`{-~]/.test(r.charAt(c)) && (!n.encode || !n.encode.includes(r.charAt(c))) ? s.push("\\") : (s.push(
      "&#x" + r.charCodeAt(c).toString(16).toUpperCase() + ";"
    ), l++));
  }
  return s.push(Sm(r.slice(l, u), n.after)), s.join("");
}
function u_(t, e) {
  return t - e;
}
function Sm(t, e) {
  const n = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = t + e;
  let o = -1, a = 0, l;
  for (; l = n.exec(s); )
    r.push(l.index);
  for (; ++o < r.length; )
    a !== r[o] && i.push(t.slice(a, r[o])), i.push("\\"), a = r[o];
  return i.push(t.slice(a)), i.join("");
}
function Cf(t) {
  const e = t || {}, n = e.now || {};
  let r = e.lineShift || 0, i = n.line || 1, s = n.column || 1;
  return { move: l, current: o, shift: a };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function a(u) {
    r += u;
  }
  function l(u) {
    const c = u || "", f = c.split(/\r?\n|\r/g), d = f[f.length - 1];
    return i += f.length - 1, s = f.length === 1 ? s + d.length : 1 + d.length + r, c;
  }
}
function c_(t, e = {}) {
  const n = {
    enter: i,
    indentLines: a_,
    associationId: i_,
    containerPhrasing: p_,
    containerFlow: m_,
    createTracker: Cf,
    safe: g_,
    stack: [],
    unsafe: [],
    join: [],
    // @ts-expect-error: we’ll fill it next.
    handlers: {},
    options: {},
    indexStack: [],
    // @ts-expect-error: we’ll add `handle` later.
    handle: void 0
  };
  Aa(n, { unsafe: t_, join: Zk, handlers: Xk }), Aa(n, e), n.options.tightDefinitions && Aa(n, { join: [h_] }), n.handle = ys("type", {
    invalid: f_,
    unknown: d_,
    handlers: n.handlers
  });
  let r = n.handle(t, void 0, n, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return r && r.charCodeAt(r.length - 1) !== 10 && r.charCodeAt(r.length - 1) !== 13 && (r += `
`), r;
  function i(s) {
    return n.stack.push(s), o;
    function o() {
      n.stack.pop();
    }
  }
}
function f_(t) {
  throw new Error("Cannot handle value `" + t + "`, expected node");
}
function d_(t) {
  throw new Error("Cannot handle unknown node `" + t.type + "`");
}
function h_(t, e) {
  if (t.type === "definition" && t.type === e.type)
    return 0;
}
function p_(t, e) {
  return bf(t, this, e);
}
function m_(t, e) {
  return g5(t, this, e);
}
function g_(t, e) {
  return l_(this, t, e);
}
function T_(t) {
  Object.assign(this, { Compiler: (n) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return c_(
      n,
      Object.assign({}, r, t, {
        // Note: this option is not in the readme.
        // The goal is for it to be set by plugins on `data` instead of being
        // passed by users.
        extensions: (
          /** @type {ToMarkdownOptions['extensions']} */
          this.data("toMarkdownExtensions") || []
        )
      })
    );
  } });
}
function Pt(t, e, n, r) {
  const i = t.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, n), [].splice.apply(t, o);
  else
    for (n && [].splice.apply(t, [e, n]); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), [].splice.apply(t, o), s += 1e4, e += 1e4;
}
function $t(t, e) {
  return t.length > 0 ? (Pt(t, t.length, 0, e), t) : e;
}
const Nm = {}.hasOwnProperty;
function T5(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    E_(e, t[n]);
  return e;
}
function E_(t, e) {
  let n;
  for (n in e) {
    const i = (Nm.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let o;
    for (o in s) {
      Nm.call(i, o) || (i[o] = []);
      const a = s[o];
      y_(
        // @ts-expect-error Looks like a list.
        i[o],
        Array.isArray(a) ? a : a ? [a] : []
      );
    }
  }
}
function y_(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  Pt(t, 0, 0, r);
}
const A_ = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, jt = Ir(/[A-Za-z]/), dc = Ir(/\d/), b_ = Ir(/[\dA-Fa-f]/), dt = Ir(/[\dA-Za-z]/), C_ = Ir(/[!-/:-@[-`{-~]/), km = Ir(/[#-'*+\--9=?A-Z^-~]/);
function hc(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
function ze(t) {
  return t !== null && (t < 0 || t === 32);
}
function ee(t) {
  return t !== null && t < -2;
}
function De(t) {
  return t === -2 || t === -1 || t === 32;
}
const x_ = Ir(/\s/), S_ = Ir(A_);
function Ir(t) {
  return e;
  function e(n) {
    return n !== null && t.test(String.fromCharCode(n));
  }
}
function fl(t) {
  if (t === null || ze(t) || x_(t))
    return 1;
  if (S_(t))
    return 2;
}
function $l(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
function N_(t = {}) {
  let e = t.singleTilde;
  const n = {
    tokenize: i,
    resolveAll: r
  };
  return e == null && (e = !0), {
    text: {
      [126]: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(s, o) {
    let a = -1;
    for (; ++a < s.length; )
      if (s[a][0] === "enter" && s[a][1].type === "strikethroughSequenceTemporary" && s[a][1]._close) {
        let l = a;
        for (; l--; )
          if (s[l][0] === "exit" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._open && // If the sizes are the same:
          s[a][1].end.offset - s[a][1].start.offset === s[l][1].end.offset - s[l][1].start.offset) {
            s[a][1].type = "strikethroughSequence", s[l][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, s[l][1].start),
              end: Object.assign({}, s[a][1].end)
            }, c = {
              type: "strikethroughText",
              start: Object.assign({}, s[l][1].end),
              end: Object.assign({}, s[a][1].start)
            }, f = [
              ["enter", u, o],
              ["enter", s[l][1], o],
              ["exit", s[l][1], o],
              ["enter", c, o]
            ];
            Pt(
              f,
              f.length,
              0,
              $l(
                o.parser.constructs.insideSpan.null,
                s.slice(l + 1, a),
                o
              )
            ), Pt(f, f.length, 0, [
              ["exit", c, o],
              ["enter", s[a][1], o],
              ["exit", s[a][1], o],
              ["exit", u, o]
            ]), Pt(s, l - 1, a - l + 3, f), a = l + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < s.length; )
      s[a][1].type === "strikethroughSequenceTemporary" && (s[a][1].type = "data");
    return s;
  }
  function i(s, o, a) {
    const l = this.previous, u = this.events;
    let c = 0;
    return f;
    function f(h) {
      return l === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(h) : (s.enter("strikethroughSequenceTemporary"), d(h));
    }
    function d(h) {
      const m = fl(l);
      if (h === 126)
        return c > 1 ? a(h) : (s.consume(h), c++, d);
      if (c < 2 && !e)
        return a(h);
      const g = s.exit("strikethroughSequenceTemporary"), T = fl(h);
      return g._open = !T || T === 2 && Boolean(m), g._close = !m || m === 2 && Boolean(T), o(h);
    }
  }
}
const k_ = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
E5.peek = D_;
const __ = {
  canContainEols: ["delete"],
  enter: { strikethrough: w_ },
  exit: { strikethrough: v_ }
}, O_ = {
  unsafe: [
    {
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: k_
    }
  ],
  handlers: { delete: E5 }
};
function w_(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function v_(t) {
  this.exit(t);
}
function E5(t, e, n, r) {
  const i = Cf(r), s = n.enter("strikethrough");
  let o = i.move("~~");
  return o += bf(t, n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function D_() {
  return "~";
}
function M_(t) {
  return T5([N_(t)]);
}
function I_() {
  return [__];
}
function R_() {
  return {
    extensions: [O_]
  };
}
function L_(t = {}) {
  const e = this.data(), n = (r, i) => {
    (e[r] ? e[r] : e[r] = []).push(i);
  };
  n("micromarkExtensions", M_(t)), n("fromMarkdownExtensions", I_()), n("toMarkdownExtensions", R_());
}
const y5 = L_, A5 = "֑-߿יִ-﷽ﹰ-ﻼ", b5 = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", P_ = new RegExp("^[^" + b5 + "]*[" + A5 + "]"), B_ = new RegExp("^[^" + A5 + "]*[" + b5 + "]");
function F_(t) {
  const e = String(t || "");
  return P_.test(e) ? "rtl" : B_.test(e) ? "ltr" : "neutral";
}
function H_(t) {
  return "children" in t ? C5(t) : "value" in t ? t.value : "";
}
function U_(t) {
  return t.type === "text" ? t.value : "children" in t ? C5(t) : "";
}
function C5(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.children.length; )
    n[e] = U_(t.children[e]);
  return n.join("");
}
function q_(t, e) {
  const n = t.schema, r = t.language, i = t.direction, s = t.editableOrEditingHost;
  let o;
  if (e.type === "element" && e.properties) {
    const u = e.properties.xmlLang || e.properties.lang, c = e.properties.type || "text", f = _m(e);
    u != null && (t.language = String(u)), n && n.space === "html" ? (e.properties.contentEditable === "true" && (t.editableOrEditingHost = !0), e.tagName === "svg" && (t.schema = Xn), f === "rtl" ? o = f : /* Explicit `[dir=ltr]`. */ f === "ltr" || // HTML with an invalid or no `[dir]`.
    f !== "auto" && e.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
    f !== "auto" && e.tagName === "input" && c === "tel" ? o = "ltr" : (f === "auto" || e.tagName === "bdi") && (e.tagName === "textarea" ? o = ou(H_(e)) : e.tagName === "input" && (c === "email" || c === "search" || c === "tel" || c === "text") ? o = e.properties.value ? (
      // @ts-expect-error Assume string
      ou(e.properties.value)
    ) : "ltr" : Jt(e, l)), o && (t.direction = o)) : t.editableOrEditingHost && (t.editableOrEditingHost = !1);
  }
  return a;
  function a() {
    t.schema = n, t.language = r, t.direction = i, t.editableOrEditingHost = s;
  }
  function l(u) {
    if (u.type === "text")
      return o = ou(u.value), o ? Ao : void 0;
    if (u !== e && u.type === "element" && (u.tagName === "bdi" || u.tagName === "script" || u.tagName === "style" || u.tagName === "textare" || _m(u)))
      return Hl;
  }
}
function ou(t) {
  const e = F_(t);
  return e === "neutral" ? void 0 : e;
}
function _m(t) {
  const e = t.type === "element" && t.properties && typeof t.properties.dir == "string" ? t.properties.dir.toLowerCase() : void 0;
  return e === "auto" || e === "ltr" || e === "rtl" ? e : void 0;
}
const z_ = ys("operator", {
  unknown: J_,
  // @ts-expect-error: hush.
  invalid: V_,
  handlers: {
    "=": G_,
    "~=": j_,
    "|=": K_,
    "^=": W_,
    "$=": Y_,
    "*=": Q_
  }
});
function $_(t, e, n) {
  const r = t.attrs;
  let i = -1;
  for (; ++i < r.length; )
    if (!z_(r[i], e, Oo(n, r[i].name)))
      return !1;
  return !0;
}
function V_(t, e, n) {
  return Ve(e, n.property);
}
function G_(t, e, n) {
  return Boolean(
    Ve(e, n.property) && e.properties && As(e.properties[n.property], n) === t.value
  );
}
function j_(t, e, n) {
  const r = e.properties && e.properties[n.property];
  return (
    // If this is a space-separated list, and the query is contained in it, return
    // true.
    !n.commaSeparated && r && typeof r == "object" && t.value && r.includes(t.value) || // For all other values (including comma-separated lists), return whether this
    // is an exact match.
    Ve(e, n.property) && As(r, n) === t.value
  );
}
function K_(t, e, n) {
  const r = As(
    e.properties && e.properties[n.property],
    n
  );
  return Boolean(
    Ve(e, n.property) && t.value && (r === t.value || r.slice(0, t.value.length) === t.value && r.charAt(t.value.length) === "-")
  );
}
function W_(t, e, n) {
  return Boolean(
    Ve(e, n.property) && e.properties && t.value && As(e.properties[n.property], n).slice(
      0,
      t.value.length
    ) === t.value
  );
}
function Y_(t, e, n) {
  return Boolean(
    Ve(e, n.property) && e.properties && t.value && As(e.properties[n.property], n).slice(
      -t.value.length
    ) === t.value
  );
}
function Q_(t, e, n) {
  return Boolean(
    Ve(e, n.property) && e.properties && t.value && As(e.properties[n.property], n).includes(
      t.value
    )
  );
}
function J_(t) {
  throw new Error("Unknown operator `" + t.operator + "`");
}
function As(t, e) {
  return typeof t == "boolean" ? e.attribute : Array.isArray(t) ? (e.commaSeparated ? hf : df)(t) : String(t);
}
function X_(t, e) {
  const n = e.properties.className || [];
  let r = -1;
  if (t.classNames) {
    for (; ++r < t.classNames.length; )
      if (!n.includes(t.classNames[r]))
        return !1;
  }
  return !0;
}
function Z_(t, e) {
  return Boolean(e.properties && e.properties.id === t.id);
}
function eO(t, e) {
  return t.tagName === "*" || t.tagName === e.tagName;
}
function tO(t, e) {
  return function(n, r) {
    let i = Om(n, "tag");
    const s = Om(
      r ?? "*",
      "range"
    ), o = [];
    let a = -1;
    for (; ++a < s.length; ) {
      const l = s[a].toLowerCase();
      if (!e && l === "*")
        continue;
      let u = -1;
      const c = [];
      for (; ++u < i.length; )
        if (t(i[u].toLowerCase(), l)) {
          if (!e)
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              i[u]
            );
          o.push(i[u]);
        } else
          c.push(i[u]);
      i = c;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      e ? o : void 0
    );
  };
}
const nO = tO(function(t, e) {
  const n = t.split("-"), r = e.split("-");
  let i = 0, s = 0;
  if (r[s] !== "*" && n[i] !== r[s])
    return !1;
  for (i++, s++; s < r.length; ) {
    if (r[s] === "*") {
      s++;
      continue;
    }
    if (!n[i])
      return !1;
    if (n[i] === r[s]) {
      i++, s++;
      continue;
    }
    if (n[i].length === 1)
      return !1;
    i++;
  }
  return !0;
}, !0);
function Om(t, e) {
  const n = t && typeof t == "string" ? [t] : t;
  if (!n || typeof n != "object" || !("length" in n))
    throw new Error(
      "Invalid " + e + " `" + n + "`, expected non-empty string"
    );
  return n;
}
const rO = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]), wm = "0".charCodeAt(0), iO = "9".charCodeAt(0);
function sO(t) {
  if (t = t.trim().toLowerCase(), t === "even")
    return [2, 0];
  if (t === "odd")
    return [2, 1];
  let e = 0, n = 0, r = s(), i = o();
  if (e < t.length && t.charAt(e) === "n" && (e++, n = r * (i ?? 1), a(), e < t.length ? (r = s(), a(), i = o()) : r = i = 0), i === null || e < t.length)
    throw new Error(`n-th rule couldn't be parsed ('${t}')`);
  return [n, r * i];
  function s() {
    return t.charAt(e) === "-" ? (e++, -1) : (t.charAt(e) === "+" && e++, 1);
  }
  function o() {
    const l = e;
    let u = 0;
    for (; e < t.length && t.charCodeAt(e) >= wm && t.charCodeAt(e) <= iO; )
      u = u * 10 + (t.charCodeAt(e) - wm), e++;
    return e === l ? null : u;
  }
  function a() {
    for (; e < t.length && rO.has(t.charCodeAt(e)); )
      e++;
  }
}
var vm = {
  trueFunc: function() {
    return !0;
  },
  falseFunc: function() {
    return !1;
  }
};
function oO(t) {
  const e = t[0], n = t[1] - 1;
  if (n < 0 && e <= 0)
    return vm.falseFunc;
  if (e === -1)
    return (s) => s <= n;
  if (e === 0)
    return (s) => s === n;
  if (e === 1)
    return n < 0 ? vm.trueFunc : (s) => s >= n;
  const r = Math.abs(e), i = (n % r + r) % r;
  return e > 1 ? (s) => s >= n && s % r === i : (s) => s <= n && s % r === i;
}
function Dm(t) {
  return oO(sO(t));
}
const aO = Dm.default || Dm, lO = ys("name", {
  unknown: IO,
  invalid: MO,
  handlers: {
    any: pc,
    "any-link": uO,
    blank: cO,
    checked: fO,
    dir: dO,
    disabled: S5,
    empty: hO,
    enabled: pO,
    "first-child": mO,
    "first-of-type": gO,
    has: TO,
    lang: EO,
    "last-child": yO,
    "last-of-type": AO,
    matches: pc,
    not: bO,
    "nth-child": CO,
    "nth-last-child": xO,
    "nth-of-type": NO,
    "nth-last-of-type": SO,
    "only-child": kO,
    "only-of-type": _O,
    optional: OO,
    "read-only": wO,
    "read-write": N5,
    required: k5,
    root: vO,
    scope: DO
  }
});
x5.needsIndex = [
  "any",
  "first-child",
  "first-of-type",
  "last-child",
  "last-of-type",
  "matches",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-of-type",
  "nth-last-of-type",
  "only-child",
  "only-of-type"
];
function x5(t, e, n, r, i) {
  const s = t.pseudos;
  let o = -1;
  for (; ++o < s.length; )
    if (!lO(s[o], e, n, r, i))
      return !1;
  return !0;
}
function uO(t, e) {
  return (e.tagName === "a" || e.tagName === "area" || e.tagName === "link") && Ve(e, "href");
}
function cO(t, e) {
  return !_5(e, n);
  function n(r) {
    return r.type === "element" || r.type === "text" && !Nr(r);
  }
}
function fO(t, e) {
  return e.tagName === "input" || e.tagName === "menuitem" ? Boolean(
    e.properties && (e.properties.type === "checkbox" || e.properties.type === "radio") && Ve(e, "checked")
  ) : e.tagName === "option" ? Ve(e, "selected") : !1;
}
function dO(t, e, n, r, i) {
  return i.direction === t.value;
}
function S5(t, e) {
  return (e.tagName === "button" || e.tagName === "input" || e.tagName === "select" || e.tagName === "textarea" || e.tagName === "optgroup" || e.tagName === "option" || e.tagName === "menuitem" || e.tagName === "fieldset") && Ve(e, "disabled");
}
function hO(t, e) {
  return !_5(e, n);
  function n(r) {
    return r.type === "element" || r.type === "text";
  }
}
function pO(t, e) {
  return !S5(t, e);
}
function mO(t, e, n, r, i) {
  return Rn(i, t), i.elementIndex === 0;
}
function gO(t, e, n, r, i) {
  return Rn(i, t), i.typeIndex === 0;
}
function TO(t, e, n, r, i) {
  const s = {
    ...i,
    // Not found yet.
    found: !1,
    // Do walk deep.
    shallow: !1,
    // One result is enough.
    one: !0,
    scopeElements: [e],
    results: [],
    rootQuery: xf(t.value)
  };
  return Sf(s, { type: "root", children: e.children }), s.results.length > 0;
}
function EO(t, e, n, r, i) {
  return i.language !== "" && i.language !== void 0 && // @ts-expect-error never `selectors`.
  nO(i.language, ac(t.value)).length > 0;
}
function yO(t, e, n, r, i) {
  return Rn(i, t), Boolean(
    i.elementCount && i.elementIndex === i.elementCount - 1
  );
}
function AO(t, e, n, r, i) {
  return Rn(i, t), typeof i.typeIndex == "number" && typeof i.typeCount == "number" && i.typeIndex === i.typeCount - 1;
}
function pc(t, e, n, r, i) {
  const s = {
    ...i,
    // Not found yet.
    found: !1,
    // Do walk deep.
    shallow: !1,
    // One result is enough.
    one: !0,
    scopeElements: [e],
    results: [],
    rootQuery: xf(t.value)
  };
  return Sf(s, e), s.results[0] === e;
}
function bO(t, e, n, r, i) {
  return !pc(t, e, n, r, i);
}
function CO(t, e, n, r, i) {
  const s = Vl(t);
  return Rn(i, t), typeof i.elementIndex == "number" && s(i.elementIndex);
}
function xO(t, e, n, r, i) {
  const s = Vl(t);
  return Rn(i, t), Boolean(
    typeof i.elementCount == "number" && typeof i.elementIndex == "number" && s(i.elementCount - i.elementIndex - 1)
  );
}
function SO(t, e, n, r, i) {
  const s = Vl(t);
  return Rn(i, t), typeof i.typeCount == "number" && typeof i.typeIndex == "number" && s(i.typeCount - 1 - i.typeIndex);
}
function NO(t, e, n, r, i) {
  const s = Vl(t);
  return Rn(i, t), typeof i.typeIndex == "number" && s(i.typeIndex);
}
function kO(t, e, n, r, i) {
  return Rn(i, t), i.elementCount === 1;
}
function _O(t, e, n, r, i) {
  return Rn(i, t), i.typeCount === 1;
}
function OO(t, e) {
  return !k5(t, e);
}
function wO(t, e, n, r, i) {
  return !N5(t, e, n, r, i);
}
function N5(t, e, n, r, i) {
  return e.tagName === "input" || e.tagName === "textarea" ? !Ve(e, "readOnly") && !Ve(e, "disabled") : Boolean(i.editableOrEditingHost);
}
function k5(t, e) {
  return (e.tagName === "input" || e.tagName === "textarea" || e.tagName === "select") && Ve(e, "required");
}
function vO(t, e, n, r, i) {
  return Boolean(
    (!r || r.type === "root") && i.schema && (i.schema.space === "html" || i.schema.space === "svg") && (e.tagName === "html" || e.tagName === "svg")
  );
}
function DO(t, e, n, r, i) {
  return i.scopeElements.includes(e);
}
function MO() {
  throw new Error("Invalid pseudo-selector");
}
function IO(t) {
  throw t.name ? new Error("Unknown pseudo-selector `" + t.name + "`") : new Error("Unexpected pseudo-element or empty pseudo-class");
}
function _5(t, e) {
  const n = t.children;
  let r = -1;
  for (; ++r < n.length; )
    if (e(n[r]))
      return !0;
  return !1;
}
function Rn(t, e) {
  if (t.shallow)
    throw new Error("Cannot use `:" + e.name + "` without parent");
}
function Vl(t) {
  let e = t._cachedFn;
  return e || (e = aO(t.value), t._cachedFn = e), e;
}
function RO(t, e, n, r, i) {
  return Boolean(
    (!t.tagName || eO(t, e)) && (!t.classNames || X_(t, e)) && (!t.id || Z_(t, e)) && (!t.attrs || $_(t, e, i.schema)) && (!t.pseudos || x5(t, e, n, r, i))
  );
}
const LO = [];
function xf(t) {
  return t === null ? { type: "selectors", selectors: [] } : t.type === "ruleSet" ? { type: "selectors", selectors: [t] } : t;
}
function Sf(t, e) {
  e && O5(t, [], e, void 0, void 0);
}
function O5(t, e, n, r, i) {
  let s = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  const o = q_(t, n);
  return n.type === "element" && (s = BO(
    t,
    // Try the root rules for this element too.
    ba(e, t.rootQuery.selectors),
    n,
    r,
    i
  )), "children" in n && !t.shallow && !(t.one && t.found) && PO(t, s, n), o(), s;
}
function PO(t, e, n) {
  const r = ba(e.descendant, e.directChild);
  let i, s = -1;
  const o = { count: 0, types: /* @__PURE__ */ new Map() }, a = { count: 0, types: /* @__PURE__ */ new Map() };
  for (; ++s < n.children.length; )
    Mm(o, n.children[s]);
  for (s = -1; ++s < n.children.length; ) {
    const l = n.children[s], u = l.type === "element" ? l.tagName.toUpperCase() : void 0;
    if (t.elementIndex = a.count, t.typeIndex = u && a.types.get(u) || 0, t.elementCount = o.count, t.typeCount = u ? o.types.get(u) : 0, "children" in l) {
      const c = ba(r, i), f = O5(t, c, n.children[s], s, n);
      i = ba(f.generalSibling, f.adjacentSibling);
    }
    if (t.one && t.found)
      break;
    Mm(a, n.children[s]);
  }
}
function BO(t, e, n, r, i) {
  const s = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  let o = -1;
  for (; ++o < e.length; ) {
    const a = e[o];
    if (t.one && t.found)
      break;
    if (t.shallow && a.rule.rule)
      throw new Error("Expected selector without nesting");
    if (RO(a.rule, n, r, i, t)) {
      const l = a.rule.rule;
      if (l) {
        const u = { type: "ruleSet", rule: l }, c = l.nestingOperator === "+" ? "adjacentSibling" : l.nestingOperator === "~" ? "generalSibling" : l.nestingOperator === ">" ? "directChild" : "descendant";
        au(s, c, u);
      } else
        t.found = !0, t.results.includes(n) || t.results.push(n);
    }
    a.rule.nestingOperator === null ? au(s, "descendant", a) : a.rule.nestingOperator === "~" && au(s, "generalSibling", a);
  }
  return s;
}
function ba(t, e) {
  return t && e && t.length > 0 && e.length > 0 ? [...t, ...e] : t && t.length > 0 ? t : e && e.length > 0 ? e : LO;
}
function au(t, e, n) {
  const r = t[e];
  r ? r.push(n) : t[e] = [n];
}
function Mm(t, e) {
  if (e.type === "element") {
    const n = e.tagName.toUpperCase(), r = (t.types.get(n) || 0) + 1;
    t.count++, t.types.set(n, r);
  }
}
var w5 = {}, Nf = {}, kf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(o) {
    return o >= "a" && o <= "z" || o >= "A" && o <= "Z" || o === "-" || o === "_";
  }
  t.isIdentStart = e;
  function n(o) {
    return o >= "a" && o <= "z" || o >= "A" && o <= "Z" || o >= "0" && o <= "9" || o === "-" || o === "_";
  }
  t.isIdent = n;
  function r(o) {
    return o >= "a" && o <= "f" || o >= "A" && o <= "F" || o >= "0" && o <= "9";
  }
  t.isHex = r;
  function i(o) {
    for (var a = o.length, l = "", u = 0; u < a; ) {
      var c = o.charAt(u);
      if (t.identSpecialChars[c])
        l += "\\" + c;
      else if (c === "_" || c === "-" || c >= "A" && c <= "Z" || c >= "a" && c <= "z" || u !== 0 && c >= "0" && c <= "9")
        l += c;
      else {
        var f = c.charCodeAt(0);
        if ((f & 63488) === 55296) {
          var d = o.charCodeAt(u++);
          if ((f & 64512) !== 55296 || (d & 64512) !== 56320)
            throw Error("UCS-2(decode): illegal sequence");
          f = ((f & 1023) << 10) + (d & 1023) + 65536;
        }
        l += "\\" + f.toString(16) + " ";
      }
      u++;
    }
    return l;
  }
  t.escapeIdentifier = i;
  function s(o) {
    for (var a = o.length, l = "", u = 0, c; u < a; ) {
      var f = o.charAt(u);
      f === '"' ? f = '\\"' : f === "\\" ? f = "\\\\" : (c = t.strReplacementsRev[f]) !== void 0 && (f = c), l += f, u++;
    }
    return '"' + l + '"';
  }
  t.escapeStr = s, t.identSpecialChars = {
    "!": !0,
    '"': !0,
    "#": !0,
    $: !0,
    "%": !0,
    "&": !0,
    "'": !0,
    "(": !0,
    ")": !0,
    "*": !0,
    "+": !0,
    ",": !0,
    ".": !0,
    "/": !0,
    ";": !0,
    "<": !0,
    "=": !0,
    ">": !0,
    "?": !0,
    "@": !0,
    "[": !0,
    "\\": !0,
    "]": !0,
    "^": !0,
    "`": !0,
    "{": !0,
    "|": !0,
    "}": !0,
    "~": !0
  }, t.strReplacementsRev = {
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\f": "\\f",
    "\v": "\\v"
  }, t.singleQuoteEscapeChars = {
    n: `
`,
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    "'": "'"
  }, t.doubleQuotesEscapeChars = {
    n: `
`,
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    '"': '"'
  };
})(kf);
Object.defineProperty(Nf, "__esModule", { value: !0 });
var sn = kf;
function FO(t, e, n, r, i, s) {
  var o = t.length, a = "";
  function l(g, T) {
    var E = "";
    for (e++, a = t.charAt(e); e < o; ) {
      if (a === g)
        return e++, E;
      if (a === "\\") {
        e++, a = t.charAt(e);
        var _ = void 0;
        if (a === g)
          E += g;
        else if ((_ = T[a]) !== void 0)
          E += _;
        else if (sn.isHex(a)) {
          var k = a;
          for (e++, a = t.charAt(e); sn.isHex(a); )
            k += a, e++, a = t.charAt(e);
          a === " " && (e++, a = t.charAt(e)), E += String.fromCharCode(parseInt(k, 16));
          continue;
        } else
          E += a;
      } else
        E += a;
      e++, a = t.charAt(e);
    }
    return E;
  }
  function u() {
    var g = "";
    for (a = t.charAt(e); e < o; ) {
      if (sn.isIdent(a))
        g += a;
      else if (a === "\\") {
        if (e++, e >= o)
          throw Error("Expected symbol but end of file reached.");
        if (a = t.charAt(e), sn.identSpecialChars[a])
          g += a;
        else if (sn.isHex(a)) {
          var T = a;
          for (e++, a = t.charAt(e); sn.isHex(a); )
            T += a, e++, a = t.charAt(e);
          a === " " && (e++, a = t.charAt(e)), g += String.fromCharCode(parseInt(T, 16));
          continue;
        } else
          g += a;
      } else
        return g;
      e++, a = t.charAt(e);
    }
    return g;
  }
  function c() {
    a = t.charAt(e);
    for (var g = !1; a === " " || a === "	" || a === `
` || a === "\r" || a === "\f"; )
      g = !0, e++, a = t.charAt(e);
    return g;
  }
  function f() {
    var g = d();
    if (e < o)
      throw Error('Rule expected but "' + t.charAt(e) + '" found.');
    return g;
  }
  function d() {
    var g = h();
    if (!g)
      return null;
    var T = g;
    for (a = t.charAt(e); a === ","; ) {
      if (e++, c(), T.type !== "selectors" && (T = {
        type: "selectors",
        selectors: [g]
      }), g = h(), !g)
        throw Error('Rule expected after ",".');
      T.selectors.push(g);
    }
    return T;
  }
  function h() {
    c();
    var g = {
      type: "ruleSet"
    }, T = m();
    if (!T)
      return null;
    for (var E = g; T && (T.type = "rule", E.rule = T, E = T, c(), a = t.charAt(e), !(e >= o || a === "," || a === ")")); )
      if (i[a]) {
        var _ = a;
        if (e++, c(), T = m(), !T)
          throw Error('Rule expected after "' + _ + '".');
        T.nestingOperator = _;
      } else
        T = m(), T && (T.nestingOperator = null);
    return g;
  }
  function m() {
    for (var g = null; e < o; )
      if (a = t.charAt(e), a === "*")
        e++, (g = g || {}).tagName = "*";
      else if (sn.isIdentStart(a) || a === "\\")
        (g = g || {}).tagName = u();
      else if (a === ".")
        e++, g = g || {}, (g.classNames = g.classNames || []).push(u());
      else if (a === "#")
        e++, (g = g || {}).id = u();
      else if (a === "[") {
        e++, c();
        var T = {
          name: u()
        };
        if (c(), a === "]")
          e++;
        else {
          var E = "";
          if (r[a] && (E = a, e++, a = t.charAt(e)), e >= o)
            throw Error('Expected "=" but end of file reached.');
          if (a !== "=")
            throw Error('Expected "=" but "' + a + '" found.');
          T.operator = E + "=", e++, c();
          var _ = "";
          if (T.valueType = "string", a === '"')
            _ = l('"', sn.doubleQuotesEscapeChars);
          else if (a === "'")
            _ = l("'", sn.singleQuoteEscapeChars);
          else if (s && a === "$")
            e++, _ = u(), T.valueType = "substitute";
          else {
            for (; e < o && a !== "]"; )
              _ += a, e++, a = t.charAt(e);
            _ = _.trim();
          }
          if (c(), e >= o)
            throw Error('Expected "]" but end of file reached.');
          if (a !== "]")
            throw Error('Expected "]" but "' + a + '" found.');
          e++, T.value = _;
        }
        g = g || {}, (g.attrs = g.attrs || []).push(T);
      } else if (a === ":") {
        e++;
        var k = u(), A = {
          name: k
        };
        if (a === "(") {
          e++;
          var v = "";
          if (c(), n[k] === "selector")
            A.valueType = "selector", v = d();
          else {
            if (A.valueType = n[k] || "string", a === '"')
              v = l('"', sn.doubleQuotesEscapeChars);
            else if (a === "'")
              v = l("'", sn.singleQuoteEscapeChars);
            else if (s && a === "$")
              e++, v = u(), A.valueType = "substitute";
            else {
              for (; e < o && a !== ")"; )
                v += a, e++, a = t.charAt(e);
              v = v.trim();
            }
            c();
          }
          if (e >= o)
            throw Error('Expected ")" but end of file reached.');
          if (a !== ")")
            throw Error('Expected ")" but "' + a + '" found.');
          e++, A.value = v;
        }
        g = g || {}, (g.pseudos = g.pseudos || []).push(A);
      } else
        break;
    return g;
  }
  return f();
}
Nf.parseCssSelector = FO;
var _f = {};
Object.defineProperty(_f, "__esModule", { value: !0 });
var vt = kf;
function Ca(t) {
  var e = "";
  switch (t.type) {
    case "ruleSet":
      for (var n = t.rule, r = []; n; )
        n.nestingOperator && r.push(n.nestingOperator), r.push(Ca(n)), n = n.rule;
      e = r.join(" ");
      break;
    case "selectors":
      e = t.selectors.map(Ca).join(", ");
      break;
    case "rule":
      t.tagName && (t.tagName === "*" ? e = "*" : e = vt.escapeIdentifier(t.tagName)), t.id && (e += "#" + vt.escapeIdentifier(t.id)), t.classNames && (e += t.classNames.map(function(i) {
        return "." + vt.escapeIdentifier(i);
      }).join("")), t.attrs && (e += t.attrs.map(function(i) {
        return "operator" in i ? i.valueType === "substitute" ? "[" + vt.escapeIdentifier(i.name) + i.operator + "$" + i.value + "]" : "[" + vt.escapeIdentifier(i.name) + i.operator + vt.escapeStr(i.value) + "]" : "[" + vt.escapeIdentifier(i.name) + "]";
      }).join("")), t.pseudos && (e += t.pseudos.map(function(i) {
        return i.valueType ? i.valueType === "selector" ? ":" + vt.escapeIdentifier(i.name) + "(" + Ca(i.value) + ")" : i.valueType === "substitute" ? ":" + vt.escapeIdentifier(i.name) + "($" + i.value + ")" : i.valueType === "numeric" ? ":" + vt.escapeIdentifier(i.name) + "(" + i.value + ")" : ":" + vt.escapeIdentifier(i.name) + "(" + vt.escapeIdentifier(i.value) + ")" : ":" + vt.escapeIdentifier(i.name);
      }).join(""));
      break;
    default:
      throw Error('Unknown entity type: "' + t.type + '".');
  }
  return e;
}
_f.renderEntity = Ca;
Object.defineProperty(w5, "__esModule", { value: !0 });
var HO = Nf, UO = _f, qO = (
  /** @class */
  function() {
    function t() {
      this.pseudos = {}, this.attrEqualityMods = {}, this.ruleNestingOperators = {}, this.substitutesEnabled = !1;
    }
    return t.prototype.registerSelectorPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.pseudos[s] = "selector";
      }
      return this;
    }, t.prototype.unregisterSelectorPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.pseudos[s];
      }
      return this;
    }, t.prototype.registerNumericPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.pseudos[s] = "numeric";
      }
      return this;
    }, t.prototype.unregisterNumericPseudos = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.pseudos[s];
      }
      return this;
    }, t.prototype.registerNestingOperators = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.ruleNestingOperators[s] = !0;
      }
      return this;
    }, t.prototype.unregisterNestingOperators = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.ruleNestingOperators[s];
      }
      return this;
    }, t.prototype.registerAttrEqualityMods = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        this.attrEqualityMods[s] = !0;
      }
      return this;
    }, t.prototype.unregisterAttrEqualityMods = function() {
      for (var e = [], n = 0; n < arguments.length; n++)
        e[n] = arguments[n];
      for (var r = 0, i = e; r < i.length; r++) {
        var s = i[r];
        delete this.attrEqualityMods[s];
      }
      return this;
    }, t.prototype.enableSubstitutes = function() {
      return this.substitutesEnabled = !0, this;
    }, t.prototype.disableSubstitutes = function() {
      return this.substitutesEnabled = !1, this;
    }, t.prototype.parse = function(e) {
      return HO.parseCssSelector(e, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    }, t.prototype.render = function(e) {
      return UO.renderEntity(e).trim();
    }, t;
  }()
), zO = w5.CssSelectorParser = qO;
const Gl = new zO();
Gl.registerAttrEqualityMods("~", "|", "^", "$", "*");
Gl.registerSelectorPseudos("any", "matches", "not", "has");
Gl.registerNestingOperators(">", "+", "~");
function $O(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `string` as selector, not `" + t + "`");
  return Gl.parse(t);
}
function VO(t, e, n) {
  const r = GO(t, e, n);
  return Sf(r, e || void 0), r.results;
}
function GO(t, e, n) {
  return {
    // State of the query.
    rootQuery: xf($O(t)),
    results: [],
    // @ts-expect-error assume elements.
    scopeElements: e ? e.type === "root" ? e.children : [e] : [],
    one: !1,
    shallow: !1,
    found: !1,
    // State in the tree.
    schema: n === "svg" ? Xn : Ts,
    language: void 0,
    direction: "ltr",
    editableOrEditingHost: !1,
    typeIndex: void 0,
    elementIndex: void 0,
    typeCount: void 0,
    elementCount: void 0
  };
}
const jO = (t) => {
  const { selector: e, rewrite: n } = t || {};
  return (r) => {
    if (!(!n || typeof n != "function")) {
      if (e && typeof e == "string") {
        const i = VO(e, r);
        i && i.length > 0 && Jt(r, i, (s, o, a) => {
          n(s, o, a);
        });
        return;
      }
      Jt(r, (i, s, o) => {
        n(i, s, o);
      });
    }
  };
}, v5 = jO, io = {
  strip: ["script"],
  clobberPrefix: "user-content-",
  clobber: ["name", "id"],
  ancestors: {
    tbody: ["table"],
    tfoot: ["table"],
    thead: ["table"],
    td: ["table"],
    th: ["table"],
    tr: ["table"]
  },
  protocols: {
    href: ["http", "https", "mailto", "xmpp", "irc", "ircs"],
    cite: ["http", "https"],
    src: ["http", "https"],
    longDesc: ["http", "https"]
  },
  tagNames: [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "br",
    "b",
    "i",
    "strong",
    "em",
    "a",
    "pre",
    "code",
    "img",
    "tt",
    "div",
    "ins",
    "del",
    "sup",
    "sub",
    "p",
    "ol",
    "ul",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "blockquote",
    "dl",
    "dt",
    "dd",
    "kbd",
    "q",
    "samp",
    "var",
    "hr",
    "ruby",
    "rt",
    "rp",
    "li",
    "tr",
    "td",
    "th",
    "s",
    "strike",
    "summary",
    "details",
    "caption",
    "figure",
    "figcaption",
    "abbr",
    "bdo",
    "cite",
    "dfn",
    "mark",
    "small",
    "span",
    "time",
    "wbr",
    "input"
  ],
  attributes: {
    a: ["href"],
    img: ["src", "longDesc"],
    input: [
      ["type", "checkbox"],
      ["disabled", !0]
    ],
    li: [["className", "task-list-item"]],
    div: ["itemScope", "itemType"],
    blockquote: ["cite"],
    del: ["cite"],
    ins: ["cite"],
    q: ["cite"],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "ariaDescribedBy",
      "ariaHidden",
      "ariaLabel",
      "ariaLabelledBy",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "cols",
      "colSpan",
      "color",
      "compact",
      "coords",
      "dateTime",
      "dir",
      "disabled",
      "encType",
      "htmlFor",
      "frame",
      "headers",
      "height",
      "hrefLang",
      "hSpace",
      "isMap",
      "id",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rel",
      "rev",
      "rows",
      "rowSpan",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "vAlign",
      "value",
      "vSpace",
      "width",
      "itemProp"
    ]
  },
  required: {
    input: {
      type: "checkbox",
      disabled: !0
    }
  }
}, _n = {}.hasOwnProperty, lu = {
  root: { children: Im },
  doctype: WO,
  comment: YO,
  element: {
    tagName: M5,
    properties: QO,
    children: Im
  },
  text: { value: ZO },
  "*": { data: Rm, position: Rm }
};
function KO(t, e) {
  let n = { type: "root", children: [] };
  if (t && typeof t == "object" && t.type) {
    const r = D5(
      Object.assign({}, io, e || {}),
      t,
      []
    );
    r && (Array.isArray(r) ? r.length === 1 ? n = r[0] : n.children = r : n = r);
  }
  return n;
}
function D5(t, e, n) {
  const r = e && e.type, i = { type: e.type };
  let s;
  if (_n.call(lu, r)) {
    let o = lu[r];
    if (typeof o == "function" && (o = o(t, e)), o) {
      const a = Object.assign({}, o, lu["*"]);
      let l;
      s = !0;
      for (l in a)
        if (_n.call(a, l)) {
          const u = a[l](t, e[l], e, n);
          u === !1 ? (s = void 0, i[l] = e[l]) : u != null && (i[l] = u);
        }
    }
  }
  return s ? i : i.type === "element" && t.strip && !t.strip.includes(i.tagName) ? i.children : void 0;
}
function Im(t, e, n, r) {
  const i = [];
  if (Array.isArray(e)) {
    let s = -1;
    for (n.type === "element" && r.push(n.tagName); ++s < e.length; ) {
      const o = D5(t, e[s], r);
      o && (Array.isArray(o) ? i.push(...o) : i.push(o));
    }
    n.type === "element" && r.pop();
  }
  return i;
}
function WO(t) {
  return t.allowDoctypes ? { name: JO } : void 0;
}
function YO(t) {
  return t.allowComments ? { value: XO } : void 0;
}
function QO(t, e, n, r) {
  const i = M5(t, n.tagName, n, r), s = t.attributes || {}, o = t.required || {}, a = e || {}, l = Object.assign(
    {},
    Lm(s["*"]),
    Lm(i && _n.call(s, i) ? s[i] : [])
  ), u = {};
  let c;
  for (c in a)
    if (_n.call(a, c)) {
      let f = a[c], d;
      if (_n.call(l, c))
        d = l[c];
      else if (nw(c) && _n.call(l, "data*"))
        d = l["data*"];
      else
        continue;
      f = Array.isArray(f) ? ew(t, f, c, d) : I5(t, f, c, d), f != null && (u[c] = f);
    }
  if (i && _n.call(o, i))
    for (c in o[i])
      _n.call(u, c) || (u[c] = o[i][c]);
  return u;
}
function JO() {
  return "html";
}
function M5(t, e, n, r) {
  const i = typeof e == "string" ? e : "";
  let s = -1;
  if (!i || i === "*" || t.tagNames && !t.tagNames.includes(i))
    return !1;
  if (t.ancestors && _n.call(t.ancestors, i)) {
    for (; ++s < t.ancestors[i].length; )
      if (r.includes(t.ancestors[i][s]))
        return i;
    return !1;
  }
  return i;
}
function XO(t, e) {
  const n = typeof e == "string" ? e : "", r = n.indexOf("-->");
  return r < 0 ? n : n.slice(0, r);
}
function ZO(t, e) {
  return typeof e == "string" ? e : "";
}
function Rm(t, e) {
  return e;
}
function ew(t, e, n, r) {
  let i = -1;
  const s = [];
  for (; ++i < e.length; ) {
    const o = I5(t, e[i], n, r);
    o != null && s.push(o);
  }
  return s;
}
function I5(t, e, n, r) {
  if ((typeof e == "boolean" || typeof e == "number" || typeof e == "string") && tw(t, e, n) && (r.length === 0 || r.some(
    (i) => i && typeof i == "object" && "flags" in i ? i.test(String(e)) : i === e
  )))
    return t.clobberPrefix && t.clobber && t.clobber.includes(n) ? t.clobberPrefix + e : e;
}
function tw(t, e, n) {
  const r = String(e), i = r.indexOf(":"), s = r.indexOf("?"), o = r.indexOf("#"), a = r.indexOf("/"), l = t.protocols && _n.call(t.protocols, n) ? t.protocols[n].concat() : [];
  let u = -1;
  if (l.length === 0 || i < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
  a > -1 && i > a || s > -1 && i > s || o > -1 && i > o)
    return !0;
  for (; ++u < l.length; )
    if (i === l[u].length && r.slice(0, l[u].length) === l[u])
      return !0;
  return !1;
}
function Lm(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? e[r[0]] = r.slice(1) : e[r] = [];
  }
  return e;
}
function nw(t) {
  return t.length > 4 && t.slice(0, 4).toLowerCase() === "data";
}
function R5(t = io) {
  return (e) => KO(e, t);
}
const L5 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
function P5(t, e) {
  if (t = t.replace(
    e.subset ? rw(e.subset) : /["&'<>`]/g,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, n).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    r
  );
  function n(i, s, o) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      o.charCodeAt(s + 2),
      e
    );
  }
  function r(i, s, o) {
    return e.format(
      i.charCodeAt(0),
      o.charCodeAt(s + 1),
      e
    );
  }
}
function rw(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
function iw(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !/[\dA-Fa-f]/.test(String.fromCharCode(e)) ? r : r + ";";
}
function sw(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !/\d/.test(String.fromCharCode(e)) ? r : r + ";";
}
const B5 = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], uu = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, ow = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], F5 = {}.hasOwnProperty, mc = {};
let oa;
for (oa in uu)
  F5.call(uu, oa) && (mc[uu[oa]] = oa);
function aw(t, e, n, r) {
  const i = String.fromCharCode(t);
  if (F5.call(mc, i)) {
    const s = mc[i], o = "&" + s;
    return n && B5.includes(s) && !ow.includes(s) && (!r || e && e !== 61 && /[^\da-z]/i.test(String.fromCharCode(e))) ? o : o + ";";
  }
  return "";
}
function lw(t, e, n) {
  let r = iw(t, e, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = aw(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const s = sw(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function uw(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function Zi(t, e) {
  return P5(t, Object.assign({ format: lw }, e));
}
function cw(t, e) {
  return P5(t, Object.assign({ format: uw }, e));
}
function fw(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Zi(
    t.value,
    Object.assign({}, r.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + t.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, i) + "-->";
  function i(s) {
    return Zi(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function dw(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
function Pm(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(e);
  for (; i !== -1; )
    r++, i = n.indexOf(e, i + e.length);
  return r;
}
const Ue = U5(1), H5 = U5(-1);
function U5(t) {
  return e;
  function e(n, r, i) {
    const s = n ? n.children : [];
    let o = (r || 0) + t, a = s && s[o];
    if (!i)
      for (; a && Nr(a); )
        o += t, a = s[o];
    return a;
  }
}
const hw = {}.hasOwnProperty;
function q5(t) {
  return e;
  function e(n, r, i) {
    return hw.call(t, n.tagName) && t[n.tagName](n, r, i);
  }
}
const Of = q5({
  html: pw,
  head: cu,
  body: mw,
  p: gw,
  li: Tw,
  dt: Ew,
  dd: yw,
  rt: Bm,
  rp: Bm,
  optgroup: Aw,
  option: bw,
  menuitem: Cw,
  colgroup: cu,
  caption: cu,
  thead: xw,
  tbody: Sw,
  tfoot: Nw,
  tr: kw,
  td: Fm,
  th: Fm
});
function cu(t, e, n) {
  const r = Ue(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && Nr(r.value.charAt(0)));
}
function pw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type !== "comment";
}
function mw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type !== "comment";
}
function gw(t, e, n) {
  const r = Ue(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function Tw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function Ew(t, e, n) {
  const r = Ue(n, e);
  return r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function yw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function Bm(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function Aw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function bw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function Cw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "menuitem" || r.tagName === "hr" || r.tagName === "menu");
}
function xw(t, e, n) {
  const r = Ue(n, e);
  return r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function Sw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function Nw(t, e, n) {
  return !Ue(n, e);
}
function kw(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function Fm(t, e, n) {
  const r = Ue(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const _w = q5({
  html: Ow,
  head: ww,
  body: vw,
  colgroup: Dw,
  tbody: Mw
});
function Ow(t) {
  const e = Ue(t, -1);
  return !e || e.type !== "comment";
}
function ww(t) {
  const e = t.children, n = [];
  let r = -1;
  for (; ++r < e.length; ) {
    const i = e[r];
    if (i.type === "element" && (i.tagName === "title" || i.tagName === "base")) {
      if (n.includes(i.tagName))
        return !1;
      n.push(i.tagName);
    }
  }
  return e.length > 0;
}
function vw(t) {
  const e = Ue(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && Nr(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Dw(t, e, n) {
  const r = H5(n, e), i = Ue(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && Of(r, n.children.indexOf(r), n) ? !1 : i && i.type === "element" && i.tagName === "col";
}
function Mw(t, e, n) {
  const r = H5(n, e), i = Ue(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && Of(r, n.children.indexOf(r), n) ? !1 : i && i.type === "element" && i.tagName === "tr";
}
const aa = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Iw(t, e, n, r) {
  const i = r.schema, s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let o = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const a = [];
  let l;
  i.space === "html" && t.tagName === "svg" && (r.schema = Xn);
  const u = Rw(r, t.properties), c = r.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = i, c && (o = !1), (u || !s || !_w(t, e, n)) && (a.push("<", t.tagName, u ? " " + u : ""), o && (i.space === "svg" || r.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(c), !o && (!s || !Of(t, e, n)) && a.push("</" + t.tagName + ">"), a.join("");
}
function Rw(t, e) {
  const n = [];
  let r = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== void 0 && e[i] !== null) {
        const s = Lw(t, i, e[i]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : null;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function Lw(t, e, n) {
  const r = Oo(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let o = t.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean && typeof n != "string") && (n = Boolean(n)), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const l = Zi(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: aa.name[i][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? hf : df)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? l : (t.settings.preferUnquoted && (a = Zi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      subset: aa.unquoted[i][s],
      attribute: !0
    })
  )), a !== n && (t.settings.quoteSmart && Pm(n, o) > Pm(n, t.alternative) && (o = t.alternative), a = o + Zi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (o === "'" ? aa.single : aa.double)[i][s],
      attribute: !0
    })
  ) + o), l + (a && "=" + a));
}
function z5(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Zi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function Pw(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : z5(t, e, n, r);
}
function Bw(t, e, n, r) {
  return r.all(t);
}
const Fw = ys("type", {
  invalid: Hw,
  unknown: Uw,
  handlers: { comment: fw, doctype: dw, element: Iw, raw: Pw, root: Bw, text: z5 }
});
function Hw(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function Uw(t) {
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
function $5(t, e) {
  const n = e || {}, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: qw,
    all: zw,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || L5,
      characterReferences: n.characterReferences || n.entities || {},
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Xn : Ts,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function qw(t, e, n) {
  return Fw(t, e, n, this);
}
function zw(t) {
  const e = [], n = t && t.children || [];
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
const $w = {
  bullet: "*",
  listItemIndent: "one",
  rule: "-",
  emphasis: "_"
}, Vw = { allowDangerousHtml: !0 }, V5 = { fragment: !0 }, Gw = {
  handlers: {
    figure(t, e) {
      return t(
        e,
        "html",
        $5(e, {
          closeSelfClosing: !1,
          closeEmptyElements: !0
        })
      );
    }
  }
}, G5 = {
  closeSelfClosing: !1,
  closeEmptyElements: !0
}, j5 = {
  rewrite: (t, e, n) => {
    t.type == "element" && t.tagName == "a" && t.properties && (t.properties.target = "_blank", t.properties.rel = "noopener noreferrer nofollow"), t.type == "element" && t.tagName == "del" && (t.tagName = "s"), t.type == "element" && t.tagName == "u" && (t.tagName = "strong");
  }
}, K5 = {
  tagNames: [
    ...io.tagNames,
    "iframe",
    "footer",
    "header",
    "audio",
    "source"
  ],
  protocols: {
    ...io.protocols,
    href: ["http", "https", "mailto", "tel"]
  },
  attributes: {
    ...io.attributes,
    a: ["href", "ref", "target"],
    img: ["src", "srcSet", "data*"],
    audio: ["controls", "data*", ["preload", "metadata"]],
    source: ["src", "type", "data*"],
    figure: [["className", "image", "audio", "embed-code", "embed-video"]],
    div: [
      [
        "className",
        "player",
        "progress-bar",
        "meta",
        "time",
        "iframe-container"
      ],
      "data*"
    ],
    h4: [["className", "title"]],
    span: [["className", "play", "current", "duration"], "data*"],
    iframe: [
      "src",
      "allowFullScreen",
      ["loading", "lazy"],
      ["frameBorder", "0"],
      ["sandbox", "allow-scripts", "allow-same-origin", "allow-popups"]
    ]
  }
}, vR = async (t) => {
  const n = await Xc().use(M2, V5).use(v5, j5).use(bk, Gw).use(y5).use(T_, $w).process(t);
  return String(n);
};
function Te(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(l) {
    return De(l) ? (t.enter(n), a(l)) : e(l);
  }
  function a(l) {
    return De(l) && s++ < i ? (t.consume(l), a) : (t.exit(n), e(l));
  }
}
const jw = {
  tokenize: Kw
};
function Kw(t) {
  const e = t.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return e;
  function r(a) {
    if (a === null) {
      t.consume(a);
      return;
    }
    return t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), Te(t, e, "linePrefix");
  }
  function i(a) {
    return t.enter("paragraph"), s(a);
  }
  function s(a) {
    const l = t.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(a);
  }
  function o(a) {
    if (a === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(a);
      return;
    }
    return ee(a) ? (t.consume(a), t.exit("chunkText"), s) : (t.consume(a), o);
  }
}
const Ww = {
  tokenize: Yw
}, Hm = {
  tokenize: Qw
};
function Yw(t) {
  const e = this, n = [];
  let r = 0, i, s, o;
  return a;
  function a(k) {
    if (r < n.length) {
      const A = n[r];
      return e.containerState = A[1], t.attempt(
        A[0].continuation,
        l,
        u
      )(k);
    }
    return u(k);
  }
  function l(k) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && _();
      const A = e.events.length;
      let v = A, y;
      for (; v--; )
        if (e.events[v][0] === "exit" && e.events[v][1].type === "chunkFlow") {
          y = e.events[v][1].end;
          break;
        }
      E(r);
      let b = A;
      for (; b < e.events.length; )
        e.events[b][1].end = Object.assign({}, y), b++;
      return Pt(
        e.events,
        v + 1,
        0,
        e.events.slice(A)
      ), e.events.length = b, u(k);
    }
    return a(k);
  }
  function u(k) {
    if (r === n.length) {
      if (!i)
        return d(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(k);
      e.interrupt = Boolean(
        i.currentConstruct && !i._gfmTableDynamicInterruptHack
      );
    }
    return e.containerState = {}, t.check(
      Hm,
      c,
      f
    )(k);
  }
  function c(k) {
    return i && _(), E(r), d(k);
  }
  function f(k) {
    return e.parser.lazy[e.now().line] = r !== n.length, o = e.now().offset, m(k);
  }
  function d(k) {
    return e.containerState = {}, t.attempt(
      Hm,
      h,
      m
    )(k);
  }
  function h(k) {
    return r++, n.push([e.currentConstruct, e.containerState]), d(k);
  }
  function m(k) {
    if (k === null) {
      i && _(), E(0), t.consume(k);
      return;
    }
    return i = i || e.parser.flow(e.now()), t.enter("chunkFlow", {
      contentType: "flow",
      previous: s,
      _tokenizer: i
    }), g(k);
  }
  function g(k) {
    if (k === null) {
      T(t.exit("chunkFlow"), !0), E(0), t.consume(k);
      return;
    }
    return ee(k) ? (t.consume(k), T(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, a) : (t.consume(k), g);
  }
  function T(k, A) {
    const v = e.sliceStream(k);
    if (A && v.push(null), k.previous = s, s && (s.next = k), s = k, i.defineSkip(k.start), i.write(v), e.parser.lazy[k.start.line]) {
      let y = i.events.length;
      for (; y--; )
        if (
          // The token starts before the line ending…
          i.events[y][1].start.offset < o && // …and either is not ended yet…
          (!i.events[y][1].end || // …or ends after it.
          i.events[y][1].end.offset > o)
        )
          return;
      const b = e.events.length;
      let O = b, P, $;
      for (; O--; )
        if (e.events[O][0] === "exit" && e.events[O][1].type === "chunkFlow") {
          if (P) {
            $ = e.events[O][1].end;
            break;
          }
          P = !0;
        }
      for (E(r), y = b; y < e.events.length; )
        e.events[y][1].end = Object.assign({}, $), y++;
      Pt(
        e.events,
        O + 1,
        0,
        e.events.slice(b)
      ), e.events.length = y;
    }
  }
  function E(k) {
    let A = n.length;
    for (; A-- > k; ) {
      const v = n[A];
      e.containerState = v[1], v[0].exit.call(e, t);
    }
    n.length = k;
  }
  function _() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function Qw(t, e, n) {
  return Te(
    t,
    t.attempt(this.parser.constructs.document, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const gc = {
  name: "attention",
  tokenize: Xw,
  resolveAll: Jw
};
function Jw(t, e) {
  let n = -1, r, i, s, o, a, l, u, c;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
            continue;
          l = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, t[r][1].end), d = Object.assign({}, t[n][1].start);
          Um(f, -l), Um(d, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, t[r][1].end)
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, t[n][1].start),
            end: d
          }, s = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, t[r][1].end),
            end: Object.assign({}, t[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, a.end)
          }, t[r][1].end = Object.assign({}, o.start), t[n][1].start = Object.assign({}, a.end), u = [], t[r][1].end.offset - t[r][1].start.offset && (u = $t(u, [
            ["enter", t[r][1], e],
            ["exit", t[r][1], e]
          ])), u = $t(u, [
            ["enter", i, e],
            ["enter", o, e],
            ["exit", o, e],
            ["enter", s, e]
          ]), u = $t(
            u,
            $l(
              e.parser.constructs.insideSpan.null,
              t.slice(r + 1, n),
              e
            )
          ), u = $t(u, [
            ["exit", s, e],
            ["enter", a, e],
            ["exit", a, e],
            ["exit", i, e]
          ]), t[n][1].end.offset - t[n][1].start.offset ? (c = 2, u = $t(u, [
            ["enter", t[n][1], e],
            ["exit", t[n][1], e]
          ])) : c = 0, Pt(t, r - 1, n - r + 3, u), n = r + u.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < t.length; )
    t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function Xw(t, e) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = fl(r);
  let s;
  return o;
  function o(l) {
    return t.enter("attentionSequence"), s = l, a(l);
  }
  function a(l) {
    if (l === s)
      return t.consume(l), a;
    const u = t.exit("attentionSequence"), c = fl(l), f = !c || c === 2 && i || n.includes(l), d = !i || i === 2 && c || n.includes(r);
    return u._open = Boolean(s === 42 ? f : f && (i || !d)), u._close = Boolean(s === 42 ? d : d && (c || !f)), e(l);
  }
}
function Um(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
const Zw = {
  name: "autolink",
  tokenize: ev
};
function ev(t, e, n) {
  let r = 1;
  return i;
  function i(m) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(m), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), s;
  }
  function s(m) {
    return jt(m) ? (t.consume(m), o) : km(m) ? u(m) : n(m);
  }
  function o(m) {
    return m === 43 || m === 45 || m === 46 || dt(m) ? a(m) : u(m);
  }
  function a(m) {
    return m === 58 ? (t.consume(m), l) : (m === 43 || m === 45 || m === 46 || dt(m)) && r++ < 32 ? (t.consume(m), a) : u(m);
  }
  function l(m) {
    return m === 62 ? (t.exit("autolinkProtocol"), h(m)) : m === null || m === 32 || m === 60 || hc(m) ? n(m) : (t.consume(m), l);
  }
  function u(m) {
    return m === 64 ? (t.consume(m), r = 0, c) : km(m) ? (t.consume(m), u) : n(m);
  }
  function c(m) {
    return dt(m) ? f(m) : n(m);
  }
  function f(m) {
    return m === 46 ? (t.consume(m), r = 0, c) : m === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", h(m)) : d(m);
  }
  function d(m) {
    return (m === 45 || dt(m)) && r++ < 63 ? (t.consume(m), m === 45 ? d : f) : n(m);
  }
  function h(m) {
    return t.enter("autolinkMarker"), t.consume(m), t.exit("autolinkMarker"), t.exit("autolink"), e;
  }
}
const jl = {
  tokenize: tv,
  partial: !0
};
function tv(t, e, n) {
  return Te(t, r, "linePrefix");
  function r(i) {
    return i === null || ee(i) ? e(i) : n(i);
  }
}
const W5 = {
  name: "blockQuote",
  tokenize: nv,
  continuation: {
    tokenize: rv
  },
  exit: iv
};
function nv(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (t.enter("blockQuote", {
        _container: !0
      }), a.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(o), t.exit("blockQuoteMarker"), s;
    }
    return n(o);
  }
  function s(o) {
    return De(o) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(o), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(o));
  }
}
function rv(t, e, n) {
  return Te(
    t,
    t.attempt(W5, e, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function iv(t) {
  t.exit("blockQuote");
}
const Y5 = {
  name: "characterEscape",
  tokenize: sv
};
function sv(t, e, n) {
  return r;
  function r(s) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(s), t.exit("escapeMarker"), i;
  }
  function i(s) {
    return C_(s) ? (t.enter("characterEscapeValue"), t.consume(s), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(s);
  }
}
const Q5 = {
  name: "characterReference",
  tokenize: ov
};
function ov(t, e, n) {
  const r = this;
  let i = 0, s, o;
  return a;
  function a(f) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(f), t.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(f), t.exit("characterReferenceMarkerNumeric"), u) : (t.enter("characterReferenceValue"), s = 31, o = dt, c(f));
  }
  function u(f) {
    return f === 88 || f === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(f), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), s = 6, o = b_, c) : (t.enter("characterReferenceValue"), s = 7, o = dc, c(f));
  }
  function c(f) {
    let d;
    return f === 59 && i ? (d = t.exit("characterReferenceValue"), o === dt && !bo(r.sliceSerialize(d)) ? n(f) : (t.enter("characterReferenceMarker"), t.consume(f), t.exit("characterReferenceMarker"), t.exit("characterReference"), e)) : o(f) && i++ < s ? (t.consume(f), c) : n(f);
  }
}
const qm = {
  name: "codeFenced",
  tokenize: av,
  concrete: !0
};
function av(t, e, n) {
  const r = this, i = {
    tokenize: v,
    partial: !0
  }, s = {
    tokenize: A,
    partial: !0
  }, o = this.events[this.events.length - 1], a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;
  let l = 0, u;
  return c;
  function c(y) {
    return t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), u = y, f(y);
  }
  function f(y) {
    return y === u ? (t.consume(y), l++, f) : (t.exit("codeFencedFenceSequence"), l < 3 ? n(y) : Te(t, d, "whitespace")(y));
  }
  function d(y) {
    return y === null || ee(y) ? T(y) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), h(y));
  }
  function h(y) {
    return y === null || ze(y) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Te(t, m, "whitespace")(y)) : y === 96 && y === u ? n(y) : (t.consume(y), h);
  }
  function m(y) {
    return y === null || ee(y) ? T(y) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), g(y));
  }
  function g(y) {
    return y === null || ee(y) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), T(y)) : y === 96 && y === u ? n(y) : (t.consume(y), g);
  }
  function T(y) {
    return t.exit("codeFencedFence"), r.interrupt ? e(y) : E(y);
  }
  function E(y) {
    return y === null ? k(y) : ee(y) ? t.attempt(
      s,
      t.attempt(
        i,
        k,
        a ? Te(
          t,
          E,
          "linePrefix",
          a + 1
        ) : E
      ),
      k
    )(y) : (t.enter("codeFlowValue"), _(y));
  }
  function _(y) {
    return y === null || ee(y) ? (t.exit("codeFlowValue"), E(y)) : (t.consume(y), _);
  }
  function k(y) {
    return t.exit("codeFenced"), e(y);
  }
  function A(y, b, O) {
    const P = this;
    return $;
    function $(R) {
      return y.enter("lineEnding"), y.consume(R), y.exit("lineEnding"), M;
    }
    function M(R) {
      return P.parser.lazy[P.now().line] ? O(R) : b(R);
    }
  }
  function v(y, b, O) {
    let P = 0;
    return Te(
      y,
      $,
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
    function $(V) {
      return y.enter("codeFencedFence"), y.enter("codeFencedFenceSequence"), M(V);
    }
    function M(V) {
      return V === u ? (y.consume(V), P++, M) : P < l ? O(V) : (y.exit("codeFencedFenceSequence"), Te(y, R, "whitespace")(V));
    }
    function R(V) {
      return V === null || ee(V) ? (y.exit("codeFencedFence"), b(V)) : O(V);
    }
  }
}
const fu = {
  name: "codeIndented",
  tokenize: uv
}, lv = {
  tokenize: cv,
  partial: !0
};
function uv(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return t.enter("codeIndented"), Te(t, s, "linePrefix", 4 + 1)(u);
  }
  function s(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? o(u) : n(u);
  }
  function o(u) {
    return u === null ? l(u) : ee(u) ? t.attempt(lv, o, l)(u) : (t.enter("codeFlowValue"), a(u));
  }
  function a(u) {
    return u === null || ee(u) ? (t.exit("codeFlowValue"), o(u)) : (t.consume(u), a);
  }
  function l(u) {
    return t.exit("codeIndented"), e(u);
  }
}
function cv(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : ee(o) ? (t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), i) : Te(t, s, "linePrefix", 4 + 1)(o);
  }
  function s(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : ee(o) ? i(o) : n(o);
  }
}
const fv = {
  name: "codeText",
  tokenize: pv,
  resolve: dv,
  previous: hv
};
function dv(t) {
  let e = t.length - 4, n = 3, r, i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2;
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData", r !== i + 2 && (t[i][1].end = t[r - 1][1].end, t.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return t;
}
function hv(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function pv(t, e, n) {
  let r = 0, i, s;
  return o;
  function o(f) {
    return t.enter("codeText"), t.enter("codeTextSequence"), a(f);
  }
  function a(f) {
    return f === 96 ? (t.consume(f), r++, a) : (t.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 96 ? (s = t.enter("codeTextSequence"), i = 0, c(f)) : f === 32 ? (t.enter("space"), t.consume(f), t.exit("space"), l) : ee(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), l) : (t.enter("codeTextData"), u(f));
  }
  function u(f) {
    return f === null || f === 32 || f === 96 || ee(f) ? (t.exit("codeTextData"), l(f)) : (t.consume(f), u);
  }
  function c(f) {
    return f === 96 ? (t.consume(f), i++, c) : i === r ? (t.exit("codeTextSequence"), t.exit("codeText"), e(f)) : (s.type = "codeTextData", u(f));
  }
}
function J5(t) {
  const e = {};
  let n = -1, r, i, s, o, a, l, u;
  for (; ++n < t.length; ) {
    for (; n in e; )
      n = e[n];
    if (r = t[n], n && r[1].type === "chunkFlow" && t[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content"))
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, mv(t, n)), n = e[n], u = !0);
    else if (r[1]._container) {
      for (s = n, i = void 0; s-- && (o = t[s], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (t[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
      i && (r[1].end = Object.assign({}, t[i][1].start), a = t.slice(i, n), a.unshift(r), Pt(t, i, n - i + 1, a));
    }
  }
  return !u;
}
function mv(t, e) {
  const n = t[e][1], r = t[e][2];
  let i = e - 1;
  const s = [], o = n._tokenizer || r.parser[n.contentType](n.start), a = o.events, l = [], u = {};
  let c, f, d = -1, h = n, m = 0, g = 0;
  const T = [g];
  for (; h; ) {
    for (; t[++i][1] !== h; )
      ;
    s.push(i), h._tokenizer || (c = r.sliceStream(h), h.next || c.push(null), f && o.defineSkip(h.start), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(c), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = h, h = h.next;
  }
  for (h = n; ++d < a.length; )
    // Find a void token that includes a break.
    a[d][0] === "exit" && a[d - 1][0] === "enter" && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (g = d + 1, T.push(g), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (o.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : T.pop(), d = T.length; d--; ) {
    const E = a.slice(T[d], T[d + 1]), _ = s.pop();
    l.unshift([_, _ + E.length - 1]), Pt(t, _, 2, E);
  }
  for (d = -1; ++d < l.length; )
    u[m + l[d][0]] = m + l[d][1], m += l[d][1] - l[d][0] - 1;
  return u;
}
const gv = {
  tokenize: yv,
  resolve: Ev
}, Tv = {
  tokenize: Av,
  partial: !0
};
function Ev(t) {
  return J5(t), t;
}
function yv(t, e) {
  let n;
  return r;
  function r(a) {
    return t.enter("content"), n = t.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? s(a) : ee(a) ? t.check(
      Tv,
      o,
      s
    )(a) : (t.consume(a), i);
  }
  function s(a) {
    return t.exit("chunkContent"), t.exit("content"), e(a);
  }
  function o(a) {
    return t.consume(a), t.exit("chunkContent"), n.next = t.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function Av(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), Te(t, s, "linePrefix");
  }
  function s(o) {
    if (o === null || ee(o))
      return n(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : t.interrupt(r.parser.constructs.flow, n, e)(o);
  }
}
function X5(t, e, n, r, i, s, o, a, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return f;
  function f(E) {
    return E === 60 ? (t.enter(r), t.enter(i), t.enter(s), t.consume(E), t.exit(s), d) : E === null || E === 41 || hc(E) ? n(E) : (t.enter(r), t.enter(o), t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), g(E));
  }
  function d(E) {
    return E === 62 ? (t.enter(s), t.consume(E), t.exit(s), t.exit(i), t.exit(r), e) : (t.enter(a), t.enter("chunkString", {
      contentType: "string"
    }), h(E));
  }
  function h(E) {
    return E === 62 ? (t.exit("chunkString"), t.exit(a), d(E)) : E === null || E === 60 || ee(E) ? n(E) : (t.consume(E), E === 92 ? m : h);
  }
  function m(E) {
    return E === 60 || E === 62 || E === 92 ? (t.consume(E), h) : h(E);
  }
  function g(E) {
    return E === 40 ? ++c > u ? n(E) : (t.consume(E), g) : E === 41 ? c-- ? (t.consume(E), g) : (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(E)) : E === null || ze(E) ? c ? n(E) : (t.exit("chunkString"), t.exit(a), t.exit(o), t.exit(r), e(E)) : hc(E) ? n(E) : (t.consume(E), E === 92 ? T : g);
  }
  function T(E) {
    return E === 40 || E === 41 || E === 92 ? (t.consume(E), g) : g(E);
  }
}
function Z5(t, e, n, r, i, s) {
  const o = this;
  let a = 0, l;
  return u;
  function u(h) {
    return t.enter(r), t.enter(i), t.consume(h), t.exit(i), t.enter(s), c;
  }
  function c(h) {
    return h === null || h === 91 || h === 93 && !l || /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */
    /* Hidden footnotes hook */
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs || a > 999 ? n(h) : h === 93 ? (t.exit(s), t.enter(i), t.consume(h), t.exit(i), t.exit(r), e) : ee(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), c) : (t.enter("chunkString", {
      contentType: "string"
    }), f(h));
  }
  function f(h) {
    return h === null || h === 91 || h === 93 || ee(h) || a++ > 999 ? (t.exit("chunkString"), c(h)) : (t.consume(h), l = l || !De(h), h === 92 ? d : f);
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), a++, f) : f(h);
  }
}
function e4(t, e, n, r, i, s) {
  let o;
  return a;
  function a(d) {
    return t.enter(r), t.enter(i), t.consume(d), t.exit(i), o = d === 40 ? 41 : d, l;
  }
  function l(d) {
    return d === o ? (t.enter(i), t.consume(d), t.exit(i), t.exit(r), e) : (t.enter(s), u(d));
  }
  function u(d) {
    return d === o ? (t.exit(s), l(o)) : d === null ? n(d) : ee(d) ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), Te(t, u, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), c(d));
  }
  function c(d) {
    return d === o || d === null || ee(d) ? (t.exit("chunkString"), u(d)) : (t.consume(d), d === 92 ? f : c);
  }
  function f(d) {
    return d === o || d === 92 ? (t.consume(d), c) : c(d);
  }
}
function Wn(t, e) {
  let n;
  return r;
  function r(i) {
    return ee(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), n = !0, r) : De(i) ? Te(
      t,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : e(i);
  }
}
function es(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const bv = {
  name: "definition",
  tokenize: xv
}, Cv = {
  tokenize: Sv,
  partial: !0
};
function xv(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(l) {
    return t.enter("definition"), Z5.call(
      r,
      t,
      o,
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(l);
  }
  function o(l) {
    return i = es(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), l === 58 ? (t.enter("definitionMarker"), t.consume(l), t.exit("definitionMarker"), Wn(
      t,
      X5(
        t,
        t.attempt(
          Cv,
          Te(t, a, "whitespace"),
          Te(t, a, "whitespace")
        ),
        n,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )
    )) : n(l);
  }
  function a(l) {
    return l === null || ee(l) ? (t.exit("definition"), r.parser.defined.includes(i) || r.parser.defined.push(i), e(l)) : n(l);
  }
}
function Sv(t, e, n) {
  return r;
  function r(o) {
    return ze(o) ? Wn(t, i)(o) : n(o);
  }
  function i(o) {
    return o === 34 || o === 39 || o === 40 ? e4(
      t,
      Te(t, s, "whitespace"),
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o) : n(o);
  }
  function s(o) {
    return o === null || ee(o) ? e(o) : n(o);
  }
}
const Nv = {
  name: "hardBreakEscape",
  tokenize: kv
};
function kv(t, e, n) {
  return r;
  function r(s) {
    return t.enter("hardBreakEscape"), t.enter("escapeMarker"), t.consume(s), i;
  }
  function i(s) {
    return ee(s) ? (t.exit("escapeMarker"), t.exit("hardBreakEscape"), e(s)) : n(s);
  }
}
const _v = {
  name: "headingAtx",
  tokenize: wv,
  resolve: Ov
};
function Ov(t, e) {
  let n = t.length - 2, r = 3, i, s;
  return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[n][1].end
  }, s = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[n][1].end,
    // @ts-expect-error Constants are fine to assign.
    contentType: "text"
  }, Pt(t, r, n - r + 1, [
    ["enter", i, e],
    ["enter", s, e],
    ["exit", s, e],
    ["exit", i, e]
  ])), t;
}
function wv(t, e, n) {
  const r = this;
  let i = 0;
  return s;
  function s(c) {
    return t.enter("atxHeading"), t.enter("atxHeadingSequence"), o(c);
  }
  function o(c) {
    return c === 35 && i++ < 6 ? (t.consume(c), o) : c === null || ze(c) ? (t.exit("atxHeadingSequence"), r.interrupt ? e(c) : a(c)) : n(c);
  }
  function a(c) {
    return c === 35 ? (t.enter("atxHeadingSequence"), l(c)) : c === null || ee(c) ? (t.exit("atxHeading"), e(c)) : De(c) ? Te(t, a, "whitespace")(c) : (t.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (t.consume(c), l) : (t.exit("atxHeadingSequence"), a(c));
  }
  function u(c) {
    return c === null || c === 35 || ze(c) ? (t.exit("atxHeadingText"), a(c)) : (t.consume(c), u);
  }
}
const vv = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], zm = ["pre", "script", "style", "textarea"], Dv = {
  name: "htmlFlow",
  tokenize: Rv,
  resolveTo: Iv,
  concrete: !0
}, Mv = {
  tokenize: Lv,
  partial: !0
};
function Iv(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t;
}
function Rv(t, e, n) {
  const r = this;
  let i, s, o, a, l;
  return u;
  function u(S) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(S), c;
  }
  function c(S) {
    return S === 33 ? (t.consume(S), f) : S === 47 ? (t.consume(S), m) : S === 63 ? (t.consume(S), i = 3, r.interrupt ? e : de) : jt(S) ? (t.consume(S), o = String.fromCharCode(S), s = !0, g) : n(S);
  }
  function f(S) {
    return S === 45 ? (t.consume(S), i = 2, d) : S === 91 ? (t.consume(S), i = 5, o = "CDATA[", a = 0, h) : jt(S) ? (t.consume(S), i = 4, r.interrupt ? e : de) : n(S);
  }
  function d(S) {
    return S === 45 ? (t.consume(S), r.interrupt ? e : de) : n(S);
  }
  function h(S) {
    return S === o.charCodeAt(a++) ? (t.consume(S), a === o.length ? r.interrupt ? e : M : h) : n(S);
  }
  function m(S) {
    return jt(S) ? (t.consume(S), o = String.fromCharCode(S), g) : n(S);
  }
  function g(S) {
    return S === null || S === 47 || S === 62 || ze(S) ? S !== 47 && s && zm.includes(o.toLowerCase()) ? (i = 1, r.interrupt ? e(S) : M(S)) : vv.includes(o.toLowerCase()) ? (i = 6, S === 47 ? (t.consume(S), T) : r.interrupt ? e(S) : M(S)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(S) : s ? _(S) : E(S)) : S === 45 || dt(S) ? (t.consume(S), o += String.fromCharCode(S), g) : n(S);
  }
  function T(S) {
    return S === 62 ? (t.consume(S), r.interrupt ? e : M) : n(S);
  }
  function E(S) {
    return De(S) ? (t.consume(S), E) : P(S);
  }
  function _(S) {
    return S === 47 ? (t.consume(S), P) : S === 58 || S === 95 || jt(S) ? (t.consume(S), k) : De(S) ? (t.consume(S), _) : P(S);
  }
  function k(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || dt(S) ? (t.consume(S), k) : A(S);
  }
  function A(S) {
    return S === 61 ? (t.consume(S), v) : De(S) ? (t.consume(S), A) : _(S);
  }
  function v(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (t.consume(S), l = S, y) : De(S) ? (t.consume(S), v) : (l = null, b(S));
  }
  function y(S) {
    return S === null || ee(S) ? n(S) : S === l ? (t.consume(S), O) : (t.consume(S), y);
  }
  function b(S) {
    return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 62 || S === 96 || ze(S) ? A(S) : (t.consume(S), b);
  }
  function O(S) {
    return S === 47 || S === 62 || De(S) ? _(S) : n(S);
  }
  function P(S) {
    return S === 62 ? (t.consume(S), $) : n(S);
  }
  function $(S) {
    return De(S) ? (t.consume(S), $) : S === null || ee(S) ? M(S) : n(S);
  }
  function M(S) {
    return S === 45 && i === 2 ? (t.consume(S), w) : S === 60 && i === 1 ? (t.consume(S), ue) : S === 62 && i === 4 ? (t.consume(S), he) : S === 63 && i === 3 ? (t.consume(S), de) : S === 93 && i === 5 ? (t.consume(S), ie) : ee(S) && (i === 6 || i === 7) ? t.check(
      Mv,
      he,
      R
    )(S) : S === null || ee(S) ? R(S) : (t.consume(S), M);
  }
  function R(S) {
    return t.exit("htmlFlowData"), V(S);
  }
  function V(S) {
    return S === null ? N(S) : ee(S) ? t.attempt(
      {
        tokenize: Y,
        partial: !0
      },
      V,
      N
    )(S) : (t.enter("htmlFlowData"), M(S));
  }
  function Y(S, gt, ut) {
    return je;
    function je(Ke) {
      return S.enter("lineEnding"), S.consume(Ke), S.exit("lineEnding"), Ae;
    }
    function Ae(Ke) {
      return r.parser.lazy[r.now().line] ? ut(Ke) : gt(Ke);
    }
  }
  function w(S) {
    return S === 45 ? (t.consume(S), de) : M(S);
  }
  function ue(S) {
    return S === 47 ? (t.consume(S), o = "", se) : M(S);
  }
  function se(S) {
    return S === 62 && zm.includes(o.toLowerCase()) ? (t.consume(S), he) : jt(S) && o.length < 8 ? (t.consume(S), o += String.fromCharCode(S), se) : M(S);
  }
  function ie(S) {
    return S === 93 ? (t.consume(S), de) : M(S);
  }
  function de(S) {
    return S === 62 ? (t.consume(S), he) : S === 45 && i === 2 ? (t.consume(S), de) : M(S);
  }
  function he(S) {
    return S === null || ee(S) ? (t.exit("htmlFlowData"), N(S)) : (t.consume(S), he);
  }
  function N(S) {
    return t.exit("htmlFlow"), e(S);
  }
}
function Lv(t, e, n) {
  return r;
  function r(i) {
    return t.exit("htmlFlowData"), t.enter("lineEndingBlank"), t.consume(i), t.exit("lineEndingBlank"), t.attempt(jl, e, n);
  }
}
const Pv = {
  name: "htmlText",
  tokenize: Bv
};
function Bv(t, e, n) {
  const r = this;
  let i, s, o, a;
  return l;
  function l(N) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(N), u;
  }
  function u(N) {
    return N === 33 ? (t.consume(N), c) : N === 47 ? (t.consume(N), b) : N === 63 ? (t.consume(N), v) : jt(N) ? (t.consume(N), $) : n(N);
  }
  function c(N) {
    return N === 45 ? (t.consume(N), f) : N === 91 ? (t.consume(N), s = "CDATA[", o = 0, T) : jt(N) ? (t.consume(N), A) : n(N);
  }
  function f(N) {
    return N === 45 ? (t.consume(N), d) : n(N);
  }
  function d(N) {
    return N === null || N === 62 ? n(N) : N === 45 ? (t.consume(N), h) : m(N);
  }
  function h(N) {
    return N === null || N === 62 ? n(N) : m(N);
  }
  function m(N) {
    return N === null ? n(N) : N === 45 ? (t.consume(N), g) : ee(N) ? (a = m, ie(N)) : (t.consume(N), m);
  }
  function g(N) {
    return N === 45 ? (t.consume(N), he) : m(N);
  }
  function T(N) {
    return N === s.charCodeAt(o++) ? (t.consume(N), o === s.length ? E : T) : n(N);
  }
  function E(N) {
    return N === null ? n(N) : N === 93 ? (t.consume(N), _) : ee(N) ? (a = E, ie(N)) : (t.consume(N), E);
  }
  function _(N) {
    return N === 93 ? (t.consume(N), k) : E(N);
  }
  function k(N) {
    return N === 62 ? he(N) : N === 93 ? (t.consume(N), k) : E(N);
  }
  function A(N) {
    return N === null || N === 62 ? he(N) : ee(N) ? (a = A, ie(N)) : (t.consume(N), A);
  }
  function v(N) {
    return N === null ? n(N) : N === 63 ? (t.consume(N), y) : ee(N) ? (a = v, ie(N)) : (t.consume(N), v);
  }
  function y(N) {
    return N === 62 ? he(N) : v(N);
  }
  function b(N) {
    return jt(N) ? (t.consume(N), O) : n(N);
  }
  function O(N) {
    return N === 45 || dt(N) ? (t.consume(N), O) : P(N);
  }
  function P(N) {
    return ee(N) ? (a = P, ie(N)) : De(N) ? (t.consume(N), P) : he(N);
  }
  function $(N) {
    return N === 45 || dt(N) ? (t.consume(N), $) : N === 47 || N === 62 || ze(N) ? M(N) : n(N);
  }
  function M(N) {
    return N === 47 ? (t.consume(N), he) : N === 58 || N === 95 || jt(N) ? (t.consume(N), R) : ee(N) ? (a = M, ie(N)) : De(N) ? (t.consume(N), M) : he(N);
  }
  function R(N) {
    return N === 45 || N === 46 || N === 58 || N === 95 || dt(N) ? (t.consume(N), R) : V(N);
  }
  function V(N) {
    return N === 61 ? (t.consume(N), Y) : ee(N) ? (a = V, ie(N)) : De(N) ? (t.consume(N), V) : M(N);
  }
  function Y(N) {
    return N === null || N === 60 || N === 61 || N === 62 || N === 96 ? n(N) : N === 34 || N === 39 ? (t.consume(N), i = N, w) : ee(N) ? (a = Y, ie(N)) : De(N) ? (t.consume(N), Y) : (t.consume(N), i = void 0, se);
  }
  function w(N) {
    return N === i ? (t.consume(N), ue) : N === null ? n(N) : ee(N) ? (a = w, ie(N)) : (t.consume(N), w);
  }
  function ue(N) {
    return N === 62 || N === 47 || ze(N) ? M(N) : n(N);
  }
  function se(N) {
    return N === null || N === 34 || N === 39 || N === 60 || N === 61 || N === 96 ? n(N) : N === 62 || ze(N) ? M(N) : (t.consume(N), se);
  }
  function ie(N) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(N), t.exit("lineEnding"), Te(
      t,
      de,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function de(N) {
    return t.enter("htmlTextData"), a(N);
  }
  function he(N) {
    return N === 62 ? (t.consume(N), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(N);
  }
}
const wf = {
  name: "labelEnd",
  tokenize: $v,
  resolveTo: zv,
  resolveAll: qv
}, Fv = {
  tokenize: Vv
}, Hv = {
  tokenize: Gv
}, Uv = {
  tokenize: jv
};
function qv(t) {
  let e = -1, n;
  for (; ++e < t.length; )
    n = t[e][1], (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (t.splice(e + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", e++);
  return t;
}
function zv(t, e) {
  let n = t.length, r = 0, i, s, o, a;
  for (; n--; )
    if (i = t[n][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = n);
  const l = {
    type: t[s][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, t[s][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, t[s][1].start),
    end: Object.assign({}, t[o][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, t[s + r + 2][1].end),
    end: Object.assign({}, t[o - 2][1].start)
  };
  return a = [
    ["enter", l, e],
    ["enter", u, e]
  ], a = $t(a, t.slice(s + 1, s + r + 3)), a = $t(a, [["enter", c, e]]), a = $t(
    a,
    $l(
      e.parser.constructs.insideSpan.null,
      t.slice(s + r + 4, o - 3),
      e
    )
  ), a = $t(a, [
    ["exit", c, e],
    t[o - 2],
    t[o - 1],
    ["exit", u, e]
  ]), a = $t(a, t.slice(o + 1)), a = $t(a, [["exit", l, e]]), Pt(t, s, t.length, a), t;
}
function $v(t, e, n) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return a;
  function a(c) {
    return s ? s._inactive ? u(c) : (o = r.parser.defined.includes(
      es(
        r.sliceSerialize({
          start: s.end,
          end: r.now()
        })
      )
    ), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(c), t.exit("labelMarker"), t.exit("labelEnd"), l) : n(c);
  }
  function l(c) {
    return c === 40 ? t.attempt(
      Fv,
      e,
      o ? e : u
    )(c) : c === 91 ? t.attempt(
      Hv,
      e,
      o ? t.attempt(Uv, e, u) : u
    )(c) : o ? e(c) : u(c);
  }
  function u(c) {
    return s._balanced = !0, n(c);
  }
}
function Vv(t, e, n) {
  return r;
  function r(l) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(l), t.exit("resourceMarker"), Wn(t, i);
  }
  function i(l) {
    return l === 41 ? a(l) : X5(
      t,
      s,
      n,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(l);
  }
  function s(l) {
    return ze(l) ? Wn(t, o)(l) : a(l);
  }
  function o(l) {
    return l === 34 || l === 39 || l === 40 ? e4(
      t,
      Wn(t, a),
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(l) : a(l);
  }
  function a(l) {
    return l === 41 ? (t.enter("resourceMarker"), t.consume(l), t.exit("resourceMarker"), t.exit("resource"), e) : n(l);
  }
}
function Gv(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return Z5.call(
      r,
      t,
      s,
      n,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function s(o) {
    return r.parser.defined.includes(
      es(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? e(o) : n(o);
  }
}
function jv(t, e, n) {
  return r;
  function r(s) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), t.exit("reference"), e) : n(s);
  }
}
const Kv = {
  name: "labelStartImage",
  tokenize: Wv,
  resolveAll: wf.resolveAll
};
function Wv(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(a), t.exit("labelImageMarker"), s;
  }
  function s(a) {
    return a === 91 ? (t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelImage"), o) : n(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const Yv = {
  name: "labelStartLink",
  tokenize: Qv,
  resolveAll: wf.resolveAll
};
function Qv(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const du = {
  name: "lineEnding",
  tokenize: Jv
};
function Jv(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), Te(t, e, "linePrefix");
  }
}
const xa = {
  name: "thematicBreak",
  tokenize: Xv
};
function Xv(t, e, n) {
  let r = 0, i;
  return s;
  function s(l) {
    return t.enter("thematicBreak"), i = l, o(l);
  }
  function o(l) {
    return l === i ? (t.enter("thematicBreakSequence"), a(l)) : De(l) ? Te(t, o, "whitespace")(l) : r < 3 || l !== null && !ee(l) ? n(l) : (t.exit("thematicBreak"), e(l));
  }
  function a(l) {
    return l === i ? (t.consume(l), r++, a) : (t.exit("thematicBreakSequence"), o(l));
  }
}
const yt = {
  name: "list",
  tokenize: tD,
  continuation: {
    tokenize: nD
  },
  exit: iD
}, Zv = {
  tokenize: sD,
  partial: !0
}, eD = {
  tokenize: rD,
  partial: !0
};
function tD(t, e, n) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return a;
  function a(h) {
    const m = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : dc(h)) {
      if (r.containerState.type || (r.containerState.type = m, t.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return t.enter("listItemPrefix"), h === 42 || h === 45 ? t.check(xa, n, u)(h) : u(h);
      if (!r.interrupt || h === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), l(h);
    }
    return n(h);
  }
  function l(h) {
    return dc(h) && ++o < 10 ? (t.consume(h), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (t.exit("listItemValue"), u(h)) : n(h);
  }
  function u(h) {
    return t.enter("listItemMarker"), t.consume(h), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, t.check(
      jl,
      // Can’t be empty when interrupting.
      r.interrupt ? n : c,
      t.attempt(
        Zv,
        d,
        f
      )
    );
  }
  function c(h) {
    return r.containerState.initialBlankLine = !0, s++, d(h);
  }
  function f(h) {
    return De(h) ? (t.enter("listItemPrefixWhitespace"), t.consume(h), t.exit("listItemPrefixWhitespace"), d) : n(h);
  }
  function d(h) {
    return r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(h);
  }
}
function nD(t, e, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(jl, i, s);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Te(
      t,
      e,
      "listItemIndent",
      r.containerState.size + 1
    )(a);
  }
  function s(a) {
    return r.containerState.furtherBlankLines || !De(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(eD, e, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Te(
      t,
      t.attempt(yt, e, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a);
  }
}
function rD(t, e, n) {
  const r = this;
  return Te(
    t,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : n(s);
  }
}
function iD(t) {
  t.exit(this.containerState.type);
}
function sD(t, e, n) {
  const r = this;
  return Te(
    t,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !De(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : n(s);
  }
}
const $m = {
  name: "setextUnderline",
  tokenize: aD,
  resolveTo: oD
};
function oD(t, e) {
  let n = t.length, r, i, s;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else
      t[n][1].type === "content" && t.splice(n, 1), !s && t[n][1].type === "definition" && (s = n);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, t[i][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  };
  return t[i][1].type = "setextHeadingText", s ? (t.splice(i, 0, ["enter", o, e]), t.splice(s + 1, 0, ["exit", t[r][1], e]), t[r][1].end = Object.assign({}, t[s][1].end)) : t[r][1] = o, t.push(["exit", o, e]), t;
}
function aD(t, e, n) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if (r.events[i][1].type !== "lineEnding" && r.events[i][1].type !== "linePrefix" && r.events[i][1].type !== "content") {
      o = r.events[i][1].type === "paragraph";
      break;
    }
  return a;
  function a(c) {
    return !r.parser.lazy[r.now().line] && (r.interrupt || o) ? (t.enter("setextHeadingLine"), t.enter("setextHeadingLineSequence"), s = c, l(c)) : n(c);
  }
  function l(c) {
    return c === s ? (t.consume(c), l) : (t.exit("setextHeadingLineSequence"), Te(t, u, "lineSuffix")(c));
  }
  function u(c) {
    return c === null || ee(c) ? (t.exit("setextHeadingLine"), e(c)) : n(c);
  }
}
const lD = {
  tokenize: uD
};
function uD(t) {
  const e = this, n = t.attempt(
    // Try to parse a blank line.
    jl,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(
      this.parser.constructs.flowInitial,
      i,
      Te(
        t,
        t.attempt(
          this.parser.constructs.flow,
          i,
          t.attempt(gv, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(s), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n;
  }
  function i(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), e.currentConstruct = void 0, n;
  }
}
const cD = {
  resolveAll: n4()
}, fD = t4("string"), dD = t4("text");
function t4(t) {
  return {
    tokenize: e,
    resolveAll: n4(
      t === "text" ? hD : void 0
    )
  };
  function e(n) {
    const r = this, i = this.parser.constructs[t], s = n.attempt(i, o, a);
    return o;
    function o(c) {
      return u(c) ? s(c) : a(c);
    }
    function a(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), l;
    }
    function l(c) {
      return u(c) ? (n.exit("data"), s(c)) : (n.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const f = i[c];
      let d = -1;
      if (f)
        for (; ++d < f.length; ) {
          const h = f[d];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function n4(t) {
  return e;
  function e(n, r) {
    let i = -1, s;
    for (; ++i <= n.length; )
      s === void 0 ? n[i] && n[i][1].type === "data" && (s = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end, n.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return t ? t(n, r) : n;
  }
}
function hD(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, a = 0, l;
      for (; s--; ) {
        const u = i[s];
        if (typeof u == "string") {
          for (o = u.length; u.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o)
            break;
          o = -1;
        } else if (u === -2)
          l = !0, a++;
        else if (u !== -1) {
          s++;
          break;
        }
      }
      if (a) {
        const u = {
          type: n === t.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + s,
            _bufferIndex: s ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, u.start), r.start.offset === r.end.offset ? Object.assign(r, u) : (t.splice(
          n,
          0,
          ["enter", u, e],
          ["exit", u, e]
        ), n += 2);
      }
      n++;
    }
  return t;
}
function pD(t, e, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, s = [];
  let o = [], a = [];
  const l = {
    consume: _,
    enter: k,
    exit: A,
    attempt: b(v),
    check: b(y),
    interrupt: b(y, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: t,
    sliceStream: h,
    sliceSerialize: d,
    now: m,
    defineSkip: g,
    write: f
  };
  let c = e.tokenize.call(u, l);
  return e.resolveAll && s.push(e), u;
  function f(M) {
    return o = $t(o, M), T(), o[o.length - 1] !== null ? [] : (O(e, 0), u.events = $l(s, u.events, u), u.events);
  }
  function d(M, R) {
    return gD(h(M), R);
  }
  function h(M) {
    return mD(o, M);
  }
  function m() {
    return Object.assign({}, r);
  }
  function g(M) {
    i[M.line] = M.column, $();
  }
  function T() {
    let M;
    for (; r._index < o.length; ) {
      const R = o[r._index];
      if (typeof R == "string")
        for (M = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === M && r._bufferIndex < R.length; )
          E(R.charCodeAt(r._bufferIndex));
      else
        E(R);
    }
  }
  function E(M) {
    c = c(M);
  }
  function _(M) {
    ee(M) ? (r.line++, r.column = 1, r.offset += M === -3 ? 2 : 1, $()) : M !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = M;
  }
  function k(M, R) {
    const V = R || {};
    return V.type = M, V.start = m(), u.events.push(["enter", V, u]), a.push(V), V;
  }
  function A(M) {
    const R = a.pop();
    return R.end = m(), u.events.push(["exit", R, u]), R;
  }
  function v(M, R) {
    O(M, R.from);
  }
  function y(M, R) {
    R.restore();
  }
  function b(M, R) {
    return V;
    function V(Y, w, ue) {
      let se, ie, de, he;
      return Array.isArray(Y) ? (
        /* c8 ignore next 1 */
        S(Y)
      ) : "tokenize" in Y ? S([Y]) : N(Y);
      function N(Ae) {
        return Ke;
        function Ke(We) {
          const Ot = We !== null && Ae[We], ct = We !== null && Ae.null, yn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Ot) ? Ot : Ot ? [Ot] : [],
            ...Array.isArray(ct) ? ct : ct ? [ct] : []
          ];
          return S(yn)(We);
        }
      }
      function S(Ae) {
        return se = Ae, ie = 0, Ae.length === 0 ? ue : gt(Ae[ie]);
      }
      function gt(Ae) {
        return Ke;
        function Ke(We) {
          return he = P(), de = Ae, Ae.partial || (u.currentConstruct = Ae), Ae.name && u.parser.constructs.disable.null.includes(Ae.name) ? je() : Ae.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            R ? Object.assign(Object.create(u), R) : u,
            l,
            ut,
            je
          )(We);
        }
      }
      function ut(Ae) {
        return M(de, he), w;
      }
      function je(Ae) {
        return he.restore(), ++ie < se.length ? gt(se[ie]) : ue;
      }
    }
  }
  function O(M, R) {
    M.resolveAll && !s.includes(M) && s.push(M), M.resolve && Pt(
      u.events,
      R,
      u.events.length - R,
      M.resolve(u.events.slice(R), u)
    ), M.resolveTo && (u.events = M.resolveTo(u.events, u));
  }
  function P() {
    const M = m(), R = u.previous, V = u.currentConstruct, Y = u.events.length, w = Array.from(a);
    return {
      restore: ue,
      from: Y
    };
    function ue() {
      r = M, u.previous = R, u.currentConstruct = V, u.events.length = Y, a = w, $();
    }
  }
  function $() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function mD(t, e) {
  const n = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  return n === i ? o = [t[n].slice(r, s)] : (o = t.slice(n, i), r > -1 && (o[0] = o[0].slice(r)), s > 0 && o.push(t[i].slice(0, s))), o;
}
function gD(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const s = t[n];
    let o;
    if (typeof s == "string")
      o = s;
    else
      switch (s) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = e ? " " : "	";
          break;
        }
        case -1: {
          if (!e && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(s);
      }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
const TD = {
  [42]: yt,
  [43]: yt,
  [45]: yt,
  [48]: yt,
  [49]: yt,
  [50]: yt,
  [51]: yt,
  [52]: yt,
  [53]: yt,
  [54]: yt,
  [55]: yt,
  [56]: yt,
  [57]: yt,
  [62]: W5
}, ED = {
  [91]: bv
}, yD = {
  [-2]: fu,
  [-1]: fu,
  [32]: fu
}, AD = {
  [35]: _v,
  [42]: xa,
  [45]: [$m, xa],
  [60]: Dv,
  [61]: $m,
  [95]: xa,
  [96]: qm,
  [126]: qm
}, bD = {
  [38]: Q5,
  [92]: Y5
}, CD = {
  [-5]: du,
  [-4]: du,
  [-3]: du,
  [33]: Kv,
  [38]: Q5,
  [42]: gc,
  [60]: [Zw, Pv],
  [91]: Yv,
  [92]: [Nv, Y5],
  [93]: wf,
  [95]: gc,
  [96]: fv
}, xD = {
  null: [gc, cD]
}, SD = {
  null: [42, 95]
}, ND = {
  null: []
}, kD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: SD,
  contentInitial: ED,
  disable: ND,
  document: TD,
  flow: AD,
  flowInitial: yD,
  insideSpan: xD,
  string: bD,
  text: CD
}, Symbol.toStringTag, { value: "Module" }));
function _D(t = {}) {
  const e = T5(
    // @ts-expect-error Same as above.
    [kD].concat(t.extensions || [])
  ), n = {
    defined: [],
    lazy: {},
    constructs: e,
    content: r(jw),
    document: r(Ww),
    flow: r(lD),
    string: r(fD),
    text: r(dD)
  };
  return n;
  function r(i) {
    return s;
    function s(o) {
      return pD(n, i, o);
    }
  }
}
const Vm = /[\0\t\n\r]/g;
function OD() {
  let t = 1, e = "", n = !0, r;
  return i;
  function i(s, o, a) {
    const l = [];
    let u, c, f, d, h;
    for (s = e + s.toString(o), f = 0, e = "", n && (s.charCodeAt(0) === 65279 && f++, n = void 0); f < s.length; ) {
      if (Vm.lastIndex = f, u = Vm.exec(s), d = u && u.index !== void 0 ? u.index : s.length, h = s.charCodeAt(d), !u) {
        e = s.slice(f);
        break;
      }
      if (h === 10 && f === d && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < d && (l.push(s.slice(f, d)), t += d - f), h) {
          case 0: {
            l.push(65533), t++;
            break;
          }
          case 9: {
            for (c = Math.ceil(t / 4) * 4, l.push(-2); t++ < c; )
              l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      f = d + 1;
    }
    return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
  }
}
function wD(t) {
  for (; !J5(t); )
    ;
  return t;
}
const r4 = {}.hasOwnProperty, vD = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(t, e, n) {
    return typeof e != "string" && (n = e, e = void 0), DD(n)(
      wD(
        // @ts-expect-error: micromark types need to accept `null`.
        _D(n).document().write(OD()(t, e, !0))
      )
    );
  }
);
function DD(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(Bt),
      autolinkProtocol: M,
      autolinkEmail: M,
      atxHeading: a(Zn),
      blockQuote: a(yn),
      characterEscape: M,
      characterReference: M,
      codeFenced: a(Rr),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: a(Rr, l),
      codeText: a(Lr, l),
      codeTextData: M,
      data: M,
      codeFlowValue: M,
      definition: a(Ei),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: a(yi),
      hardBreakEscape: a(er),
      hardBreakTrailing: a(er),
      htmlFlow: a(Pr, l),
      htmlFlowData: M,
      htmlText: a(Pr, l),
      htmlTextData: M,
      image: a(Ai),
      label: l,
      link: a(Bt),
      listItem: a(Br),
      listItemValue: m,
      listOrdered: a(nn, h),
      listUnordered: a(nn),
      paragraph: a(Ln),
      reference: je,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: a(Zn),
      strong: a(Fr),
      thematicBreak: a(Ci)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: b,
      autolink: c(),
      autolinkEmail: ct,
      autolinkProtocol: Ot,
      blockQuote: c(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: Ke,
      characterReferenceMarkerNumeric: Ke,
      characterReferenceValue: We,
      codeFenced: c(_),
      codeFencedFence: E,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: T,
      codeFlowValue: R,
      codeIndented: c(k),
      codeText: c(se),
      codeTextData: R,
      data: R,
      definition: c(),
      definitionDestinationString: y,
      definitionLabelString: A,
      definitionTitleString: v,
      emphasis: c(),
      hardBreakEscape: c(Y),
      hardBreakTrailing: c(Y),
      htmlFlow: c(w),
      htmlFlowData: R,
      htmlText: c(ue),
      htmlTextData: R,
      image: c(de),
      label: N,
      labelText: he,
      lineEnding: V,
      link: c(ie),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: Ae,
      resourceDestinationString: S,
      resourceTitleString: gt,
      resource: ut,
      setextHeading: c($),
      setextHeadingLineSequence: P,
      setextHeadingText: O,
      strong: c(),
      thematicBreak: c()
    }
  };
  i4(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(I) {
    let q = {
      type: "root",
      children: []
    };
    const re = {
      stack: [q],
      tokenStack: [],
      config: e,
      enter: u,
      exit: f,
      buffer: l,
      resume: d,
      setData: s,
      getData: o
    }, ye = [];
    let be = -1;
    for (; ++be < I.length; )
      if (I[be][1].type === "listOrdered" || I[be][1].type === "listUnordered")
        if (I[be][0] === "enter")
          ye.push(be);
        else {
          const wt = ye.pop();
          be = i(I, wt, be);
        }
    for (be = -1; ++be < I.length; ) {
      const wt = e[I[be][0]];
      r4.call(wt, I[be][1].type) && wt[I[be][1].type].call(
        Object.assign(
          {
            sliceSerialize: I[be][2].sliceSerialize
          },
          re
        ),
        I[be][1]
      );
    }
    if (re.tokenStack.length > 0) {
      const wt = re.tokenStack[re.tokenStack.length - 1];
      (wt[1] || Gm).call(re, void 0, wt[0]);
    }
    for (q.position = {
      start: lr(
        I.length > 0 ? I[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: lr(
        I.length > 0 ? I[I.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, be = -1; ++be < e.transforms.length; )
      q = e.transforms[be](q) || q;
    return q;
  }
  function i(I, q, re) {
    let ye = q - 1, be = -1, wt = !1, An, D, j, X;
    for (; ++ye <= re; ) {
      const te = I[ye];
      if (te[1].type === "listUnordered" || te[1].type === "listOrdered" || te[1].type === "blockQuote" ? (te[0] === "enter" ? be++ : be--, X = void 0) : te[1].type === "lineEndingBlank" ? te[0] === "enter" && (An && !X && !be && !j && (j = ye), X = void 0) : te[1].type === "linePrefix" || te[1].type === "listItemValue" || te[1].type === "listItemMarker" || te[1].type === "listItemPrefix" || te[1].type === "listItemPrefixWhitespace" || (X = void 0), !be && te[0] === "enter" && te[1].type === "listItemPrefix" || be === -1 && te[0] === "exit" && (te[1].type === "listUnordered" || te[1].type === "listOrdered")) {
        if (An) {
          let pe = ye;
          for (D = void 0; pe--; ) {
            const ke = I[pe];
            if (ke[1].type === "lineEnding" || ke[1].type === "lineEndingBlank") {
              if (ke[0] === "exit")
                continue;
              D && (I[D][1].type = "lineEndingBlank", wt = !0), ke[1].type = "lineEnding", D = pe;
            } else if (!(ke[1].type === "linePrefix" || ke[1].type === "blockQuotePrefix" || ke[1].type === "blockQuotePrefixWhitespace" || ke[1].type === "blockQuoteMarker" || ke[1].type === "listItemIndent"))
              break;
          }
          j && (!D || j < D) && (An._spread = !0), An.end = Object.assign(
            {},
            D ? I[D][1].start : te[1].end
          ), I.splice(D || ye, 0, ["exit", An, te[2]]), ye++, re++;
        }
        te[1].type === "listItemPrefix" && (An = {
          type: "listItem",
          // @ts-expect-error Patched
          _spread: !1,
          start: Object.assign({}, te[1].start)
        }, I.splice(ye, 0, ["enter", An, te[2]]), ye++, re++, j = void 0, X = !0);
      }
    }
    return I[q][1]._spread = wt, re;
  }
  function s(I, q) {
    n[I] = q;
  }
  function o(I) {
    return n[I];
  }
  function a(I, q) {
    return re;
    function re(ye) {
      u.call(this, I(ye), ye), q && q.call(this, ye);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(I, q, re) {
    return this.stack[this.stack.length - 1].children.push(I), this.stack.push(I), this.tokenStack.push([q, re]), I.position = {
      start: lr(q.start)
    }, I;
  }
  function c(I) {
    return q;
    function q(re) {
      I && I.call(this, re), f.call(this, re);
    }
  }
  function f(I, q) {
    const re = this.stack.pop(), ye = this.tokenStack.pop();
    if (ye)
      ye[0].type !== I.type && (q ? q.call(this, I, ye[0]) : (ye[1] || Gm).call(this, I, ye[0]));
    else
      throw new Error(
        "Cannot close `" + I.type + "` (" + Js({
          start: I.start,
          end: I.end
        }) + "): it’s not open"
      );
    return re.position.end = lr(I.end), re;
  }
  function d() {
    return ql(this.stack.pop());
  }
  function h() {
    s("expectingFirstListItemValue", !0);
  }
  function m(I) {
    if (o("expectingFirstListItemValue")) {
      const q = this.stack[this.stack.length - 2];
      q.start = Number.parseInt(this.sliceSerialize(I), 10), s("expectingFirstListItemValue");
    }
  }
  function g() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.lang = I;
  }
  function T() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.meta = I;
  }
  function E() {
    o("flowCodeInside") || (this.buffer(), s("flowCodeInside", !0));
  }
  function _() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.value = I.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), s("flowCodeInside");
  }
  function k() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.value = I.replace(/(\r?\n|\r)$/g, "");
  }
  function A(I) {
    const q = this.resume(), re = this.stack[this.stack.length - 1];
    re.label = q, re.identifier = es(
      this.sliceSerialize(I)
    ).toLowerCase();
  }
  function v() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.title = I;
  }
  function y() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.url = I;
  }
  function b(I) {
    const q = this.stack[this.stack.length - 1];
    if (!q.depth) {
      const re = this.sliceSerialize(I).length;
      q.depth = re;
    }
  }
  function O() {
    s("setextHeadingSlurpLineEnding", !0);
  }
  function P(I) {
    const q = this.stack[this.stack.length - 1];
    q.depth = this.sliceSerialize(I).charCodeAt(0) === 61 ? 1 : 2;
  }
  function $() {
    s("setextHeadingSlurpLineEnding");
  }
  function M(I) {
    const q = this.stack[this.stack.length - 1];
    let re = q.children[q.children.length - 1];
    (!re || re.type !== "text") && (re = bi(), re.position = {
      start: lr(I.start)
    }, q.children.push(re)), this.stack.push(re);
  }
  function R(I) {
    const q = this.stack.pop();
    q.value += this.sliceSerialize(I), q.position.end = lr(I.end);
  }
  function V(I) {
    const q = this.stack[this.stack.length - 1];
    if (o("atHardBreak")) {
      const re = q.children[q.children.length - 1];
      re.position.end = lr(I.end), s("atHardBreak");
      return;
    }
    !o("setextHeadingSlurpLineEnding") && e.canContainEols.includes(q.type) && (M.call(this, I), R.call(this, I));
  }
  function Y() {
    s("atHardBreak", !0);
  }
  function w() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.value = I;
  }
  function ue() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.value = I;
  }
  function se() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.value = I;
  }
  function ie() {
    const I = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const q = o("referenceType") || "shortcut";
      I.type += "Reference", I.referenceType = q, delete I.url, delete I.title;
    } else
      delete I.identifier, delete I.label;
    s("referenceType");
  }
  function de() {
    const I = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const q = o("referenceType") || "shortcut";
      I.type += "Reference", I.referenceType = q, delete I.url, delete I.title;
    } else
      delete I.identifier, delete I.label;
    s("referenceType");
  }
  function he(I) {
    const q = this.sliceSerialize(I), re = this.stack[this.stack.length - 2];
    re.label = m5(q), re.identifier = es(q).toLowerCase();
  }
  function N() {
    const I = this.stack[this.stack.length - 1], q = this.resume(), re = this.stack[this.stack.length - 1];
    if (s("inReference", !0), re.type === "link") {
      const ye = I.children;
      re.children = ye;
    } else
      re.alt = q;
  }
  function S() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.url = I;
  }
  function gt() {
    const I = this.resume(), q = this.stack[this.stack.length - 1];
    q.title = I;
  }
  function ut() {
    s("inReference");
  }
  function je() {
    s("referenceType", "collapsed");
  }
  function Ae(I) {
    const q = this.resume(), re = this.stack[this.stack.length - 1];
    re.label = q, re.identifier = es(
      this.sliceSerialize(I)
    ).toLowerCase(), s("referenceType", "full");
  }
  function Ke(I) {
    s("characterReferenceType", I.type);
  }
  function We(I) {
    const q = this.sliceSerialize(I), re = o("characterReferenceType");
    let ye;
    re ? (ye = p5(
      q,
      re === "characterReferenceMarkerNumeric" ? 10 : 16
    ), s("characterReferenceType")) : ye = bo(q);
    const be = this.stack.pop();
    be.value += ye, be.position.end = lr(I.end);
  }
  function Ot(I) {
    R.call(this, I);
    const q = this.stack[this.stack.length - 1];
    q.url = this.sliceSerialize(I);
  }
  function ct(I) {
    R.call(this, I);
    const q = this.stack[this.stack.length - 1];
    q.url = "mailto:" + this.sliceSerialize(I);
  }
  function yn() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Rr() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Lr() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ei() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function yi() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Zn() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function er() {
    return {
      type: "break"
    };
  }
  function Pr() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ai() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Bt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function nn(I) {
    return {
      type: "list",
      ordered: I.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: I._spread,
      children: []
    };
  }
  function Br(I) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: I._spread,
      checked: null,
      children: []
    };
  }
  function Ln() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Fr() {
    return {
      type: "strong",
      children: []
    };
  }
  function bi() {
    return {
      type: "text",
      value: ""
    };
  }
  function Ci() {
    return {
      type: "thematicBreak"
    };
  }
}
function lr(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function i4(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? i4(t, r) : MD(t, r);
  }
}
function MD(t, e) {
  let n;
  for (n in e)
    if (r4.call(e, n)) {
      if (n === "canContainEols") {
        const r = e[n];
        r && t[n].push(...r);
      } else if (n === "transforms") {
        const r = e[n];
        r && t[n].push(...r);
      } else if (n === "enter" || n === "exit") {
        const r = e[n];
        r && Object.assign(t[n], r);
      }
    }
}
function Gm(t, e) {
  throw t ? new Error(
    "Cannot close `" + t.type + "` (" + Js({
      start: t.start,
      end: t.end
    }) + "): a different token (`" + e.type + "`, " + Js({
      start: e.start,
      end: e.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + e.type + "`, " + Js({
      start: e.start,
      end: e.end
    }) + ") is still open"
  );
}
function ID(t) {
  Object.assign(this, { Parser: (n) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return vD(
      n,
      Object.assign({}, r, t, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
function RD(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function LD(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function PD(t, e) {
  const n = e.value ? e.value + `
` : "", r = e.lang ? e.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, i = {};
  r && (i.className = ["language-" + r]);
  let s = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (s.data = { meta: e.meta }), t.patch(e, s), s = t.applyData(e, s), s = { type: "element", tagName: "pre", properties: {}, children: [s] }, t.patch(e, s), s;
}
function BD(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function FD(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function bs(t) {
  const e = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < t.length; ) {
    const s = t.charCodeAt(n);
    let o = "";
    if (s === 37 && dt(t.charCodeAt(n + 1)) && dt(t.charCodeAt(n + 2)))
      i = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (o = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const a = t.charCodeAt(n + 1);
      s < 56320 && a > 56319 && a < 57344 ? (o = String.fromCharCode(s, a), i = 1) : o = "�";
    } else
      o = String.fromCharCode(s);
    o && (e.push(t.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return e.join("") + t.slice(r);
}
function s4(t, e) {
  const n = String(e.identifier).toUpperCase(), r = bs(n.toLowerCase()), i = t.footnoteOrder.indexOf(n);
  let s;
  i === -1 ? (t.footnoteOrder.push(n), t.footnoteCounts[n] = 1, s = t.footnoteOrder.length) : (t.footnoteCounts[n]++, s = i + 1);
  const o = t.footnoteCounts[n], a = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + t.clobberPrefix + "fn-" + r,
      id: t.clobberPrefix + "fnref-" + r + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  t.patch(e, a);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [a]
  };
  return t.patch(e, l), t.applyData(e, l);
}
function HD(t, e) {
  const n = t.footnoteById;
  let r = 1;
  for (; r in n; )
    r++;
  const i = String(r);
  return n[i] = {
    type: "footnoteDefinition",
    identifier: i,
    children: [{ type: "paragraph", children: e.children }],
    position: e.position
  }, s4(t, {
    type: "footnoteReference",
    identifier: i,
    position: e.position
  });
}
function UD(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function qD(t, e) {
  if (t.dangerous) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
  return null;
}
function o4(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return { type: "text", value: "![" + e.alt + r };
  const i = t.all(e), s = i[0];
  s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function zD(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return o4(t, e);
  const r = { src: bs(n.url || ""), alt: e.alt };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = { type: "element", tagName: "img", properties: r, children: [] };
  return t.patch(e, i), t.applyData(e, i);
}
function $D(t, e) {
  const n = { src: bs(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function VD(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function GD(t, e) {
  const n = t.definition(e.identifier);
  if (!n)
    return o4(t, e);
  const r = { href: bs(n.url || "") };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: r,
    children: t.all(e)
  };
  return t.patch(e, i), t.applyData(e, i);
}
function jD(t, e) {
  const n = { href: bs(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function KD(t, e, n) {
  const r = t.all(e), i = n ? WD(n) : a4(e), s = {}, o = [];
  if (typeof e.checked == "boolean") {
    const c = r[0];
    let f;
    c && c.type === "element" && c.tagName === "p" ? f = c : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const c = r[a];
    (i || a !== 0 || c.type !== "element" || c.tagName !== "p") && o.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? o.push(...c.children) : o.push(c);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: s, children: o };
  return t.patch(e, u), t.applyData(e, u);
}
function WD(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = a4(n[r]);
  }
  return e;
}
function a4(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function YD(t, e) {
  const n = {}, r = t.all(e);
  let i = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function QD(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function JD(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function XD(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const vo = l4("start"), Kl = l4("end");
function ZD(t) {
  return { start: vo(t), end: Kl(t) };
}
function l4(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: r.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: r.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: r.offset > -1 ? r.offset : null
    };
  }
}
function eM(t, e) {
  const n = t.all(e), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, a = vo(e.children[1]), l = Kl(e.children[e.children.length - 1]);
    a.line && l.line && (o.position = { start: a, end: l }), i.push(o);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(i, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function tM(t, e, n) {
  const r = n ? n.children : void 0, s = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, a = o ? o.length : e.children.length;
  let l = -1;
  const u = [];
  for (; ++l < a; ) {
    const f = e.children[l], d = {}, h = o ? o[l] : void 0;
    h && (d.align = h);
    let m = { type: "element", tagName: s, properties: d, children: [] };
    f && (m.children = t.all(f), t.patch(f, m), m = t.applyData(e, m)), u.push(m);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(u, !0)
  };
  return t.patch(e, c), t.applyData(e, c);
}
function nM(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const jm = 9, Km = 32;
function rM(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), i = 0;
  const s = [];
  for (; r; )
    s.push(
      Wm(e.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(e);
  return s.push(Wm(e.slice(i), i > 0, !1)), s.join("");
}
function Wm(t, e, n) {
  let r = 0, i = t.length;
  if (e) {
    let s = t.codePointAt(r);
    for (; s === jm || s === Km; )
      r++, s = t.codePointAt(r);
  }
  if (n) {
    let s = t.codePointAt(i - 1);
    for (; s === jm || s === Km; )
      i--, s = t.codePointAt(i - 1);
  }
  return i > r ? t.slice(r, i) : "";
}
function iM(t, e) {
  const n = { type: "text", value: rM(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function sM(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const oM = {
  blockquote: RD,
  break: LD,
  code: PD,
  delete: BD,
  emphasis: FD,
  footnoteReference: s4,
  footnote: HD,
  heading: UD,
  html: qD,
  imageReference: zD,
  image: $D,
  inlineCode: VD,
  linkReference: GD,
  link: jD,
  listItem: KD,
  list: YD,
  paragraph: QD,
  root: JD,
  strong: XD,
  table: eM,
  tableCell: nM,
  tableRow: tM,
  text: iM,
  thematicBreak: sM,
  toml: la,
  yaml: la,
  definition: la,
  footnoteDefinition: la
};
function la() {
  return null;
}
function aM(t) {
  return !t || !t.position || !t.position.start || !t.position.start.line || !t.position.start.column || !t.position.end || !t.position.end.line || !t.position.end.column;
}
const Ym = {}.hasOwnProperty;
function lM(t) {
  const e = /* @__PURE__ */ Object.create(null);
  if (!t || !t.type)
    throw new Error("mdast-util-definitions expected node");
  return Jt(t, "definition", (r) => {
    const i = Qm(r.identifier);
    i && !Ym.call(e, i) && (e[i] = r);
  }), n;
  function n(r) {
    const i = Qm(r);
    return i && Ym.call(e, i) ? e[i] : null;
  }
}
function Qm(t) {
  return String(t || "").toUpperCase();
}
const dl = {}.hasOwnProperty;
function uM(t, e) {
  const n = e || {}, r = n.allowDangerousHtml || !1, i = {};
  return o.dangerous = r, o.clobberPrefix = n.clobberPrefix === void 0 || n.clobberPrefix === null ? "user-content-" : n.clobberPrefix, o.footnoteLabel = n.footnoteLabel || "Footnotes", o.footnoteLabelTagName = n.footnoteLabelTagName || "h2", o.footnoteLabelProperties = n.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o.footnoteBackLabel = n.footnoteBackLabel || "Back to content", o.unknownHandler = n.unknownHandler, o.passThrough = n.passThrough, o.handlers = { ...oM, ...n.handlers }, o.definition = lM(t), o.footnoteById = i, o.footnoteOrder = [], o.footnoteCounts = {}, o.patch = cM, o.applyData = fM, o.one = a, o.all = l, o.wrap = hM, o.augment = s, Jt(t, "footnoteDefinition", (u) => {
    const c = String(u.identifier).toUpperCase();
    dl.call(i, c) || (i[c] = u);
  }), o;
  function s(u, c) {
    if (u && "data" in u && u.data) {
      const f = u.data;
      f.hName && (c.type !== "element" && (c = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), c.tagName = f.hName), c.type === "element" && f.hProperties && (c.properties = { ...c.properties, ...f.hProperties }), "children" in c && c.children && f.hChildren && (c.children = f.hChildren);
    }
    if (u) {
      const f = "type" in u ? u : { position: u };
      aM(f) || (c.position = { start: vo(f), end: Kl(f) });
    }
    return c;
  }
  function o(u, c, f, d) {
    return Array.isArray(f) && (d = f, f = {}), s(u, {
      type: "element",
      tagName: c,
      properties: f || {},
      children: d || []
    });
  }
  function a(u, c) {
    return u4(o, u, c);
  }
  function l(u) {
    return vf(o, u);
  }
}
function cM(t, e) {
  t.position && (e.position = ZD(t));
}
function fM(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, i = t.data.hChildren, s = t.data.hProperties;
    typeof r == "string" && (n.type === "element" ? n.tagName = r : n = {
      type: "element",
      tagName: r,
      properties: {},
      children: []
    }), n.type === "element" && s && (n.properties = { ...n.properties, ...s }), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function u4(t, e, n) {
  const r = e && e.type;
  if (!r)
    throw new Error("Expected node, got `" + e + "`");
  return dl.call(t.handlers, r) ? t.handlers[r](t, e, n) : t.passThrough && t.passThrough.includes(r) ? "children" in e ? { ...e, children: vf(t, e) } : e : t.unknownHandler ? t.unknownHandler(t, e, n) : dM(t, e);
}
function vf(t, e) {
  const n = [];
  if ("children" in e) {
    const r = e.children;
    let i = -1;
    for (; ++i < r.length; ) {
      const s = u4(t, r[i], e);
      if (s) {
        if (i && r[i - 1].type === "break" && (!Array.isArray(s) && s.type === "text" && (s.value = s.value.replace(/^\s+/, "")), !Array.isArray(s) && s.type === "element")) {
          const o = s.children[0];
          o && o.type === "text" && (o.value = o.value.replace(/^\s+/, ""));
        }
        Array.isArray(s) ? n.push(...s) : n.push(s);
      }
    }
  }
  return n;
}
function dM(t, e) {
  const n = e.data || {}, r = "value" in e && !(dl.call(n, "hProperties") || dl.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: vf(t, e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function hM(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function pM(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.footnoteOrder.length; ) {
    const r = t.footnoteById[t.footnoteOrder[n]];
    if (!r)
      continue;
    const i = t.all(r), s = String(r.identifier).toUpperCase(), o = bs(s.toLowerCase());
    let a = 0;
    const l = [];
    for (; ++a <= t.footnoteCounts[s]; ) {
      const f = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t.clobberPrefix + "fnref-" + o + (a > 1 ? "-" + a : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: t.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      a > 1 && f.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(a) }]
      }), l.length > 0 && l.push({ type: "text", value: " " }), l.push(f);
    }
    const u = i[i.length - 1];
    if (u && u.type === "element" && u.tagName === "p") {
      const f = u.children[u.children.length - 1];
      f && f.type === "text" ? f.value += " " : u.children.push({ type: "text", value: " " }), u.children.push(...l);
    } else
      i.push(...l);
    const c = {
      type: "element",
      tagName: "li",
      properties: { id: t.clobberPrefix + "fn-" + o },
      children: t.wrap(i, !0)
    };
    t.patch(r, c), e.push(c);
  }
  if (e.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: t.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(t.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: t.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(e, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function c4(t, e) {
  const n = uM(t, e), r = n.one(t, null), i = pM(n);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
const mM = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(t, e) {
    return t && "run" in t ? TM(t, e) : EM(t || e);
  }
), gM = mM;
function TM(t, e) {
  return (n, r, i) => {
    t.run(c4(n, e), r, (s) => {
      i(s);
    });
  };
}
function EM(t) {
  return (e) => c4(e, t);
}
function f4(t) {
  const e = (
    /** @type {Options} */
    this.data("settings")
  ), n = Object.assign({}, e, t);
  Object.assign(this, { Compiler: r });
  function r(i) {
    return $5(i, n);
  }
}
const yM = {}.hasOwnProperty, d4 = ys("type", { handlers: { root: bM, element: kM, text: SM, comment: NM, doctype: xM } });
function AM(t, e) {
  const n = e && typeof e == "object" ? e.space : e;
  return d4(t, n === "svg" ? Xn : Ts);
}
function bM(t, e) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Df(t.children, n, e), Cs(t, n), n;
}
function CM(t, e) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Df(t.children, n, e), Cs(t, n), n;
}
function xM(t) {
  const e = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    // @ts-expect-error: change to `null` in a major?
    parentNode: void 0
  };
  return Cs(t, e), e;
}
function SM(t) {
  const e = {
    nodeName: "#text",
    value: t.value,
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return Cs(t, e), e;
}
function NM(t) {
  const e = {
    nodeName: "#comment",
    data: t.value,
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return Cs(t, e), e;
}
function kM(t, e) {
  const n = e;
  let r = n;
  t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Xn);
  const i = [];
  let s;
  if (t.properties) {
    for (s in t.properties)
      if (s !== "children" && yM.call(t.properties, s)) {
        const a = _M(
          r,
          s,
          t.properties[s]
        );
        a && i.push(a);
      }
  }
  const o = {
    nodeName: t.tagName,
    tagName: t.tagName,
    attrs: i,
    // @ts-expect-error: html and svg both have a space.
    namespaceURI: yo[r.space],
    childNodes: [],
    // @ts-expect-error: no `parentNode`
    parentNode: void 0
  };
  return o.childNodes = Df(t.children, o, r), Cs(t, o), t.tagName === "template" && t.content && (o.content = CM(t.content, r)), o;
}
function _M(t, e, n) {
  const r = Oo(t, e);
  if (n == null || n === !1 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? hf(n) : df(n));
  const i = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const s = i.name.indexOf(":");
    s < 0 ? i.prefix = "" : (i.name = i.name.slice(s + 1), i.prefix = r.attribute.slice(0, s)), i.namespace = yo[r.space];
  }
  return i;
}
function Df(t, e, n) {
  let r = -1;
  const i = [];
  if (t)
    for (; ++r < t.length; ) {
      const s = d4(t[r], n);
      s.parentNode = e, i.push(s);
    }
  return i;
}
function Cs(t, e) {
  const n = t.position;
  n && n.start && n.end && (e.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    // @ts-expect-error assume this is set.
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    // @ts-expect-error assume this is set.
    endOffset: n.end.offset
  });
}
const OM = "IN_TEMPLATE_MODE", wM = "DATA_STATE", vM = "CHARACTER_TOKEN", DM = "START_TAG_TOKEN", MM = "END_TAG_TOKEN", IM = "COMMENT_TOKEN", RM = "DOCTYPE_TOKEN", LM = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }, h4 = (
  /**
   * @type {(
   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &
   *   ((tree: Node, options?: Options) => Node)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {VFile} [file]
   * @param {Options} [options]
   */
  function(t, e, n) {
    let r = -1;
    const i = new E2(LM), s = ys("type", {
      handlers: { root: g, element: T, text: E, comment: k, doctype: _, raw: A },
      // @ts-expect-error: hush.
      unknown: HM
    });
    let o, a, l, u, c;
    if (qM(e) && (n = e, e = void 0), n && n.passThrough)
      for (; ++r < n.passThrough.length; )
        s.handlers[n.passThrough[r]] = v;
    const f = v2(
      UM(t) ? h() : d(),
      e
    );
    if (o && Jt(f, "comment", (b, O, P) => {
      const $ = (
        /** @type {Stitch} */
        /** @type {unknown} */
        b
      );
      if ($.value.stitch && P !== null && O !== null)
        return P.children[O] = $.value.stitch, O;
    }), t.type !== "root" && f.type === "root" && f.children.length === 1)
      return f.children[0];
    return f;
    function d() {
      const b = {
        nodeName: "template",
        tagName: "template",
        attrs: [],
        namespaceURI: yo.html,
        childNodes: []
      }, O = {
        nodeName: "documentmock",
        tagName: "documentmock",
        attrs: [],
        namespaceURI: yo.html,
        childNodes: []
      }, P = { nodeName: "#document-fragment", childNodes: [] };
      if (i._bootstrap(O, b), i._pushTmplInsertionMode(OM), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), a = i.tokenizer, !a)
        throw new Error("Expected `tokenizer`");
      return l = a.preprocessor, c = a.__mixins[0], u = c.posTracker, s(t), y(), i._adoptNodes(O.childNodes[0], P), P;
    }
    function h() {
      const b = i.treeAdapter.createDocument();
      if (i._bootstrap(b, void 0), a = i.tokenizer, !a)
        throw new Error("Expected `tokenizer`");
      return l = a.preprocessor, c = a.__mixins[0], u = c.posTracker, s(t), y(), b;
    }
    function m(b) {
      let O = -1;
      if (b)
        for (; ++O < b.length; )
          s(b[O]);
    }
    function g(b) {
      m(b.children);
    }
    function T(b) {
      y(), i._processInputToken(PM(b)), m(b.children), L5.includes(b.tagName) || (y(), i._processInputToken(FM(b)));
    }
    function E(b) {
      y(), i._processInputToken({
        type: vM,
        chars: b.value,
        location: ji(b)
      });
    }
    function _(b) {
      y(), i._processInputToken({
        type: RM,
        name: "html",
        forceQuirks: !1,
        publicId: "",
        systemId: "",
        location: ji(b)
      });
    }
    function k(b) {
      y(), i._processInputToken({
        type: IM,
        data: b.value,
        location: ji(b)
      });
    }
    function A(b) {
      const O = vo(b), P = O.line || 1, $ = O.column || 1, M = O.offset || 0;
      if (!l)
        throw new Error("Expected `preprocessor`");
      if (!a)
        throw new Error("Expected `tokenizer`");
      if (!u)
        throw new Error("Expected `posTracker`");
      if (!c)
        throw new Error("Expected `locationTracker`");
      l.html = void 0, l.pos = -1, l.lastGapPos = -1, l.lastCharPos = -1, l.gapStack = [], l.skipNextNewLine = !1, l.lastChunkWritten = !1, l.endOfChunkHit = !1, u.isEol = !1, u.lineStartPos = -$ + 1, u.droppedBufferSize = M, u.offset = 0, u.col = 1, u.line = P, c.currentAttrLocation = void 0, c.ctLoc = ji(b), a.write(b.value), i._runParsingLoop(null), (a.state === "NAMED_CHARACTER_REFERENCE_STATE" || a.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") && (l.lastChunkWritten = !0, a[a.state](a._consume()));
    }
    function v(b) {
      o = !0;
      let O;
      "children" in b ? O = {
        ...b,
        children: h4(
          { type: "root", children: b.children },
          e,
          n
          // @ts-expect-error Assume a given parent yields a parent.
        ).children
      } : O = { ...b }, k({ type: "comment", value: { stitch: O } });
    }
    function y() {
      if (!a)
        throw new Error("Expected `tokenizer`");
      if (!u)
        throw new Error("Expected `posTracker`");
      const b = a.currentCharacterToken;
      b && (b.location.endLine = u.line, b.location.endCol = u.col + 1, b.location.endOffset = u.offset + 1, i._processInputToken(b)), a.tokenQueue = [], a.state = wM, a.returnState = "", a.charRefCode = -1, a.tempBuff = [], a.lastStartTagName = "", a.consumedAfterSnapshot = -1, a.active = !1, a.currentCharacterToken = void 0, a.currentToken = void 0, a.currentAttr = void 0;
    }
  }
);
function PM(t) {
  const e = Object.assign(ji(t));
  return e.startTag = Object.assign({}, e), {
    type: DM,
    tagName: t.tagName,
    selfClosing: !1,
    attrs: BM(t),
    location: e
  };
}
function BM(t) {
  return AM({
    tagName: t.tagName,
    type: "element",
    properties: t.properties,
    children: []
    // @ts-expect-error Assume element.
  }).attrs;
}
function FM(t) {
  const e = Object.assign(ji(t));
  return e.startTag = Object.assign({}, e), {
    type: MM,
    tagName: t.tagName,
    attrs: [],
    location: e
  };
}
function HM(t) {
  throw new Error("Cannot compile `" + t.type + "` node");
}
function UM(t) {
  const e = t.type === "root" ? t.children[0] : t;
  return Boolean(
    e && (e.type === "doctype" || e.type === "element" && e.tagName === "html")
  );
}
function ji(t) {
  const e = vo(t), n = Kl(t);
  return {
    startLine: e.line,
    startCol: e.column,
    startOffset: e.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function qM(t) {
  return Boolean(t && !("message" in t && "messages" in t));
}
function p4(t = {}) {
  return (e, n) => (
    /** @type {Root} */
    h4(e, n, t)
  );
}
const zM = [
  "pre",
  "script",
  "style",
  "textarea"
], $M = R2({ newlines: !0 });
function m4(t = {}) {
  let e = t.indent || 2, n = t.indentInitial;
  return typeof e == "number" && (e = " ".repeat(e)), n == null && (n = !0), (s) => {
    let o;
    $M(s), Ef(s, (a, l) => {
      let u = -1;
      if (!("children" in a))
        return;
      if (Sr(a, "head") && (o = !0), o && Sr(a, "body") && (o = void 0), Sr(a, zM))
        return Hl;
      const c = a.children;
      let f = l.length;
      if (c.length === 0 || !hu(a, o))
        return;
      n || f--;
      let d;
      for (; ++u < c.length; ) {
        const g = c[u];
        (g.type === "text" || g.type === "comment") && (g.value.includes(`
`) && (d = !0), g.value = g.value.replace(
          / *\n/g,
          "$&" + String(e).repeat(f)
        ));
      }
      const h = [];
      let m;
      for (u = -1; ++u < c.length; ) {
        const g = c[u];
        (hu(g, o) || d && !u) && (r(h, f, g), d = !0), m = g, h.push(g);
      }
      m && (d || hu(m, o)) && (Nr(m) && (h.pop(), m = h[h.length - 1]), r(h, f - 1)), a.children = h;
    });
  };
  function r(s, o, a) {
    const l = s[s.length - 1], u = Nr(l) ? s[s.length - 2] : l, c = (i(u) && i(a) ? `

` : `
`) + String(e).repeat(Math.max(o, 0));
    l && l.type === "text" ? l.value = Nr(l) ? c : l.value + c : s.push({ type: "text", value: c });
  }
  function i(s) {
    return Boolean(
      s && s.type === "element" && t.blanks && t.blanks.length > 0 && t.blanks.includes(s.tagName)
    );
  }
}
function hu(t, e) {
  return t.type === "root" || (t.type === "element" ? e || Sr(t, "script") || gf(t) || !U2(t) : !1);
}
const pu = /[\t ]*(?:\r?\n|\r)/g;
function VM() {
  return (t) => {
    Jt(t, "text", (e, n, r) => {
      const i = [];
      let s = 0;
      pu.lastIndex = 0;
      let o = pu.exec(e.value);
      for (; o; ) {
        const a = o.index;
        s !== a && i.push({ type: "text", value: e.value.slice(s, a) }), i.push({ type: "break" }), s = a + o[0].length, o = pu.exec(e.value);
      }
      if (i.length > 0 && r && typeof n == "number")
        return s < e.value.length && i.push({ type: "text", value: e.value.slice(s) }), r.children.splice(n, 1, ...i), n + i.length;
    });
  };
}
function Mf(t, e, n, r, i, s, o, a, l, u, c, f, d, h, m) {
  let g, T;
  return E;
  function E(w) {
    return t.enter(r), t.enter(i), t.consume(w), t.exit(i), _;
  }
  function _(w) {
    return w === 35 ? (g = o, k(w)) : w === 46 ? (g = a, k(w)) : w === 58 || w === 95 || jt(w) ? (t.enter(s), t.enter(l), t.consume(w), y) : m && De(w) ? Te(t, _, "whitespace")(w) : !m && ze(w) ? Wn(t, _)(w) : Y(w);
  }
  function k(w) {
    return t.enter(s), t.enter(g), t.enter(g + "Marker"), t.consume(w), t.exit(g + "Marker"), A;
  }
  function A(w) {
    return w === null || w === 34 || w === 35 || w === 39 || w === 46 || w === 60 || w === 61 || w === 62 || w === 96 || w === 125 || ze(w) ? n(w) : (t.enter(g + "Value"), t.consume(w), v);
  }
  function v(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 35 || w === 46 || w === 125 || ze(w) ? (t.exit(g + "Value"), t.exit(g), t.exit(s), _(w)) : (t.consume(w), v);
  }
  function y(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || dt(w) ? (t.consume(w), y) : (t.exit(l), m && De(w) ? Te(t, b, "whitespace")(w) : !m && ze(w) ? Wn(t, b)(w) : b(w));
  }
  function b(w) {
    return w === 61 ? (t.enter(u), t.consume(w), t.exit(u), O) : (t.exit(s), _(w));
  }
  function O(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 || w === 125 || m && ee(w) ? n(w) : w === 34 || w === 39 ? (t.enter(c), t.enter(d), t.consume(w), t.exit(d), T = w, $) : m && De(w) ? Te(t, O, "whitespace")(w) : !m && ze(w) ? Wn(t, O)(w) : (t.enter(f), t.enter(h), t.consume(w), T = void 0, P);
  }
  function P(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 125 || ze(w) ? (t.exit(h), t.exit(f), t.exit(s), _(w)) : (t.consume(w), P);
  }
  function $(w) {
    return w === T ? (t.enter(d), t.consume(w), t.exit(d), t.exit(c), t.exit(s), V) : (t.enter(f), M(w));
  }
  function M(w) {
    return w === T ? (t.exit(f), $(w)) : w === null ? n(w) : ee(w) ? m ? n(w) : Wn(t, M)(w) : (t.enter(h), t.consume(w), R);
  }
  function R(w) {
    return w === T || w === null || ee(w) ? (t.exit(h), M(w)) : (t.consume(w), R);
  }
  function V(w) {
    return w === 125 || ze(w) ? _(w) : Y(w);
  }
  function Y(w) {
    return w === 125 ? (t.enter(i), t.consume(w), t.exit(i), t.exit(r), e) : n(w);
  }
}
function If(t, e, n, r, i, s, o) {
  let a = 0, l = 0, u;
  return c;
  function c(T) {
    return t.enter(r), t.enter(i), t.consume(T), t.exit(i), f;
  }
  function f(T) {
    return T === 93 ? (t.enter(i), t.consume(T), t.exit(i), t.exit(r), e) : (t.enter(s), d(T));
  }
  function d(T) {
    if (T === 93 && !l)
      return g(T);
    const E = t.enter("chunkText", {
      contentType: "text",
      previous: u
    });
    return u && (u.next = E), u = E, h(T);
  }
  function h(T) {
    return T === null || a > 999 || T === 91 && ++l > 32 ? n(T) : T === 93 && !l-- ? (t.exit("chunkText"), g(T)) : ee(T) ? o ? n(T) : (t.consume(T), t.exit("chunkText"), d) : (t.consume(T), T === 92 ? m : h);
  }
  function m(T) {
    return T === 91 || T === 92 || T === 93 ? (t.consume(T), a++, h) : h(T);
  }
  function g(T) {
    return t.exit(s), t.enter(i), t.consume(T), t.exit(i), t.exit(r), e;
  }
}
function Rf(t, e, n, r) {
  const i = this;
  return s;
  function s(a) {
    return jt(a) ? (t.enter(r), t.consume(a), o) : n(a);
  }
  function o(a) {
    return a === 45 || a === 95 || dt(a) ? (t.consume(a), o) : (t.exit(r), i.previous === 45 || i.previous === 95 ? n(a) : e(a));
  }
}
const GM = {
  tokenize: WM,
  concrete: !0
}, jM = {
  tokenize: YM,
  partial: !0
}, KM = {
  tokenize: QM,
  partial: !0
}, Jm = {
  tokenize: JM,
  partial: !0
};
function WM(t, e, n) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0, a;
  return l;
  function l(b) {
    return t.enter("directiveContainer"), t.enter("directiveContainerFence"), t.enter("directiveContainerSequence"), u(b);
  }
  function u(b) {
    return b === 58 ? (t.consume(b), o++, u) : o < 3 ? n(b) : (t.exit("directiveContainerSequence"), Rf.call(
      r,
      t,
      c,
      n,
      "directiveContainerName"
    )(b));
  }
  function c(b) {
    return b === 91 ? t.attempt(jM, f, f)(b) : f(b);
  }
  function f(b) {
    return b === 123 ? t.attempt(KM, d, d)(b) : d(b);
  }
  function d(b) {
    return Te(t, h, "whitespace")(b);
  }
  function h(b) {
    return t.exit("directiveContainerFence"), b === null ? m(b) : ee(b) ? r.interrupt ? e(b) : t.attempt(Jm, g, m)(b) : n(b);
  }
  function m(b) {
    return t.exit("directiveContainer"), e(b);
  }
  function g(b) {
    return b === null ? (t.exit("directiveContainer"), e(b)) : (t.enter("directiveContainerContent"), T(b));
  }
  function T(b) {
    return b === null ? v(b) : t.attempt(
      {
        tokenize: y,
        partial: !0
      },
      v,
      s ? Te(t, E, "linePrefix", s + 1) : E
    )(b);
  }
  function E(b) {
    if (b === null)
      return v(b);
    const O = t.enter("chunkDocument", {
      contentType: "document",
      previous: a
    });
    return a && (a.next = O), a = O, _(b);
  }
  function _(b) {
    if (b === null) {
      const O = t.exit("chunkDocument");
      return r.parser.lazy[O.start.line] = !1, v(b);
    }
    return ee(b) ? t.check(Jm, k, A)(b) : (t.consume(b), _);
  }
  function k(b) {
    t.consume(b);
    const O = t.exit("chunkDocument");
    return r.parser.lazy[O.start.line] = !1, T;
  }
  function A(b) {
    const O = t.exit("chunkDocument");
    return r.parser.lazy[O.start.line] = !1, v(b);
  }
  function v(b) {
    return t.exit("directiveContainerContent"), t.exit("directiveContainer"), e(b);
  }
  function y(b, O, P) {
    let $ = 0;
    return Te(b, M, "linePrefix", 4);
    function M(Y) {
      return b.enter("directiveContainerFence"), b.enter("directiveContainerSequence"), R(Y);
    }
    function R(Y) {
      return Y === 58 ? (b.consume(Y), $++, R) : $ < o ? P(Y) : (b.exit("directiveContainerSequence"), Te(b, V, "whitespace")(Y));
    }
    function V(Y) {
      return Y === null || ee(Y) ? (b.exit("directiveContainerFence"), O(Y)) : P(Y);
    }
  }
}
function YM(t, e, n) {
  return If(
    t,
    e,
    n,
    "directiveContainerLabel",
    "directiveContainerLabelMarker",
    "directiveContainerLabelString",
    !0
  );
}
function QM(t, e, n) {
  return Mf(
    t,
    e,
    n,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    !0
  );
}
function JM(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), s;
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? n(o) : e(o);
  }
}
const XM = {
  tokenize: tI
}, ZM = {
  tokenize: nI,
  partial: !0
}, eI = {
  tokenize: rI,
  partial: !0
};
function tI(t, e, n) {
  const r = this;
  return i;
  function i(c) {
    return t.enter("directiveLeaf"), t.enter("directiveLeafSequence"), t.consume(c), s;
  }
  function s(c) {
    return c === 58 ? (t.consume(c), t.exit("directiveLeafSequence"), Rf.call(
      r,
      t,
      o,
      n,
      "directiveLeafName"
    )) : n(c);
  }
  function o(c) {
    return c === 91 ? t.attempt(ZM, a, a)(c) : a(c);
  }
  function a(c) {
    return c === 123 ? t.attempt(eI, l, l)(c) : l(c);
  }
  function l(c) {
    return Te(t, u, "whitespace")(c);
  }
  function u(c) {
    return c === null || ee(c) ? (t.exit("directiveLeaf"), e(c)) : n(c);
  }
}
function nI(t, e, n) {
  return If(
    t,
    e,
    n,
    "directiveLeafLabel",
    "directiveLeafLabelMarker",
    "directiveLeafLabelString",
    !0
  );
}
function rI(t, e, n) {
  return Mf(
    t,
    e,
    n,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    !0
  );
}
const iI = {
  tokenize: lI,
  previous: aI
}, sI = {
  tokenize: uI,
  partial: !0
}, oI = {
  tokenize: cI,
  partial: !0
};
function aI(t) {
  return t !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function lI(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return t.enter("directiveText"), t.enter("directiveTextMarker"), t.consume(l), t.exit("directiveTextMarker"), Rf.call(r, t, s, n, "directiveTextName");
  }
  function s(l) {
    return l === 58 ? n(l) : l === 91 ? t.attempt(sI, o, o)(l) : o(l);
  }
  function o(l) {
    return l === 123 ? t.attempt(oI, a, a)(l) : a(l);
  }
  function a(l) {
    return t.exit("directiveText"), e(l);
  }
}
function uI(t, e, n) {
  return If(
    t,
    e,
    n,
    "directiveTextLabel",
    "directiveTextLabelMarker",
    "directiveTextLabelString"
  );
}
function cI(t, e, n) {
  return Mf(
    t,
    e,
    n,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}
function fI() {
  return {
    text: {
      [58]: iI
    },
    flow: {
      [58]: [GM, XM]
    }
  };
}
const Xm = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function g4(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 48 && e <= 57;
}
function dI(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 102 || e >= 65 && e <= 70 || e >= 48 && e <= 57;
}
function hI(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function Zm(t) {
  return hI(t) || g4(t);
}
const Mi = String.fromCharCode, pI = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function Lf(t, e = {}) {
  const n = typeof e.additional == "string" ? e.additional.charCodeAt(0) : e.additional, r = [];
  let i = 0, s = -1, o = "", a, l;
  e.position && ("start" in e.position || "indent" in e.position ? (l = e.position.indent, a = e.position.start) : a = e.position);
  let u = (a ? a.line : 0) || 1, c = (a ? a.column : 0) || 1, f = h(), d;
  for (i--; ++i <= t.length; )
    if (d === 10 && (c = (l ? l[s] : 0) || 1), d = t.charCodeAt(i), d === 38) {
      const T = t.charCodeAt(i + 1);
      if (T === 9 || T === 10 || T === 12 || T === 32 || T === 38 || T === 60 || Number.isNaN(T) || n && T === n) {
        o += Mi(d), c++;
        continue;
      }
      const E = i + 1;
      let _ = E, k = E, A;
      if (T === 35) {
        k = ++_;
        const R = t.charCodeAt(k);
        R === 88 || R === 120 ? (A = "hexadecimal", k = ++_) : A = "decimal";
      } else
        A = "named";
      let v = "", y = "", b = "";
      const O = A === "named" ? Zm : A === "decimal" ? g4 : dI;
      for (k--; ++k <= t.length; ) {
        const R = t.charCodeAt(k);
        if (!O(R))
          break;
        b += Mi(R), A === "named" && B5.includes(b) && (v = b, y = bo(b));
      }
      let P = t.charCodeAt(k) === 59;
      if (P) {
        k++;
        const R = A === "named" ? bo(b) : !1;
        R && (v = b, y = R);
      }
      let $ = 1 + k - E, M = "";
      if (!(!P && e.nonTerminated === !1))
        if (!b)
          A !== "named" && m(4, $);
        else if (A === "named") {
          if (P && !y)
            m(5, 1);
          else if (v !== b && (k = _ + v.length, $ = 1 + k - _, P = !1), !P) {
            const R = v ? 1 : 3;
            if (e.attribute) {
              const V = t.charCodeAt(k);
              V === 61 ? (m(R, $), y = "") : Zm(V) ? y = "" : m(R, $);
            } else
              m(R, $);
          }
          M = y;
        } else {
          P || m(2, $);
          let R = Number.parseInt(
            b,
            A === "hexadecimal" ? 16 : 10
          );
          if (mI(R))
            m(7, $), M = Mi(
              65533
              /* `�` */
            );
          else if (R in Xm)
            m(6, $), M = Xm[R];
          else {
            let V = "";
            gI(R) && m(6, $), R > 65535 && (R -= 65536, V += Mi(R >>> 10 | 55296), R = 56320 | R & 1023), M = V + Mi(R);
          }
        }
      if (M) {
        g(), f = h(), i = k - 1, c += k - E + 1, r.push(M);
        const R = h();
        R.offset++, e.reference && e.reference.call(
          e.referenceContext,
          M,
          { start: f, end: R },
          t.slice(E - 1, k)
        ), f = R;
      } else
        b = t.slice(E - 1, k), o += b, c += b.length, i = k - 1;
    } else
      d === 10 && (u++, s++, c = 0), Number.isNaN(d) ? g() : (o += Mi(d), c++);
  return r.join("");
  function h() {
    return {
      line: u,
      column: c,
      offset: i + ((a ? a.offset : 0) || 0)
    };
  }
  function m(T, E) {
    let _;
    e.warning && (_ = h(), _.column += E, _.offset += E, e.warning.call(
      e.warningContext,
      pI[T],
      _,
      T
    ));
  }
  function g() {
    o && (r.push(o), e.text && e.text.call(e.textContext, o, {
      start: f,
      end: h()
    }), o = "");
  }
}
function mI(t) {
  return t >= 55296 && t <= 57343 || t > 1114111;
}
function gI(t) {
  return t >= 1 && t <= 8 || t === 11 || t >= 13 && t <= 31 || t >= 127 && t <= 159 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534;
}
const TI = {}.hasOwnProperty, e0 = /^[^\t\n\r "#'.<=>`}]+$/;
Sa.peek = NI;
const EI = {
  canContainEols: ["textDirective"],
  enter: {
    directiveContainer: AI,
    directiveContainerAttributes: gu,
    directiveContainerLabel: xI,
    directiveLeaf: bI,
    directiveLeafAttributes: gu,
    directiveText: CI,
    directiveTextAttributes: gu
  },
  exit: {
    directiveContainer: Cu,
    directiveContainerAttributeClassValue: Eu,
    directiveContainerAttributeIdValue: Tu,
    directiveContainerAttributeName: Au,
    directiveContainerAttributeValue: yu,
    directiveContainerAttributes: bu,
    directiveContainerLabel: SI,
    directiveContainerName: mu,
    directiveLeaf: Cu,
    directiveLeafAttributeClassValue: Eu,
    directiveLeafAttributeIdValue: Tu,
    directiveLeafAttributeName: Au,
    directiveLeafAttributeValue: yu,
    directiveLeafAttributes: bu,
    directiveLeafName: mu,
    directiveText: Cu,
    directiveTextAttributeClassValue: Eu,
    directiveTextAttributeIdValue: Tu,
    directiveTextAttributeName: Au,
    directiveTextAttributeValue: yu,
    directiveTextAttributes: bu,
    directiveTextName: mu
  }
}, yI = {
  unsafe: [
    {
      character: "\r",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      character: `
`,
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      before: "[^:]",
      character: ":",
      after: "[A-Za-z]",
      inConstruct: ["phrasing"]
    },
    { atBreak: !0, character: ":", after: ":" }
  ],
  handlers: {
    containerDirective: Sa,
    leafDirective: Sa,
    textDirective: Sa
  }
};
function AI(t) {
  Pf.call(this, "containerDirective", t);
}
function bI(t) {
  Pf.call(this, "leafDirective", t);
}
function CI(t) {
  Pf.call(this, "textDirective", t);
}
function Pf(t, e) {
  this.enter({ type: t, name: "", attributes: {}, children: [] }, e);
}
function mu(t) {
  const e = (
    /** @type {Directive} */
    this.stack[this.stack.length - 1]
  );
  e.name = this.sliceSerialize(t);
}
function xI(t) {
  this.enter(
    { type: "paragraph", data: { directiveLabel: !0 }, children: [] },
    t
  );
}
function SI(t) {
  this.exit(t);
}
function gu() {
  this.setData("directiveAttributes", []), this.buffer();
}
function Tu(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([
    "id",
    Lf(this.sliceSerialize(t), {
      attribute: !0
    })
  ]);
}
function Eu(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([
    "class",
    Lf(this.sliceSerialize(t), {
      attribute: !0
    })
  ]);
}
function yu(t) {
  const e = (
    /** @type {Array<[string, string]>} */
    this.getData("directiveAttributes")
  );
  e[e.length - 1][1] = Lf(this.sliceSerialize(t), {
    attribute: !0
  });
}
function Au(t) {
  /** @type {Array<[string, string]>} */
  this.getData("directiveAttributes").push([this.sliceSerialize(t), ""]);
}
function bu() {
  const t = (
    /** @type {Array<[string, string]>} */
    this.getData("directiveAttributes")
  ), e = {};
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n];
    i[0] === "class" && e.class ? e.class += " " + i[1] : e[i[0]] = i[1];
  }
  this.setData("directiveAttributes"), this.resume();
  const r = (
    /** @type {Directive} */
    this.stack[this.stack.length - 1]
  );
  r.attributes = e;
}
function Cu(t) {
  this.exit(t);
}
function Sa(t, e, n, r) {
  const i = Cf(r), s = _I(t), o = n.enter(t.type);
  let a = i.move(s + (t.name || "")), l;
  if (t.type === "containerDirective") {
    const u = (t.children || [])[0];
    l = t0(u) ? u : void 0;
  } else
    l = t;
  if (l && l.children && l.children.length > 0) {
    const u = n.enter("label"), c = `${t.type}Label`, f = n.enter(c);
    a += i.move("["), a += i.move(
      bf(l, n, {
        ...i.current(),
        before: a,
        after: "]"
      })
    ), a += i.move("]"), f(), u();
  }
  if (a += i.move(kI(t, n)), t.type === "containerDirective") {
    const u = (t.children || [])[0];
    let c = t;
    t0(u) && (c = Object.assign({}, t, { children: t.children.slice(1) })), c && c.children && c.children.length > 0 && (a += i.move(`
`), a += i.move(g5(c, n, i.current()))), a += i.move(`
` + s);
  }
  return o(), a;
}
function NI() {
  return ":";
}
function kI(t, e) {
  const n = zl(e), r = t.type === "textDirective" ? [n] : [n, `
`, "\r"], i = t.attributes || {}, s = [];
  let o, a, l, u;
  for (u in i)
    if (TI.call(i, u) && i[u] !== void 0 && i[u] !== null) {
      const f = String(i[u]);
      if (u === "id")
        l = e0.test(f) ? "#" + f : c("id", f);
      else if (u === "class") {
        const d = f.split(/[\t\n\r ]+/g), h = [], m = [];
        let g = -1;
        for (; ++g < d.length; )
          (e0.test(d[g]) ? m : h).push(
            d[g]
          );
        o = h.length > 0 ? c("class", h.join(" ")) : "", a = m.length > 0 ? "." + m.join(".") : "";
      } else
        s.push(c(u, f));
    }
  return o && s.unshift(o), a && s.unshift(a), l && s.unshift(l), s.length > 0 ? "{" + s.join(" ") + "}" : "";
  function c(f, d) {
    return f + (d ? "=" + n + cw(d, { subset: r }) + n : "");
  }
}
function t0(t) {
  return Boolean(
    t && t.type === "paragraph" && t.data && t.data.directiveLabel
  );
}
function _I(t) {
  let e = 0;
  return t.type === "containerDirective" ? (Ef(t, function(n, r) {
    if (n.type === "containerDirective") {
      let i = r.length, s = 0;
      for (; i--; )
        r[i].type === "containerDirective" && s++;
      s > e && (e = s);
    }
  }), e += 3) : t.type === "leafDirective" ? e = 2 : e = 1, ":".repeat(e);
}
function OI() {
  const t = this.data();
  e("micromarkExtensions", fI()), e("fromMarkdownExtensions", EI), e("toMarkdownExtensions", yI);
  function e(n, r) {
    /** @type {unknown[]} */
    // Other extensions
    /* c8 ignore next 2 */
    (t[n] ? t[n] : t[n] = []).push(r);
  }
}
function wI(t, e) {
  return n(t, null, null);
  function n(r, i, s) {
    const o = Object.assign({}, e(r, i, s));
    return "children" in r && (o.children = r.children.map(function(a, l) {
      return n(a, l, r);
    })), o;
  }
}
const vI = (t) => {
  const { type: e } = t;
  return e === "textDirective" || e === "leafDirective" || e === "containerDirective";
}, DI = (t) => {
  if (vI(t)) {
    const { properties: e, tagName: n } = O2(t.name, t.attributes);
    return Object.assign(Object.assign({}, t), { data: {
      hName: n,
      hProperties: e
    } });
  }
  return t;
}, MI = (t) => wI(t, DI), II = () => MI, DR = async (t) => {
  const n = await Xc().use(ID).use(OI).use(II).use(VM).use(y5).use(gM, Vw).use(v5, j5).use(p4).use(R5, K5).use(m4).use(f4, G5).process(t);
  return String(n);
}, MR = async (t) => {
  const n = await Xc().use(M2, V5).use(p4).use(R5, K5).use(m4).use(f4, G5).process(t);
  return String(n);
};
var we;
(function(t) {
  t.Attribute = "attribute", t.Pseudo = "pseudo", t.PseudoElement = "pseudo-element", t.Tag = "tag", t.Universal = "universal", t.Adjacent = "adjacent", t.Child = "child", t.Descendant = "descendant", t.Parent = "parent", t.Sibling = "sibling", t.ColumnCombinator = "column-combinator";
})(we || (we = {}));
var Vt;
(function(t) {
  t.Any = "any", t.Element = "element", t.End = "end", t.Equals = "equals", t.Exists = "exists", t.Hyphen = "hyphen", t.Not = "not", t.Start = "start";
})(Vt || (Vt = {}));
const n0 = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, RI = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, LI = /* @__PURE__ */ new Map([
  [126, Vt.Element],
  [94, Vt.Start],
  [36, Vt.End],
  [42, Vt.Any],
  [33, Vt.Not],
  [124, Vt.Hyphen]
]), PI = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function BI(t) {
  switch (t.type) {
    case we.Adjacent:
    case we.Child:
    case we.Descendant:
    case we.Parent:
    case we.Sibling:
    case we.ColumnCombinator:
      return !0;
    default:
      return !1;
  }
}
const FI = /* @__PURE__ */ new Set(["contains", "icontains"]);
function HI(t, e, n) {
  const r = parseInt(e, 16) - 65536;
  return r !== r || n ? e : r < 0 ? (
    // BMP codepoint
    String.fromCharCode(r + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(r >> 10 | 55296, r & 1023 | 56320)
  );
}
function Ls(t) {
  return t.replace(RI, HI);
}
function xu(t) {
  return t === 39 || t === 34;
}
function r0(t) {
  return t === 32 || t === 9 || t === 10 || t === 12 || t === 13;
}
function UI(t) {
  const e = [], n = T4(e, `${t}`, 0);
  if (n < t.length)
    throw new Error(`Unmatched selector: ${t.slice(n)}`);
  return e;
}
function T4(t, e, n) {
  let r = [];
  function i(d) {
    const h = e.slice(n + d).match(n0);
    if (!h)
      throw new Error(`Expected name, found ${e.slice(n)}`);
    const [m] = h;
    return n += d + m.length, Ls(m);
  }
  function s(d) {
    for (n += d; n < e.length && r0(e.charCodeAt(n)); )
      n++;
  }
  function o() {
    n += 1;
    const d = n;
    let h = 1;
    for (; h > 0 && n < e.length; n++)
      e.charCodeAt(n) === 40 && !a(n) ? h++ : e.charCodeAt(n) === 41 && !a(n) && h--;
    if (h)
      throw new Error("Parenthesis not matched");
    return Ls(e.slice(d, n - 1));
  }
  function a(d) {
    let h = 0;
    for (; e.charCodeAt(--d) === 92; )
      h++;
    return (h & 1) === 1;
  }
  function l() {
    if (r.length > 0 && BI(r[r.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function u(d) {
    if (r.length > 0 && r[r.length - 1].type === we.Descendant) {
      r[r.length - 1].type = d;
      return;
    }
    l(), r.push({ type: d });
  }
  function c(d, h) {
    r.push({
      type: we.Attribute,
      name: d,
      action: h,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function f() {
    if (r.length && r[r.length - 1].type === we.Descendant && r.pop(), r.length === 0)
      throw new Error("Empty sub-selector");
    t.push(r);
  }
  if (s(0), e.length === n)
    return n;
  e:
    for (; n < e.length; ) {
      const d = e.charCodeAt(n);
      switch (d) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          (r.length === 0 || r[0].type !== we.Descendant) && (l(), r.push({ type: we.Descendant })), s(1);
          break;
        }
        case 62: {
          u(we.Child), s(1);
          break;
        }
        case 60: {
          u(we.Parent), s(1);
          break;
        }
        case 126: {
          u(we.Sibling), s(1);
          break;
        }
        case 43: {
          u(we.Adjacent), s(1);
          break;
        }
        case 46: {
          c("class", Vt.Element);
          break;
        }
        case 35: {
          c("id", Vt.Equals);
          break;
        }
        case 91: {
          s(1);
          let h, m = null;
          e.charCodeAt(n) === 124 ? h = i(1) : e.startsWith("*|", n) ? (m = "*", h = i(2)) : (h = i(0), e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 61 && (m = h, h = i(1))), s(0);
          let g = Vt.Exists;
          const T = LI.get(e.charCodeAt(n));
          if (T) {
            if (g = T, e.charCodeAt(n + 1) !== 61)
              throw new Error("Expected `=`");
            s(2);
          } else
            e.charCodeAt(n) === 61 && (g = Vt.Equals, s(1));
          let E = "", _ = null;
          if (g !== "exists") {
            if (xu(e.charCodeAt(n))) {
              const v = e.charCodeAt(n);
              let y = n + 1;
              for (; y < e.length && (e.charCodeAt(y) !== v || a(y)); )
                y += 1;
              if (e.charCodeAt(y) !== v)
                throw new Error("Attribute value didn't end");
              E = Ls(e.slice(n + 1, y)), n = y + 1;
            } else {
              const v = n;
              for (; n < e.length && (!r0(e.charCodeAt(n)) && e.charCodeAt(n) !== 93 || a(n)); )
                n += 1;
              E = Ls(e.slice(v, n));
            }
            s(0);
            const A = e.charCodeAt(n) | 32;
            A === 115 ? (_ = !1, s(1)) : A === 105 && (_ = !0, s(1));
          }
          if (e.charCodeAt(n) !== 93)
            throw new Error("Attribute selector didn't terminate");
          n += 1;
          const k = {
            type: we.Attribute,
            name: h,
            action: g,
            value: E,
            namespace: m,
            ignoreCase: _
          };
          r.push(k);
          break;
        }
        case 58: {
          if (e.charCodeAt(n + 1) === 58) {
            r.push({
              type: we.PseudoElement,
              name: i(2).toLowerCase(),
              data: e.charCodeAt(n) === 40 ? o() : null
            });
            continue;
          }
          const h = i(1).toLowerCase();
          let m = null;
          if (e.charCodeAt(n) === 40)
            if (PI.has(h)) {
              if (xu(e.charCodeAt(n + 1)))
                throw new Error(`Pseudo-selector ${h} cannot be quoted`);
              if (m = [], n = T4(m, e, n + 1), e.charCodeAt(n) !== 41)
                throw new Error(`Missing closing parenthesis in :${h} (${e})`);
              n += 1;
            } else {
              if (m = o(), FI.has(h)) {
                const g = m.charCodeAt(0);
                g === m.charCodeAt(m.length - 1) && xu(g) && (m = m.slice(1, -1));
              }
              m = Ls(m);
            }
          r.push({ type: we.Pseudo, name: h, data: m });
          break;
        }
        case 44: {
          f(), r = [], s(1);
          break;
        }
        default: {
          if (e.startsWith("/*", n)) {
            const g = e.indexOf("*/", n + 2);
            if (g < 0)
              throw new Error("Comment was not terminated");
            n = g + 2, r.length === 0 && s(0);
            break;
          }
          let h = null, m;
          if (d === 42)
            n += 1, m = "*";
          else if (d === 124) {
            if (m = "", e.charCodeAt(n + 1) === 124) {
              u(we.ColumnCombinator), s(2);
              break;
            }
          } else if (n0.test(e.slice(n)))
            m = i(0);
          else
            break e;
          e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 124 && (h = m, e.charCodeAt(n + 1) === 42 ? (m = "*", n += 2) : m = i(1)), r.push(m === "*" ? { type: we.Universal, namespace: h } : { type: we.Tag, name: m, namespace: h });
        }
      }
    }
  return f(), n;
}
var qI = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/, zI = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g, $I = {
  aacute: "á",
  Aacute: "Á",
  abreve: "ă",
  Abreve: "Ă",
  ac: "∾",
  acd: "∿",
  acE: "∾̳",
  acirc: "â",
  Acirc: "Â",
  acute: "´",
  acy: "а",
  Acy: "А",
  aelig: "æ",
  AElig: "Æ",
  af: "⁡",
  afr: "𝔞",
  Afr: "𝔄",
  agrave: "à",
  Agrave: "À",
  alefsym: "ℵ",
  aleph: "ℵ",
  alpha: "α",
  Alpha: "Α",
  amacr: "ā",
  Amacr: "Ā",
  amalg: "⨿",
  amp: "&",
  AMP: "&",
  and: "∧",
  And: "⩓",
  andand: "⩕",
  andd: "⩜",
  andslope: "⩘",
  andv: "⩚",
  ang: "∠",
  ange: "⦤",
  angle: "∠",
  angmsd: "∡",
  angmsdaa: "⦨",
  angmsdab: "⦩",
  angmsdac: "⦪",
  angmsdad: "⦫",
  angmsdae: "⦬",
  angmsdaf: "⦭",
  angmsdag: "⦮",
  angmsdah: "⦯",
  angrt: "∟",
  angrtvb: "⊾",
  angrtvbd: "⦝",
  angsph: "∢",
  angst: "Å",
  angzarr: "⍼",
  aogon: "ą",
  Aogon: "Ą",
  aopf: "𝕒",
  Aopf: "𝔸",
  ap: "≈",
  apacir: "⩯",
  ape: "≊",
  apE: "⩰",
  apid: "≋",
  apos: "'",
  ApplyFunction: "⁡",
  approx: "≈",
  approxeq: "≊",
  aring: "å",
  Aring: "Å",
  ascr: "𝒶",
  Ascr: "𝒜",
  Assign: "≔",
  ast: "*",
  asymp: "≈",
  asympeq: "≍",
  atilde: "ã",
  Atilde: "Ã",
  auml: "ä",
  Auml: "Ä",
  awconint: "∳",
  awint: "⨑",
  backcong: "≌",
  backepsilon: "϶",
  backprime: "‵",
  backsim: "∽",
  backsimeq: "⋍",
  Backslash: "∖",
  Barv: "⫧",
  barvee: "⊽",
  barwed: "⌅",
  Barwed: "⌆",
  barwedge: "⌅",
  bbrk: "⎵",
  bbrktbrk: "⎶",
  bcong: "≌",
  bcy: "б",
  Bcy: "Б",
  bdquo: "„",
  becaus: "∵",
  because: "∵",
  Because: "∵",
  bemptyv: "⦰",
  bepsi: "϶",
  bernou: "ℬ",
  Bernoullis: "ℬ",
  beta: "β",
  Beta: "Β",
  beth: "ℶ",
  between: "≬",
  bfr: "𝔟",
  Bfr: "𝔅",
  bigcap: "⋂",
  bigcirc: "◯",
  bigcup: "⋃",
  bigodot: "⨀",
  bigoplus: "⨁",
  bigotimes: "⨂",
  bigsqcup: "⨆",
  bigstar: "★",
  bigtriangledown: "▽",
  bigtriangleup: "△",
  biguplus: "⨄",
  bigvee: "⋁",
  bigwedge: "⋀",
  bkarow: "⤍",
  blacklozenge: "⧫",
  blacksquare: "▪",
  blacktriangle: "▴",
  blacktriangledown: "▾",
  blacktriangleleft: "◂",
  blacktriangleright: "▸",
  blank: "␣",
  blk12: "▒",
  blk14: "░",
  blk34: "▓",
  block: "█",
  bne: "=⃥",
  bnequiv: "≡⃥",
  bnot: "⌐",
  bNot: "⫭",
  bopf: "𝕓",
  Bopf: "𝔹",
  bot: "⊥",
  bottom: "⊥",
  bowtie: "⋈",
  boxbox: "⧉",
  boxdl: "┐",
  boxdL: "╕",
  boxDl: "╖",
  boxDL: "╗",
  boxdr: "┌",
  boxdR: "╒",
  boxDr: "╓",
  boxDR: "╔",
  boxh: "─",
  boxH: "═",
  boxhd: "┬",
  boxhD: "╥",
  boxHd: "╤",
  boxHD: "╦",
  boxhu: "┴",
  boxhU: "╨",
  boxHu: "╧",
  boxHU: "╩",
  boxminus: "⊟",
  boxplus: "⊞",
  boxtimes: "⊠",
  boxul: "┘",
  boxuL: "╛",
  boxUl: "╜",
  boxUL: "╝",
  boxur: "└",
  boxuR: "╘",
  boxUr: "╙",
  boxUR: "╚",
  boxv: "│",
  boxV: "║",
  boxvh: "┼",
  boxvH: "╪",
  boxVh: "╫",
  boxVH: "╬",
  boxvl: "┤",
  boxvL: "╡",
  boxVl: "╢",
  boxVL: "╣",
  boxvr: "├",
  boxvR: "╞",
  boxVr: "╟",
  boxVR: "╠",
  bprime: "‵",
  breve: "˘",
  Breve: "˘",
  brvbar: "¦",
  bscr: "𝒷",
  Bscr: "ℬ",
  bsemi: "⁏",
  bsim: "∽",
  bsime: "⋍",
  bsol: "\\",
  bsolb: "⧅",
  bsolhsub: "⟈",
  bull: "•",
  bullet: "•",
  bump: "≎",
  bumpe: "≏",
  bumpE: "⪮",
  bumpeq: "≏",
  Bumpeq: "≎",
  cacute: "ć",
  Cacute: "Ć",
  cap: "∩",
  Cap: "⋒",
  capand: "⩄",
  capbrcup: "⩉",
  capcap: "⩋",
  capcup: "⩇",
  capdot: "⩀",
  CapitalDifferentialD: "ⅅ",
  caps: "∩︀",
  caret: "⁁",
  caron: "ˇ",
  Cayleys: "ℭ",
  ccaps: "⩍",
  ccaron: "č",
  Ccaron: "Č",
  ccedil: "ç",
  Ccedil: "Ç",
  ccirc: "ĉ",
  Ccirc: "Ĉ",
  Cconint: "∰",
  ccups: "⩌",
  ccupssm: "⩐",
  cdot: "ċ",
  Cdot: "Ċ",
  cedil: "¸",
  Cedilla: "¸",
  cemptyv: "⦲",
  cent: "¢",
  centerdot: "·",
  CenterDot: "·",
  cfr: "𝔠",
  Cfr: "ℭ",
  chcy: "ч",
  CHcy: "Ч",
  check: "✓",
  checkmark: "✓",
  chi: "χ",
  Chi: "Χ",
  cir: "○",
  circ: "ˆ",
  circeq: "≗",
  circlearrowleft: "↺",
  circlearrowright: "↻",
  circledast: "⊛",
  circledcirc: "⊚",
  circleddash: "⊝",
  CircleDot: "⊙",
  circledR: "®",
  circledS: "Ⓢ",
  CircleMinus: "⊖",
  CirclePlus: "⊕",
  CircleTimes: "⊗",
  cire: "≗",
  cirE: "⧃",
  cirfnint: "⨐",
  cirmid: "⫯",
  cirscir: "⧂",
  ClockwiseContourIntegral: "∲",
  CloseCurlyDoubleQuote: "”",
  CloseCurlyQuote: "’",
  clubs: "♣",
  clubsuit: "♣",
  colon: ":",
  Colon: "∷",
  colone: "≔",
  Colone: "⩴",
  coloneq: "≔",
  comma: ",",
  commat: "@",
  comp: "∁",
  compfn: "∘",
  complement: "∁",
  complexes: "ℂ",
  cong: "≅",
  congdot: "⩭",
  Congruent: "≡",
  conint: "∮",
  Conint: "∯",
  ContourIntegral: "∮",
  copf: "𝕔",
  Copf: "ℂ",
  coprod: "∐",
  Coproduct: "∐",
  copy: "©",
  COPY: "©",
  copysr: "℗",
  CounterClockwiseContourIntegral: "∳",
  crarr: "↵",
  cross: "✗",
  Cross: "⨯",
  cscr: "𝒸",
  Cscr: "𝒞",
  csub: "⫏",
  csube: "⫑",
  csup: "⫐",
  csupe: "⫒",
  ctdot: "⋯",
  cudarrl: "⤸",
  cudarrr: "⤵",
  cuepr: "⋞",
  cuesc: "⋟",
  cularr: "↶",
  cularrp: "⤽",
  cup: "∪",
  Cup: "⋓",
  cupbrcap: "⩈",
  cupcap: "⩆",
  CupCap: "≍",
  cupcup: "⩊",
  cupdot: "⊍",
  cupor: "⩅",
  cups: "∪︀",
  curarr: "↷",
  curarrm: "⤼",
  curlyeqprec: "⋞",
  curlyeqsucc: "⋟",
  curlyvee: "⋎",
  curlywedge: "⋏",
  curren: "¤",
  curvearrowleft: "↶",
  curvearrowright: "↷",
  cuvee: "⋎",
  cuwed: "⋏",
  cwconint: "∲",
  cwint: "∱",
  cylcty: "⌭",
  dagger: "†",
  Dagger: "‡",
  daleth: "ℸ",
  darr: "↓",
  dArr: "⇓",
  Darr: "↡",
  dash: "‐",
  dashv: "⊣",
  Dashv: "⫤",
  dbkarow: "⤏",
  dblac: "˝",
  dcaron: "ď",
  Dcaron: "Ď",
  dcy: "д",
  Dcy: "Д",
  dd: "ⅆ",
  DD: "ⅅ",
  ddagger: "‡",
  ddarr: "⇊",
  DDotrahd: "⤑",
  ddotseq: "⩷",
  deg: "°",
  Del: "∇",
  delta: "δ",
  Delta: "Δ",
  demptyv: "⦱",
  dfisht: "⥿",
  dfr: "𝔡",
  Dfr: "𝔇",
  dHar: "⥥",
  dharl: "⇃",
  dharr: "⇂",
  DiacriticalAcute: "´",
  DiacriticalDot: "˙",
  DiacriticalDoubleAcute: "˝",
  DiacriticalGrave: "`",
  DiacriticalTilde: "˜",
  diam: "⋄",
  diamond: "⋄",
  Diamond: "⋄",
  diamondsuit: "♦",
  diams: "♦",
  die: "¨",
  DifferentialD: "ⅆ",
  digamma: "ϝ",
  disin: "⋲",
  div: "÷",
  divide: "÷",
  divideontimes: "⋇",
  divonx: "⋇",
  djcy: "ђ",
  DJcy: "Ђ",
  dlcorn: "⌞",
  dlcrop: "⌍",
  dollar: "$",
  dopf: "𝕕",
  Dopf: "𝔻",
  dot: "˙",
  Dot: "¨",
  DotDot: "⃜",
  doteq: "≐",
  doteqdot: "≑",
  DotEqual: "≐",
  dotminus: "∸",
  dotplus: "∔",
  dotsquare: "⊡",
  doublebarwedge: "⌆",
  DoubleContourIntegral: "∯",
  DoubleDot: "¨",
  DoubleDownArrow: "⇓",
  DoubleLeftArrow: "⇐",
  DoubleLeftRightArrow: "⇔",
  DoubleLeftTee: "⫤",
  DoubleLongLeftArrow: "⟸",
  DoubleLongLeftRightArrow: "⟺",
  DoubleLongRightArrow: "⟹",
  DoubleRightArrow: "⇒",
  DoubleRightTee: "⊨",
  DoubleUpArrow: "⇑",
  DoubleUpDownArrow: "⇕",
  DoubleVerticalBar: "∥",
  downarrow: "↓",
  Downarrow: "⇓",
  DownArrow: "↓",
  DownArrowBar: "⤓",
  DownArrowUpArrow: "⇵",
  DownBreve: "̑",
  downdownarrows: "⇊",
  downharpoonleft: "⇃",
  downharpoonright: "⇂",
  DownLeftRightVector: "⥐",
  DownLeftTeeVector: "⥞",
  DownLeftVector: "↽",
  DownLeftVectorBar: "⥖",
  DownRightTeeVector: "⥟",
  DownRightVector: "⇁",
  DownRightVectorBar: "⥗",
  DownTee: "⊤",
  DownTeeArrow: "↧",
  drbkarow: "⤐",
  drcorn: "⌟",
  drcrop: "⌌",
  dscr: "𝒹",
  Dscr: "𝒟",
  dscy: "ѕ",
  DScy: "Ѕ",
  dsol: "⧶",
  dstrok: "đ",
  Dstrok: "Đ",
  dtdot: "⋱",
  dtri: "▿",
  dtrif: "▾",
  duarr: "⇵",
  duhar: "⥯",
  dwangle: "⦦",
  dzcy: "џ",
  DZcy: "Џ",
  dzigrarr: "⟿",
  eacute: "é",
  Eacute: "É",
  easter: "⩮",
  ecaron: "ě",
  Ecaron: "Ě",
  ecir: "≖",
  ecirc: "ê",
  Ecirc: "Ê",
  ecolon: "≕",
  ecy: "э",
  Ecy: "Э",
  eDDot: "⩷",
  edot: "ė",
  eDot: "≑",
  Edot: "Ė",
  ee: "ⅇ",
  efDot: "≒",
  efr: "𝔢",
  Efr: "𝔈",
  eg: "⪚",
  egrave: "è",
  Egrave: "È",
  egs: "⪖",
  egsdot: "⪘",
  el: "⪙",
  Element: "∈",
  elinters: "⏧",
  ell: "ℓ",
  els: "⪕",
  elsdot: "⪗",
  emacr: "ē",
  Emacr: "Ē",
  empty: "∅",
  emptyset: "∅",
  EmptySmallSquare: "◻",
  emptyv: "∅",
  EmptyVerySmallSquare: "▫",
  emsp: " ",
  emsp13: " ",
  emsp14: " ",
  eng: "ŋ",
  ENG: "Ŋ",
  ensp: " ",
  eogon: "ę",
  Eogon: "Ę",
  eopf: "𝕖",
  Eopf: "𝔼",
  epar: "⋕",
  eparsl: "⧣",
  eplus: "⩱",
  epsi: "ε",
  epsilon: "ε",
  Epsilon: "Ε",
  epsiv: "ϵ",
  eqcirc: "≖",
  eqcolon: "≕",
  eqsim: "≂",
  eqslantgtr: "⪖",
  eqslantless: "⪕",
  Equal: "⩵",
  equals: "=",
  EqualTilde: "≂",
  equest: "≟",
  Equilibrium: "⇌",
  equiv: "≡",
  equivDD: "⩸",
  eqvparsl: "⧥",
  erarr: "⥱",
  erDot: "≓",
  escr: "ℯ",
  Escr: "ℰ",
  esdot: "≐",
  esim: "≂",
  Esim: "⩳",
  eta: "η",
  Eta: "Η",
  eth: "ð",
  ETH: "Ð",
  euml: "ë",
  Euml: "Ë",
  euro: "€",
  excl: "!",
  exist: "∃",
  Exists: "∃",
  expectation: "ℰ",
  exponentiale: "ⅇ",
  ExponentialE: "ⅇ",
  fallingdotseq: "≒",
  fcy: "ф",
  Fcy: "Ф",
  female: "♀",
  ffilig: "ﬃ",
  fflig: "ﬀ",
  ffllig: "ﬄ",
  ffr: "𝔣",
  Ffr: "𝔉",
  filig: "ﬁ",
  FilledSmallSquare: "◼",
  FilledVerySmallSquare: "▪",
  fjlig: "fj",
  flat: "♭",
  fllig: "ﬂ",
  fltns: "▱",
  fnof: "ƒ",
  fopf: "𝕗",
  Fopf: "𝔽",
  forall: "∀",
  ForAll: "∀",
  fork: "⋔",
  forkv: "⫙",
  Fouriertrf: "ℱ",
  fpartint: "⨍",
  frac12: "½",
  frac13: "⅓",
  frac14: "¼",
  frac15: "⅕",
  frac16: "⅙",
  frac18: "⅛",
  frac23: "⅔",
  frac25: "⅖",
  frac34: "¾",
  frac35: "⅗",
  frac38: "⅜",
  frac45: "⅘",
  frac56: "⅚",
  frac58: "⅝",
  frac78: "⅞",
  frasl: "⁄",
  frown: "⌢",
  fscr: "𝒻",
  Fscr: "ℱ",
  gacute: "ǵ",
  gamma: "γ",
  Gamma: "Γ",
  gammad: "ϝ",
  Gammad: "Ϝ",
  gap: "⪆",
  gbreve: "ğ",
  Gbreve: "Ğ",
  Gcedil: "Ģ",
  gcirc: "ĝ",
  Gcirc: "Ĝ",
  gcy: "г",
  Gcy: "Г",
  gdot: "ġ",
  Gdot: "Ġ",
  ge: "≥",
  gE: "≧",
  gel: "⋛",
  gEl: "⪌",
  geq: "≥",
  geqq: "≧",
  geqslant: "⩾",
  ges: "⩾",
  gescc: "⪩",
  gesdot: "⪀",
  gesdoto: "⪂",
  gesdotol: "⪄",
  gesl: "⋛︀",
  gesles: "⪔",
  gfr: "𝔤",
  Gfr: "𝔊",
  gg: "≫",
  Gg: "⋙",
  ggg: "⋙",
  gimel: "ℷ",
  gjcy: "ѓ",
  GJcy: "Ѓ",
  gl: "≷",
  gla: "⪥",
  glE: "⪒",
  glj: "⪤",
  gnap: "⪊",
  gnapprox: "⪊",
  gne: "⪈",
  gnE: "≩",
  gneq: "⪈",
  gneqq: "≩",
  gnsim: "⋧",
  gopf: "𝕘",
  Gopf: "𝔾",
  grave: "`",
  GreaterEqual: "≥",
  GreaterEqualLess: "⋛",
  GreaterFullEqual: "≧",
  GreaterGreater: "⪢",
  GreaterLess: "≷",
  GreaterSlantEqual: "⩾",
  GreaterTilde: "≳",
  gscr: "ℊ",
  Gscr: "𝒢",
  gsim: "≳",
  gsime: "⪎",
  gsiml: "⪐",
  gt: ">",
  Gt: "≫",
  GT: ">",
  gtcc: "⪧",
  gtcir: "⩺",
  gtdot: "⋗",
  gtlPar: "⦕",
  gtquest: "⩼",
  gtrapprox: "⪆",
  gtrarr: "⥸",
  gtrdot: "⋗",
  gtreqless: "⋛",
  gtreqqless: "⪌",
  gtrless: "≷",
  gtrsim: "≳",
  gvertneqq: "≩︀",
  gvnE: "≩︀",
  Hacek: "ˇ",
  hairsp: " ",
  half: "½",
  hamilt: "ℋ",
  hardcy: "ъ",
  HARDcy: "Ъ",
  harr: "↔",
  hArr: "⇔",
  harrcir: "⥈",
  harrw: "↭",
  Hat: "^",
  hbar: "ℏ",
  hcirc: "ĥ",
  Hcirc: "Ĥ",
  hearts: "♥",
  heartsuit: "♥",
  hellip: "…",
  hercon: "⊹",
  hfr: "𝔥",
  Hfr: "ℌ",
  HilbertSpace: "ℋ",
  hksearow: "⤥",
  hkswarow: "⤦",
  hoarr: "⇿",
  homtht: "∻",
  hookleftarrow: "↩",
  hookrightarrow: "↪",
  hopf: "𝕙",
  Hopf: "ℍ",
  horbar: "―",
  HorizontalLine: "─",
  hscr: "𝒽",
  Hscr: "ℋ",
  hslash: "ℏ",
  hstrok: "ħ",
  Hstrok: "Ħ",
  HumpDownHump: "≎",
  HumpEqual: "≏",
  hybull: "⁃",
  hyphen: "‐",
  iacute: "í",
  Iacute: "Í",
  ic: "⁣",
  icirc: "î",
  Icirc: "Î",
  icy: "и",
  Icy: "И",
  Idot: "İ",
  iecy: "е",
  IEcy: "Е",
  iexcl: "¡",
  iff: "⇔",
  ifr: "𝔦",
  Ifr: "ℑ",
  igrave: "ì",
  Igrave: "Ì",
  ii: "ⅈ",
  iiiint: "⨌",
  iiint: "∭",
  iinfin: "⧜",
  iiota: "℩",
  ijlig: "ĳ",
  IJlig: "Ĳ",
  Im: "ℑ",
  imacr: "ī",
  Imacr: "Ī",
  image: "ℑ",
  ImaginaryI: "ⅈ",
  imagline: "ℐ",
  imagpart: "ℑ",
  imath: "ı",
  imof: "⊷",
  imped: "Ƶ",
  Implies: "⇒",
  in: "∈",
  incare: "℅",
  infin: "∞",
  infintie: "⧝",
  inodot: "ı",
  int: "∫",
  Int: "∬",
  intcal: "⊺",
  integers: "ℤ",
  Integral: "∫",
  intercal: "⊺",
  Intersection: "⋂",
  intlarhk: "⨗",
  intprod: "⨼",
  InvisibleComma: "⁣",
  InvisibleTimes: "⁢",
  iocy: "ё",
  IOcy: "Ё",
  iogon: "į",
  Iogon: "Į",
  iopf: "𝕚",
  Iopf: "𝕀",
  iota: "ι",
  Iota: "Ι",
  iprod: "⨼",
  iquest: "¿",
  iscr: "𝒾",
  Iscr: "ℐ",
  isin: "∈",
  isindot: "⋵",
  isinE: "⋹",
  isins: "⋴",
  isinsv: "⋳",
  isinv: "∈",
  it: "⁢",
  itilde: "ĩ",
  Itilde: "Ĩ",
  iukcy: "і",
  Iukcy: "І",
  iuml: "ï",
  Iuml: "Ï",
  jcirc: "ĵ",
  Jcirc: "Ĵ",
  jcy: "й",
  Jcy: "Й",
  jfr: "𝔧",
  Jfr: "𝔍",
  jmath: "ȷ",
  jopf: "𝕛",
  Jopf: "𝕁",
  jscr: "𝒿",
  Jscr: "𝒥",
  jsercy: "ј",
  Jsercy: "Ј",
  jukcy: "є",
  Jukcy: "Є",
  kappa: "κ",
  Kappa: "Κ",
  kappav: "ϰ",
  kcedil: "ķ",
  Kcedil: "Ķ",
  kcy: "к",
  Kcy: "К",
  kfr: "𝔨",
  Kfr: "𝔎",
  kgreen: "ĸ",
  khcy: "х",
  KHcy: "Х",
  kjcy: "ќ",
  KJcy: "Ќ",
  kopf: "𝕜",
  Kopf: "𝕂",
  kscr: "𝓀",
  Kscr: "𝒦",
  lAarr: "⇚",
  lacute: "ĺ",
  Lacute: "Ĺ",
  laemptyv: "⦴",
  lagran: "ℒ",
  lambda: "λ",
  Lambda: "Λ",
  lang: "⟨",
  Lang: "⟪",
  langd: "⦑",
  langle: "⟨",
  lap: "⪅",
  Laplacetrf: "ℒ",
  laquo: "«",
  larr: "←",
  lArr: "⇐",
  Larr: "↞",
  larrb: "⇤",
  larrbfs: "⤟",
  larrfs: "⤝",
  larrhk: "↩",
  larrlp: "↫",
  larrpl: "⤹",
  larrsim: "⥳",
  larrtl: "↢",
  lat: "⪫",
  latail: "⤙",
  lAtail: "⤛",
  late: "⪭",
  lates: "⪭︀",
  lbarr: "⤌",
  lBarr: "⤎",
  lbbrk: "❲",
  lbrace: "{",
  lbrack: "[",
  lbrke: "⦋",
  lbrksld: "⦏",
  lbrkslu: "⦍",
  lcaron: "ľ",
  Lcaron: "Ľ",
  lcedil: "ļ",
  Lcedil: "Ļ",
  lceil: "⌈",
  lcub: "{",
  lcy: "л",
  Lcy: "Л",
  ldca: "⤶",
  ldquo: "“",
  ldquor: "„",
  ldrdhar: "⥧",
  ldrushar: "⥋",
  ldsh: "↲",
  le: "≤",
  lE: "≦",
  LeftAngleBracket: "⟨",
  leftarrow: "←",
  Leftarrow: "⇐",
  LeftArrow: "←",
  LeftArrowBar: "⇤",
  LeftArrowRightArrow: "⇆",
  leftarrowtail: "↢",
  LeftCeiling: "⌈",
  LeftDoubleBracket: "⟦",
  LeftDownTeeVector: "⥡",
  LeftDownVector: "⇃",
  LeftDownVectorBar: "⥙",
  LeftFloor: "⌊",
  leftharpoondown: "↽",
  leftharpoonup: "↼",
  leftleftarrows: "⇇",
  leftrightarrow: "↔",
  Leftrightarrow: "⇔",
  LeftRightArrow: "↔",
  leftrightarrows: "⇆",
  leftrightharpoons: "⇋",
  leftrightsquigarrow: "↭",
  LeftRightVector: "⥎",
  LeftTee: "⊣",
  LeftTeeArrow: "↤",
  LeftTeeVector: "⥚",
  leftthreetimes: "⋋",
  LeftTriangle: "⊲",
  LeftTriangleBar: "⧏",
  LeftTriangleEqual: "⊴",
  LeftUpDownVector: "⥑",
  LeftUpTeeVector: "⥠",
  LeftUpVector: "↿",
  LeftUpVectorBar: "⥘",
  LeftVector: "↼",
  LeftVectorBar: "⥒",
  leg: "⋚",
  lEg: "⪋",
  leq: "≤",
  leqq: "≦",
  leqslant: "⩽",
  les: "⩽",
  lescc: "⪨",
  lesdot: "⩿",
  lesdoto: "⪁",
  lesdotor: "⪃",
  lesg: "⋚︀",
  lesges: "⪓",
  lessapprox: "⪅",
  lessdot: "⋖",
  lesseqgtr: "⋚",
  lesseqqgtr: "⪋",
  LessEqualGreater: "⋚",
  LessFullEqual: "≦",
  LessGreater: "≶",
  lessgtr: "≶",
  LessLess: "⪡",
  lesssim: "≲",
  LessSlantEqual: "⩽",
  LessTilde: "≲",
  lfisht: "⥼",
  lfloor: "⌊",
  lfr: "𝔩",
  Lfr: "𝔏",
  lg: "≶",
  lgE: "⪑",
  lHar: "⥢",
  lhard: "↽",
  lharu: "↼",
  lharul: "⥪",
  lhblk: "▄",
  ljcy: "љ",
  LJcy: "Љ",
  ll: "≪",
  Ll: "⋘",
  llarr: "⇇",
  llcorner: "⌞",
  Lleftarrow: "⇚",
  llhard: "⥫",
  lltri: "◺",
  lmidot: "ŀ",
  Lmidot: "Ŀ",
  lmoust: "⎰",
  lmoustache: "⎰",
  lnap: "⪉",
  lnapprox: "⪉",
  lne: "⪇",
  lnE: "≨",
  lneq: "⪇",
  lneqq: "≨",
  lnsim: "⋦",
  loang: "⟬",
  loarr: "⇽",
  lobrk: "⟦",
  longleftarrow: "⟵",
  Longleftarrow: "⟸",
  LongLeftArrow: "⟵",
  longleftrightarrow: "⟷",
  Longleftrightarrow: "⟺",
  LongLeftRightArrow: "⟷",
  longmapsto: "⟼",
  longrightarrow: "⟶",
  Longrightarrow: "⟹",
  LongRightArrow: "⟶",
  looparrowleft: "↫",
  looparrowright: "↬",
  lopar: "⦅",
  lopf: "𝕝",
  Lopf: "𝕃",
  loplus: "⨭",
  lotimes: "⨴",
  lowast: "∗",
  lowbar: "_",
  LowerLeftArrow: "↙",
  LowerRightArrow: "↘",
  loz: "◊",
  lozenge: "◊",
  lozf: "⧫",
  lpar: "(",
  lparlt: "⦓",
  lrarr: "⇆",
  lrcorner: "⌟",
  lrhar: "⇋",
  lrhard: "⥭",
  lrm: "‎",
  lrtri: "⊿",
  lsaquo: "‹",
  lscr: "𝓁",
  Lscr: "ℒ",
  lsh: "↰",
  Lsh: "↰",
  lsim: "≲",
  lsime: "⪍",
  lsimg: "⪏",
  lsqb: "[",
  lsquo: "‘",
  lsquor: "‚",
  lstrok: "ł",
  Lstrok: "Ł",
  lt: "<",
  Lt: "≪",
  LT: "<",
  ltcc: "⪦",
  ltcir: "⩹",
  ltdot: "⋖",
  lthree: "⋋",
  ltimes: "⋉",
  ltlarr: "⥶",
  ltquest: "⩻",
  ltri: "◃",
  ltrie: "⊴",
  ltrif: "◂",
  ltrPar: "⦖",
  lurdshar: "⥊",
  luruhar: "⥦",
  lvertneqq: "≨︀",
  lvnE: "≨︀",
  macr: "¯",
  male: "♂",
  malt: "✠",
  maltese: "✠",
  map: "↦",
  Map: "⤅",
  mapsto: "↦",
  mapstodown: "↧",
  mapstoleft: "↤",
  mapstoup: "↥",
  marker: "▮",
  mcomma: "⨩",
  mcy: "м",
  Mcy: "М",
  mdash: "—",
  mDDot: "∺",
  measuredangle: "∡",
  MediumSpace: " ",
  Mellintrf: "ℳ",
  mfr: "𝔪",
  Mfr: "𝔐",
  mho: "℧",
  micro: "µ",
  mid: "∣",
  midast: "*",
  midcir: "⫰",
  middot: "·",
  minus: "−",
  minusb: "⊟",
  minusd: "∸",
  minusdu: "⨪",
  MinusPlus: "∓",
  mlcp: "⫛",
  mldr: "…",
  mnplus: "∓",
  models: "⊧",
  mopf: "𝕞",
  Mopf: "𝕄",
  mp: "∓",
  mscr: "𝓂",
  Mscr: "ℳ",
  mstpos: "∾",
  mu: "μ",
  Mu: "Μ",
  multimap: "⊸",
  mumap: "⊸",
  nabla: "∇",
  nacute: "ń",
  Nacute: "Ń",
  nang: "∠⃒",
  nap: "≉",
  napE: "⩰̸",
  napid: "≋̸",
  napos: "ŉ",
  napprox: "≉",
  natur: "♮",
  natural: "♮",
  naturals: "ℕ",
  nbsp: " ",
  nbump: "≎̸",
  nbumpe: "≏̸",
  ncap: "⩃",
  ncaron: "ň",
  Ncaron: "Ň",
  ncedil: "ņ",
  Ncedil: "Ņ",
  ncong: "≇",
  ncongdot: "⩭̸",
  ncup: "⩂",
  ncy: "н",
  Ncy: "Н",
  ndash: "–",
  ne: "≠",
  nearhk: "⤤",
  nearr: "↗",
  neArr: "⇗",
  nearrow: "↗",
  nedot: "≐̸",
  NegativeMediumSpace: "​",
  NegativeThickSpace: "​",
  NegativeThinSpace: "​",
  NegativeVeryThinSpace: "​",
  nequiv: "≢",
  nesear: "⤨",
  nesim: "≂̸",
  NestedGreaterGreater: "≫",
  NestedLessLess: "≪",
  NewLine: `
`,
  nexist: "∄",
  nexists: "∄",
  nfr: "𝔫",
  Nfr: "𝔑",
  nge: "≱",
  ngE: "≧̸",
  ngeq: "≱",
  ngeqq: "≧̸",
  ngeqslant: "⩾̸",
  nges: "⩾̸",
  nGg: "⋙̸",
  ngsim: "≵",
  ngt: "≯",
  nGt: "≫⃒",
  ngtr: "≯",
  nGtv: "≫̸",
  nharr: "↮",
  nhArr: "⇎",
  nhpar: "⫲",
  ni: "∋",
  nis: "⋼",
  nisd: "⋺",
  niv: "∋",
  njcy: "њ",
  NJcy: "Њ",
  nlarr: "↚",
  nlArr: "⇍",
  nldr: "‥",
  nle: "≰",
  nlE: "≦̸",
  nleftarrow: "↚",
  nLeftarrow: "⇍",
  nleftrightarrow: "↮",
  nLeftrightarrow: "⇎",
  nleq: "≰",
  nleqq: "≦̸",
  nleqslant: "⩽̸",
  nles: "⩽̸",
  nless: "≮",
  nLl: "⋘̸",
  nlsim: "≴",
  nlt: "≮",
  nLt: "≪⃒",
  nltri: "⋪",
  nltrie: "⋬",
  nLtv: "≪̸",
  nmid: "∤",
  NoBreak: "⁠",
  NonBreakingSpace: " ",
  nopf: "𝕟",
  Nopf: "ℕ",
  not: "¬",
  Not: "⫬",
  NotCongruent: "≢",
  NotCupCap: "≭",
  NotDoubleVerticalBar: "∦",
  NotElement: "∉",
  NotEqual: "≠",
  NotEqualTilde: "≂̸",
  NotExists: "∄",
  NotGreater: "≯",
  NotGreaterEqual: "≱",
  NotGreaterFullEqual: "≧̸",
  NotGreaterGreater: "≫̸",
  NotGreaterLess: "≹",
  NotGreaterSlantEqual: "⩾̸",
  NotGreaterTilde: "≵",
  NotHumpDownHump: "≎̸",
  NotHumpEqual: "≏̸",
  notin: "∉",
  notindot: "⋵̸",
  notinE: "⋹̸",
  notinva: "∉",
  notinvb: "⋷",
  notinvc: "⋶",
  NotLeftTriangle: "⋪",
  NotLeftTriangleBar: "⧏̸",
  NotLeftTriangleEqual: "⋬",
  NotLess: "≮",
  NotLessEqual: "≰",
  NotLessGreater: "≸",
  NotLessLess: "≪̸",
  NotLessSlantEqual: "⩽̸",
  NotLessTilde: "≴",
  NotNestedGreaterGreater: "⪢̸",
  NotNestedLessLess: "⪡̸",
  notni: "∌",
  notniva: "∌",
  notnivb: "⋾",
  notnivc: "⋽",
  NotPrecedes: "⊀",
  NotPrecedesEqual: "⪯̸",
  NotPrecedesSlantEqual: "⋠",
  NotReverseElement: "∌",
  NotRightTriangle: "⋫",
  NotRightTriangleBar: "⧐̸",
  NotRightTriangleEqual: "⋭",
  NotSquareSubset: "⊏̸",
  NotSquareSubsetEqual: "⋢",
  NotSquareSuperset: "⊐̸",
  NotSquareSupersetEqual: "⋣",
  NotSubset: "⊂⃒",
  NotSubsetEqual: "⊈",
  NotSucceeds: "⊁",
  NotSucceedsEqual: "⪰̸",
  NotSucceedsSlantEqual: "⋡",
  NotSucceedsTilde: "≿̸",
  NotSuperset: "⊃⃒",
  NotSupersetEqual: "⊉",
  NotTilde: "≁",
  NotTildeEqual: "≄",
  NotTildeFullEqual: "≇",
  NotTildeTilde: "≉",
  NotVerticalBar: "∤",
  npar: "∦",
  nparallel: "∦",
  nparsl: "⫽⃥",
  npart: "∂̸",
  npolint: "⨔",
  npr: "⊀",
  nprcue: "⋠",
  npre: "⪯̸",
  nprec: "⊀",
  npreceq: "⪯̸",
  nrarr: "↛",
  nrArr: "⇏",
  nrarrc: "⤳̸",
  nrarrw: "↝̸",
  nrightarrow: "↛",
  nRightarrow: "⇏",
  nrtri: "⋫",
  nrtrie: "⋭",
  nsc: "⊁",
  nsccue: "⋡",
  nsce: "⪰̸",
  nscr: "𝓃",
  Nscr: "𝒩",
  nshortmid: "∤",
  nshortparallel: "∦",
  nsim: "≁",
  nsime: "≄",
  nsimeq: "≄",
  nsmid: "∤",
  nspar: "∦",
  nsqsube: "⋢",
  nsqsupe: "⋣",
  nsub: "⊄",
  nsube: "⊈",
  nsubE: "⫅̸",
  nsubset: "⊂⃒",
  nsubseteq: "⊈",
  nsubseteqq: "⫅̸",
  nsucc: "⊁",
  nsucceq: "⪰̸",
  nsup: "⊅",
  nsupe: "⊉",
  nsupE: "⫆̸",
  nsupset: "⊃⃒",
  nsupseteq: "⊉",
  nsupseteqq: "⫆̸",
  ntgl: "≹",
  ntilde: "ñ",
  Ntilde: "Ñ",
  ntlg: "≸",
  ntriangleleft: "⋪",
  ntrianglelefteq: "⋬",
  ntriangleright: "⋫",
  ntrianglerighteq: "⋭",
  nu: "ν",
  Nu: "Ν",
  num: "#",
  numero: "№",
  numsp: " ",
  nvap: "≍⃒",
  nvdash: "⊬",
  nvDash: "⊭",
  nVdash: "⊮",
  nVDash: "⊯",
  nvge: "≥⃒",
  nvgt: ">⃒",
  nvHarr: "⤄",
  nvinfin: "⧞",
  nvlArr: "⤂",
  nvle: "≤⃒",
  nvlt: "<⃒",
  nvltrie: "⊴⃒",
  nvrArr: "⤃",
  nvrtrie: "⊵⃒",
  nvsim: "∼⃒",
  nwarhk: "⤣",
  nwarr: "↖",
  nwArr: "⇖",
  nwarrow: "↖",
  nwnear: "⤧",
  oacute: "ó",
  Oacute: "Ó",
  oast: "⊛",
  ocir: "⊚",
  ocirc: "ô",
  Ocirc: "Ô",
  ocy: "о",
  Ocy: "О",
  odash: "⊝",
  odblac: "ő",
  Odblac: "Ő",
  odiv: "⨸",
  odot: "⊙",
  odsold: "⦼",
  oelig: "œ",
  OElig: "Œ",
  ofcir: "⦿",
  ofr: "𝔬",
  Ofr: "𝔒",
  ogon: "˛",
  ograve: "ò",
  Ograve: "Ò",
  ogt: "⧁",
  ohbar: "⦵",
  ohm: "Ω",
  oint: "∮",
  olarr: "↺",
  olcir: "⦾",
  olcross: "⦻",
  oline: "‾",
  olt: "⧀",
  omacr: "ō",
  Omacr: "Ō",
  omega: "ω",
  Omega: "Ω",
  omicron: "ο",
  Omicron: "Ο",
  omid: "⦶",
  ominus: "⊖",
  oopf: "𝕠",
  Oopf: "𝕆",
  opar: "⦷",
  OpenCurlyDoubleQuote: "“",
  OpenCurlyQuote: "‘",
  operp: "⦹",
  oplus: "⊕",
  or: "∨",
  Or: "⩔",
  orarr: "↻",
  ord: "⩝",
  order: "ℴ",
  orderof: "ℴ",
  ordf: "ª",
  ordm: "º",
  origof: "⊶",
  oror: "⩖",
  orslope: "⩗",
  orv: "⩛",
  oS: "Ⓢ",
  oscr: "ℴ",
  Oscr: "𝒪",
  oslash: "ø",
  Oslash: "Ø",
  osol: "⊘",
  otilde: "õ",
  Otilde: "Õ",
  otimes: "⊗",
  Otimes: "⨷",
  otimesas: "⨶",
  ouml: "ö",
  Ouml: "Ö",
  ovbar: "⌽",
  OverBar: "‾",
  OverBrace: "⏞",
  OverBracket: "⎴",
  OverParenthesis: "⏜",
  par: "∥",
  para: "¶",
  parallel: "∥",
  parsim: "⫳",
  parsl: "⫽",
  part: "∂",
  PartialD: "∂",
  pcy: "п",
  Pcy: "П",
  percnt: "%",
  period: ".",
  permil: "‰",
  perp: "⊥",
  pertenk: "‱",
  pfr: "𝔭",
  Pfr: "𝔓",
  phi: "φ",
  Phi: "Φ",
  phiv: "ϕ",
  phmmat: "ℳ",
  phone: "☎",
  pi: "π",
  Pi: "Π",
  pitchfork: "⋔",
  piv: "ϖ",
  planck: "ℏ",
  planckh: "ℎ",
  plankv: "ℏ",
  plus: "+",
  plusacir: "⨣",
  plusb: "⊞",
  pluscir: "⨢",
  plusdo: "∔",
  plusdu: "⨥",
  pluse: "⩲",
  PlusMinus: "±",
  plusmn: "±",
  plussim: "⨦",
  plustwo: "⨧",
  pm: "±",
  Poincareplane: "ℌ",
  pointint: "⨕",
  popf: "𝕡",
  Popf: "ℙ",
  pound: "£",
  pr: "≺",
  Pr: "⪻",
  prap: "⪷",
  prcue: "≼",
  pre: "⪯",
  prE: "⪳",
  prec: "≺",
  precapprox: "⪷",
  preccurlyeq: "≼",
  Precedes: "≺",
  PrecedesEqual: "⪯",
  PrecedesSlantEqual: "≼",
  PrecedesTilde: "≾",
  preceq: "⪯",
  precnapprox: "⪹",
  precneqq: "⪵",
  precnsim: "⋨",
  precsim: "≾",
  prime: "′",
  Prime: "″",
  primes: "ℙ",
  prnap: "⪹",
  prnE: "⪵",
  prnsim: "⋨",
  prod: "∏",
  Product: "∏",
  profalar: "⌮",
  profline: "⌒",
  profsurf: "⌓",
  prop: "∝",
  Proportion: "∷",
  Proportional: "∝",
  propto: "∝",
  prsim: "≾",
  prurel: "⊰",
  pscr: "𝓅",
  Pscr: "𝒫",
  psi: "ψ",
  Psi: "Ψ",
  puncsp: " ",
  qfr: "𝔮",
  Qfr: "𝔔",
  qint: "⨌",
  qopf: "𝕢",
  Qopf: "ℚ",
  qprime: "⁗",
  qscr: "𝓆",
  Qscr: "𝒬",
  quaternions: "ℍ",
  quatint: "⨖",
  quest: "?",
  questeq: "≟",
  quot: '"',
  QUOT: '"',
  rAarr: "⇛",
  race: "∽̱",
  racute: "ŕ",
  Racute: "Ŕ",
  radic: "√",
  raemptyv: "⦳",
  rang: "⟩",
  Rang: "⟫",
  rangd: "⦒",
  range: "⦥",
  rangle: "⟩",
  raquo: "»",
  rarr: "→",
  rArr: "⇒",
  Rarr: "↠",
  rarrap: "⥵",
  rarrb: "⇥",
  rarrbfs: "⤠",
  rarrc: "⤳",
  rarrfs: "⤞",
  rarrhk: "↪",
  rarrlp: "↬",
  rarrpl: "⥅",
  rarrsim: "⥴",
  rarrtl: "↣",
  Rarrtl: "⤖",
  rarrw: "↝",
  ratail: "⤚",
  rAtail: "⤜",
  ratio: "∶",
  rationals: "ℚ",
  rbarr: "⤍",
  rBarr: "⤏",
  RBarr: "⤐",
  rbbrk: "❳",
  rbrace: "}",
  rbrack: "]",
  rbrke: "⦌",
  rbrksld: "⦎",
  rbrkslu: "⦐",
  rcaron: "ř",
  Rcaron: "Ř",
  rcedil: "ŗ",
  Rcedil: "Ŗ",
  rceil: "⌉",
  rcub: "}",
  rcy: "р",
  Rcy: "Р",
  rdca: "⤷",
  rdldhar: "⥩",
  rdquo: "”",
  rdquor: "”",
  rdsh: "↳",
  Re: "ℜ",
  real: "ℜ",
  realine: "ℛ",
  realpart: "ℜ",
  reals: "ℝ",
  rect: "▭",
  reg: "®",
  REG: "®",
  ReverseElement: "∋",
  ReverseEquilibrium: "⇋",
  ReverseUpEquilibrium: "⥯",
  rfisht: "⥽",
  rfloor: "⌋",
  rfr: "𝔯",
  Rfr: "ℜ",
  rHar: "⥤",
  rhard: "⇁",
  rharu: "⇀",
  rharul: "⥬",
  rho: "ρ",
  Rho: "Ρ",
  rhov: "ϱ",
  RightAngleBracket: "⟩",
  rightarrow: "→",
  Rightarrow: "⇒",
  RightArrow: "→",
  RightArrowBar: "⇥",
  RightArrowLeftArrow: "⇄",
  rightarrowtail: "↣",
  RightCeiling: "⌉",
  RightDoubleBracket: "⟧",
  RightDownTeeVector: "⥝",
  RightDownVector: "⇂",
  RightDownVectorBar: "⥕",
  RightFloor: "⌋",
  rightharpoondown: "⇁",
  rightharpoonup: "⇀",
  rightleftarrows: "⇄",
  rightleftharpoons: "⇌",
  rightrightarrows: "⇉",
  rightsquigarrow: "↝",
  RightTee: "⊢",
  RightTeeArrow: "↦",
  RightTeeVector: "⥛",
  rightthreetimes: "⋌",
  RightTriangle: "⊳",
  RightTriangleBar: "⧐",
  RightTriangleEqual: "⊵",
  RightUpDownVector: "⥏",
  RightUpTeeVector: "⥜",
  RightUpVector: "↾",
  RightUpVectorBar: "⥔",
  RightVector: "⇀",
  RightVectorBar: "⥓",
  ring: "˚",
  risingdotseq: "≓",
  rlarr: "⇄",
  rlhar: "⇌",
  rlm: "‏",
  rmoust: "⎱",
  rmoustache: "⎱",
  rnmid: "⫮",
  roang: "⟭",
  roarr: "⇾",
  robrk: "⟧",
  ropar: "⦆",
  ropf: "𝕣",
  Ropf: "ℝ",
  roplus: "⨮",
  rotimes: "⨵",
  RoundImplies: "⥰",
  rpar: ")",
  rpargt: "⦔",
  rppolint: "⨒",
  rrarr: "⇉",
  Rrightarrow: "⇛",
  rsaquo: "›",
  rscr: "𝓇",
  Rscr: "ℛ",
  rsh: "↱",
  Rsh: "↱",
  rsqb: "]",
  rsquo: "’",
  rsquor: "’",
  rthree: "⋌",
  rtimes: "⋊",
  rtri: "▹",
  rtrie: "⊵",
  rtrif: "▸",
  rtriltri: "⧎",
  RuleDelayed: "⧴",
  ruluhar: "⥨",
  rx: "℞",
  sacute: "ś",
  Sacute: "Ś",
  sbquo: "‚",
  sc: "≻",
  Sc: "⪼",
  scap: "⪸",
  scaron: "š",
  Scaron: "Š",
  sccue: "≽",
  sce: "⪰",
  scE: "⪴",
  scedil: "ş",
  Scedil: "Ş",
  scirc: "ŝ",
  Scirc: "Ŝ",
  scnap: "⪺",
  scnE: "⪶",
  scnsim: "⋩",
  scpolint: "⨓",
  scsim: "≿",
  scy: "с",
  Scy: "С",
  sdot: "⋅",
  sdotb: "⊡",
  sdote: "⩦",
  searhk: "⤥",
  searr: "↘",
  seArr: "⇘",
  searrow: "↘",
  sect: "§",
  semi: ";",
  seswar: "⤩",
  setminus: "∖",
  setmn: "∖",
  sext: "✶",
  sfr: "𝔰",
  Sfr: "𝔖",
  sfrown: "⌢",
  sharp: "♯",
  shchcy: "щ",
  SHCHcy: "Щ",
  shcy: "ш",
  SHcy: "Ш",
  ShortDownArrow: "↓",
  ShortLeftArrow: "←",
  shortmid: "∣",
  shortparallel: "∥",
  ShortRightArrow: "→",
  ShortUpArrow: "↑",
  shy: "­",
  sigma: "σ",
  Sigma: "Σ",
  sigmaf: "ς",
  sigmav: "ς",
  sim: "∼",
  simdot: "⩪",
  sime: "≃",
  simeq: "≃",
  simg: "⪞",
  simgE: "⪠",
  siml: "⪝",
  simlE: "⪟",
  simne: "≆",
  simplus: "⨤",
  simrarr: "⥲",
  slarr: "←",
  SmallCircle: "∘",
  smallsetminus: "∖",
  smashp: "⨳",
  smeparsl: "⧤",
  smid: "∣",
  smile: "⌣",
  smt: "⪪",
  smte: "⪬",
  smtes: "⪬︀",
  softcy: "ь",
  SOFTcy: "Ь",
  sol: "/",
  solb: "⧄",
  solbar: "⌿",
  sopf: "𝕤",
  Sopf: "𝕊",
  spades: "♠",
  spadesuit: "♠",
  spar: "∥",
  sqcap: "⊓",
  sqcaps: "⊓︀",
  sqcup: "⊔",
  sqcups: "⊔︀",
  Sqrt: "√",
  sqsub: "⊏",
  sqsube: "⊑",
  sqsubset: "⊏",
  sqsubseteq: "⊑",
  sqsup: "⊐",
  sqsupe: "⊒",
  sqsupset: "⊐",
  sqsupseteq: "⊒",
  squ: "□",
  square: "□",
  Square: "□",
  SquareIntersection: "⊓",
  SquareSubset: "⊏",
  SquareSubsetEqual: "⊑",
  SquareSuperset: "⊐",
  SquareSupersetEqual: "⊒",
  SquareUnion: "⊔",
  squarf: "▪",
  squf: "▪",
  srarr: "→",
  sscr: "𝓈",
  Sscr: "𝒮",
  ssetmn: "∖",
  ssmile: "⌣",
  sstarf: "⋆",
  star: "☆",
  Star: "⋆",
  starf: "★",
  straightepsilon: "ϵ",
  straightphi: "ϕ",
  strns: "¯",
  sub: "⊂",
  Sub: "⋐",
  subdot: "⪽",
  sube: "⊆",
  subE: "⫅",
  subedot: "⫃",
  submult: "⫁",
  subne: "⊊",
  subnE: "⫋",
  subplus: "⪿",
  subrarr: "⥹",
  subset: "⊂",
  Subset: "⋐",
  subseteq: "⊆",
  subseteqq: "⫅",
  SubsetEqual: "⊆",
  subsetneq: "⊊",
  subsetneqq: "⫋",
  subsim: "⫇",
  subsub: "⫕",
  subsup: "⫓",
  succ: "≻",
  succapprox: "⪸",
  succcurlyeq: "≽",
  Succeeds: "≻",
  SucceedsEqual: "⪰",
  SucceedsSlantEqual: "≽",
  SucceedsTilde: "≿",
  succeq: "⪰",
  succnapprox: "⪺",
  succneqq: "⪶",
  succnsim: "⋩",
  succsim: "≿",
  SuchThat: "∋",
  sum: "∑",
  Sum: "∑",
  sung: "♪",
  sup: "⊃",
  Sup: "⋑",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  supdot: "⪾",
  supdsub: "⫘",
  supe: "⊇",
  supE: "⫆",
  supedot: "⫄",
  Superset: "⊃",
  SupersetEqual: "⊇",
  suphsol: "⟉",
  suphsub: "⫗",
  suplarr: "⥻",
  supmult: "⫂",
  supne: "⊋",
  supnE: "⫌",
  supplus: "⫀",
  supset: "⊃",
  Supset: "⋑",
  supseteq: "⊇",
  supseteqq: "⫆",
  supsetneq: "⊋",
  supsetneqq: "⫌",
  supsim: "⫈",
  supsub: "⫔",
  supsup: "⫖",
  swarhk: "⤦",
  swarr: "↙",
  swArr: "⇙",
  swarrow: "↙",
  swnwar: "⤪",
  szlig: "ß",
  Tab: "	",
  target: "⌖",
  tau: "τ",
  Tau: "Τ",
  tbrk: "⎴",
  tcaron: "ť",
  Tcaron: "Ť",
  tcedil: "ţ",
  Tcedil: "Ţ",
  tcy: "т",
  Tcy: "Т",
  tdot: "⃛",
  telrec: "⌕",
  tfr: "𝔱",
  Tfr: "𝔗",
  there4: "∴",
  therefore: "∴",
  Therefore: "∴",
  theta: "θ",
  Theta: "Θ",
  thetasym: "ϑ",
  thetav: "ϑ",
  thickapprox: "≈",
  thicksim: "∼",
  ThickSpace: "  ",
  thinsp: " ",
  ThinSpace: " ",
  thkap: "≈",
  thksim: "∼",
  thorn: "þ",
  THORN: "Þ",
  tilde: "˜",
  Tilde: "∼",
  TildeEqual: "≃",
  TildeFullEqual: "≅",
  TildeTilde: "≈",
  times: "×",
  timesb: "⊠",
  timesbar: "⨱",
  timesd: "⨰",
  tint: "∭",
  toea: "⤨",
  top: "⊤",
  topbot: "⌶",
  topcir: "⫱",
  topf: "𝕥",
  Topf: "𝕋",
  topfork: "⫚",
  tosa: "⤩",
  tprime: "‴",
  trade: "™",
  TRADE: "™",
  triangle: "▵",
  triangledown: "▿",
  triangleleft: "◃",
  trianglelefteq: "⊴",
  triangleq: "≜",
  triangleright: "▹",
  trianglerighteq: "⊵",
  tridot: "◬",
  trie: "≜",
  triminus: "⨺",
  TripleDot: "⃛",
  triplus: "⨹",
  trisb: "⧍",
  tritime: "⨻",
  trpezium: "⏢",
  tscr: "𝓉",
  Tscr: "𝒯",
  tscy: "ц",
  TScy: "Ц",
  tshcy: "ћ",
  TSHcy: "Ћ",
  tstrok: "ŧ",
  Tstrok: "Ŧ",
  twixt: "≬",
  twoheadleftarrow: "↞",
  twoheadrightarrow: "↠",
  uacute: "ú",
  Uacute: "Ú",
  uarr: "↑",
  uArr: "⇑",
  Uarr: "↟",
  Uarrocir: "⥉",
  ubrcy: "ў",
  Ubrcy: "Ў",
  ubreve: "ŭ",
  Ubreve: "Ŭ",
  ucirc: "û",
  Ucirc: "Û",
  ucy: "у",
  Ucy: "У",
  udarr: "⇅",
  udblac: "ű",
  Udblac: "Ű",
  udhar: "⥮",
  ufisht: "⥾",
  ufr: "𝔲",
  Ufr: "𝔘",
  ugrave: "ù",
  Ugrave: "Ù",
  uHar: "⥣",
  uharl: "↿",
  uharr: "↾",
  uhblk: "▀",
  ulcorn: "⌜",
  ulcorner: "⌜",
  ulcrop: "⌏",
  ultri: "◸",
  umacr: "ū",
  Umacr: "Ū",
  uml: "¨",
  UnderBar: "_",
  UnderBrace: "⏟",
  UnderBracket: "⎵",
  UnderParenthesis: "⏝",
  Union: "⋃",
  UnionPlus: "⊎",
  uogon: "ų",
  Uogon: "Ų",
  uopf: "𝕦",
  Uopf: "𝕌",
  uparrow: "↑",
  Uparrow: "⇑",
  UpArrow: "↑",
  UpArrowBar: "⤒",
  UpArrowDownArrow: "⇅",
  updownarrow: "↕",
  Updownarrow: "⇕",
  UpDownArrow: "↕",
  UpEquilibrium: "⥮",
  upharpoonleft: "↿",
  upharpoonright: "↾",
  uplus: "⊎",
  UpperLeftArrow: "↖",
  UpperRightArrow: "↗",
  upsi: "υ",
  Upsi: "ϒ",
  upsih: "ϒ",
  upsilon: "υ",
  Upsilon: "Υ",
  UpTee: "⊥",
  UpTeeArrow: "↥",
  upuparrows: "⇈",
  urcorn: "⌝",
  urcorner: "⌝",
  urcrop: "⌎",
  uring: "ů",
  Uring: "Ů",
  urtri: "◹",
  uscr: "𝓊",
  Uscr: "𝒰",
  utdot: "⋰",
  utilde: "ũ",
  Utilde: "Ũ",
  utri: "▵",
  utrif: "▴",
  uuarr: "⇈",
  uuml: "ü",
  Uuml: "Ü",
  uwangle: "⦧",
  vangrt: "⦜",
  varepsilon: "ϵ",
  varkappa: "ϰ",
  varnothing: "∅",
  varphi: "ϕ",
  varpi: "ϖ",
  varpropto: "∝",
  varr: "↕",
  vArr: "⇕",
  varrho: "ϱ",
  varsigma: "ς",
  varsubsetneq: "⊊︀",
  varsubsetneqq: "⫋︀",
  varsupsetneq: "⊋︀",
  varsupsetneqq: "⫌︀",
  vartheta: "ϑ",
  vartriangleleft: "⊲",
  vartriangleright: "⊳",
  vBar: "⫨",
  Vbar: "⫫",
  vBarv: "⫩",
  vcy: "в",
  Vcy: "В",
  vdash: "⊢",
  vDash: "⊨",
  Vdash: "⊩",
  VDash: "⊫",
  Vdashl: "⫦",
  vee: "∨",
  Vee: "⋁",
  veebar: "⊻",
  veeeq: "≚",
  vellip: "⋮",
  verbar: "|",
  Verbar: "‖",
  vert: "|",
  Vert: "‖",
  VerticalBar: "∣",
  VerticalLine: "|",
  VerticalSeparator: "❘",
  VerticalTilde: "≀",
  VeryThinSpace: " ",
  vfr: "𝔳",
  Vfr: "𝔙",
  vltri: "⊲",
  vnsub: "⊂⃒",
  vnsup: "⊃⃒",
  vopf: "𝕧",
  Vopf: "𝕍",
  vprop: "∝",
  vrtri: "⊳",
  vscr: "𝓋",
  Vscr: "𝒱",
  vsubne: "⊊︀",
  vsubnE: "⫋︀",
  vsupne: "⊋︀",
  vsupnE: "⫌︀",
  Vvdash: "⊪",
  vzigzag: "⦚",
  wcirc: "ŵ",
  Wcirc: "Ŵ",
  wedbar: "⩟",
  wedge: "∧",
  Wedge: "⋀",
  wedgeq: "≙",
  weierp: "℘",
  wfr: "𝔴",
  Wfr: "𝔚",
  wopf: "𝕨",
  Wopf: "𝕎",
  wp: "℘",
  wr: "≀",
  wreath: "≀",
  wscr: "𝓌",
  Wscr: "𝒲",
  xcap: "⋂",
  xcirc: "◯",
  xcup: "⋃",
  xdtri: "▽",
  xfr: "𝔵",
  Xfr: "𝔛",
  xharr: "⟷",
  xhArr: "⟺",
  xi: "ξ",
  Xi: "Ξ",
  xlarr: "⟵",
  xlArr: "⟸",
  xmap: "⟼",
  xnis: "⋻",
  xodot: "⨀",
  xopf: "𝕩",
  Xopf: "𝕏",
  xoplus: "⨁",
  xotime: "⨂",
  xrarr: "⟶",
  xrArr: "⟹",
  xscr: "𝓍",
  Xscr: "𝒳",
  xsqcup: "⨆",
  xuplus: "⨄",
  xutri: "△",
  xvee: "⋁",
  xwedge: "⋀",
  yacute: "ý",
  Yacute: "Ý",
  yacy: "я",
  YAcy: "Я",
  ycirc: "ŷ",
  Ycirc: "Ŷ",
  ycy: "ы",
  Ycy: "Ы",
  yen: "¥",
  yfr: "𝔶",
  Yfr: "𝔜",
  yicy: "ї",
  YIcy: "Ї",
  yopf: "𝕪",
  Yopf: "𝕐",
  yscr: "𝓎",
  Yscr: "𝒴",
  yucy: "ю",
  YUcy: "Ю",
  yuml: "ÿ",
  Yuml: "Ÿ",
  zacute: "ź",
  Zacute: "Ź",
  zcaron: "ž",
  Zcaron: "Ž",
  zcy: "з",
  Zcy: "З",
  zdot: "ż",
  Zdot: "Ż",
  zeetrf: "ℨ",
  ZeroWidthSpace: "​",
  zeta: "ζ",
  Zeta: "Ζ",
  zfr: "𝔷",
  Zfr: "ℨ",
  zhcy: "ж",
  ZHcy: "Ж",
  zigrarr: "⇝",
  zopf: "𝕫",
  Zopf: "ℤ",
  zscr: "𝓏",
  Zscr: "𝒵",
  zwj: "‍",
  zwnj: "‌"
}, VI = {
  aacute: "á",
  Aacute: "Á",
  acirc: "â",
  Acirc: "Â",
  acute: "´",
  aelig: "æ",
  AElig: "Æ",
  agrave: "à",
  Agrave: "À",
  amp: "&",
  AMP: "&",
  aring: "å",
  Aring: "Å",
  atilde: "ã",
  Atilde: "Ã",
  auml: "ä",
  Auml: "Ä",
  brvbar: "¦",
  ccedil: "ç",
  Ccedil: "Ç",
  cedil: "¸",
  cent: "¢",
  copy: "©",
  COPY: "©",
  curren: "¤",
  deg: "°",
  divide: "÷",
  eacute: "é",
  Eacute: "É",
  ecirc: "ê",
  Ecirc: "Ê",
  egrave: "è",
  Egrave: "È",
  eth: "ð",
  ETH: "Ð",
  euml: "ë",
  Euml: "Ë",
  frac12: "½",
  frac14: "¼",
  frac34: "¾",
  gt: ">",
  GT: ">",
  iacute: "í",
  Iacute: "Í",
  icirc: "î",
  Icirc: "Î",
  iexcl: "¡",
  igrave: "ì",
  Igrave: "Ì",
  iquest: "¿",
  iuml: "ï",
  Iuml: "Ï",
  laquo: "«",
  lt: "<",
  LT: "<",
  macr: "¯",
  micro: "µ",
  middot: "·",
  nbsp: " ",
  not: "¬",
  ntilde: "ñ",
  Ntilde: "Ñ",
  oacute: "ó",
  Oacute: "Ó",
  ocirc: "ô",
  Ocirc: "Ô",
  ograve: "ò",
  Ograve: "Ò",
  ordf: "ª",
  ordm: "º",
  oslash: "ø",
  Oslash: "Ø",
  otilde: "õ",
  Otilde: "Õ",
  ouml: "ö",
  Ouml: "Ö",
  para: "¶",
  plusmn: "±",
  pound: "£",
  quot: '"',
  QUOT: '"',
  raquo: "»",
  reg: "®",
  REG: "®",
  sect: "§",
  shy: "­",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  szlig: "ß",
  thorn: "þ",
  THORN: "Þ",
  times: "×",
  uacute: "ú",
  Uacute: "Ú",
  ucirc: "û",
  Ucirc: "Û",
  ugrave: "ù",
  Ugrave: "Ù",
  uml: "¨",
  uuml: "ü",
  Uuml: "Ü",
  yacute: "ý",
  Yacute: "Ý",
  yen: "¥",
  yuml: "ÿ"
}, i0 = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
}, GI = [
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  11,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  64976,
  64977,
  64978,
  64979,
  64980,
  64981,
  64982,
  64983,
  64984,
  64985,
  64986,
  64987,
  64988,
  64989,
  64990,
  64991,
  64992,
  64993,
  64994,
  64995,
  64996,
  64997,
  64998,
  64999,
  65e3,
  65001,
  65002,
  65003,
  65004,
  65005,
  65006,
  65007,
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
], s0 = String.fromCharCode, jI = function(t, e) {
  let n = -1;
  const r = t.length;
  for (; ++n < r; )
    if (t[n] === e)
      return !0;
  return !1;
};
function KI(t, e) {
  if (!t)
    return e;
  const n = {};
  let r;
  for (r in e)
    n[r] = Ql(t, r) ? t[r] : e[r];
  return n;
}
var o0 = function(t, e) {
  let n = "";
  return t >= 55296 && t <= 57343 || t > 1114111 ? (e && jn("character reference outside the permissible Unicode range"), "�") : Ql(i0, t) ? (e && jn("disallowed character reference"), i0[t]) : (e && jI(GI, t) && jn("disallowed character reference"), t > 65535 && (t -= 65536, n += s0(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), n += s0(t), n);
};
function jn(t) {
  throw new Error(`Parse error: ${t}`);
}
function Bf(t, e) {
  e = KI(e, Bf.options);
  const n = e.strict;
  return n && qI.test(t) && jn("malformed character reference"), t.replace(
    zI,
    (r, i, s, o, a, l, u, c, f) => {
      let d, h, m, g, T, E;
      return i ? (T = i, $I[T]) : s ? (T = s, E = o, E && e.isAttributeValue ? (n && E === "=" && jn("`&` did not start a character reference"), r) : (n && jn(
        "named character reference was not terminated by a semicolon"
      ), VI[T] + (E || ""))) : a ? (m = a, h = l, n && !h && jn("character reference was not terminated by a semicolon"), d = parseInt(m, 10), o0(d, n)) : u ? (g = u, h = c, n && !h && jn("character reference was not terminated by a semicolon"), d = parseInt(g, 16), o0(d, n)) : (n && jn(
        "named character reference was not terminated by a semicolon"
      ), r);
    }
  );
}
Bf.options = {
  isAttributeValue: !1,
  strict: !1
};
var Tc = (t) => t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;"), a0 = (t) => Bf(t);
function WI(t, e, n, r) {
  if (typeof e == "function")
    return e({
      props: { ...n, children: r },
      attrs: n,
      children: r,
      h: t.h,
      context: t
    });
  {
    let i = !0, s;
    if (e ? e.toLowerCase() === "fragment" ? (s = t.document.createDocumentFragment(), i = !1) : s = t.document.createElement(e) : s = t.document.createElement("div"), n && i) {
      const o = s;
      for (let [a, l] of Object.entries(n)) {
        a = a.toString();
        const u = a.toLowerCase();
        u === "classname" ? o.className = l : u === "on" ? Object.entries(l).forEach(([c, f]) => {
          o.setAttribute(`on${c}`, String(f));
        }) : l !== !1 && l != null && (l === !0 ? o.setAttribute(a, a) : o.setAttribute(a, l.toString()));
      }
    }
    if (r)
      for (const o of r) {
        const a = Array.isArray(o) ? [...o] : [o];
        for (const l of a)
          l && l !== !1 && l != null && (typeof l != "object" ? s.appendChild(
            t.document.createTextNode(l.toString())
          ) : s.appendChild(l));
      }
    return s;
  }
}
function E4(t, e, ...n) {
  return typeof t == "object" && (t = "fragment", n = t.children, e = t.attrs), Array.isArray(e) ? (n = [e], e = {}) : e ? e.attrs && (e = { ...e.attrs, ...e }, delete e.attrs) : e = {}, {
    tag: t,
    attrs: e,
    children: typeof n[0] == "string" ? n : n.flat(1 / 0)
  };
}
function YI(t) {
  return t.h = function(n, r, ...i) {
    const { tag: s, attrs: o, children: a } = E4(n, r, i);
    return WI(t, s, o, a);
  }, t.h;
}
var y4 = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
  "command"
];
function A4(t, e, n = {}, r) {
  const i = !(typeof r == "string" && r === "" || Array.isArray(r) && (r.length === 0 || r.length === 1 && r[0] === "") || r == null), s = [];
  if (e = e.replace(/__/g, ":"), e !== "noop" && e !== "") {
    e !== "cdata" ? s.push(`<${e}`) : s.push("<![CDATA[");
    for (let o in n)
      if (o && Ql(n, o)) {
        const a = n[o];
        if (o === "html")
          continue;
        o.toLowerCase() === "classname" && (o = "class"), o = o.replace(/__/g, ":"), a === !0 ? s.push(` ${o}`) : o === "style" && typeof a == "object" ? s.push(
          ` ${o}="${Object.keys(a).filter((l) => a[l] != null).map((l) => {
            let u = a[l];
            return u = typeof u == "number" ? `${u}px` : u, `${l.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${u}`;
          }).join(";")}"`
        ) : a !== !1 && a != null && s.push(` ${o}="${Tc(a.toString())}"`);
      }
    if (e !== "cdata") {
      if (t && !i)
        return s.push(" />"), s.join("");
      s.push(">");
    }
    if (!t && y4.includes(e))
      return s.join("");
  }
  if (i) {
    if (typeof r == "string")
      s.push(r);
    else if (r && r.length > 0) {
      for (let o of r)
        if (o != null && o !== !1) {
          Array.isArray(o) || (o = [o]);
          for (const a of o)
            a.startsWith("<") && a.endsWith(">") || e === "script" || e === "style" ? s.push(a) : s.push(Tc(a.toString()));
        }
    }
  }
  return n.html && s.push(n.html), e !== "noop" && e !== "" && (e !== "cdata" ? s.push(`</${e}>`) : s.push("]]>")), s.join("");
}
function Wl(t, e, ...n) {
  const { tag: r, attrs: i, children: s } = E4(t, e, n);
  return A4(!1, r, i, s);
}
var hl = A4.bind(null, !1);
Wl.firstLine = "<!DOCTYPE html>";
Wl.html = !0;
var l0 = {};
function QI(t) {
  let e = l0[t];
  return e == null && (e = UI(t), l0[t] = e), e;
}
function JI(t, e, { debug: n = !1 } = {}) {
  for (const r of QI(t)) {
    const i = (s, o) => {
      var l, u, c;
      let a = !1;
      for (const f of o) {
        const { type: d, name: h, action: m, value: g, ignoreCase: T = !0, data: E } = f;
        if (d === "attribute")
          m === "equals" ? a = s.getAttribute(h) === g : m === "start" ? a = !!((l = s.getAttribute(h)) != null && l.startsWith(g)) : m === "end" ? a = !!((u = s.getAttribute(h)) != null && u.endsWith(g)) : m === "element" ? h === "class" ? a = s.classList.contains(g) : a = !!((c = s.getAttribute(h)) != null && c.includes(g)) : m === "exists" ? a = s.hasAttribute(h) : console.warn("Unknown CSS selector action", m);
        else if (d === "tag")
          a = s.tagName === h.toUpperCase();
        else if (d === "universal")
          a = !0;
        else if (d === "pseudo") {
          if (h === "not") {
            let _ = !0;
            E.forEach((k) => {
              i(s, k) || (_ = !1);
            }), a = !_;
          }
        } else
          console.warn("Unknown CSS selector type", d, t, o);
        if (!a)
          break;
      }
      return a;
    };
    if (i(e, r))
      return !0;
  }
  return !1;
}
var XI = Symbol.for("nodejs.util.inspect.custom"), u0 = { fontWeight: "bold" }, c0 = { fontStyle: "italic" }, f0 = { backgroundColor: "rgb(255, 250, 165)" }, d0 = { textDecorations: "underline" }, Su = { textDecorations: "line-through" }, ZI = {
  b: u0,
  strong: u0,
  em: c0,
  i: c0,
  mark: f0,
  u: d0,
  a: d0,
  s: Su,
  del: Su,
  ins: f0,
  strike: Su
  // 'code': C,
  // 'tt': C
}, eR = (t) => t.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (e, n) => n.toUpperCase()), Na = class {
  constructor() {
    this.append = this.appendChild, this._parentNode = null, this._childNodes = [];
  }
  get nodeType() {
    return console.error("Subclasses should define nodeType!"), 0;
  }
  get nodeName() {
    return console.error("Subclasses should define nodeName!"), "";
  }
  get nodeValue() {
    return null;
  }
  cloneNode(t = !1) {
    const e = new this.constructor();
    return t && (e._childNodes = this._childNodes.map((n) => n.cloneNode(!0)), e._fixChildNodesParent()), e;
  }
  _fixChildNodesParent() {
    this._childNodes.forEach((t) => t._parentNode = this);
  }
  insertBefore(t, e) {
    if (t !== e) {
      let n = e ? this._childNodes.indexOf(e) : 0;
      n < 0 && (n = 0), this._childNodes.splice(n, 0, t), this._fixChildNodesParent();
    }
  }
  appendChild(t) {
    if (t != null) {
      if (t === this) {
        console.warn("Cannot appendChild to self");
        return;
      }
      if (t instanceof Hf && console.warn("No defined how to append a document to a node!", t), t instanceof Yl)
        for (const e of [...t._childNodes])
          this.appendChild(e);
      else if (Array.isArray(t))
        for (const e of [...t])
          this.appendChild(e);
      else if (t instanceof Na)
        t.remove(), this._childNodes.push(t);
      else
        try {
          const e = typeof t == "string" ? t : JSON.stringify(t, null, 2);
          this._childNodes.push(new Ki(e));
        } catch (e) {
          console.error(
            `The data ${t} to be added to ${this.render()} is problematic: ${e}`
          );
        }
      this._fixChildNodesParent();
    }
  }
  removeChild(t) {
    const e = this._childNodes.indexOf(t);
    e >= 0 && (t._parentNode = null, this._childNodes.splice(e, 1), this._fixChildNodesParent());
  }
  remove() {
    var t;
    return (t = this == null ? void 0 : this.parentNode) == null || t.removeChild(this), this;
  }
  replaceChildren(...t) {
    this._childNodes = t.map(
      (e) => typeof e == "string" ? new Ki(e) : e.remove()
    ), this._fixChildNodesParent();
  }
  replaceWith(...t) {
    const e = this._parentNode;
    if (e) {
      const n = this._indexInParent();
      n >= 0 && (t = t.map(
        (r) => typeof r == "string" ? new Ki(r) : r.remove()
      ), e._childNodes.splice(n, 1, ...t), this._parentNode = null, e._fixChildNodesParent());
    }
  }
  _indexInParent() {
    return this._parentNode ? this._parentNode.childNodes.indexOf(this) : -1;
  }
  get parentNode() {
    return this._parentNode;
  }
  get childNodes() {
    return this._childNodes || [];
  }
  get children() {
    return this._childNodes || [];
  }
  get firstChild() {
    return this._childNodes[0];
  }
  get lastChild() {
    return this._childNodes[this._childNodes.length - 1];
  }
  get nextSibling() {
    const t = this._indexInParent();
    return t != null && this.parentNode.childNodes[t + 1] || null;
  }
  get previousSibling() {
    const t = this._indexInParent();
    return t > 0 && this.parentNode.childNodes[t - 1] || null;
  }
  flatten() {
    const t = [];
    this instanceof ln && t.push(this);
    for (const e of this._childNodes)
      t.push(...e.flatten());
    return t;
  }
  flattenNodes() {
    const t = [];
    t.push(this);
    for (const e of this._childNodes)
      t.push(...e.flattenNodes());
    return t;
  }
  render() {
    return "";
  }
  get textContent() {
    return this._childNodes.map((t) => t.textContent).join("");
  }
  set textContent(t) {
    this._childNodes = [], t && this.appendChild(new Ki(t.toString()));
  }
  contains(t) {
    return t === this ? !0 : this._childNodes.some((e) => e.contains(t));
  }
  get ownerDocument() {
    var t;
    return this.nodeType === Na.DOCUMENT_NODE || this.nodeType === Na.DOCUMENT_FRAGMENT_NODE ? this : (t = this == null ? void 0 : this._parentNode) == null ? void 0 : t.ownerDocument;
  }
  toString() {
    return `${this.nodeName}`;
  }
  [XI]() {
    return `${this.constructor.name} "${this.render()}"`;
  }
}, lt = Na;
lt.ELEMENT_NODE = 1;
lt.TEXT_NODE = 3;
lt.CDATA_SECTION_NODE = 4;
lt.PROCESSING_INSTRUCTION_NODE = 7;
lt.COMMENT_NODE = 8;
lt.DOCUMENT_NODE = 9;
lt.DOCUMENT_TYPE_NODE = 10;
lt.DOCUMENT_FRAGMENT_NODE = 11;
var Ki = class extends lt {
  constructor(t = "") {
    super(), this._text = t;
  }
  get nodeType() {
    return lt.TEXT_NODE;
  }
  get nodeName() {
    return "#text";
  }
  get nodeValue() {
    return this._text || "";
  }
  get textContent() {
    return this.nodeValue;
  }
  render() {
    var e;
    const t = (e = this.parentNode) == null ? void 0 : e.tagName;
    return t === "SCRIPT" || t === "STYLE" ? this._text : Tc(this._text);
  }
  cloneNode(t = !1) {
    const e = super.cloneNode(t);
    return e._text = this._text, e;
  }
}, b4 = class extends lt {
  getElementById(t) {
    return this.flatten().find((e) => e._attributes.id === t);
  }
  getElementsByClassName(t) {
    return this.flatten().filter((e) => e.classList.contains(t));
  }
  matches(t) {
    return JI(t, this);
  }
  querySelectorAll(t) {
    return this.flatten().filter((e) => e.matches(t));
  }
  querySelector(t) {
    return this.flatten().find((e) => e.matches(t));
  }
  //
  parent(t) {
    var e;
    return this.matches(t) ? this : this.parentNode == null ? null : (e = this.parentNode) == null ? void 0 : e.parent(t);
  }
  handle(t, e) {
    let n = 0;
    for (const r of this.querySelectorAll(t))
      e(r, n++);
  }
}, ln = class extends b4 {
  constructor(t = "div", e = {}) {
    super(), this._originalTagName = t, this._nodeName = (t || "").toUpperCase(), this._attributes = e || {}, this._styles = null;
  }
  get nodeType() {
    return lt.ELEMENT_NODE;
  }
  get nodeName() {
    return this._nodeName;
  }
  cloneNode(t = !1) {
    const e = super.cloneNode(t);
    return e._originalTagName = this._originalTagName, e._nodeName = this._nodeName, e._attributes = Object.assign({}, this._attributes), e;
  }
  get attributes() {
    return this._attributes;
  }
  _findAttributeName(t) {
    const e = t.toLowerCase();
    return Object.keys(this._attributes).find(
      (n) => e === n.toLowerCase()
    ) || null;
  }
  setAttribute(t, e) {
    this.removeAttribute(t), this._attributes[t] = e, this._styles = null;
  }
  getAttribute(t) {
    const e = this._findAttributeName(t);
    return e ? this._attributes[e] : null;
  }
  removeAttribute(t) {
    this._findAttributeName(String(t)) && delete this._attributes[t];
  }
  hasAttribute(t) {
    const e = this._findAttributeName(t);
    return e ? this._attributes[e] != null : !1;
  }
  get style() {
    if (this._styles == null) {
      const t = Object.assign({}, ZI[this.tagName.toLowerCase()] || {}), e = this.getAttribute("style");
      if (e) {
        let n;
        const r = /\s*([\w-]+)\s*:\s*([^;]+)/g;
        for (; n = r.exec(e); ) {
          const i = n[1], s = n[2].trim();
          t[i] = s, t[eR(i)] = s;
        }
      }
      this._styles = t;
    }
    return this._styles;
  }
  get tagName() {
    return this._nodeName;
  }
  get id() {
    return this._attributes.id || null;
  }
  set id(t) {
    t == null ? delete this._attributes.id : this._attributes.id = t;
  }
  get src() {
    return this._attributes.src;
  }
  set src(t) {
    t == null ? delete this._attributes.src : this._attributes.src = t;
  }
  //
  getElementsByTagName(t) {
    t = t.toUpperCase();
    const e = this.flatten();
    return t !== "*" ? e.filter((n) => n.tagName === t) : e;
  }
  // html
  setInnerHTML(t) {
  }
  get innerHTML() {
    return this._childNodes.map((t) => t.render(Wl)).join("");
  }
  set innerHTML(t) {
    this.setInnerHTML(t);
  }
  get outerHTML() {
    return this.render(hl);
  }
  // class
  get className() {
    return this._attributes.class || "";
  }
  set className(t) {
    Array.isArray(t) ? t = t.filter((e) => !!e).join(" ") : typeof t == "object" && (t = Object.entries(t).filter(([e, n]) => !!n).map(([e, n]) => e).join(" ")), this._attributes.class = t;
  }
  get classList() {
    const t = this, e = (this.className || "").trim().split(/\s+/g) || [];
    return {
      contains(n) {
        return e.includes(n);
      },
      add(n) {
        e.includes(n) || (e.push(n), t.className = e);
      },
      remove(n) {
        const r = e.indexOf(n);
        r >= 0 && (e.splice(r, 1), t.className = e);
      }
    };
  }
  //
  render(t = hl) {
    return t(
      this._originalTagName || this.tagName,
      this.attributes,
      this._childNodes.map((e) => e.render(t)).join("")
      // children:string is not escaped again
    );
  }
}, Ff = class extends lt {
  get nodeName() {
    return super.nodeName;
  }
  get nodeValue() {
    return super.nodeValue;
  }
  get nodeType() {
    return Ff.DOCUMENT_TYPE_NODE;
  }
  render() {
    return "<!DOCTYPE html>";
  }
}, Yl = class extends b4 {
  get nodeType() {
    return lt.DOCUMENT_FRAGMENT_NODE;
  }
  get nodeName() {
    return "#document-fragment";
  }
  render(t = hl) {
    return this._childNodes.map((e) => e.render(t) || []).join("");
  }
  get innerHTML() {
    return this._childNodes.map((t) => t.render(Wl)).join("");
  }
  createElement(t, e = {}) {
    return new ln(t, e);
  }
  createDocumentFragment() {
    return new Yl();
  }
  createTextNode(t) {
    return new Ki(t);
  }
}, Hf = class extends Yl {
  get nodeType() {
    return lt.DOCUMENT_NODE;
  }
  get nodeName() {
    return "#document";
  }
  get documentElement() {
    return this.firstChild;
  }
  render(t = hl) {
    let e = super.render(t);
    return this.docType && (e = this.docType.render() + e), e;
  }
}, C4 = class extends Hf {
  constructor(t = !1) {
    if (super(), this.docType = new Ff(), !t) {
      const e = new ln("html"), n = new ln("body"), r = new ln("head"), i = new ln("title");
      e.appendChild(r), r.appendChild(i), e.appendChild(n), this.appendChild(e);
    }
  }
  get body() {
    let t = this.querySelector("body");
    if (!t) {
      let e = this.querySelector("html");
      e || (e = new ln("html"), this.appendChild(e)), t = new ln("body"), e.appendChild(e);
    }
    return t;
  }
  get title() {
    var t;
    return ((t = this.querySelector("title")) == null ? void 0 : t.textContent) || "";
  }
  set title(t) {
    const e = this.querySelector("title");
    e && (e.textContent = t);
  }
  get head() {
    let t = this.querySelector("head");
    if (!t) {
      let e = this.querySelector("html");
      e || (e = new ln("html"), this.appendChild(e)), t = new ln("head"), e.insertBefore(e);
    }
    return t;
  }
};
function tR() {
  return new Hf();
}
function nR() {
  return new C4();
}
var x4 = tR();
YI({ document: x4 });
var rR = {}, iR = rR.hasOwnProperty;
function Ql(t, e) {
  return iR.call(t, e);
}
/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var sR = /([^=\s]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^>\s]+))?/gm, oR = /^<\/([^>\s]+)[^>]*>/m, aR = /^<([^>\s\/]+)((\s+[^=>\s]+(\s*=\s*(("[^"]*")|('[^']*')|[^>\s]+))?)*)\s*\/?\s*>/m, lR = /\s*\/\s*>\s*$/m, uR = class {
  constructor(t = {}) {
    this.attrRe = sR, this.endTagRe = oR, this.startTagRe = aR, this.defaults = { ignoreWhitespaceText: !1 }, t.scanner && (this.scanner = t.scanner), this.options = Object.assign({}, this.defaults, t);
  }
  parse(t) {
    let e = !1, n, r, i;
    for (; t.length; )
      t.substring(0, 4) === "<!--" ? (n = t.indexOf("-->"), n !== -1 ? (this.scanner.comment(t.substring(4, n)), t = t.substring(n + 3), e = !1) : e = !0) : t.substring(0, 2) === "</" ? (r = this.endTagRe.exec(t), r ? (t = RegExp.rightContext, e = !1, this.parseEndTag(RegExp.lastMatch, r[1])) : e = !0) : t.charAt(0) === "<" && (r = this.startTagRe.exec(t), r ? (t = RegExp.rightContext, e = !1, this.parseStartTag(RegExp.lastMatch, r[1], r)) : e = !0), e && (n = t.indexOf("<"), n === 0 && (n = t.substring(1).indexOf("<")), n === -1 ? (i = t, t = "") : (i = t.substring(0, n), t = t.substring(n)), (!this.options.ignoreWhitespaceText || !/^\s*$/.test(i)) && this.scanner.characters(i)), e = !0, r = null;
  }
  parseStartTag(t, e, n) {
    const r = lR.test(t);
    let i = n[2];
    r && (i = i.replace(/\s*\/\s*$/, ""));
    const s = this.parseAttributes(e, i);
    this.scanner.startElement(e, s, r, n[0]);
  }
  parseEndTag(t, e) {
    this.scanner.endElement(e);
  }
  parseAttributes(t, e) {
    const n = {};
    return e.replace(this.attrRe, (...r) => {
      const [i, s, o, a, l, u, c, f] = r;
      n[s] = f ?? u ?? a ?? !0;
    }), n;
  }
};
function S4(t) {
  if (typeof t != "string")
    throw console.error("parseHTML requires string, found", t), new Error("parseHTML requires string");
  const e = t.indexOf("<!") === 0 ? new C4(!0) : new Yl(), n = [e];
  return new uR({
    // the for methods must be implemented yourself
    scanner: {
      startElement(i, s, o) {
        if (i.toLowerCase() === "!doctype") {
          e.docType = new Ff();
          return;
        }
        for (const u in s)
          if (Ql(s, u)) {
            const c = s[u];
            typeof c == "string" && (s[u] = a0(c));
          }
        const l = n[n.length - 1];
        if (l) {
          const u = x4.createElement(i, s);
          l.appendChild(u), y4.includes(i.toLowerCase()) || o || n.push(u);
        }
      },
      endElement(i) {
        n.pop();
      },
      characters(i) {
        var o;
        i = a0(i);
        const s = n[n.length - 1];
        ((o = s == null ? void 0 : s.lastChild) == null ? void 0 : o.nodeType) === lt.TEXT_NODE ? s.lastChild._text += i : s && s.appendChild(new Ki(i));
      },
      comment(i) {
      }
    }
  }).parse(t), e;
}
ln.prototype.setInnerHTML = function(t) {
  const e = S4(t);
  this._childNodes = e._childNodes, this._fixChildNodesParent();
};
const N4 = (t) => {
  const e = Ry(t);
  return (n) => {
    const r = S4(n), i = li.fromSchema(e).parse(r).toJSON(), s = Ar.fromJSON(e, i);
    return fn.fromSchema(e).serializeFragment(
      s.content,
      {
        document: nR()
      }
    ).render();
  };
}, IR = (t) => {
  const e = U9({});
  return N4(e)(t);
}, RR = (t) => {
  const e = q9({});
  return N4(e)(t);
};
export {
  pR as BubbleMenu,
  mR as EditorContent,
  gR as FloatingMenu,
  vR as html2md,
  U9 as makeArticleEditorExtensions,
  q9 as makeCommentEditorExtensions,
  N4 as makeNormalizer,
  DR as md2html,
  IR as normalizeArticleHTML,
  RR as normalizeCommentHTML,
  MR as sanitizeHTML,
  TR as useArticleEdtor,
  ER as useCommentEditor
};
